<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["E:","\\","sql-layer","benches","my_benchmark.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\r\nuse piggysql::{db::Database, errors::*, storage::piggy_stroage::PiggyKVStroage};\r\nconst QUERY_BENCH_SQLITE_PATH: \u0026'static str = \"./sqlite_bench\";\r\n\r\nasync fn data_source_lsm() -\u003e Result\u003cDatabase\u003cPiggyKVStroage\u003e\u003e {\r\n    let path = tempdir::TempDir::new(\"piggydb\").unwrap().path().join(\"lsm\");\r\n    let db = Database::new_lsm(path)?;\r\n    db.run(\r\n        \"CREATE TABLE benchtable(\r\n            id INT PRIMARY KEY,\r\n            val INT);\r\n            \",\r\n    )\r\n    .await?;\r\n    let mut batch = String::new();\r\n    for i in 0..500000 {\r\n        batch += format!(\"({},{})\", i, i).as_str();\r\n        batch += \",\"\r\n    }\r\n    batch += format!(\"({},{})\", 500001, 500001).as_str();\r\n\r\n    db.run(\u0026format!(\"INSERT INTO benchtable VALUES {}\", batch))\r\n        .await?;\r\n    Ok(db)\r\n}\r\nasync fn data_source_sqlite() -\u003e Result\u003c()\u003e {\r\n    let db = sqlite::open(QUERY_BENCH_SQLITE_PATH).unwrap();\r\n    db.execute(\r\n        \"DROP TABLE if EXISTS benchtable;\",\r\n    ).unwrap();\r\n    db.execute(\r\n        \"CREATE TABLE benchtable(\r\n            id INT PRIMARY KEY,\r\n            val INT);\r\n            \",\r\n    ).unwrap();\r\n    let mut batch = String::new();\r\n    for i in 0..500000 {\r\n        batch += format!(\"({},{})\", i, i).as_str();\r\n        batch += \",\"\r\n    }\r\n    batch += format!(\"({},{})\", 500001, 500001).as_str();\r\n\r\n    db.execute(\u0026format!(\"INSERT INTO benchtable VALUES {}\", batch)).unwrap();\r\n    Ok(())\r\n}\r\n\r\npub async fn lsm_benchmark_100000(engine: \u0026Database\u003cPiggyKVStroage\u003e) -\u003e Result\u003c()\u003e {\r\n    let _ = engine\r\n        .run(\"SELECT * FROM benchtable where id=490000\")\r\n        .await?;\r\n    Ok(())\r\n}\r\npub async fn lsm_without_primary_benchmark_100000(engine: \u0026Database\u003cPiggyKVStroage\u003e) -\u003e Result\u003c()\u003e {\r\n    let _ = engine\r\n        .run(\"SELECT * FROM benchtable where val=490000\")\r\n        .await?;\r\n    Ok(())\r\n}\r\n\r\nfn lsm_benchmark(c: \u0026mut Criterion) {\r\n    let rt = tokio::runtime::Builder::new_multi_thread()\r\n        .worker_threads(6)\r\n        .enable_all()\r\n        .build()\r\n        .unwrap();\r\n    let lsm = rt.block_on(async { data_source_lsm().await.unwrap() });\r\n    c.bench_function(\"lsm benchmark select rows with primary key\", |b| {\r\n        b.to_async(\u0026rt)\r\n            .iter(|| async { lsm_benchmark_100000(\u0026lsm).await.unwrap() })\r\n    });\r\n    c.bench_function(\"lsm benchmark select rows without primary key\", |b| {\r\n        b.to_async(\u0026rt)\r\n            .iter(|| async { lsm_without_primary_benchmark_100000(\u0026lsm).await.unwrap() })\r\n    });\r\n}\r\n\r\nfn data_insert(c: \u0026mut Criterion) {\r\n    let rt = tokio::runtime::Builder::new_multi_thread()\r\n        .worker_threads(6)\r\n        .enable_all()\r\n        .build()\r\n        .unwrap();\r\n    // let _=rt.block_on(data_source_sqlite()).unwrap();\r\n    c.bench_function(\"lsm insert benchmark select rows with primary key\", |b| {\r\n        b.to_async(\u0026rt)\r\n            .iter(|| async { data_source_lsm().await.unwrap() })\r\n    });\r\n    c.bench_function(\"sqlite insert benchmark select rows with primary key\", |b| {\r\n        b.to_async(\u0026rt)\r\n            .iter(|| async { data_source_sqlite().await.unwrap() })\r\n    });\r\n\r\n}\r\ncriterion_group!(\r\n    name = benches;\r\n    config = Criterion::default().sample_size(10);\r\n    targets = data_insert\r\n);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","client","src","lib.rs"],"content":"use anyhow::{bail, Context, Result};\r\nuse comfy_table::{Cell, Table};\r\nuse rand::Rng;\r\nuse tokio_postgres::{Client, NoTls,  SimpleQueryMessage};\r\n\r\npub struct SQLClient {\r\n    pub client: Client,\r\n}\r\n\r\nimpl SQLClient {\r\n    pub async fn connect() -\u003e Result\u003cSelf\u003e {\r\n        let (client, connection) =\r\n            tokio_postgres::connect(\"host=localhost user=postgres\", NoTls).await?;\r\n        tokio::spawn(async move {\r\n            if let Err(e) = connection.await {\r\n                eprintln!(\"connection error: {}\", e);\r\n            }\r\n        });\r\n        Ok(Self { client })\r\n    }\r\n    pub async fn query(\u0026self, sql: \u0026str) -\u003e Result\u003cVec\u003cSimpleQueryMessage\u003e\u003e {\r\n        for i in 0..16 {\r\n            if i \u003e 0 {\r\n                tokio::time::sleep(std::time::Duration::from_millis(\r\n                    2_u64.pow(i as u32 - 1) * rand::thread_rng().gen_range(25..=75),\r\n                ))\r\n                .await;\r\n            }\r\n            let result = self\r\n                .client\r\n                .simple_query(sql)\r\n                .await\r\n                .context(\"sql query error\");\r\n            return result;\r\n        }\r\n        bail!(\"Serialization verfication failed\")\r\n    }\r\n}\r\n\r\npub fn create_table(rows: Vec\u003cSimpleQueryMessage\u003e) -\u003e Table {\r\n    let mut table = Table::new();\r\n\r\n    if rows.is_empty() {\r\n        return table;\r\n    }\r\n\r\n    let mut show_schema = false;\r\n    for row in rows {\r\n        if let SimpleQueryMessage::Row(row) = row {\r\n            if !show_schema {\r\n                let mut header = Vec::new();\r\n                show_schema = true;\r\n                for col in row.columns() {\r\n                    header.push(Cell::new(col.name().to_string()));\r\n                }\r\n                table.set_header(header);\r\n            }\r\n\r\n            let mut cols = vec![];\r\n            for idx in 0..row.len() {\r\n                let val = row.get(idx);\r\n                cols.push(val);\r\n            }\r\n            let cells = cols\r\n                .iter()\r\n                .map(|value| match value {\r\n                    Some(value) =\u003e Cell::new(format!(\"{value}\")),\r\n                    None =\u003e Cell::new(format!(\"null\")),\r\n                })\r\n                .collect::\u003cVec\u003c_\u003e\u003e();\r\n            table.add_row(cells);\r\n        }\r\n    }\r\n\r\n    table\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","client","src","main.rs"],"content":"use anyhow::Result;\r\nuse client::{create_table, SQLClient};\r\nuse rustyline::error::ReadlineError;\r\nuse rustyline::DefaultEditor;\r\n\r\n#[tokio::main]\r\nasync fn main() -\u003e Result\u003c()\u003e {\r\n    // `()` can be used when no completer is required\r\n    let mut rl = DefaultEditor::new()?;\r\n    if rl.load_history(\"history.txt\").is_err() {\r\n        println!(\"No previous history.\");\r\n    }\r\n    let client = SQLClient::connect().await?;\r\n    loop {\r\n        let readline = rl.readline(\"SQL\u003e \");\r\n        match readline {\r\n            Ok(line) =\u003e {\r\n                rl.add_history_entry(line.as_str())?;\r\n                match client.query(line.as_str()).await {\r\n                    Ok(result) =\u003e println!(\"{}\", create_table(result)),\r\n                    Err(e) =\u003e {\r\n                        println!(\"Error: {:?}\", e);\r\n                    }\r\n                }\r\n                // let result = client.query(line.as_str()).await?;\r\n                // println!(\"{}\", create_table(result));\r\n            }\r\n            Err(ReadlineError::Interrupted) =\u003e {\r\n                println!(\"CTRL-C\");\r\n                break;\r\n            }\r\n            Err(ReadlineError::Eof) =\u003e {\r\n                println!(\"CTRL-D\");\r\n                break;\r\n            }\r\n            Err(err) =\u003e {\r\n                println!(\"Error: {:?}\", err);\r\n            }\r\n        }\r\n    }\r\n    rl.save_history(\"history.txt\")?;\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","binder","aggregate.rs"],"content":"use ahash::RandomState;\r\nuse itertools::Itertools;\r\nuse sqlparser::ast::{Expr, OrderByExpr};\r\nuse std::collections::HashSet;\r\n\r\nuse crate::errors::*;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::{\r\n    expression::ScalarExpression,\r\n    planner::operator::{aggregate::AggregateOperator, sort::SortField},\r\n};\r\n\r\nuse super::Binder;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub fn bind_aggregate(\r\n        \u0026mut self,\r\n        children: LogicalPlan,\r\n        agg_calls: Vec\u003cScalarExpression\u003e,\r\n        groupby_exprs: Vec\u003cScalarExpression\u003e,\r\n    ) -\u003e LogicalPlan {\r\n        AggregateOperator::build(children, agg_calls, groupby_exprs, false)\r\n    }\r\n\r\n    pub fn extract_select_aggregate(\r\n        \u0026mut self,\r\n        select_items: \u0026mut [ScalarExpression],\r\n    ) -\u003e Result\u003c()\u003e {\r\n        for column in select_items {\r\n            self.visit_column_agg_expr(column)?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub fn extract_group_by_aggregate(\r\n        \u0026mut self,\r\n        select_list: \u0026mut [ScalarExpression],\r\n        groupby: \u0026[Expr],\r\n    ) -\u003e Result\u003c()\u003e {\r\n        self.validate_groupby_illegal_column(select_list, groupby)?;\r\n\r\n        for gb in groupby {\r\n            let mut expr = self.bind_expr(gb)?;\r\n            self.visit_group_by_expr(select_list, \u0026mut expr);\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub fn extract_having_orderby_aggregate(\r\n        \u0026mut self,\r\n        having: \u0026Option\u003cExpr\u003e,\r\n        orderbys: \u0026[OrderByExpr],\r\n    ) -\u003e Result\u003c(Option\u003cScalarExpression\u003e, Option\u003cVec\u003cSortField\u003e\u003e)\u003e {\r\n        // Extract having expression.\r\n        let return_having = if let Some(having) = having {\r\n            let mut having = self.bind_expr(having)?;\r\n            self.visit_column_agg_expr(\u0026mut having)?;\r\n\r\n            Some(having)\r\n        } else {\r\n            None\r\n        };\r\n\r\n        // Extract orderby expression.\r\n        let return_orderby = if !orderbys.is_empty() {\r\n            let mut return_orderby = vec![];\r\n            for orderby in orderbys {\r\n                let OrderByExpr {\r\n                    expr,\r\n                    asc,\r\n                    nulls_first,\r\n                } = orderby;\r\n                let mut expr = self.bind_expr(expr)?;\r\n                self.visit_column_agg_expr(\u0026mut expr)?;\r\n\r\n                return_orderby.push(SortField::new(\r\n                    expr,\r\n                    asc.map_or(true, |asc| asc),\r\n                    nulls_first.map_or(false, |first| first),\r\n                ));\r\n            }\r\n            Some(return_orderby)\r\n        } else {\r\n            None\r\n        };\r\n        Ok((return_having, return_orderby))\r\n    }\r\n\r\n    fn visit_column_agg_expr(\u0026mut self, expr: \u0026mut ScalarExpression) -\u003e Result\u003c()\u003e {\r\n        match expr {\r\n            ScalarExpression::AggCall { .. } =\u003e {\r\n                self.context.agg_calls.push(expr.clone());\r\n            }\r\n            ScalarExpression::TypeCast { expr, .. } =\u003e self.visit_column_agg_expr(expr)?,\r\n            ScalarExpression::IsNull { expr, .. } =\u003e self.visit_column_agg_expr(expr)?,\r\n            ScalarExpression::Unary { expr, .. } =\u003e self.visit_column_agg_expr(expr)?,\r\n            ScalarExpression::Alias { expr, .. } =\u003e self.visit_column_agg_expr(expr)?,\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                ..\r\n            } =\u003e {\r\n                self.visit_column_agg_expr(left_expr)?;\r\n                self.visit_column_agg_expr(right_expr)?;\r\n            }\r\n            ScalarExpression::In { expr, args, .. } =\u003e {\r\n                self.visit_column_agg_expr(expr)?;\r\n                for arg in args {\r\n                    self.visit_column_agg_expr(arg)?;\r\n                }\r\n            }\r\n            ScalarExpression::Constant(_) | ScalarExpression::ColumnRef { .. } =\u003e {}\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// Validate select exprs must appear in the GROUP BY clause or be used in\r\n    /// an aggregate function.\r\n    /// e.g. SELECT a,count(b) FROM t GROUP BY a. it's ok.\r\n    ///      SELECT a,b FROM t GROUP BY a.        it's error.\r\n    ///      SELECT a,count(b) FROM t GROUP BY b. it's error.\r\n    fn validate_groupby_illegal_column(\r\n        \u0026mut self,\r\n        select_items: \u0026[ScalarExpression],\r\n        groupby: \u0026[Expr],\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let mut group_raw_exprs = vec![];\r\n        for expr in groupby {\r\n            let expr = self.bind_expr(expr)?;\r\n\r\n            if let ScalarExpression::Alias { alias, .. } = expr {\r\n                let alias_expr = select_items.iter().find(|column| {\r\n                    if let ScalarExpression::Alias {\r\n                        alias: inner_alias, ..\r\n                    } = \u0026column\r\n                    {\r\n                        alias == *inner_alias\r\n                    } else {\r\n                        false\r\n                    }\r\n                });\r\n\r\n                if let Some(inner_expr) = alias_expr {\r\n                    group_raw_exprs.push(inner_expr.clone());\r\n                }\r\n            } else {\r\n                group_raw_exprs.push(expr);\r\n            }\r\n        }\r\n        let mut group_raw_set: HashSet\u003c\u0026ScalarExpression, RandomState\u003e =\r\n            HashSet::from_iter(group_raw_exprs.iter());\r\n\r\n        for expr in select_items {\r\n            if expr.has_agg_call() {\r\n                continue;\r\n            }\r\n            group_raw_set.remove(expr);\r\n\r\n            if !group_raw_exprs.iter().contains(expr) {\r\n                return Err(DatabaseError::AggMiss(format!(\r\n                    \"{:?} must appear in the GROUP BY clause or be used in an aggregate function\",\r\n                    expr\r\n                )));\r\n            }\r\n        }\r\n\r\n        if !group_raw_set.is_empty() {\r\n            return Err(DatabaseError::AggMiss(\r\n                \"In the GROUP BY clause the field must be in the select clause\".to_string(),\r\n            ));\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn visit_group_by_expr(\r\n        \u0026mut self,\r\n        select_list: \u0026mut [ScalarExpression],\r\n        expr: \u0026mut ScalarExpression,\r\n    ) {\r\n        if let ScalarExpression::Alias { alias, .. } = expr {\r\n            if let Some(i) = select_list.iter().position(|inner_expr| {\r\n                if let ScalarExpression::Alias {\r\n                    alias: inner_alias, ..\r\n                } = \u0026inner_expr\r\n                {\r\n                    alias == inner_alias\r\n                } else {\r\n                    false\r\n                }\r\n            }) {\r\n                self.context.group_by_exprs.push(select_list[i].clone());\r\n                return;\r\n            }\r\n        }\r\n\r\n        if let Some(i) = select_list.iter().position(|column| column == expr) {\r\n            self.context.group_by_exprs.push(select_list[i].clone())\r\n        }\r\n    }\r\n\r\n    /// Validate having or orderby clause is valid, if SQL has group by clause.\r\n    pub fn validate_having_orderby(\u0026self, expr: \u0026ScalarExpression) -\u003e Result\u003c()\u003e {\r\n        if self.context.group_by_exprs.is_empty() {\r\n            return Ok(());\r\n        }\r\n\r\n        match expr {\r\n            ScalarExpression::AggCall { .. } =\u003e {\r\n                if self.context.group_by_exprs.contains(expr)\r\n                    || self.context.agg_calls.contains(expr)\r\n                {\r\n                    return Ok(());\r\n                }\r\n\r\n                Err(DatabaseError::AggMiss(\r\n                    format!(\r\n                        \"column {:?} must appear in the GROUP BY clause or be used in an aggregate function\",\r\n                        expr\r\n                    )\r\n                ))\r\n            }\r\n            ScalarExpression::ColumnRef { .. } | ScalarExpression::Alias { .. } =\u003e {\r\n                if self.context.group_by_exprs.contains(expr) {\r\n                    return Ok(());\r\n                }\r\n                if matches!(expr, ScalarExpression::Alias { .. }) {\r\n                    return self.validate_having_orderby(expr.unpack_alias());\r\n                }\r\n\r\n                Err(DatabaseError::AggMiss(\r\n                    format!(\r\n                        \"column {:?} must appear in the GROUP BY clause or be used in an aggregate function\",\r\n                        expr\r\n                    )\r\n                ))\r\n            }\r\n\r\n            ScalarExpression::TypeCast { expr, .. } =\u003e self.validate_having_orderby(expr),\r\n            ScalarExpression::IsNull { expr, .. } =\u003e self.validate_having_orderby(expr),\r\n            ScalarExpression::Unary { expr, .. } =\u003e self.validate_having_orderby(expr),\r\n            ScalarExpression::In { expr, args, .. } =\u003e {\r\n                self.validate_having_orderby(expr)?;\r\n                for arg in args {\r\n                    self.validate_having_orderby(arg)?;\r\n                }\r\n                Ok(())\r\n            }\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                ..\r\n            } =\u003e {\r\n                self.validate_having_orderby(left_expr)?;\r\n                self.validate_having_orderby(right_expr)?;\r\n                Ok(())\r\n            }\r\n\r\n            ScalarExpression::Constant(_) =\u003e Ok(()),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":15204152342002794496},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":15636497906230362112},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":15636497906230362112},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":14195346025471803392},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":15636497906230362112},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null}],"covered":69,"coverable":134},{"path":["E:","\\","sql-layer","src","binder","alter_table.rs"],"content":"use crate::errors::*;\r\nuse sqlparser::ast::{AlterTableOperation, ObjectName};\r\n\r\nuse std::sync::Arc;\r\n\r\nuse super::{is_valid_identifier, Binder};\r\nuse crate::binder::{lower_case_name, split_name};\r\nuse crate::planner::operator::alter_table::AddColumnOperator;\r\nuse crate::planner::operator::alter_table::DropColumnOperator;\r\nuse crate::planner::operator::scan::ScanOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_alter_table(\r\n        \u0026mut self,\r\n        name: \u0026ObjectName,\r\n        operation: \u0026AlterTableOperation,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let name = lower_case_name(name);\r\n        let table_name: Arc\u003cString\u003e = Arc::new(split_name(\u0026name)?.1.to_string());\r\n\r\n        if let Some(table) = self.context.table(table_name.clone()) {\r\n            let plan = match operation {\r\n                AlterTableOperation::AddColumn {\r\n                    column_keyword: _,\r\n                    if_not_exists,\r\n                    column_def,\r\n                } =\u003e {\r\n                    let plan = ScanOperator::build(table_name.clone(), \u0026table);\r\n                    let column = self.bind_column(column_def)?;\r\n                    if !is_valid_identifier(column.name()) {\r\n                        return Err(DatabaseError::InvalidColumn(\r\n                            \"illegal column naming\".to_string(),\r\n                        ));\r\n                    }\r\n                    LogicalPlan::new(\r\n                        Operator::AddColumn(AddColumnOperator {\r\n                            table_name,\r\n                            if_not_exists: *if_not_exists,\r\n                            column: self.bind_column(column_def)?,\r\n                        }),\r\n                        vec![plan],\r\n                    )\r\n                }\r\n                AlterTableOperation::DropColumn {\r\n                    column_name,\r\n                    if_exists,\r\n                    ..\r\n                } =\u003e {\r\n                    let plan = ScanOperator::build(table_name.clone(), \u0026table);\r\n                    let column_name = column_name.value.clone();\r\n                    LogicalPlan::new(\r\n                        Operator::DropColumn(DropColumnOperator {\r\n                            table_name,\r\n                            if_exists: *if_exists,\r\n                            column_name,\r\n                        }),\r\n                        vec![plan],\r\n                    )\r\n                }\r\n                AlterTableOperation::DropPrimaryKey =\u003e todo!(),\r\n                AlterTableOperation::RenameColumn {\r\n                    old_column_name: _,\r\n                    new_column_name: _,\r\n                } =\u003e todo!(),\r\n                AlterTableOperation::RenameTable { table_name: _ } =\u003e todo!(),\r\n                AlterTableOperation::ChangeColumn {\r\n                    old_name: _,\r\n                    new_name: _,\r\n                    data_type: _,\r\n                    options: _,\r\n                } =\u003e todo!(),\r\n                AlterTableOperation::AlterColumn {\r\n                    column_name: _,\r\n                    op: _,\r\n                } =\u003e todo!(),\r\n                _ =\u003e todo!(),\r\n            };\r\n\r\n            Ok(plan)\r\n        } else {\r\n            Err(DatabaseError::InvalidTable(format!(\r\n                \"not found table {}\",\r\n                table_name\r\n            )))\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":47},{"path":["E:","\\","sql-layer","src","binder","copy.rs"],"content":"use crate::planner::operator::copy_from_file::CopyFromFileOperator;\r\nuse crate::planner::operator::Operator;\r\nuse serde::{Deserialize, Serialize};\r\nuse sqlparser::ast::{CopyOption, CopySource, CopyTarget};\r\nuse std::{path::PathBuf, sync::Arc};\r\n\r\nuse super::*;\r\n\r\n#[derive(Debug, PartialEq, PartialOrd, Ord, Hash, Eq, Clone, Serialize, Deserialize)]\r\npub struct ExtSource {\r\n    pub path: PathBuf,\r\n    pub format: FileFormat,\r\n}\r\n\r\n/// File format.\r\n#[derive(Debug, PartialEq, PartialOrd, Ord, Hash, Eq, Clone, Serialize, Deserialize)]\r\npub enum FileFormat {\r\n    Csv {\r\n        /// Delimiter to parse.\r\n        delimiter: char,\r\n        /// Quote to use.\r\n        quote: char,\r\n        /// Escape character to use.\r\n        escape: Option\u003cchar\u003e,\r\n        /// Whether or not the file has a header line.\r\n        header: bool,\r\n    },\r\n}\r\n\r\nimpl std::fmt::Display for ExtSource {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        write!(f, \"{self:?}\")\r\n    }\r\n}\r\n\r\nimpl std::fmt::Display for FileFormat {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        write!(f, \"{self:?}\")\r\n    }\r\n}\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(super) fn bind_copy(\r\n        \u0026mut self,\r\n        source: CopySource,\r\n        target: CopyTarget,\r\n        options: \u0026[CopyOption],\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let (table_name, ..) = match source {\r\n            CopySource::Table {\r\n                table_name,\r\n                columns,\r\n            } =\u003e (table_name, columns),\r\n            CopySource::Query(_) =\u003e {\r\n                return Err(DatabaseError::UnsupportedCopySource(\r\n                    \"bad copy source\".to_string(),\r\n                ));\r\n            }\r\n        };\r\n\r\n        if let Some(table) = self\r\n            .context\r\n            .table(Arc::new(table_name.to_string().to_lowercase()))\r\n        {\r\n            let schema_ref = table.all_columns();\r\n            let ext_source = ExtSource {\r\n                path: match target {\r\n                    CopyTarget::File { filename } =\u003e filename.into(),\r\n                    t =\u003e todo!(\"unsupported copy target: {:?}\", t),\r\n                },\r\n                format: FileFormat::from_options(options),\r\n            };\r\n            // COPY \u003cdest_table\u003e FROM \u003csource_file\u003e\r\n\r\n            Ok(LogicalPlan::new(\r\n                Operator::CopyFromFile(CopyFromFileOperator {\r\n                    source: ext_source,\r\n                    schema_ref,\r\n                    table: table_name.to_string().to_lowercase(),\r\n                }),\r\n                vec![],\r\n            ))\r\n        } else {\r\n            Err(DatabaseError::InvalidTable(format!(\r\n                \"not found table {}\",\r\n                table_name\r\n            )))\r\n        }\r\n    }\r\n}\r\n\r\nimpl FileFormat {\r\n    /// Create from copy options.\r\n    pub fn from_options(options: \u0026[CopyOption]) -\u003e Self {\r\n        let mut delimiter = ',';\r\n        let mut quote = '\"';\r\n        let mut escape = None;\r\n        let mut header = false;\r\n        for opt in options {\r\n            match opt {\r\n                CopyOption::Format(fmt) =\u003e {\r\n                    assert_eq!(fmt.value.to_lowercase(), \"csv\", \"only support CSV format\")\r\n                }\r\n                CopyOption::Delimiter(c) =\u003e delimiter = *c,\r\n                CopyOption::Header(b) =\u003e header = *b,\r\n                CopyOption::Quote(c) =\u003e quote = *c,\r\n                CopyOption::Escape(c) =\u003e escape = Some(*c),\r\n                o =\u003e panic!(\"unsupported copy option: {:?}\", o),\r\n            }\r\n        }\r\n        FileFormat::Csv {\r\n            delimiter,\r\n            quote,\r\n            escape,\r\n            header,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1683},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1683},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1683},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1683},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1683},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3366},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1683},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3366},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":41},{"path":["E:","\\","sql-layer","src","binder","create_index.rs"],"content":"use crate::errors::*;\r\nuse std::sync::Arc;\r\n\r\nuse itertools::Itertools;\r\nuse sqlparser::ast::{ObjectName, OrderByExpr};\r\n\r\nuse crate::{\r\n    binder::lower_case_name,\r\n    planner::{\r\n        operator::{create_index::CreateIndexOperator, Operator},\r\n        LogicalPlan,\r\n    },\r\n    storage::Transaction,\r\n};\r\n\r\nuse super::Binder;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_create_index(\r\n        \u0026mut self,\r\n        index_name: \u0026ObjectName,\r\n        table_name: \u0026ObjectName,\r\n        columns: \u0026[OrderByExpr],\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let table_name = lower_case_name(table_name);\r\n        let index_name = lower_case_name(index_name);\r\n        let table_name = Arc::new(table_name.to_string());\r\n        let index_name = Arc::new(index_name.to_string());\r\n\r\n        let col_ident = columns\r\n            .iter()\r\n            .filter_map(|col| match \u0026col.expr {\r\n                sqlparser::ast::Expr::Identifier(ident) =\u003e Some(ident.to_string()),\r\n                _ =\u003e unreachable!(),\r\n            })\r\n            .collect_vec();\r\n        //now only support unique index\r\n        assert_eq!(col_ident.len(), 1);\r\n        let col_name = col_ident[0].clone();\r\n        Ok(LogicalPlan::new(\r\n            Operator::CreateIndex(CreateIndexOperator {\r\n                table_name,\r\n                index_name,\r\n                col_name,\r\n            }),\r\n            vec![],\r\n        ))\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["E:","\\","sql-layer","src","binder","create_table.rs"],"content":"use crate::errors::*;\r\nuse itertools::Itertools;\r\nuse sqlparser::ast::{ColumnDef, ColumnOption, ObjectName, TableConstraint};\r\nuse std::collections::HashSet;\r\nuse std::sync::Arc;\r\n\r\nuse super::{is_valid_identifier, Binder};\r\nuse crate::binder::{lower_case_name, split_name};\r\nuse crate::catalog::{ColumnCatalog, ColumnDesc};\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::create_table::CreateTableOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::value::DataValue;\r\nuse crate::types::LogicalType;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    // TODO: TableConstraint\r\n    pub(crate) fn bind_create_table(\r\n        \u0026mut self,\r\n        name: \u0026ObjectName,\r\n        columns: \u0026[ColumnDef],\r\n        constraints: \u0026[TableConstraint],\r\n        if_not_exists: bool,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let name = lower_case_name(name);\r\n        let (_, name) = split_name(\u0026name)?;\r\n        let table_name = Arc::new(name.to_string());\r\n\r\n        if !is_valid_identifier(\u0026table_name) {\r\n            return Err(DatabaseError::InvalidTable(\r\n                \"illegal table naming\".to_string(),\r\n            ));\r\n        }\r\n\r\n        {\r\n            // check duplicated column names\r\n            let mut set = HashSet::new();\r\n            for col in columns.iter() {\r\n                let col_name = \u0026col.name.value;\r\n                if !set.insert(col_name.clone()) {\r\n                    return Err(DatabaseError::AmbiguousColumn(col_name.to_lowercase()));\r\n                }\r\n                if !is_valid_identifier(col_name) {\r\n                    return Err(DatabaseError::InvalidColumn(\r\n                        \"illegal column naming\".to_string(),\r\n                    ));\r\n                }\r\n            }\r\n        }\r\n        let mut columns: Vec\u003cColumnCatalog\u003e = columns\r\n            .iter()\r\n            .map(|col| self.bind_column(col))\r\n            .try_collect()?;\r\n        for constraint in constraints {\r\n            match constraint {\r\n                TableConstraint::Unique {\r\n                    columns: column_names,\r\n                    is_primary,\r\n                    ..\r\n                } =\u003e {\r\n                    for column_name in column_names {\r\n                        if let Some(column) = columns\r\n                            .iter_mut()\r\n                            .find(|column| column.name() == column_name.to_string())\r\n                        {\r\n                            if *is_primary {\r\n                                column.desc.is_primary = true;\r\n                            } else {\r\n                                column.desc.is_unique = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                _ =\u003e todo!(),\r\n            }\r\n        }\r\n        //experiment\r\n        //allow table no primary key\r\n        // if columns.iter().filter(|col| col.desc.is_primary).count() != 1 {\r\n        //     return Err(DatabaseError::InvalidTable(\r\n        //         \"The primary key field must exist and have at least one\".to_string(),\r\n        //     ));\r\n        // }\r\n\r\n        Ok(LogicalPlan::new(\r\n            Operator::CreateTable(CreateTableOperator {\r\n                table_name,\r\n                columns,\r\n                if_not_exists,\r\n            }),\r\n            vec![],\r\n        ))\r\n    }\r\n\r\n    pub fn bind_column(\u0026mut self, column_def: \u0026ColumnDef) -\u003e Result\u003cColumnCatalog\u003e {\r\n        let column_name = column_def.name.to_string();\r\n        let mut column_desc = ColumnDesc::new(\r\n            LogicalType::try_from(column_def.data_type.clone())?,\r\n            false,\r\n            false,\r\n            None,\r\n        );\r\n        let mut nullable = true;\r\n\r\n        // TODO: \r\n        for option_def in \u0026column_def.options {\r\n            match \u0026option_def.option {\r\n                ColumnOption::Null =\u003e nullable = true,\r\n                ColumnOption::NotNull =\u003e nullable = false,\r\n                ColumnOption::Unique { is_primary } =\u003e {\r\n                    if *is_primary {\r\n                        column_desc.is_primary = true;\r\n                        nullable = false;\r\n                        // Skip other options when using primary key\r\n                        break;\r\n                    } else {\r\n                        column_desc.is_unique = true;\r\n                    }\r\n                }\r\n                ColumnOption::Default(expr) =\u003e {\r\n                    if let ScalarExpression::Constant(value) = self.bind_expr(expr)? {\r\n                        let cast_value =\r\n                            DataValue::clone(\u0026value).cast(\u0026column_desc.column_datatype)?;\r\n                        column_desc.default = Some(Arc::new(cast_value));\r\n                    } else {\r\n                        unreachable!(\"'default' only for constant\")\r\n                    }\r\n                }\r\n                _ =\u003e todo!(),\r\n            }\r\n        }\r\n\r\n        Ok(ColumnCatalog::new(column_name, nullable, column_desc))\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1369094286720630785},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1801439850948198400},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null}],"covered":29,"coverable":57},{"path":["E:","\\","sql-layer","src","binder","delete.rs"],"content":"use crate::binder::{lower_case_name, split_name, Binder};\r\nuse crate::errors::*;\r\nuse crate::planner::operator::delete::DeleteOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse sqlparser::ast::{Expr, TableFactor, TableWithJoins};\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_delete(\r\n        \u0026mut self,\r\n        from: \u0026TableWithJoins,\r\n        selection: \u0026Option\u003cExpr\u003e,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        if let TableFactor::Table { name, alias, .. } = \u0026from.relation {\r\n            let name = lower_case_name(name);\r\n            let (_, name) = split_name(\u0026name)?;\r\n            let (table_name, mut plan) =\r\n                self._bind_single_table_ref(None, name, Self::trans_alias(alias))?;\r\n\r\n            if let Some(predicate) = selection {\r\n                plan = self.bind_where(plan, predicate)?;\r\n            }\r\n\r\n            Ok(LogicalPlan::new(\r\n                Operator::Delete(DeleteOperator { table_name }),\r\n                vec![plan],\r\n            ))\r\n        } else {\r\n            unreachable!(\"only table\")\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":9,"coverable":11},{"path":["E:","\\","sql-layer","src","binder","describe.rs"],"content":"use crate::binder::Binder;\r\nuse crate::errors::DatabaseError;\r\nuse crate::planner::operator::describe::DescribeOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse sqlparser::ast::ObjectName;\r\nuse std::sync::Arc;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_describe(\r\n        \u0026mut self,\r\n        name: \u0026ObjectName,\r\n    ) -\u003e Result\u003cLogicalPlan, DatabaseError\u003e {\r\n        let table_name = Arc::new(name.to_string());\r\n\r\n        Ok(LogicalPlan::new(\r\n            Operator::Describe(DescribeOperator { table_name }),\r\n            vec![],\r\n        ))\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["E:","\\","sql-layer","src","binder","distinct.rs"],"content":"use crate::binder::Binder;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::aggregate::AggregateOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub fn bind_distinct(\r\n        \u0026mut self,\r\n        children: LogicalPlan,\r\n        select_list: Vec\u003cScalarExpression\u003e,\r\n    ) -\u003e LogicalPlan {\r\n        AggregateOperator::build(children, vec![], select_list, true)\r\n    }\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":2,"coverable":2},{"path":["E:","\\","sql-layer","src","binder","drop_index.rs"],"content":"use std::sync::Arc;\r\n\r\nuse sqlparser::ast::ObjectName;\r\n\r\nuse crate::errors::*;\r\nuse crate::{\r\n    planner::{\r\n        operator::{drop_index::DropIndexOperator, Operator},\r\n        LogicalPlan,\r\n    },\r\n    storage::Transaction,\r\n};\r\n\r\nuse super::Binder;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_drop_index(\r\n        \u0026mut self,\r\n        names: \u0026ObjectName,\r\n        if_exists: \u0026bool,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let object_name = \u0026names.0;\r\n        let table_name = object_name[0].value.to_string();\r\n        let index_name = object_name[1].value.to_string();\r\n\r\n        let table_name = Arc::new(table_name);\r\n        let index_name = Arc::new(index_name);\r\n\r\n        //now only support unique index\r\n\r\n        let plan = LogicalPlan::new(\r\n            Operator::DropIndex(DropIndexOperator {\r\n                table_name,\r\n                index_name,\r\n                if_exists: *if_exists,\r\n            }),\r\n            vec![],\r\n        );\r\n        Ok(plan)\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["E:","\\","sql-layer","src","binder","drop_table.rs"],"content":"use crate::binder::{lower_case_name, split_name, Binder};\r\nuse crate::errors::*;\r\nuse crate::planner::operator::drop_table::DropTableOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse sqlparser::ast::ObjectName;\r\nuse std::sync::Arc;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_drop_table(\r\n        \u0026mut self,\r\n        name: \u0026ObjectName,\r\n        if_exists: \u0026bool,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let name = lower_case_name(name);\r\n        let (_, name) = split_name(\u0026name)?;\r\n        let table_name = Arc::new(name.to_string());\r\n\r\n        let plan = LogicalPlan::new(\r\n            Operator::DropTable(DropTableOperator {\r\n                table_name,\r\n                if_exists: *if_exists,\r\n            }),\r\n            vec![],\r\n        );\r\n\r\n        Ok(plan)\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":9},{"path":["E:","\\","sql-layer","src","binder","explain.rs"],"content":"use crate::binder::Binder;\r\nuse crate::errors::*;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_explain(\u0026mut self, plan: LogicalPlan) -\u003e Result\u003cLogicalPlan\u003e {\r\n        Ok(LogicalPlan::new(Operator::Explain, vec![plan]))\r\n    }\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["E:","\\","sql-layer","src","binder","expr.rs"],"content":"use crate::catalog::ColumnCatalog;\r\n\r\nuse crate::errors::*;\r\nuse crate::expression;\r\nuse crate::expression::agg::Aggregate;\r\nuse crate::planner::LogicalPlan;\r\nuse itertools::Itertools;\r\nuse sqlparser::ast::Query;\r\nuse sqlparser::ast::{\r\n    BinaryOperator, DataType, Expr, Function, FunctionArg, FunctionArgExpr, Ident, UnaryOperator,\r\n};\r\nuse std::slice;\r\nuse std::sync::Arc;\r\n\r\nuse super::Binder;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::storage::Transaction;\r\nuse crate::types::value::DataValue;\r\nuse crate::types::LogicalType;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_expr(\u0026mut self, expr: \u0026Expr) -\u003e Result\u003cScalarExpression\u003e {\r\n        match expr {\r\n            Expr::Identifier(ident) =\u003e {\r\n                self.bind_column_ref_from_identifiers(slice::from_ref(ident), None)\r\n            }\r\n            Expr::CompoundIdentifier(idents) =\u003e self.bind_column_ref_from_identifiers(idents, None),\r\n            Expr::BinaryOp { left, right, op } =\u003e self.bind_binary_op_internal(left, right, op),\r\n            Expr::Value(v) =\u003e Ok(ScalarExpression::Constant(Arc::new(v.into()))),\r\n            Expr::Function(func) =\u003e self.bind_function(func),\r\n            Expr::Nested(expr) =\u003e self.bind_expr(expr),\r\n            Expr::UnaryOp { expr, op } =\u003e self.bind_unary_op_internal(expr, op),\r\n            Expr::Like {\r\n                negated,\r\n                expr,\r\n                pattern,\r\n                ..\r\n            } =\u003e self.bind_like(*negated, expr, pattern),\r\n            Expr::IsNull(expr) =\u003e self.bind_is_null(expr, false),\r\n            Expr::IsNotNull(expr) =\u003e self.bind_is_null(expr, true),\r\n            Expr::InList {\r\n                expr,\r\n                list,\r\n                negated,\r\n            } =\u003e self.bind_is_in(expr, list, *negated),\r\n            Expr::Cast { expr, data_type } =\u003e self.bind_cast(expr, data_type),\r\n            Expr::Subquery(subquery)=\u003e{\r\n                let (sub_query, column) = self.bind_subquery(subquery)?;\r\n                let (expr, _sub_query) =(ScalarExpression::ColumnRef(column), sub_query);\r\n\r\n                Ok(expr)\r\n            }\r\n            _ =\u003e {\r\n                println!(\"expr: {:#?} not support\", expr);\r\n                todo!()\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    fn bind_subquery(\r\n        \u0026mut self,\r\n        subquery: \u0026Query,\r\n    ) -\u003e Result\u003c(LogicalPlan, Arc\u003cColumnCatalog\u003e)\u003e {\r\n        let mut sub_query = self.bind_query(subquery)?;\r\n        let sub_query_schema = sub_query.output_schema();\r\n\r\n        assert!(sub_query_schema.len() == 1);\r\n\r\n        let column = sub_query_schema[0].clone();\r\n        Ok((sub_query, column))\r\n    }\r\n\r\n    pub fn bind_like(\r\n        \u0026mut self,\r\n        negated: bool,\r\n        expr: \u0026Expr,\r\n        pattern: \u0026Expr,\r\n    ) -\u003e Result\u003cScalarExpression\u003e {\r\n        let left_expr = Box::new(self.bind_expr(expr)?);\r\n        let right_expr = Box::new(self.bind_expr(pattern)?);\r\n        let op = if negated {\r\n            expression::BinaryOperator::NotLike\r\n        } else {\r\n            expression::BinaryOperator::Like\r\n        };\r\n        Ok(ScalarExpression::Binary {\r\n            op,\r\n            left_expr,\r\n            right_expr,\r\n            ty: LogicalType::Boolean,\r\n        })\r\n    }\r\n\r\n    pub fn bind_column_ref_from_identifiers(\r\n        \u0026mut self,\r\n        idents: \u0026[Ident],\r\n        bind_table_name: Option\u003c\u0026String\u003e,\r\n    ) -\u003e Result\u003cScalarExpression\u003e {\r\n        let idents = idents\r\n            .iter()\r\n            .map(|ident| Ident::new(ident.value.to_lowercase()))\r\n            .collect_vec();\r\n        let (_schema_name, table_name, column_name) = match idents.as_slice() {\r\n            [column] =\u003e (None, None, \u0026column.value),\r\n            [table, column] =\u003e (None, Some(\u0026table.value), \u0026column.value),\r\n            [schema, table, column] =\u003e (Some(\u0026schema.value), Some(\u0026table.value), \u0026column.value),\r\n            _ =\u003e {\r\n                return Err(DatabaseError::InvalidColumn(\r\n                    idents\r\n                        .iter()\r\n                        .map(|ident| ident.value.clone())\r\n                        .join(\".\")\r\n                        .to_string(),\r\n                ))\r\n            }\r\n        };\r\n\r\n        if let Some(table) = table_name.or(bind_table_name) {\r\n            let table_catalog = self\r\n                .context\r\n                .table(Arc::new(table.clone()))\r\n                .ok_or_else(|| DatabaseError::InvalidTable(table.to_string()))?;\r\n\r\n            let column_catalog = table_catalog\r\n                .get_column_by_name(column_name)\r\n                .ok_or_else(|| DatabaseError::InvalidColumn(column_name.to_string()))?;\r\n            Ok(ScalarExpression::ColumnRef(column_catalog.clone()))\r\n        } else {\r\n            // handle col syntax\r\n            let mut got_column = None;\r\n            for (table_catalog, _) in self.context.bind_table.values() {\r\n                if let Some(column_catalog) = table_catalog.get_column_by_name(column_name) {\r\n                    if got_column.is_some() {\r\n                        return Err(DatabaseError::InvalidColumn(column_name.to_string()));\r\n                    }\r\n                    got_column = Some(column_catalog);\r\n                }\r\n            }\r\n            if got_column.is_none() {\r\n                if let Some(expr) = self.context.aliases.get(column_name) {\r\n                    return Ok(ScalarExpression::Alias {\r\n                        expr: Box::new(expr.clone()),\r\n                        alias: column_name.clone(),\r\n                    });\r\n                }\r\n            }\r\n            let column_catalog =\r\n                got_column.ok_or_else(|| DatabaseError::InvalidColumn(column_name.to_string()))?;\r\n            Ok(ScalarExpression::ColumnRef(column_catalog.clone()))\r\n        }\r\n    }\r\n\r\n    fn bind_binary_op_internal(\r\n        \u0026mut self,\r\n        left: \u0026Expr,\r\n        right: \u0026Expr,\r\n        op: \u0026BinaryOperator,\r\n    ) -\u003e Result\u003cScalarExpression\u003e {\r\n        let left_expr = Box::new(self.bind_expr(left)?);\r\n        let right_expr = Box::new(self.bind_expr(right)?);\r\n\r\n        let ty = match op {\r\n            BinaryOperator::Plus\r\n            | BinaryOperator::Minus\r\n            | BinaryOperator::Multiply\r\n            | BinaryOperator::Divide\r\n            | BinaryOperator::Modulo =\u003e {\r\n                LogicalType::max_logical_type(\u0026left_expr.return_type(), \u0026right_expr.return_type())?\r\n            }\r\n            BinaryOperator::Gt\r\n            | BinaryOperator::Lt\r\n            | BinaryOperator::GtEq\r\n            | BinaryOperator::LtEq\r\n            | BinaryOperator::Eq\r\n            | BinaryOperator::NotEq\r\n            | BinaryOperator::And\r\n            | BinaryOperator::Or\r\n            | BinaryOperator::Xor =\u003e LogicalType::Boolean,\r\n            _ =\u003e todo!(),\r\n        };\r\n\r\n        Ok(ScalarExpression::Binary {\r\n            op: (op.clone()).into(),\r\n            left_expr,\r\n            right_expr,\r\n            ty,\r\n        })\r\n    }\r\n\r\n    fn bind_unary_op_internal(\r\n        \u0026mut self,\r\n        expr: \u0026Expr,\r\n        op: \u0026UnaryOperator,\r\n    ) -\u003e Result\u003cScalarExpression\u003e {\r\n        let expr = Box::new(self.bind_expr(expr)?);\r\n        let ty = if let UnaryOperator::Not = op {\r\n            LogicalType::Boolean\r\n        } else {\r\n            expr.return_type()\r\n        };\r\n\r\n        Ok(ScalarExpression::Unary {\r\n            op: (*op).into(),\r\n            expr,\r\n            ty,\r\n        })\r\n    }\r\n\r\n    fn bind_function(\u0026mut self, func: \u0026Function) -\u003e Result\u003cScalarExpression\u003e {\r\n        let mut args = Vec::with_capacity(func.args.len());\r\n\r\n        for arg in func.args.iter() {\r\n            let arg_expr = match arg {\r\n                FunctionArg::Named { arg, .. } =\u003e arg,\r\n                FunctionArg::Unnamed(arg) =\u003e arg,\r\n            };\r\n            match arg_expr {\r\n                FunctionArgExpr::Expr(expr) =\u003e args.push(self.bind_expr(expr)?),\r\n                FunctionArgExpr::Wildcard =\u003e args.push(Self::wildcard_expr()),\r\n                _ =\u003e todo!(),\r\n            }\r\n        }\r\n\r\n        Ok(match func.name.to_string().as_str() {\r\n            \"count\" =\u003e ScalarExpression::AggCall {\r\n                distinct: func.distinct,\r\n                kind: Aggregate::Count,\r\n                args,\r\n                ty: LogicalType::Integer,\r\n            },\r\n            \"sum\" =\u003e {\r\n                let ty = args[0].return_type();\r\n\r\n                ScalarExpression::AggCall {\r\n                    distinct: func.distinct,\r\n                    kind: Aggregate::Sum,\r\n                    args,\r\n                    ty,\r\n                }\r\n            }\r\n            \"min\" =\u003e {\r\n                let ty = args[0].return_type();\r\n\r\n                ScalarExpression::AggCall {\r\n                    distinct: func.distinct,\r\n                    kind: Aggregate::Min,\r\n                    args,\r\n                    ty,\r\n                }\r\n            }\r\n            \"max\" =\u003e {\r\n                let ty = args[0].return_type();\r\n                ScalarExpression::AggCall {\r\n                    distinct: func.distinct,\r\n                    kind: Aggregate::Max,\r\n                    args,\r\n                    ty,\r\n                }\r\n            }\r\n            \"avg\" =\u003e {\r\n                let ty = args[0].return_type();\r\n                ScalarExpression::AggCall {\r\n                    distinct: func.distinct,\r\n                    kind: Aggregate::Avg,\r\n                    args,\r\n                    ty,\r\n                }\r\n            }\r\n            \"current_schema\" =\u003e {\r\n                let schemas = self.context.transaction.show_tables()?.join(\" \");\r\n\r\n                ScalarExpression::Constant(Arc::new(DataValue::Utf8(Some(schemas))))\r\n            }\r\n            _ =\u003e todo!(),\r\n        })\r\n    }\r\n\r\n    fn bind_is_null(\u0026mut self, expr: \u0026Expr, negated: bool) -\u003e Result\u003cScalarExpression\u003e {\r\n        Ok(ScalarExpression::IsNull {\r\n            negated,\r\n            expr: Box::new(self.bind_expr(expr)?),\r\n        })\r\n    }\r\n\r\n    fn bind_is_in(\r\n        \u0026mut self,\r\n        expr: \u0026Expr,\r\n        list: \u0026[Expr],\r\n        negated: bool,\r\n    ) -\u003e Result\u003cScalarExpression\u003e {\r\n        let args = list.iter().map(|expr| self.bind_expr(expr)).try_collect()?;\r\n\r\n        Ok(ScalarExpression::In {\r\n            negated,\r\n            expr: Box::new(self.bind_expr(expr)?),\r\n            args,\r\n        })\r\n    }\r\n\r\n    fn bind_cast(\u0026mut self, expr: \u0026Expr, ty: \u0026DataType) -\u003e Result\u003cScalarExpression\u003e {\r\n        Ok(ScalarExpression::TypeCast {\r\n            expr: Box::new(self.bind_expr(expr)?),\r\n            ty: LogicalType::try_from(ty.clone())?,\r\n        })\r\n    }\r\n\r\n    fn wildcard_expr() -\u003e ScalarExpression {\r\n        ScalarExpression::Constant(Arc::new(DataValue::Utf8(Some(\"*\".to_string()))))\r\n    }\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":8430738502437568512},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":8430738502437568512},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":8502796096475496447},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":8502796096475496447},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":9583660007044415488},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":9583660007044415488},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":10304235947423694848},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":9583660007044415488},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":10808639105689190400},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1801439850948198400},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":3602879701896396800},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":104,"coverable":180},{"path":["E:","\\","sql-layer","src","binder","insert.rs"],"content":"use crate::binder::{lower_case_name, split_name, Binder};\r\nuse crate::catalog::ColumnRef;\r\nuse crate::errors::*;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::insert::InsertOperator;\r\nuse crate::planner::operator::values::ValuesOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::value::{DataValue, ValueRef};\r\nuse sqlparser::ast::{Expr, Ident, ObjectName};\r\nuse std::slice;\r\nuse std::sync::Arc;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_insert(\r\n        \u0026mut self,\r\n        name: ObjectName,\r\n        idents: \u0026[Ident],\r\n        expr_rows: \u0026Vec\u003cVec\u003cExpr\u003e\u003e,\r\n        is_overwrite: bool,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let name = lower_case_name(\u0026name);\r\n        let (_, name) = split_name(\u0026name)?;\r\n        let table_name = Arc::new(name.to_string());\r\n\r\n        if let Some(table) = self.context.table(table_name.clone()) {\r\n            let mut columns = Vec::new();\r\n            let values_len = expr_rows[0].len();\r\n\r\n            if idents.is_empty() {\r\n                columns = table.all_columns();\r\n                if values_len \u003e columns.len() {\r\n                    return Err(DatabaseError::ValuesLenMismatch(columns.len(), values_len));\r\n                }\r\n            } else {\r\n                let bind_table_name = Some(table_name.to_string());\r\n                for ident in idents {\r\n                    match self.bind_column_ref_from_identifiers(\r\n                        slice::from_ref(ident),\r\n                        bind_table_name.as_ref(),\r\n                    )? {\r\n                        ScalarExpression::ColumnRef(catalog) =\u003e columns.push(catalog),\r\n                        _ =\u003e unreachable!(),\r\n                    }\r\n                }\r\n                if values_len != columns.len() {\r\n                    return Err(DatabaseError::ValuesLenMismatch(columns.len(), values_len));\r\n                }\r\n            }\r\n            let mut rows = Vec::with_capacity(expr_rows.len());\r\n            for expr_row in expr_rows {\r\n                if expr_row.len() != values_len {\r\n                    return Err(DatabaseError::ValuesLenNotSame());\r\n                }\r\n                let mut row = Vec::with_capacity(expr_row.len());\r\n\r\n                for (i, expr) in expr_row.iter().enumerate() {\r\n                    match \u0026self.bind_expr(expr)? {\r\n                        ScalarExpression::Constant(value) =\u003e {\r\n                            // Check if the value length is too long\r\n                            value.check_len(columns[i].datatype())?;\r\n                            let cast_value = DataValue::clone(value).cast(columns[i].datatype())?;\r\n                            row.push(Arc::new(cast_value))\r\n                        }\r\n                        ScalarExpression::Unary { expr, op, .. } =\u003e {\r\n                            if let ScalarExpression::Constant(value) = expr.as_ref() {\r\n                                row.push(Arc::new(\r\n                                    DataValue::unary_op(value, op)?.cast(columns[i].datatype())?,\r\n                                ))\r\n                            } else {\r\n                                unreachable!()\r\n                            }\r\n                        }\r\n                        _ =\u003e unreachable!(),\r\n                    }\r\n                }\r\n\r\n                rows.push(row);\r\n            }\r\n            let values_plan = self.bind_values(rows, columns);\r\n\r\n            Ok(LogicalPlan::new(\r\n                Operator::Insert(InsertOperator {\r\n                    table_name,\r\n                    is_overwrite,\r\n                }),\r\n                vec![values_plan],\r\n            ))\r\n        } else {\r\n            Err(DatabaseError::InvalidTable(format!(\r\n                \"not found table {}\",\r\n                table_name\r\n            )))\r\n        }\r\n    }\r\n\r\n    pub(crate) fn bind_values(\r\n        \u0026mut self,\r\n        rows: Vec\u003cVec\u003cValueRef\u003e\u003e,\r\n        columns: Vec\u003cColumnRef\u003e,\r\n    ) -\u003e LogicalPlan {\r\n        LogicalPlan::new(Operator::Values(ValuesOperator { rows, columns }), vec![])\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null}],"covered":27,"coverable":42},{"path":["E:","\\","sql-layer","src","binder","mod.rs"],"content":"pub mod aggregate;\r\nmod alter_table;\r\npub(crate) mod copy;\r\nmod create_index;\r\nmod create_table;\r\nmod delete;\r\nmod describe;\r\nmod distinct;\r\nmod drop_index;\r\nmod drop_table;\r\nmod explain;\r\npub mod expr;\r\nmod insert;\r\nmod select;\r\nmod set_var;\r\nmod show;\r\nmod update;\r\n\r\nuse crate::errors::*;\r\n\r\nuse sqlparser::ast::{Ident, ObjectName, ObjectType, SetExpr, Statement};\r\nuse std::collections::BTreeMap;\r\n\r\nuse crate::catalog::{TableCatalog, TableName, DEFAULT_SCHEMA_NAME};\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::join::JoinType;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\npub enum InputRefType {\r\n    AggCall,\r\n    GroupBy,\r\n}\r\n\r\n#[derive(Clone)]\r\npub struct BinderContext\u003c'a, T: Transaction\u003e {\r\n    transaction: \u0026'a T,\r\n    pub(crate) bind_table: BTreeMap\u003cTableName, (TableCatalog, Option\u003cJoinType\u003e)\u003e,\r\n    aliases: BTreeMap\u003cString, ScalarExpression\u003e,\r\n    table_aliases: BTreeMap\u003cString, TableName\u003e,\r\n    group_by_exprs: Vec\u003cScalarExpression\u003e,\r\n    pub(crate) agg_calls: Vec\u003cScalarExpression\u003e,\r\n}\r\n\r\nimpl\u003c'a, T: Transaction\u003e BinderContext\u003c'a, T\u003e {\r\n    pub fn new(transaction: \u0026'a T) -\u003e Self {\r\n        BinderContext {\r\n            transaction,\r\n            bind_table: Default::default(),\r\n            aliases: Default::default(),\r\n            table_aliases: Default::default(),\r\n            group_by_exprs: vec![],\r\n            agg_calls: Default::default(),\r\n        }\r\n    }\r\n\r\n    pub fn table(\u0026self, table_name: TableName) -\u003e Option\u003cTableCatalog\u003e {\r\n        if let Some(real_name) = self.table_aliases.get(table_name.as_ref()) {\r\n            self.transaction.table(real_name.clone())\r\n        } else {\r\n            self.transaction.table(table_name)\r\n        }\r\n    }\r\n\r\n    // Tips: The order of this index is based on Aggregate being bound first.\r\n    pub fn input_ref_index(\u0026self, ty: InputRefType) -\u003e usize {\r\n        match ty {\r\n            InputRefType::AggCall =\u003e self.agg_calls.len(),\r\n            InputRefType::GroupBy =\u003e self.agg_calls.len() + self.group_by_exprs.len(),\r\n        }\r\n    }\r\n\r\n    pub fn add_alias(\u0026mut self, alias: String, expr: ScalarExpression) -\u003e Result\u003c()\u003e {\r\n        let is_exist = self.aliases.insert(alias.clone(), expr).is_some();\r\n        if is_exist {\r\n            return Err(DatabaseError::InvalidColumn(format!(\r\n                \"{} duplicated\",\r\n                alias\r\n            )));\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub fn add_table_alias(\u0026mut self, alias: String, table: TableName) -\u003e Result\u003c()\u003e {\r\n        let is_alias_exist = self\r\n            .table_aliases\r\n            .insert(alias.clone(), table.clone())\r\n            .is_some();\r\n        if is_alias_exist {\r\n            return Err(DatabaseError::InvalidTable(format!(\"{} duplicated\", alias)));\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub fn add_bind_table(\r\n        \u0026mut self,\r\n        table: TableName,\r\n        table_catalog: TableCatalog,\r\n        join_type: Option\u003cJoinType\u003e,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let is_bound = self\r\n            .bind_table\r\n            .insert(table.clone(), (table_catalog.clone(), join_type))\r\n            .is_some();\r\n        if is_bound {\r\n            return Err(DatabaseError::InvalidTable(format!(\"{} duplicated\", table)));\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub fn has_agg_call(\u0026self, expr: \u0026ScalarExpression) -\u003e bool {\r\n        self.group_by_exprs.contains(expr)\r\n    }\r\n}\r\n\r\npub struct Binder\u003c'a, T: Transaction\u003e {\r\n    context: BinderContext\u003c'a, T\u003e,\r\n}\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub fn new(context: BinderContext\u003c'a, T\u003e) -\u003e Self {\r\n        Binder { context }\r\n    }\r\n\r\n    pub fn bind(\u0026mut self, stmt: \u0026Statement) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let plan = match stmt {\r\n            Statement::Query(query) =\u003e self.bind_query(query)?,\r\n            Statement::AlterTable { name, operation } =\u003e self.bind_alter_table(name, operation)?,\r\n            Statement::CreateTable {\r\n                name,\r\n                columns,\r\n                constraints,\r\n                if_not_exists,\r\n                ..\r\n            } =\u003e self.bind_create_table(name, columns, constraints, *if_not_exists)?,\r\n            Statement::Drop {\r\n                object_type,\r\n                names,\r\n                if_exists,\r\n                ..\r\n            } =\u003e match object_type {\r\n                ObjectType::Table =\u003e self.bind_drop_table(\u0026names[0], if_exists)?,\r\n                ObjectType::Index =\u003e self.bind_drop_index(\u0026names[0], if_exists)?,\r\n                _ =\u003e todo!(),\r\n            },\r\n            Statement::Insert {\r\n                table_name,\r\n                columns,\r\n                source,\r\n                overwrite,\r\n                ..\r\n            } =\u003e {\r\n                if let SetExpr::Values(values) = source.body.as_ref() {\r\n                    self.bind_insert(table_name.to_owned(), columns, \u0026values.rows, *overwrite)?\r\n                } else {\r\n                    todo!()\r\n                }\r\n            }\r\n            Statement::Update {\r\n                table,\r\n                selection,\r\n                assignments,\r\n                ..\r\n            } =\u003e {\r\n                if !table.joins.is_empty() {\r\n                    unimplemented!()\r\n                } else {\r\n                    self.bind_update(table, selection, assignments)?\r\n                }\r\n            }\r\n            Statement::Delete {\r\n                from, selection, ..\r\n            } =\u003e {\r\n                let table = \u0026from[0];\r\n\r\n                if !table.joins.is_empty() {\r\n                    unimplemented!()\r\n                } else {\r\n                    self.bind_delete(table, selection)?\r\n                }\r\n            }\r\n            Statement::Explain { statement, .. } =\u003e {\r\n                let plan = self.bind(statement)?;\r\n                self.bind_explain(plan)?\r\n            }\r\n            Statement::CreateIndex {\r\n                name,\r\n                table_name,\r\n                columns,\r\n                ..\r\n            } =\u003e {\r\n                //we only support single column index yet\r\n                self.bind_create_index(name, table_name, columns)?\r\n            }\r\n            // Statement::Truncate { table_name, .. } =\u003e self.bind_truncate(table_name)?,\r\n            Statement::ShowTables { .. } =\u003e self.bind_show_tables()?,\r\n            Statement::SetVariable {\r\n                variable, value, ..\r\n            } =\u003e {\r\n                //only support set transaction's  isolation level\r\n                assert_eq!(value.len(), 1);\r\n                self.bind_set_var(variable.to_string(), value[0].to_string())?\r\n            }\r\n            Statement::Copy {\r\n                source,\r\n                target,\r\n                options,\r\n                ..\r\n            } =\u003e self.bind_copy(source.clone(), target.clone(), options)?,\r\n            Statement::ExplainTable {\r\n                describe_alias: true,\r\n                table_name,\r\n            } =\u003e self.bind_describe(table_name)?,\r\n\r\n            _ =\u003e return Err(DatabaseError::UnsupportedStmt(stmt.to_string())),\r\n        };\r\n        Ok(plan)\r\n    }\r\n}\r\n\r\n/// Convert an object name into lower case\r\nfn lower_case_name(name: \u0026ObjectName) -\u003e ObjectName {\r\n    ObjectName(\r\n        name.0\r\n            .iter()\r\n            .map(|ident| Ident::new(ident.value.to_lowercase()))\r\n            .collect(),\r\n    )\r\n}\r\n\r\n/// Split an object name into `(schema name, table name)`.\r\nfn split_name(name: \u0026ObjectName) -\u003e Result\u003c(\u0026str, \u0026str)\u003e {\r\n    Ok(match name.0.as_slice() {\r\n        [table] =\u003e (DEFAULT_SCHEMA_NAME, \u0026table.value),\r\n        [schema, table] =\u003e (\u0026schema.value, \u0026table.value),\r\n        _ =\u003e return Err(DatabaseError::InvalidTable(name.to_string())),\r\n    })\r\n}\r\npub(crate) fn is_valid_identifier(s: \u0026str) -\u003e bool {\r\n    s.chars().all(|c| c.is_alphanumeric() || c == '_')\r\n        \u0026\u0026 !s.chars().next().unwrap_or_default().is_numeric()\r\n        \u0026\u0026 !s.chars().all(|c| c == '_')\r\n}\r\n\r\n#[cfg(test)]\r\npub mod test {\r\n    use super::*;\r\n    use crate::binder::{Binder, BinderContext};\r\n    use crate::catalog::{ColumnCatalog, ColumnDesc};\r\n    \r\n    use crate::parser;\r\n    use crate::planner::LogicalPlan;\r\n    use crate::storage::piggy_stroage::PiggyKVStroage;\r\n    use crate::storage::{Storage, Transaction};\r\n    use crate::types::LogicalType::Integer;\r\n    use std::sync::Arc;\r\n    use tempfile::TempDir;\r\n    pub(crate) async fn build_test_catalog() -\u003e Result\u003cPiggyKVStroage\u003e {\r\n        let path = tempdir::TempDir::new(\"piggydb\")\r\n            .unwrap()\r\n            .path()\r\n            .join(\"piggydb\");\r\n        let storage=PiggyKVStroage::new(path, None);\r\n\r\n        let mut transaction = storage.transaction().await?;\r\n\r\n        let _ = transaction.create_table(\r\n            Arc::new(\"t1\".to_string()),\r\n            vec![\r\n                ColumnCatalog::new(\r\n                    \"c1\".to_string(),\r\n                    false,\r\n                    ColumnDesc::new(Integer, true, false, None),\r\n                    // None,\r\n                ),\r\n                ColumnCatalog::new(\r\n                    \"c2\".to_string(),\r\n                    false,\r\n                    ColumnDesc::new(Integer, false, true, None),\r\n                    // None,\r\n                ),\r\n            ],\r\n            false,\r\n        )?;\r\n\r\n        let _ = transaction.create_table(\r\n            Arc::new(\"t2\".to_string()),\r\n            vec![\r\n                ColumnCatalog::new(\r\n                    \"c3\".to_string(),\r\n                    false,\r\n                    ColumnDesc::new(Integer, true, false, None),\r\n                    // None,\r\n                ),\r\n                ColumnCatalog::new(\r\n                    \"c4\".to_string(),\r\n                    false,\r\n                    ColumnDesc::new(Integer, false, false, None),\r\n                    // None,\r\n                ),\r\n            ],\r\n            false,\r\n        )?;\r\n\r\n        transaction.commit().await?;\r\n\r\n        Ok(storage)\r\n    }\r\n\r\n    pub async fn select_sql_run(sql: \u0026str) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let _temp_dir = TempDir::new().expect(\"unable to create temporary working directory\");\r\n        let storage = build_test_catalog().await?;\r\n        let transaction = storage.transaction().await?;\r\n        let mut binder = Binder::new(BinderContext::new(\u0026transaction));\r\n        let stmt = parser::parse(sql)?;\r\n\r\n        Ok(binder.bind(\u0026stmt[0])?)\r\n    }\r\n\r\n    #[test]\r\n    pub fn test_valid_identifier() {\r\n        assert!(is_valid_identifier(\"valid_table\"));\r\n        assert!(is_valid_identifier(\"valid_column\"));\r\n        assert!(is_valid_identifier(\"_valid_column\"));\r\n        assert!(is_valid_identifier(\"valid_column_1\"));\r\n\r\n        assert!(!is_valid_identifier(\"invalid_name\u0026\"));\r\n        assert!(!is_valid_identifier(\"1_invalid_name\"));\r\n        assert!(!is_valid_identifier(\"____\"));\r\n    }\r\n}\r\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":15348267530078650368},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":15348267530078650368},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":15348267530078650368},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":12249790986447749120},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":3891110078048108544},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null}],"covered":65,"coverable":122},{"path":["E:","\\","sql-layer","src","binder","select.rs"],"content":"use std::borrow::Borrow;\r\nuse std::sync::Arc;\r\n\r\nuse crate::{\r\n    expression::ScalarExpression,\r\n    planner::{\r\n        operator::{\r\n            filter::FilterOperator, join::JoinOperator as LJoinOperator, limit::LimitOperator,\r\n            project::ProjectOperator, Operator,\r\n        },\r\n        operator::{join::JoinType, scan::ScanOperator},\r\n    },\r\n    types::value::DataValue,\r\n};\r\n\r\nuse super::{lower_case_name, Binder};\r\n\r\nuse crate::catalog::{\r\n    ColumnCatalog, TableCatalog, TableName, DEFAULT_DATABASE_NAME, DEFAULT_SCHEMA_NAME,\r\n};\r\nuse crate::errors::*;\r\nuse crate::expression::BinaryOperator;\r\nuse crate::planner::operator::join::JoinCondition;\r\nuse crate::planner::operator::sort::{SortField, SortOperator};\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::LogicalType;\r\nuse itertools::Itertools;\r\nuse sqlparser::ast;\r\nuse sqlparser::ast::{\r\n    Distinct, Expr, Ident, Join, JoinConstraint, JoinOperator, Offset, OrderByExpr, Query, Select,\r\n    SelectItem, SetExpr, TableAlias, TableFactor, TableWithJoins,\r\n};\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_query(\u0026mut self, query: \u0026Query) -\u003e Result\u003cLogicalPlan\u003e {\r\n        if let Some(_with) = \u0026query.with {\r\n            // TODO support with clause.\r\n        }\r\n\r\n        let mut plan = match query.body.borrow() {\r\n            SetExpr::Select(select) =\u003e self.bind_select(select, \u0026query.order_by),\r\n            SetExpr::Query(query) =\u003e self.bind_query(query),\r\n            _ =\u003e unimplemented!(),\r\n        }?;\r\n\r\n        let limit = \u0026query.limit;\r\n        let offset = \u0026query.offset;\r\n\r\n        if limit.is_some() || offset.is_some() {\r\n            plan = self.bind_limit(plan, limit, offset)?;\r\n        }\r\n\r\n        Ok(plan)\r\n    }\r\n\r\n    fn bind_select(\u0026mut self, select: \u0026Select, orderby: \u0026[OrderByExpr]) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let mut plan = self.bind_table_ref(\u0026select.from)?;\r\n\r\n        let mut select_list = self.normalize_select_item(\u0026select.projection)?;\r\n\r\n        self.extract_select_join(\u0026mut select_list);\r\n\r\n        if let Some(predicate) = \u0026select.selection {\r\n            plan = self.bind_where(plan, predicate)?;\r\n        }\r\n\r\n        self.extract_select_aggregate(\u0026mut select_list)?;\r\n\r\n        if !select.group_by.is_empty() {\r\n            self.extract_group_by_aggregate(\u0026mut select_list, \u0026select.group_by)?;\r\n        }\r\n\r\n        let mut having_orderby = (None, None);\r\n\r\n        if select.having.is_some() || !orderby.is_empty() {\r\n            having_orderby = self.extract_having_orderby_aggregate(\u0026select.having, orderby)?;\r\n        }\r\n\r\n        if !self.context.agg_calls.is_empty() || !self.context.group_by_exprs.is_empty() {\r\n            plan = self.bind_aggregate(\r\n                plan,\r\n                self.context.agg_calls.clone(),\r\n                self.context.group_by_exprs.clone(),\r\n            );\r\n        }\r\n\r\n        if let Some(having) = having_orderby.0 {\r\n            plan = self.bind_having(plan, having)?;\r\n        }\r\n\r\n        if let Some(Distinct::Distinct) = select.distinct {\r\n            plan = self.bind_distinct(plan, select_list.clone());\r\n        }\r\n\r\n        if let Some(orderby) = having_orderby.1 {\r\n            plan = self.bind_sort(plan, orderby);\r\n        }\r\n\r\n        plan = self.bind_project(plan, select_list);\r\n        // println!(\"plan:\");\r\n        // println!(\"{:?}\", plan);\r\n        Ok(plan)\r\n    }\r\n\r\n    pub(crate) fn bind_table_ref(\u0026mut self, from: \u0026[TableWithJoins]) -\u003e Result\u003cLogicalPlan\u003e {\r\n        assert!(from.len() \u003c 2, \"not support yet.\");\r\n        if from.is_empty() {\r\n            return Ok(LogicalPlan::new(Operator::Dummy, vec![]));\r\n        }\r\n\r\n        let TableWithJoins { relation, joins } = \u0026from[0];\r\n\r\n        let (left_name, mut plan) = self.bind_single_table_ref(relation, None)?;\r\n\r\n        if !joins.is_empty() {\r\n            let left_name = Self::unpack_name(left_name, true);\r\n\r\n            for join in joins {\r\n                plan = self.bind_join(left_name.clone(), plan, join)?;\r\n            }\r\n        }\r\n        Ok(plan)\r\n    }\r\n\r\n    fn unpack_name(table_name: Option\u003cTableName\u003e, is_left: bool) -\u003e TableName {\r\n        let title = if is_left { \"Left\" } else { \"Right\" };\r\n        table_name.unwrap_or_else(|| panic!(\"{}: Table is not named\", title))\r\n    }\r\n\r\n    fn bind_single_table_ref(\r\n        \u0026mut self,\r\n        table: \u0026TableFactor,\r\n        joint_type: Option\u003cJoinType\u003e,\r\n    ) -\u003e Result\u003c(Option\u003cTableName\u003e, LogicalPlan)\u003e {\r\n        let plan_with_name = match table {\r\n            TableFactor::Table { name, alias, .. } =\u003e {\r\n                let obj_name = name\r\n                    .0\r\n                    .iter()\r\n                    .map(|ident| Ident::new(ident.value.to_string()))\r\n                    .collect_vec();\r\n\r\n                let (_database, _schema, table): (\u0026str, \u0026str, \u0026str) = match obj_name.as_slice() {\r\n                    [table] =\u003e (DEFAULT_DATABASE_NAME, DEFAULT_SCHEMA_NAME, \u0026table.value),\r\n                    [schema, table] =\u003e (DEFAULT_DATABASE_NAME, \u0026schema.value, \u0026table.value),\r\n                    [database, schema, table] =\u003e (\u0026database.value, \u0026schema.value, \u0026table.value),\r\n                    _ =\u003e return Err(DatabaseError::InvalidTable(name.to_string())),\r\n                };\r\n\r\n                let (table, plan) =\r\n                    self._bind_single_table_ref(joint_type, table, Self::trans_alias(alias))?;\r\n                (Some(table), plan)\r\n            }\r\n            TableFactor::Derived {\r\n                subquery, alias, ..\r\n            } =\u003e {\r\n                let plan = self.bind_query(subquery)?;\r\n                let mut tables = plan.referenced_table();\r\n\r\n                if let Some(alias) = Self::trans_alias(alias) {\r\n                    let alias = Arc::new(alias.clone());\r\n\r\n                    if tables.len() \u003e 1 {\r\n                        todo!(\"Implement virtual tables for multiple table aliases\");\r\n                    }\r\n                    self.context\r\n                        .add_table_alias(alias.to_string(), tables.remove(0))?;\r\n\r\n                    (Some(alias), plan)\r\n                } else {\r\n                    ((tables.len() \u003e 1).then(|| tables.pop()).flatten(), plan)\r\n                }\r\n            }\r\n            _ =\u003e unimplemented!(),\r\n        };\r\n\r\n        Ok(plan_with_name)\r\n    }\r\n\r\n    pub(crate) fn trans_alias(alias: \u0026Option\u003cTableAlias\u003e) -\u003e Option\u003c\u0026String\u003e {\r\n        alias.as_ref().map(|alias| \u0026alias.name.value)\r\n    }\r\n\r\n    pub(crate) fn _bind_single_table_ref(\r\n        \u0026mut self,\r\n        join_type: Option\u003cJoinType\u003e,\r\n        table: \u0026str,\r\n        alias: Option\u003c\u0026String\u003e,\r\n    ) -\u003e Result\u003c(Arc\u003cString\u003e, LogicalPlan)\u003e {\r\n        let table_name = Arc::new(table.to_string());\r\n\r\n        let table_catalog = self\r\n            .context\r\n            .table(table_name.clone())\r\n            .ok_or_else(|| DatabaseError::InvalidTable(format!(\"bind table {}\", table)))?;\r\n\r\n        self.context\r\n            .add_bind_table(table_name.clone(), table_catalog.clone(), join_type)?;\r\n\r\n        if let Some(alias) = alias {\r\n            self.context\r\n                .add_table_alias(alias.to_string(), table_name.clone())?;\r\n        }\r\n\r\n        Ok((\r\n            table_name.clone(),\r\n            ScanOperator::build(table_name, \u0026table_catalog),\r\n        ))\r\n    }\r\n\r\n    /// Normalize select item.\r\n    ///\r\n    /// - Qualified name, e.g. `SELECT t.a FROM t`\r\n    /// - Qualified name with wildcard, e.g. `SELECT t.* FROM t,t1`\r\n    /// - Scalar expression or aggregate expression, e.g. `SELECT COUNT(*) + 1 AS count FROM t`\r\n    ///  \r\n    fn normalize_select_item(\u0026mut self, items: \u0026[SelectItem]) -\u003e Result\u003cVec\u003cScalarExpression\u003e\u003e {\r\n        let mut select_items = vec![];\r\n\r\n        for item in items.iter().enumerate() {\r\n            match item.1 {\r\n                SelectItem::UnnamedExpr(expr) =\u003e select_items.push(self.bind_expr(expr)?),\r\n                SelectItem::ExprWithAlias { expr, alias } =\u003e {\r\n                    let expr = self.bind_expr(expr)?;\r\n                    let alias_name = alias.to_string();\r\n\r\n                    self.context.add_alias(alias_name.clone(), expr.clone())?;\r\n\r\n                    select_items.push(ScalarExpression::Alias {\r\n                        expr: Box::new(expr),\r\n                        alias: alias_name,\r\n                    });\r\n                }\r\n                SelectItem::Wildcard(_) =\u003e {\r\n                    select_items.extend_from_slice(self.bind_all_column_refs()?.as_slice());\r\n                }\r\n                SelectItem::QualifiedWildcard(table_name, _) =\u003e {\r\n                    self.bind_table_column_refs(\r\n                        \u0026mut select_items,\r\n                        Arc::new(lower_case_name(table_name).to_string()),\r\n                    )?;\r\n                }\r\n            };\r\n        }\r\n\r\n        Ok(select_items)\r\n    }\r\n\r\n    fn bind_table_column_refs(\r\n        \u0026 self,\r\n        exprs: \u0026mut Vec\u003cScalarExpression\u003e,\r\n        table_name: TableName,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let table = self\r\n            .context\r\n            .table(table_name.clone())\r\n            .ok_or(DatabaseError::TableNotFound)?;\r\n\r\n        let append = table\r\n            .all_columns()\r\n            .into_iter()\r\n            .map(ScalarExpression::ColumnRef)\r\n            .collect_vec();\r\n        exprs.extend(append);\r\n        Ok(())\r\n    }\r\n\r\n    fn bind_all_column_refs(\u0026mut self) -\u003e Result\u003cVec\u003cScalarExpression\u003e\u003e {\r\n        let mut exprs = vec![];\r\n        for table_name in self.context.bind_table.keys() {\r\n            let table = self\r\n                .context\r\n                .table(table_name.clone())\r\n                .ok_or_else(|| DatabaseError::InvalidTable(table_name.to_string()))?;\r\n            for col in table.all_columns() {\r\n                exprs.push(ScalarExpression::ColumnRef(col));\r\n            }\r\n        }\r\n\r\n        Ok(exprs)\r\n    }\r\n\r\n    fn bind_join(\r\n        \u0026mut self,\r\n        left_table: TableName,\r\n        left: LogicalPlan,\r\n        join: \u0026Join,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let Join {\r\n            relation,\r\n            join_operator,\r\n        } = join;\r\n\r\n        let (join_type, joint_condition) = match join_operator {\r\n            JoinOperator::Inner(constraint) =\u003e (JoinType::Inner, Some(constraint)),\r\n            JoinOperator::LeftOuter(constraint) =\u003e (JoinType::Left, Some(constraint)),\r\n            JoinOperator::RightOuter(constraint) =\u003e (JoinType::Right, Some(constraint)),\r\n            JoinOperator::FullOuter(constraint) =\u003e (JoinType::Full, Some(constraint)),\r\n            JoinOperator::CrossJoin =\u003e (JoinType::Cross, None),\r\n            _ =\u003e unimplemented!(),\r\n        };\r\n        let (right_table, right) = self.bind_single_table_ref(relation, Some(join_type))?;\r\n        let right_table = Self::unpack_name(right_table, false);\r\n\r\n        let left_table = self.context.table(left_table.clone()).ok_or_else(|| {\r\n            DatabaseError::InvalidTable(format!(\"Left: {} not found\", left_table))\r\n        })?;\r\n        let right_table = self.context.table(right_table.clone()).ok_or_else(|| {\r\n            DatabaseError::InvalidTable(format!(\"Right: {} not found\", right_table))\r\n        })?;\r\n\r\n        let on = match joint_condition {\r\n            Some(constraint) =\u003e self.bind_join_constraint(\u0026left_table, \u0026right_table, constraint)?,\r\n            None =\u003e JoinCondition::None,\r\n        };\r\n\r\n        Ok(LJoinOperator::build(left, right, on, join_type))\r\n    }\r\n\r\n    pub(crate) fn bind_where(\r\n        \u0026mut self,\r\n        children: LogicalPlan,\r\n        predicate: \u0026Expr,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        Ok(FilterOperator::build(\r\n            self.bind_expr(predicate)?,\r\n            children,\r\n            false,\r\n        ))\r\n    }\r\n\r\n    fn bind_having(\r\n        \u0026mut self,\r\n        children: LogicalPlan,\r\n        having: ScalarExpression,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        self.validate_having_orderby(\u0026having)?;\r\n        Ok(FilterOperator::build(having, children, true))\r\n    }\r\n\r\n    fn bind_project(\r\n        \u0026mut self,\r\n        children: LogicalPlan,\r\n        select_list: Vec\u003cScalarExpression\u003e,\r\n    ) -\u003e LogicalPlan {\r\n        LogicalPlan::new(\r\n            Operator::Project(ProjectOperator { exprs: select_list }),\r\n            vec![children],\r\n        )\r\n    }\r\n\r\n    fn bind_sort(\u0026mut self, children: LogicalPlan, sort_fields: Vec\u003cSortField\u003e) -\u003e LogicalPlan {\r\n        LogicalPlan::new(\r\n            Operator::Sort(SortOperator {\r\n                sort_fields,\r\n                limit: None,\r\n            }),\r\n            vec![children],\r\n        )\r\n    }\r\n\r\n    fn bind_limit(\r\n        \u0026mut self,\r\n        children: LogicalPlan,\r\n        limit_expr: \u0026Option\u003cExpr\u003e,\r\n        offset_expr: \u0026Option\u003cOffset\u003e,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let mut limit = None;\r\n        let mut offset = None;\r\n        if let Some(expr) = limit_expr {\r\n            let expr = self.bind_expr(expr)?;\r\n            match expr {\r\n                ScalarExpression::Constant(dv) =\u003e match dv.as_ref() {\r\n                    DataValue::Int32(Some(v)) if *v \u003e= 0 =\u003e limit = Some(*v as usize),\r\n                    DataValue::Int64(Some(v)) if *v \u003e= 0 =\u003e limit = Some(*v as usize),\r\n                    _ =\u003e return Err(DatabaseError::InvalidType),\r\n                },\r\n                _ =\u003e {\r\n                    return Err(DatabaseError::InvalidColumn(\r\n                        \"invalid limit expression.\".to_owned(),\r\n                    ))\r\n                }\r\n            }\r\n        }\r\n\r\n        if let Some(expr) = offset_expr {\r\n            let expr = self.bind_expr(\u0026expr.value)?;\r\n            match expr {\r\n                ScalarExpression::Constant(dv) =\u003e match dv.as_ref() {\r\n                    DataValue::Int32(Some(v)) if *v \u003e 0 =\u003e offset = Some(*v as usize),\r\n                    DataValue::Int64(Some(v)) if *v \u003e 0 =\u003e offset = Some(*v as usize),\r\n                    _ =\u003e return Err(DatabaseError::InvalidType),\r\n                },\r\n                _ =\u003e {\r\n                    return Err(DatabaseError::InvalidColumn(\r\n                        \"invalid limit expression.\".to_string(),\r\n                    ))\r\n                }\r\n            }\r\n        }\r\n\r\n        // TODO: validate limit and offset is correct use statistic.\r\n\r\n        Ok(LimitOperator::build(offset, limit, children))\r\n    }\r\n\r\n    pub fn extract_select_join(\u0026mut self, select_items: \u0026mut [ScalarExpression]) {\r\n        let bind_tables = \u0026self.context.bind_table;\r\n        if bind_tables.len() \u003c 2 {\r\n            return;\r\n        }\r\n\r\n        let mut table_force_nullable = Vec::with_capacity(bind_tables.len());\r\n        let mut left_table_force_nullable = false;\r\n        let mut left_table = None;\r\n\r\n        for (table, join_option) in bind_tables.values() {\r\n            if let Some(join_type) = join_option {\r\n                let (left_force_nullable, right_force_nullable) = match join_type {\r\n                    JoinType::Inner =\u003e (false, false),\r\n                    JoinType::Left =\u003e (false, true),\r\n                    JoinType::Right =\u003e (true, false),\r\n                    JoinType::Full =\u003e (true, true),\r\n                    JoinType::Cross =\u003e (true, true),\r\n                };\r\n                table_force_nullable.push((table, right_force_nullable));\r\n                left_table_force_nullable = left_force_nullable;\r\n            } else {\r\n                left_table = Some(table);\r\n            }\r\n        }\r\n\r\n        if let Some(table) = left_table {\r\n            table_force_nullable.push((table, left_table_force_nullable));\r\n        }\r\n\r\n        for column in select_items {\r\n            if let ScalarExpression::ColumnRef(col) = column {\r\n                let _ = table_force_nullable\r\n                    .iter()\r\n                    .find(|(table, _)| table.contains_column(col.name()))\r\n                    .map(|(_, nullable)| {\r\n                        let mut new_col = ColumnCatalog::clone(col);\r\n                        new_col.nullable = *nullable;\r\n\r\n                        *col = Arc::new(new_col);\r\n                    });\r\n            }\r\n        }\r\n    }\r\n\r\n    fn bind_join_constraint(\r\n        \u0026mut self,\r\n        left_table: \u0026TableCatalog,\r\n        right_table: \u0026TableCatalog,\r\n        constraint: \u0026JoinConstraint,\r\n    ) -\u003e Result\u003cJoinCondition\u003e {\r\n        match constraint {\r\n            JoinConstraint::On(expr) =\u003e {\r\n                // left and right columns that match equi-join pattern\r\n                let mut on_keys: Vec\u003c(ScalarExpression, ScalarExpression)\u003e = vec![];\r\n                // expression that didn't match equi-join pattern\r\n                let mut filter = vec![];\r\n\r\n                self.extract_join_keys(expr, \u0026mut on_keys, \u0026mut filter, left_table, right_table)?;\r\n\r\n                // combine multiple filter exprs into one BinaryExpr\r\n                let join_filter = filter\r\n                    .into_iter()\r\n                    .reduce(|acc, expr| ScalarExpression::Binary {\r\n                        op: BinaryOperator::And,\r\n                        left_expr: Box::new(acc),\r\n                        right_expr: Box::new(expr),\r\n                        ty: LogicalType::Boolean,\r\n                    });\r\n                // TODO: handle cross join if on_keys is empty\r\n                Ok(JoinCondition::On {\r\n                    on: on_keys,\r\n                    filter: join_filter,\r\n                })\r\n            }\r\n            _ =\u003e unimplemented!(\"not supported join constraint {:?}\", constraint),\r\n        }\r\n    }\r\n\r\n    /// for sqlrs\r\n    /// original idea from datafusion plan.rs\r\n    /// Extracts equijoin ON condition be a single Eq or multiple conjunctive Eqs\r\n    /// Filters matching this pattern are added to `accum`\r\n    /// Filters that don't match this pattern are added to `accum_filter`\r\n    /// Examples:\r\n    /// ```text\r\n    /// foo = bar =\u003e accum=[(foo, bar)] accum_filter=[]\r\n    /// foo = bar AND bar = baz =\u003e accum=[(foo, bar), (bar, baz)] accum_filter=[]\r\n    /// foo = bar AND baz \u003e 1 =\u003e accum=[(foo, bar)] accum_filter=[baz \u003e 1]\r\n    /// ```\r\n    fn extract_join_keys(\r\n        \u0026mut self,\r\n        expr: \u0026Expr,\r\n        accum: \u0026mut Vec\u003c(ScalarExpression, ScalarExpression)\u003e,\r\n        accum_filter: \u0026mut Vec\u003cScalarExpression\u003e,\r\n        left_schema: \u0026TableCatalog,\r\n        right_schema: \u0026TableCatalog,\r\n    ) -\u003e Result\u003c()\u003e {\r\n\r\n        match expr {\r\n            Expr::BinaryOp { left, op, right } =\u003e match op {\r\n                ast::BinaryOperator::Eq =\u003e {\r\n                    let left = self.bind_expr(left)?;\r\n                    let right = self.bind_expr(right)?;\r\n\r\n                    match (\u0026left, \u0026right) {\r\n                        // example: foo = bar\r\n                        (ScalarExpression::ColumnRef(l), ScalarExpression::ColumnRef(r)) =\u003e {\r\n                            // reorder left and right joins keys to pattern: (left, right)\r\n                            if left_schema.contains_column(l.name())\r\n                                \u0026\u0026 right_schema.contains_column(r.name())\r\n                            {\r\n                                accum.push((left, right));\r\n                            } else if left_schema.contains_column(r.name())\r\n                                \u0026\u0026 right_schema.contains_column(l.name())\r\n                            {\r\n                                accum.push((right, left));\r\n                            } else {\r\n                                accum_filter.push(self.bind_expr(expr)?);\r\n                            }\r\n                        }\r\n                        // example: baz = 1\r\n                        _other =\u003e {\r\n                            accum_filter.push(self.bind_expr(expr)?);\r\n                        }\r\n                    }\r\n                }\r\n                ast::BinaryOperator::And =\u003e {\r\n                    // example: foo = bar AND baz \u003e 1\r\n                    if let Expr::BinaryOp { left, op: _, right } = expr {\r\n                        self.extract_join_keys(\r\n                            left,\r\n                            accum,\r\n                            accum_filter,\r\n                            left_schema,\r\n                            right_schema,\r\n                        )?;\r\n                        self.extract_join_keys(\r\n                            right,\r\n                            accum,\r\n                            accum_filter,\r\n                            left_schema,\r\n                            right_schema,\r\n                        )?;\r\n                    }\r\n                }\r\n                // ast::BinaryOperator::Or=\u003e{\r\n\r\n                // }\r\n\r\n                _other =\u003e {\r\n                    // example: baz \u003e 1\r\n                    accum_filter.push(self.bind_expr(expr)?);\r\n                }\r\n            },\r\n            _other =\u003e {\r\n                // example: baz in (xxx), something else will convert to filter logic\r\n                accum_filter.push(self.bind_expr(expr)?);\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":10232178353385766912},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":10232178353385766912},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":10232178353385766912},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":10304235947423694848},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":10232178353385766912},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":7349874591868649472},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":12970366926827028480},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":12970366926827028480},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":10808639105689190400},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":5692549928996306944},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":7493989779944505344},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":3746994889972252672},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":3746994889972252672},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":9799832789158199296},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":9799832789158199296},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":12321848580485677056},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":3746994889972252672},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":2666130979403333632},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":2666130979403333632},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":2666130979403333632},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":2666130979403333632},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":3891110078048108544},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":12465963768561532928},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":11240984669916758016},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":5620492334958379008},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":11240984669916758016},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":5620492334958379008},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":5620492334958379008},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":5620492334958379008},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null}],"covered":173,"coverable":270},{"path":["E:","\\","sql-layer","src","binder","set_var.rs"],"content":"use crate::binder::Binder;\r\nuse crate::planner::operator::set_var::SetVarOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\nuse crate::errors::*;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_set_var(\u0026mut self, var: String, val: String) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let op = SetVarOperator {\r\n            variable: var,\r\n            value: val,\r\n        };\r\n        let plan = LogicalPlan::new(Operator::SetVar(op), vec![]);\r\n        Ok(plan)\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["E:","\\","sql-layer","src","binder","show.rs"],"content":"use crate::binder::Binder;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\nuse crate::errors::*;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_show_tables(\u0026mut self) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let plan = LogicalPlan::new(Operator::Show, vec![]);\r\n        Ok(plan)\r\n    }\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":3,"coverable":3},{"path":["E:","\\","sql-layer","src","binder","update.rs"],"content":"use crate::binder::{lower_case_name, split_name, Binder};\r\nuse crate::errors::*;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::update::UpdateOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\nuse sqlparser::ast::{Assignment, Expr, TableFactor, TableWithJoins};\r\nuse std::slice;\r\nuse std::sync::Arc;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_update(\r\n        \u0026mut self,\r\n        to: \u0026TableWithJoins,\r\n        selection: \u0026Option\u003cExpr\u003e,\r\n        assignments: \u0026[Assignment],\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        if let TableFactor::Table { name, .. } = \u0026to.relation {\r\n            let name = lower_case_name(name);\r\n            let (_, name) = split_name(\u0026name)?;\r\n            let table_name = Arc::new(name.to_string());\r\n\r\n            let mut plan = self.bind_table_ref(slice::from_ref(to))?;\r\n\r\n            if let Some(predicate) = selection {\r\n                plan = self.bind_where(plan, predicate)?;\r\n            }\r\n\r\n            let bind_table_name = Some(table_name.to_string());\r\n\r\n            let mut columns = Vec::with_capacity(assignments.len());\r\n\r\n            let mut set_expr = Vec::with_capacity(assignments.len());\r\n\r\n            for assignment in assignments {\r\n                //set x= expr,  the expr as value\r\n                let value = self.bind_expr(\u0026assignment.value)?;\r\n\r\n                for ident in \u0026assignment.id {\r\n                    match self.bind_column_ref_from_identifiers(\r\n                        slice::from_ref(ident),\r\n                        bind_table_name.as_ref(),\r\n                    )? {\r\n                        ScalarExpression::ColumnRef(catalog) =\u003e {\r\n                            columns.push(catalog);\r\n                            set_expr.push(value.clone());\r\n                        }\r\n                        _ =\u003e unreachable!(),\r\n                    }\r\n                }\r\n            }\r\n            // let values_plan = self.bind_values(vec![], columns);\r\n            Ok(LogicalPlan::new(\r\n                Operator::Update(UpdateOperator {\r\n                    columns,\r\n                    set_expr,\r\n                    table_name,\r\n                }),\r\n                vec![plan],\r\n            ))\r\n        } else {\r\n            unreachable!(\"only table\")\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null}],"covered":21,"coverable":26},{"path":["E:","\\","sql-layer","src","catalog","column.rs"],"content":"\r\nuse serde::{Deserialize, Serialize};\r\nuse std::fmt::Display;\r\nuse std::hash::Hash;\r\nuse std::sync::Arc;\r\n\r\nuse crate::types::value::ValueRef;\r\nuse crate::types::{ColumnId, LogicalType};\r\n\r\nuse super::TableName;\r\n\r\npub type ColumnRef = Arc\u003cColumnCatalog\u003e;\r\npub type SchemaRef = Arc\u003cVec\u003cColumnRef\u003e\u003e;\r\npub type Schema=Vec\u003cColumnRef\u003e;\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]\r\npub struct ColumnCatalog {\r\n    pub summary: ColumnSummary,\r\n    pub nullable: bool,\r\n    pub desc: ColumnDesc,\r\n}\r\n\r\nimpl Display for ColumnCatalog {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        write!(\r\n            f,\r\n            \"col name:{},type:{}\",\r\n            self.summary.name, self.desc.column_datatype\r\n        )\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]\r\npub struct ColumnSummary {\r\n    pub id: Option\u003cColumnId\u003e,\r\n    pub name: String,\r\n    pub table_name: Option\u003cTableName\u003e,\r\n}\r\n\r\nimpl ColumnCatalog {\r\n    pub(crate) fn new(\r\n        column_name: String,\r\n        nullable: bool,\r\n        column_desc: ColumnDesc,\r\n        // ref_expr: Option\u003cScalarExpression\u003e,\r\n    ) -\u003e ColumnCatalog {\r\n        ColumnCatalog {\r\n            summary: ColumnSummary {\r\n                id: None,\r\n                name: column_name,\r\n                table_name: None,\r\n            },\r\n            nullable,\r\n            desc: column_desc,\r\n            // ref_expr,\r\n        }\r\n    }\r\n\r\n    pub(crate) fn new_dummy(column_name: String) -\u003e ColumnCatalog {\r\n        ColumnCatalog {\r\n            summary: ColumnSummary {\r\n                id: Some(0),\r\n                name: column_name,\r\n                table_name: None,\r\n            },\r\n            nullable: false,\r\n            desc: ColumnDesc::new(LogicalType::Varchar(None), false, false, None),\r\n            // ref_expr: None,\r\n        }\r\n    }\r\n    pub fn table_name(\u0026self) -\u003e Option\u003c\u0026TableName\u003e {\r\n        self.summary.table_name.as_ref()\r\n    }\r\n\r\n    pub fn set_table_name(\u0026mut self, table_name: TableName) {\r\n        self.summary.table_name = Some(table_name);\r\n    }\r\n\r\n    pub(crate) fn summary(\u0026self) -\u003e \u0026ColumnSummary {\r\n        \u0026self.summary\r\n    }\r\n\r\n    pub(crate) fn id(\u0026self) -\u003e Option\u003cColumnId\u003e {\r\n        self.summary.id\r\n    }\r\n\r\n    pub fn name(\u0026self) -\u003e \u0026str {\r\n        \u0026self.summary.name\r\n    }\r\n\r\n    pub(crate) fn datatype(\u0026self) -\u003e \u0026LogicalType {\r\n        \u0026self.desc.column_datatype\r\n    }\r\n\r\n    pub(crate) fn default_value(\u0026self) -\u003e Option\u003cValueRef\u003e {\r\n        self.desc.default.clone()\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    pub(crate) fn desc(\u0026self) -\u003e \u0026ColumnDesc {\r\n        \u0026self.desc\r\n    }\r\n}\r\n\r\n/// The descriptor of a column.\r\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Hash)]\r\npub struct ColumnDesc {\r\n    pub(crate) column_datatype: LogicalType,\r\n    pub(crate) is_primary: bool,\r\n    pub(crate) is_unique: bool,\r\n    pub(crate) default: Option\u003cValueRef\u003e,\r\n}\r\n\r\nimpl ColumnDesc {\r\n    pub(crate) const fn new(\r\n        column_datatype: LogicalType,\r\n        is_primary: bool,\r\n        is_unique: bool,\r\n        default: Option\u003cValueRef\u003e,\r\n    ) -\u003e ColumnDesc {\r\n        ColumnDesc {\r\n            column_datatype,\r\n            is_primary,\r\n            is_unique,\r\n            default,\r\n        }\r\n    }\r\n    #[allow(dead_code)]\r\n    pub(crate) fn is_index(\u0026self) -\u003e bool {\r\n        self.is_unique || self.is_primary\r\n    }\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1008806316530991107},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1008806316530991107},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1008806316530991107},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":5980780305148018688},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":5980780305148018688},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":15204152342002794513},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":15204152342002794513},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":4107282860161892353},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":4107282860161892353},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3674937295934324741},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3674937295934324741},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":144115188075855874},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":144115188075855874},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":14555633995661443072},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":28},{"path":["E:","\\","sql-layer","src","catalog","mod.rs"],"content":"// Module: catalog\r\n\r\npub(crate) use self::column::*;\r\npub(crate) use self::table::*;\r\n\r\npub(crate) static DEFAULT_DATABASE_NAME: \u0026str = \"Piggysql\";\r\npub(crate) static DEFAULT_SCHEMA_NAME: \u0026str = \"Piggysql\";\r\n\r\nmod column;\r\nmod table;\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","catalog","table.rs"],"content":"use std::collections::BTreeMap;\r\nuse std::sync::Arc;\r\n\r\nuse itertools::Itertools;\r\n\r\nuse super::column::{ColumnCatalog, ColumnRef};\r\nuse crate::errors::*;\r\nuse crate::types::index::{IndexId, IndexMeta, IndexMetaRef};\r\nuse crate::types::{ColumnId, LogicalType};\r\n\r\npub type TableName = Arc\u003cString\u003e;\r\npub type IndexName = Arc\u003cString\u003e;\r\n\r\n#[derive(Debug, Clone, PartialEq)]\r\npub struct TableCatalog {\r\n    pub(crate) name: TableName,\r\n    /// Mapping from column names to column ids\r\n    column_idxs: BTreeMap\u003cString, ColumnId\u003e,\r\n    pub(crate) columns: BTreeMap\u003cColumnId, ColumnRef\u003e,\r\n    pub(crate) indexes: Vec\u003cIndexMetaRef\u003e,\r\n}\r\n\r\nimpl TableCatalog {\r\n    pub(crate) fn get_unique_index(\u0026self, col_id: \u0026ColumnId) -\u003e Option\u003c\u0026IndexMetaRef\u003e {\r\n        self.indexes\r\n            .iter()\r\n            .find(|meta| meta.is_unique \u0026\u0026 \u0026meta.column_ids[0] == col_id)\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    pub(crate) fn get_column_by_id(\u0026self, id: \u0026ColumnId) -\u003e Option\u003c\u0026ColumnRef\u003e {\r\n        self.columns.get(id)\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    pub(crate) fn get_column_id_by_name(\u0026self, name: \u0026str) -\u003e Option\u003cColumnId\u003e {\r\n        self.column_idxs.get(name).cloned()\r\n    }\r\n\r\n    pub(crate) fn get_column_by_name(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026ColumnRef\u003e {\r\n        let id = self.column_idxs.get(name)?;\r\n        self.columns.get(id)\r\n    }\r\n    #[allow(dead_code)]\r\n    pub(crate) fn types(\u0026self) -\u003e Vec\u003cLogicalType\u003e {\r\n        self.columns\r\n            .values()\r\n            .map(|column| *column.datatype())\r\n            .collect_vec()\r\n    }\r\n\r\n    pub(crate) fn contains_column(\u0026self, name: \u0026str) -\u003e bool {\r\n        self.column_idxs.contains_key(name)\r\n    }\r\n\r\n    pub(crate) fn all_columns_with_id(\u0026self) -\u003e Vec\u003c(\u0026ColumnId, \u0026ColumnRef)\u003e {\r\n        self.columns.iter().collect()\r\n    }\r\n\r\n    pub(crate) fn all_columns(\u0026self) -\u003e Vec\u003cColumnRef\u003e {\r\n        self.columns.values().map(Arc::clone).collect()\r\n    }\r\n\r\n    /// Add a column to the table catalog.\r\n    pub(crate) fn add_column(\u0026mut self, mut col: ColumnCatalog) -\u003e Result\u003cColumnId\u003e {\r\n        if self.column_idxs.contains_key(col.name()) {\r\n            return Err(DatabaseError::Duplicated(\"column\", col.name().to_string()));\r\n        }\r\n\r\n        let col_id = self.columns.len() as u32;\r\n\r\n        col.summary.id = Some(col_id);\r\n        col.summary.table_name = Some(self.name.clone());\r\n        self.column_idxs.insert(col.name().to_string(), col_id);\r\n        self.columns.insert(col_id, Arc::new(col));\r\n\r\n        Ok(col_id)\r\n    }\r\n\r\n    pub(crate) fn add_index_meta(\r\n        \u0026mut self,\r\n        name: String,\r\n        column_ids: Vec\u003cColumnId\u003e,\r\n        is_unique: bool,\r\n        is_primary: bool,\r\n    ) -\u003e \u0026IndexMeta {\r\n        let index_id = self.indexes.len();\r\n\r\n        let index = IndexMeta {\r\n            id: index_id as u32,\r\n            column_ids,\r\n            name,\r\n            is_unique,\r\n            is_primary,\r\n        };\r\n        self.indexes.push(Arc::new(index));\r\n\r\n        \u0026self.indexes[index_id]\r\n    }\r\n    #[allow(dead_code)]\r\n    pub(crate) fn get_index_by_name(\u0026mut self, name: IndexName) -\u003e Result\u003cIndexId\u003e {\r\n        // let index_id = self.indexes.len();\r\n        let pos = self\r\n            .indexes\r\n            .iter()\r\n            .find_position(|idx| idx.name == format!(\"{}_{}\", \"uk\", name));\r\n        match pos {\r\n            Some(pos) =\u003e Ok(self.indexes[pos.0].id),\r\n            None =\u003e Err(DatabaseError::NotFound(\"index\", name.to_string())),\r\n        }\r\n    }\r\n    pub(crate) fn new(name: TableName, columns: Vec\u003cColumnCatalog\u003e) -\u003e Result\u003cTableCatalog\u003e {\r\n        if columns.is_empty() {\r\n            return Err(DatabaseError::ColumnsEmpty);\r\n        }\r\n        let mut table_catalog = TableCatalog {\r\n            name,\r\n            column_idxs: BTreeMap::new(),\r\n            columns: BTreeMap::new(),\r\n            indexes: vec![],\r\n        };\r\n        for col_catalog in columns.into_iter() {\r\n            let _ = table_catalog.add_column(col_catalog)?;\r\n        }\r\n\r\n        Ok(table_catalog)\r\n    }\r\n\r\n    pub(crate) fn new_with_indexes(\r\n        name: TableName,\r\n        columns: Vec\u003cColumnCatalog\u003e,\r\n        indexes: Vec\u003cIndexMetaRef\u003e,\r\n    ) -\u003e Result\u003cTableCatalog\u003e {\r\n        let mut catalog = TableCatalog::new(name, columns)?;\r\n        catalog.indexes = indexes;\r\n\r\n        Ok(catalog)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::catalog::column::ColumnDesc;\r\n    use crate::types::LogicalType;\r\n\r\n    #[test]\r\n    // | a (Int32) | b (Bool) |\r\n    // |-----------|----------|\r\n    // | 1         | true     |\r\n    // | 2         | false    |\r\n    fn test_table_catalog() {\r\n        let col0 = ColumnCatalog::new(\r\n            \"a\".into(),\r\n            false,\r\n            ColumnDesc::new(LogicalType::Integer, false, false, None),\r\n            // None,\r\n        );\r\n        let col1 = ColumnCatalog::new(\r\n            \"b\".into(),\r\n            false,\r\n            ColumnDesc::new(LogicalType::Boolean, false, false, None),\r\n            // None,\r\n        );\r\n        let col_catalogs = vec![col0, col1];\r\n        let table_catalog = TableCatalog::new(Arc::new(\"test\".to_string()), col_catalogs).unwrap();\r\n\r\n        assert_eq!(table_catalog.contains_column(\u0026\"a\".to_string()), true);\r\n        assert_eq!(table_catalog.contains_column(\u0026\"b\".to_string()), true);\r\n        assert_eq!(table_catalog.contains_column(\u0026\"c\".to_string()), false);\r\n\r\n        let col_a_id = table_catalog\r\n            .get_column_id_by_name(\u0026\"a\".to_string())\r\n            .unwrap();\r\n        let col_b_id = table_catalog\r\n            .get_column_id_by_name(\u0026\"b\".to_string())\r\n            .unwrap();\r\n        assert!(col_a_id \u003c col_b_id);\r\n\r\n        let column_catalog = table_catalog.get_column_by_id(\u0026col_a_id).unwrap();\r\n        assert_eq!(column_catalog.name(), \"a\");\r\n        assert_eq!(*column_catalog.datatype(), LogicalType::Integer,);\r\n\r\n        let column_catalog = table_catalog.get_column_by_id(\u0026col_b_id).unwrap();\r\n        assert_eq!(column_catalog.name(), \"b\");\r\n        assert_eq!(*column_catalog.datatype(), LogicalType::Boolean,);\r\n    }\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":12610078956637388800},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":6773413839565225984},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":11240984669916758016},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":11240984669916758016},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":9151314442816847872},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":9151314442816847872},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":9151314442816847872},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":9151314442816847872},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":9151314442816847872},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":12970366926827028480},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":12970366926827028480},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":36,"coverable":50},{"path":["E:","\\","sql-layer","src","db.rs"],"content":"\r\n\r\nuse crate::binder::{Binder, BinderContext};\r\nuse crate::catalog::SchemaRef;\r\nuse crate::execution::executor::{build, Source};\r\nuse crate::optimizer::apply_optimization;\r\nuse crate::parser;\r\n\r\nuse crate::errors::{DatabaseError, Result};\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::piggy_stroage::PiggyKVStroage;\r\nuse crate::storage::{Storage, Transaction};\r\nuse crate::types::tuple::Tuple;\r\npub struct Database\u003cS: Storage\u003e {\r\n    pub(crate) storage: S,\r\n}\r\nimpl Database\u003cPiggyKVStroage\u003e {\r\n    pub fn new_lsm(path: std::path::PathBuf) -\u003e Result\u003cSelf\u003e {\r\n        Ok(Database {\r\n            storage: PiggyKVStroage::new(path, None),\r\n        })\r\n    }\r\n}\r\n// impl Database\u003cMVCCLayer\u003cMemory\u003e\u003e {\r\n//     pub fn new_memory() -\u003e Result\u003cSelf\u003e {\r\n//         Ok(Database {\r\n//             storage: MVCCLayer::new_memory(),\r\n//         })\r\n//     }\r\n// }\r\n\r\nimpl\u003cS: Storage\u003e Database\u003cS\u003e {\r\n    /// Create a new Database instance.\r\n    pub fn new(storage: S) -\u003e Result\u003cSelf\u003e {\r\n        Ok(Database { storage })\r\n    }\r\n\r\n    // /// Run SQL queries.\r\n    pub async fn run(\u0026self, sql: \u0026str) -\u003e Result\u003c(SchemaRef, Vec\u003cTuple\u003e)\u003e {\r\n        let mut transaction = self.storage.transaction().await?;\r\n        let (schema, tuples) = match Self::_run(sql, \u0026mut transaction) {\r\n            Ok((schema, tuples)) =\u003e (schema, tuples),\r\n            Err(e) =\u003e {\r\n                transaction.rollback().await?;\r\n                return Err(e);\r\n            }\r\n        };\r\n\r\n        transaction.commit().await?;\r\n\r\n        Ok((schema, tuples?))\r\n    }\r\n\r\n    pub async fn new_transaction(\u0026self) -\u003e Result\u003cDBTransaction\u003cS\u003e\u003e {\r\n        let transaction = self.storage.transaction().await?;\r\n\r\n        Ok(DBTransaction { inner: transaction })\r\n    }\r\n    pub async fn prepare_sql(\u0026self, sql: \u0026str) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let mut txn = self.storage.transaction().await?;\r\n        let stmts = parser::parse(sql)?;\r\n        if stmts.is_empty() {\r\n            return Err(DatabaseError::EmptyStatement);\r\n        }\r\n        let mut binder = Binder::new(BinderContext::new(\u0026mut txn));\r\n        let source_plan = binder.bind(\u0026stmts[0])?;\r\n        // println!(\"source_plan plan: {:#?}\", source_plan);\r\n        let best_plan = apply_optimization(source_plan)?;\r\n        txn.rollback().await?;\r\n        Ok(best_plan)\r\n    }\r\n    fn _run(\r\n        sql: \u0026str,\r\n        transaction: \u0026mut \u003cS as Storage\u003e::TransactionType,\r\n    ) -\u003e Result\u003c(SchemaRef, Source)\u003e {\r\n        // parse\r\n        let stmts = parser::parse(sql)?;\r\n        if stmts.is_empty() {\r\n            return Err(DatabaseError::EmptyStatement);\r\n        }\r\n        let mut binder = Binder::new(BinderContext::new(transaction));\r\n        let source_plan = binder.bind(\u0026stmts[0])?;\r\n        // println!(\"source_plan plan: {:#?}\", source_plan);\r\n        let mut best_plan = apply_optimization(source_plan)?;\r\n        // println!(\"best_plan plan: {}\", best_plan.explain(0));\r\n        let schema = best_plan.output_schema().clone();\r\n        Ok((schema, build(best_plan, transaction)))\r\n    }\r\n}\r\n\r\npub struct DBTransaction\u003cS: Storage\u003e {\r\n    inner: S::TransactionType,\r\n}\r\n\r\nimpl\u003cS: Storage\u003e DBTransaction\u003cS\u003e {\r\n    pub async fn run(\u0026mut self, sql: \u0026str) -\u003e Result\u003c(SchemaRef, Vec\u003cTuple\u003e)\u003e {\r\n        let (schema, tuples) = Database::\u003cS\u003e::_run(sql, \u0026mut self.inner)?;\r\n        Ok((schema, tuples?))\r\n    }\r\n    pub async fn commit(self) -\u003e Result\u003c()\u003e {\r\n        self.inner.commit().await?;\r\n\r\n        Ok(())\r\n    }\r\n    pub async fn rollback(self) -\u003e Result\u003c()\u003e {\r\n        self.inner.rollback().await?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n\r\n    use crate::db::Database;\r\n    use crate::types::tuple::create_table;\r\n    use crate::types::value::DataValue;\r\n\r\n    use std::sync::Arc;\r\n    #[tokio::test]\r\n    async fn playground() -\u003e Result\u003c()\u003e {\r\n        let path = tempdir::TempDir::new(\"piggydb\")\r\n            .unwrap()\r\n            .path()\r\n            .join(\"piggydb\");\r\n\r\n        let database = Database::new_lsm(path)?;\r\n        database\r\n            .run(\"create table halloween (id int primary key,salary int)\")\r\n            .await?;\r\n\r\n        let tuple = database.run(\"show tables;\").await?;\r\n        println!(\"tuple: {:#?}\", tuple);\r\n        Ok(())\r\n    }\r\n    #[tokio::test]\r\n    async fn test_transaction_sql() -\u003e Result\u003c()\u003e {\r\n        let path = tempdir::TempDir::new(\"piggydb\")\r\n            .unwrap()\r\n            .path()\r\n            .join(\"piggydb\");\r\n\r\n        let database = Database::new_lsm(path)?;\r\n\r\n        database\r\n            .run(\"create table halloween (id int primary key,salary int)\")\r\n            .await?;\r\n        database\r\n            .run(\"insert into halloween values (1,1000), (2,2000), (3,3000), (4,4000)\")\r\n            .await?;\r\n        database\r\n            .run(\"update halloween set salary = salary + 1000 where salary \u003c 3000\")\r\n            .await?;\r\n        let (_, tuple) = database.run(\"select salary from halloween;\").await?;\r\n        assert_eq!(tuple.len(), 4);\r\n        assert_eq!(tuple[0].values[0], Arc::new(DataValue::Int32(Some(2000))));\r\n        assert_eq!(tuple[1].values[0], Arc::new(DataValue::Int32(Some(3000))));\r\n        assert_eq!(tuple[2].values[0], Arc::new(DataValue::Int32(Some(3000))));\r\n        assert_eq!(tuple[3].values[0], Arc::new(DataValue::Int32(Some(4000))));\r\n\r\n        Ok(())\r\n    }\r\n    #[tokio::test]\r\n\r\n    async fn test_crud_sql() -\u003e Result\u003c()\u003e {\r\n        let path = tempdir::TempDir::new(\"piggydb\")\r\n            .unwrap()\r\n            .path()\r\n            .join(\"piggydb\");\r\n\r\n        let database = Database::new_lsm(path)?;\r\n\r\n        let _ = database.run(\r\n            \"create table t1 (a int primary key, b int unique null, k int, z varchar unique null)\",\r\n        ).await?;\r\n        let _ = database\r\n            .run(\"create table t2 (c int primary key, d int unsigned null, e datetime)\")\r\n            .await?;\r\n        let _ = database.run(\"insert into t1 (a, b, k, z) values (-99, 1, 1, 'k'), (-1, 2, 2, 'i'), (5, 3, 2, 'p'), (29, 4, 2, 'db')\").await?;\r\n        let _ = database.run(\"insert into t2 (d, c, e) values (2, 1, '2021-05-20 21:00:00'), (3, 4, '2023-09-10 00:00:00')\").await?;\r\n\r\n        println!(\"full t1:\");\r\n        let tuples_full_fields_t1 = database.run(\"select * from t1\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_full_fields_t1));\r\n\r\n        println!(\"full t2:\");\r\n        let tuples_full_fields_t2 = database.run(\"select * from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_full_fields_t2));\r\n\r\n        println!(\"projection_and_filter:\");\r\n        let tuples_projection_and_filter = database.run(\"select a from t1 where b \u003e 1\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_projection_and_filter));\r\n\r\n        println!(\"projection_and_sort:\");\r\n        let tuples_projection_and_sort = database.run(\"select * from t1 order by a, b\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_projection_and_sort));\r\n\r\n        println!(\"like t1 1:\");\r\n        let tuples_like_1_t1 = database.run(\"select * from t1 where z like '%k'\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_like_1_t1));\r\n\r\n        println!(\"like t1 2:\");\r\n        let tuples_like_2_t1 = database.run(\"select * from t1 where z like '_b'\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_like_2_t1));\r\n\r\n        println!(\"not like t1:\");\r\n        let tuples_not_like_t1 = database\r\n            .run(\"select * from t1 where z not like '_b'\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_not_like_t1));\r\n\r\n        println!(\"in t1:\");\r\n        let tuples_in_t1 = database.run(\"select * from t1 where a in (5, 29)\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_in_t1));\r\n\r\n        println!(\"not in t1:\");\r\n        let tuples_not_in_t1 = database\r\n            .run(\"select * from t1 where a not in (5, 29)\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_not_in_t1));\r\n\r\n        println!(\"limit:\");\r\n        let tuples_limit = database.run(\"select * from t1 limit 1 offset 1\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_limit));\r\n\r\n        println!(\"inner join:\");\r\n        let tuples_inner_join = database\r\n            .run(\"select * from t1 inner join t2 on a = c\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_inner_join));\r\n\r\n        println!(\"left join:\");\r\n        let tuples_left_join = database\r\n            .run(\"select * from t1 left join t2 on a = c\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_left_join));\r\n\r\n        println!(\"right join:\");\r\n        let tuples_right_join = database\r\n            .run(\"select * from t1 right join t2 on a = c\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_right_join));\r\n\r\n        println!(\"full join:\");\r\n        let tuples_full_join = database\r\n            .run(\"select * from t1 full join t2 on a = c\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_full_join));\r\n\r\n        println!(\"count agg:\");\r\n        let tuples_count_agg = database.run(\"select count(d) from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_count_agg));\r\n\r\n        println!(\"count wildcard agg:\");\r\n        let tuples_count_wildcard_agg = database.run(\"select count(*) from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_count_wildcard_agg));\r\n\r\n        println!(\"count distinct agg:\");\r\n        let tuples_count_distinct_agg = database.run(\"select count(distinct d) from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_count_distinct_agg));\r\n\r\n        println!(\"sum agg:\");\r\n        let tuples_sum_agg = database.run(\"select sum(d) from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_sum_agg));\r\n\r\n        println!(\"sum distinct agg:\");\r\n        let tuples_sum_distinct_agg = database.run(\"select sum(distinct d) from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_sum_distinct_agg));\r\n\r\n        println!(\"avg agg:\");\r\n        let tuples_avg_agg = database.run(\"select avg(d) from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_avg_agg));\r\n\r\n        println!(\"min_max agg:\");\r\n        let tuples_min_max_agg = database.run(\"select min(d), max(d) from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_min_max_agg));\r\n\r\n        println!(\"group agg:\");\r\n        let tuples_group_agg = database\r\n            .run(\"select c, max(d) from t2 group by c having c = 1\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_group_agg));\r\n\r\n        println!(\"alias:\");\r\n        let tuples_group_agg = database.run(\"select c as o from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_group_agg));\r\n\r\n        println!(\"alias agg:\");\r\n        let tuples_group_agg = database\r\n            .run(\"select c, max(d) as max_d from t2 group by c having c = 1\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_group_agg));\r\n\r\n        println!(\"time max:\");\r\n        let tuples_time_max = database.run(\"select max(e) as max_time from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_time_max));\r\n\r\n        println!(\"time where:\");\r\n        let tuples_time_where_t2 = database\r\n            .run(\"select (c + 1) from t2 where e \u003e '2021-05-20'\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_time_where_t2));\r\n\r\n        println!(\"distinct t1:\");\r\n        let tuples_distinct_t1 = database.run(\"select distinct b, k from t1\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_distinct_t1));\r\n\r\n        println!(\"update t1 with filter:\");\r\n        let _ = database.run(\"update t1 set b = 0 where b = 1\").await?;\r\n        println!(\"after t1:\");\r\n        let update_after_full_t1 = database.run(\"select * from t1\").await?;\r\n        println!(\"{}\", create_table(\u0026update_after_full_t1));\r\n\r\n        println!(\"insert overwrite t1:\");\r\n        let _ = database\r\n            .run(\"insert overwrite t1 (a, b, k) values (-99, 1, 0)\")\r\n            .await?;\r\n        println!(\"after t1:\");\r\n        let insert_overwrite_after_full_t1 = database.run(\"select * from t1\").await?;\r\n        println!(\"{}\", create_table(\u0026insert_overwrite_after_full_t1));\r\n\r\n        assert!(database\r\n            .run(\"insert overwrite t1 (a, b, k) values (-1, 1, 0)\")\r\n            .await\r\n            .is_err());\r\n\r\n        println!(\"delete t1 with filter:\");\r\n        let _ = database.run(\"delete from t1 where b = 0\").await?;\r\n        println!(\"after t1:\");\r\n        let delete_after_full_t1 = database.run(\"select * from t1\").await?;\r\n        println!(\"{}\", create_table(\u0026delete_after_full_t1));\r\n\r\n        println!(\"drop t1:\");\r\n        let _ = database.run(\"drop table t1\").await?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":14,"coverable":45},{"path":["E:","\\","sql-layer","src","errors.rs"],"content":"use std::{\r\n    array::TryFromSliceError,\r\n    num::{ParseFloatError, ParseIntError, TryFromIntError},\r\n    str::ParseBoolError,\r\n    string::FromUtf8Error,\r\n};\r\n\r\nuse chrono::ParseError;\r\nuse sqlparser::parser::ParserError;\r\npub type Result\u003cT\u003e = std::result::Result\u003cT, DatabaseError\u003e;\r\nuse crate::{\r\n    expression::BinaryOperator,\r\n    types::{value::DataValue, LogicalType},\r\n};\r\n\r\n#[derive(thiserror::Error, Debug)]\r\npub enum DatabaseError {\r\n    #[error(\"sql statement is empty\")]\r\n    EmptyStatement,\r\n    #[error(\"invalid type\")]\r\n    InvalidType,\r\n    #[error(\"must contain PrimaryKey!\")]\r\n    PrimaryKeyNotFound,\r\n    #[error(\"not implemented sqlparser datatype: {0}\")]\r\n    NotImplementedSqlparserDataType(String),\r\n    #[error(\"Type:{0},lhs:{1} cast to {2} fail\")]\r\n    CastFail(LogicalType, DataValue, LogicalType),\r\n    #[error(\"too long\")]\r\n    TooLong,\r\n    #[error(\"cannot be Null\")]\r\n    NotNull,\r\n    #[error(\"try from int: {0}\")]\r\n    TryFromInt(\r\n        #[source]\r\n        #[from]\r\n        TryFromIntError,\r\n    ),\r\n    #[error(\"parser int: {0}\")]\r\n    ParseInt(\r\n        #[source]\r\n        #[from]\r\n        ParseIntError,\r\n    ),\r\n    #[error(\"parser bool: {0}\")]\r\n    ParseBool(\r\n        #[source]\r\n        #[from]\r\n        ParseBoolError,\r\n    ),\r\n    #[error(\"parser float: {0}\")]\r\n    ParseFloat(\r\n        #[source]\r\n        #[from]\r\n        ParseFloatError,\r\n    ),\r\n    #[error(\"parser date: {0}\")]\r\n    ParseDate(\r\n        #[source]\r\n        #[from]\r\n        ParseError,\r\n    ),\r\n    #[error(\"parser sql: {0}\")]\r\n    ParserSql(\r\n        #[source]\r\n        #[from]\r\n        ParserError,\r\n    ),\r\n    #[error(\"bindcode: {0}\")]\r\n    Bincode(\r\n        #[source]\r\n        #[from]\r\n        Box\u003cbincode::ErrorKind\u003e,\r\n    ),\r\n    #[error(\"from utf8: {0}\")]\r\n    FromUtf8Error(\r\n        #[source]\r\n        #[from]\r\n        FromUtf8Error,\r\n    ),\r\n    #[error(\"try from decimal\")]\r\n    TryFromDecimal(\r\n        #[source]\r\n        #[from]\r\n        rust_decimal::Error,\r\n    ),\r\n\r\n    #[error(\"{0} and {1} do not match\")]\r\n    MisMatch(String, String),\r\n    #[error(\"io: {0}\")]\r\n    IO(\r\n        #[source]\r\n        #[from]\r\n        std::io::Error,\r\n    ),\r\n    #[error(\"the same primary key data already exists\")]\r\n    DuplicatePrimaryKey,\r\n    #[error(\"the column has been declared unique and the value already exists\")]\r\n    DuplicateUniqueValue,\r\n    #[error(\"the table not found\")]\r\n    TableNotFound,\r\n    #[error(\"the some column already exists\")]\r\n    DuplicateColumn,\r\n    #[error(\"add column must be nullable or specify a default value\")]\r\n    NeedNullAbleOrDefault,\r\n    #[error(\"the table already exists\")]\r\n    TableExists,\r\n    #[error(\"plan is empty\")]\r\n    EmptyPlan,\r\n    #[error(\"this column must belong to a table\")]\r\n    OwnerLessColumn,\r\n    #[error(\"there are more buckets: {0} than elements: {1}\")]\r\n    TooManyBuckets(usize, usize),\r\n    #[error(\"tuple length mismatch: expected {expected} but got {actual}\")]\r\n    LengthMismatch { expected: usize, actual: usize },\r\n    #[error(\"join error\")]\r\n    JoinError(\r\n        #[from]\r\n        #[source]\r\n        tokio::task::JoinError,\r\n    ),\r\n    #[error(\"invalid index\")]\r\n    InvalidIndex,\r\n    #[error(\"{0} not found: {1}\")]\r\n    NotFound(\u0026'static str, String),\r\n    #[error(\"duplicated {0}: {1}\")]\r\n    Duplicated(\u0026'static str, String),\r\n    #[error(\"columns empty\")]\r\n    ColumnsEmpty,\r\n    #[error(\"unsupported statement {0}\")]\r\n    UnsupportedStmt(String),\r\n    #[error(\"invalid table {0}\")]\r\n    InvalidTable(String),\r\n    #[error(\"invalid column {0}\")]\r\n    InvalidColumn(String),\r\n    #[error(\"ambiguous column {0}\")]\r\n    AmbiguousColumn(String),\r\n    #[error(\"values length not match, expect {0}, got {1}\")]\r\n    ValuesLenMismatch(usize, usize),\r\n    #[error(\"values list must all be the same length\")]\r\n    ValuesLenNotSame(),\r\n    #[error(\"binary operator types mismatch: {0} != {1}\")]\r\n    BinaryOpTypeMismatch(String, String),\r\n    #[error(\"subquery error: {0}\")]\r\n    Subquery(String),\r\n    #[error(\"agg miss: {0}\")]\r\n    AggMiss(String),\r\n    #[error(\"copy error: {0}\")]\r\n    UnsupportedCopySource(String),\r\n    #[error(\"can not compare two types: {0} and {1}\")]\r\n    Incomparable(LogicalType, LogicalType),\r\n\r\n    #[error(\"transaction already exists\")]\r\n    TransactionAlreadyExists,\r\n    #[error(\"no transaction begin\")]\r\n    NoTransactionBegin,\r\n\r\n    #[error(\"W-W conflict error\")]\r\n    Serialization,\r\n    #[error(\"{0}\")]\r\n    InternalError(String),\r\n    #[error(\"type cast error {0}\")]\r\n    CastError(\r\n        #[from]\r\n        #[source]\r\n        TryFromSliceError,\r\n    ),\r\n\r\n    #[error(\"sled error {0}\")]\r\n    SledError(\r\n        #[from]\r\n        #[source]\r\n        sled::Error,\r\n    ),\r\n    #[error(\"csv error: {0}\")]\r\n    Csv(\r\n        #[from]\r\n        #[source]\r\n        csv::Error,\r\n    ),\r\n    #[error(\"the {0} cannot support {1} for calculations\")]\r\n    UnsupportedBinaryOperator(LogicalType, BinaryOperator),\r\n\r\n    #[error(\"the DDL must run in serial,already running in: {0} transaction\")]\r\n    DDLSerialError(usize),\r\n\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","execution","executor","ddl","alter_table.rs"],"content":"use crate::execution::executor::{build, DatabaseError, Source};\r\nuse crate::planner::operator::alter_table::{AddColumnOperator, DropColumnOperator};\r\n\r\nuse crate::planner::LogicalPlan;\r\nuse crate::types::tuple_builder::TupleBuilder;\r\nuse crate::types::value::DataValue;\r\n\r\nuse std::sync::Arc;\r\n\r\nuse crate::types::index::Index;\r\nuse crate::{execution::executor::Executor, storage::Transaction};\r\n\r\npub struct AddColumn {\r\n    op: AddColumnOperator,\r\n    input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(AddColumnOperator, LogicalPlan)\u003e for AddColumn {\r\n    fn from((op, input): (AddColumnOperator, LogicalPlan)) -\u003e Self {\r\n        Self { op, input }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for AddColumn {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let AddColumn { op, input } = self;\r\n        let mut input = build(input, transaction)?;\r\n        let mut unique_values = op.column.desc().is_unique.then(Vec::new);\r\n\r\n        for tuple in input.iter_mut() {\r\n            // tuple.columns.push(Arc::new(column.clone()));\r\n            if let Some(value) = op.column.default_value() {\r\n                if let Some(unique_values) = \u0026mut unique_values {\r\n                    unique_values.push((tuple.id.clone().unwrap(), value.clone()));\r\n                }\r\n                tuple.values.push(value);\r\n            } else {\r\n                tuple.values.push(Arc::new(DataValue::Null));\r\n            }\r\n            transaction.append(\u0026op.table_name, tuple.clone(), true)?;\r\n        }\r\n        let col_id = transaction.add_column(\u0026op.table_name, \u0026op.column, op.if_not_exists)?;\r\n\r\n        // Unique Index\r\n        let table = transaction\r\n            .table(op.table_name.clone())\r\n            .expect(\"table fetch error\");\r\n        let unique_meta = table.get_unique_index(\u0026col_id).cloned();\r\n        if let (Some(unique_values), Some(unique_meta)) = (unique_values, unique_meta) {\r\n            for (tuple_id, value) in unique_values {\r\n                let index = Index {\r\n                    id: unique_meta.id,\r\n                    column_values: vec![value],\r\n                };\r\n                transaction.add_index(\u0026op.table_name, index, vec![tuple_id], true)?;\r\n            }\r\n        }\r\n\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple = tuple_builder.push_result(\"ALTER TABLE SUCCESS\", \"1\")?;\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n\r\npub struct DropColumn {\r\n    op: DropColumnOperator,\r\n    input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(DropColumnOperator, LogicalPlan)\u003e for DropColumn {\r\n    fn from((op, input): (DropColumnOperator, LogicalPlan)) -\u003e Self {\r\n        Self { op, input }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for DropColumn {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let DropColumnOperator {\r\n            table_name,\r\n            column_name,\r\n            if_exists,\r\n        } = \u0026self.op;\r\n        let DropColumn { mut input, .. } = self;\r\n        let schema = input.output_schema().clone();\r\n        let mut input = build(input, transaction)?;\r\n        let mut option_column_index = None;\r\n\r\n        for tuple in input.iter_mut() {\r\n            if option_column_index.is_none() {\r\n                if let Some((column_index, is_primary)) = schema\r\n                    .iter()\r\n                    .enumerate()\r\n                    .find(|(_, column)| column.name() == column_name)\r\n                    .map(|(i, column)| (i, column.desc.is_primary))\r\n                {\r\n                    if is_primary {\r\n                        Err(DatabaseError::InvalidColumn(\r\n                            \"drop of primary key column is not allowed.\".to_owned(),\r\n                        ))?;\r\n                    }\r\n                    option_column_index = Some(column_index);\r\n                }\r\n            }\r\n            if option_column_index.is_none() \u0026\u0026 *if_exists {\r\n                return Ok(vec![]);\r\n            }\r\n            let column_index = option_column_index\r\n                .ok_or_else(|| DatabaseError::InvalidColumn(\"not found column\".to_string()))?;\r\n\r\n            let _ = tuple.values.remove(column_index);\r\n\r\n            transaction.append(table_name, tuple.clone(), true)?;\r\n        }\r\n        transaction.drop_column(table_name, column_name, *if_exists)?;\r\n\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple = tuple_builder.push_result(\"ALTER TABLE SUCCESS\", \"1\")?;\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":54},{"path":["E:","\\","sql-layer","src","execution","executor","ddl","create_index.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::planner::operator::create_index::CreateIndexOperator;\r\nuse crate::storage::Transaction;\r\n\r\nuse crate::types::tuple_builder::TupleBuilder;\r\n\r\npub struct CreateIndex {\r\n    op: CreateIndexOperator,\r\n}\r\n\r\nimpl From\u003cCreateIndexOperator\u003e for CreateIndex {\r\n    fn from(op: CreateIndexOperator) -\u003e Self {\r\n        CreateIndex { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for CreateIndex {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let CreateIndexOperator {\r\n            table_name,\r\n            index_name,\r\n            col_name,\r\n        } = self.op;\r\n        let _ = transaction.create_index(table_name.clone(), index_name, \u0026col_name)?;\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple = tuple_builder\r\n            .push_result(\"CREATE INDEX SUCCESS\", format!(\"{}\", table_name).as_str())?;\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["E:","\\","sql-layer","src","execution","executor","ddl","create_table.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::planner::operator::create_table::CreateTableOperator;\r\nuse crate::storage::Transaction;\r\n\r\nuse crate::types::tuple_builder::TupleBuilder;\r\n\r\npub struct CreateTable {\r\n    op: CreateTableOperator,\r\n}\r\n\r\nimpl From\u003cCreateTableOperator\u003e for CreateTable {\r\n    fn from(op: CreateTableOperator) -\u003e Self {\r\n        CreateTable { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for CreateTable {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let CreateTableOperator {\r\n            table_name,\r\n            columns,\r\n            if_not_exists,\r\n        } = self.op;\r\n        let _ = transaction.create_table(table_name.clone(), columns, if_not_exists)?;\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple =\r\n            tuple_builder.push_result(\"CREATE TABLE\", format!(\"{}\", table_name).as_str())?;\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null}],"covered":11,"coverable":12},{"path":["E:","\\","sql-layer","src","execution","executor","ddl","drop_index.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::planner::operator::drop_index::DropIndexOperator;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple_builder::TupleBuilder;\r\n\r\npub struct DropIndex {\r\n    op: DropIndexOperator,\r\n}\r\n\r\nimpl From\u003cDropIndexOperator\u003e for DropIndex {\r\n    fn from(op: DropIndexOperator) -\u003e Self {\r\n        DropIndex { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for DropIndex {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let DropIndexOperator {\r\n            index_name,\r\n            table_name,\r\n            if_exists,\r\n        } = self.op;\r\n\r\n        transaction.drop_index(table_name, index_name.clone(), if_exists)?;\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple =\r\n            tuple_builder.push_result(\"DROP INDEX SUCCESS\", format!(\"{}\", index_name).as_str())?;\r\n\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["E:","\\","sql-layer","src","execution","executor","ddl","drop_table.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::planner::operator::drop_table::DropTableOperator;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple_builder::TupleBuilder;\r\n\r\npub struct DropTable {\r\n    op: DropTableOperator,\r\n}\r\n\r\nimpl From\u003cDropTableOperator\u003e for DropTable {\r\n    fn from(op: DropTableOperator) -\u003e Self {\r\n        DropTable { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for DropTable {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let DropTableOperator {\r\n            table_name,\r\n            if_exists,\r\n        } = self.op;\r\n\r\n        transaction.drop_table(\u0026table_name.clone(), if_exists)?;\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple =\r\n            tuple_builder.push_result(\"DROP TABLE SUCCESS\", format!(\"{}\", table_name).as_str())?;\r\n\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":10,"coverable":11},{"path":["E:","\\","sql-layer","src","execution","executor","ddl","mod.rs"],"content":"pub(crate) mod alter_table;\npub(crate) mod create_index;\npub(crate) mod create_table;\npub(crate) mod drop_index;\npub(crate) mod drop_table;\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","execution","executor","dml","copy.rs"],"content":"use crate::binder::copy::FileFormat;\r\nuse crate::errors::*;\r\nuse crate::execution::executor::{Executor, Source};\r\nuse crate::planner::operator::copy_from_file::CopyFromFileOperator;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::tuple_builder::TupleBuilder;\r\nuse csv::Terminator;\r\nuse itertools::Itertools;\r\nuse std::fs::File;\r\nuse std::io::BufReader;\r\nuse tracing::debug;\r\n#[allow(dead_code)]\r\npub struct CopyFromFile {\r\n    op: CopyFromFileOperator,\r\n    size: usize,\r\n}\r\nimpl From\u003cCopyFromFileOperator\u003e for CopyFromFile {\r\n    fn from(op: CopyFromFileOperator) -\u003e Self {\r\n        CopyFromFile { op, size: 0 }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for CopyFromFile {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let table_name = self.op.table.clone();\r\n        let tuples = self.read_file_blocking()?;\r\n        let mut size = 0_usize;\r\n        for tuple in tuples {\r\n            transaction.append(\u0026table_name, tuple, false)?;\r\n            size += 1;\r\n        }\r\n\r\n        let res = return_result(size)?;\r\n        Ok(vec![res])\r\n    }\r\n}\r\nfn return_result(size: usize) -\u003e Result\u003cTuple\u003e {\r\n    let builder = TupleBuilder::new_result();\r\n    let tuple = builder.push_result(\"COPY FROM SOURCE\", \u0026format!(\"import {} rows\", size))?;\r\n\r\n    Ok(tuple)\r\n}\r\n\r\nimpl CopyFromFile {\r\n    /// Read records from file using blocking IO.\r\n    fn read_file_blocking(mut self) -\u003e Result\u003cVec\u003cTuple\u003e\u003e {\r\n        let file = File::open(self.op.source.path)?;\r\n        let mut buf_reader = BufReader::new(file);\r\n        let mut reader = match self.op.source.format {\r\n            FileFormat::Csv {\r\n                delimiter: _,\r\n                quote,\r\n                escape,\r\n                header,\r\n            } =\u003e csv::ReaderBuilder::new()\r\n                .delimiter(b'|')\r\n                .quote(quote as u8)\r\n                .escape(escape.map(|c| c as u8))\r\n                .has_headers(header)\r\n                .terminator(Terminator::CRLF)\r\n                .from_reader(\u0026mut buf_reader),\r\n        };\r\n\r\n        let column_count = self.op.schema_ref.len();\r\n\r\n        debug!(\"column count: {}\", column_count);\r\n        let tuple_builder = TupleBuilder::new(self.op.schema_ref.clone());\r\n        let mut tuples = vec![];\r\n        for record in reader.records() {\r\n            // read records and push raw str rows into data chunk builder\r\n            let record = record?;\r\n\r\n            if !(record.len() == column_count\r\n                || record.len() == column_count + 1 \u0026\u0026 record.get(column_count) == Some(\"\"))\r\n            {\r\n                return Err(DatabaseError::LengthMismatch {\r\n                    expected: column_count,\r\n                    actual: record.len(),\r\n                });\r\n            }\r\n\r\n            self.size += 1;\r\n            tuples.push(tuple_builder.build_with_row(record.iter().take(column_count))?);\r\n        }\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":28},{"path":["E:","\\","sql-layer","src","execution","executor","dml","delete.rs"],"content":"use crate::catalog::TableName;\r\nuse crate::execution::executor::{build, Executor, Source};\r\n\r\nuse crate::planner::operator::delete::DeleteOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::index::Index;\r\nuse crate::types::tuple_builder::TupleBuilder;\r\n\r\nuse itertools::Itertools;\r\n\r\npub struct Delete {\r\n    table_name: TableName,\r\n    input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(DeleteOperator, LogicalPlan)\u003e for Delete {\r\n    fn from((DeleteOperator { table_name }, input): (DeleteOperator, LogicalPlan)) -\u003e Self {\r\n        Delete { table_name, input }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Delete {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let Delete { table_name, input } = self;\r\n        let input = build(input, transaction)?;\r\n        let option_index_metas = transaction.table(table_name.clone()).map(|table_catalog| {\r\n            table_catalog\r\n                .all_columns()\r\n                .into_iter()\r\n                .enumerate()\r\n                .filter_map(|(i, col)| {\r\n                    col.desc\r\n                        .is_unique\r\n                        .then(|| {\r\n                            col.id().and_then(|col_id| {\r\n                                table_catalog\r\n                                    .get_unique_index(\u0026col_id)\r\n                                    .map(|index_meta| (i, index_meta.clone()))\r\n                            })\r\n                        })\r\n                        .flatten()\r\n                })\r\n                .collect_vec()\r\n        });\r\n        if let Some(index_metas) = option_index_metas {\r\n            for tuple in input.iter() {\r\n                for (i, index_meta) in index_metas.iter() {\r\n                    let value = \u0026tuple.values[*i];\r\n\r\n                    if !value.is_null() {\r\n                        let index = Index {\r\n                            id: index_meta.id,\r\n                            column_values: vec![value.clone()],\r\n                        };\r\n\r\n                        transaction.del_index(\u0026table_name, \u0026index)?;\r\n                    }\r\n                }\r\n\r\n                if let Some(tuple_id) = tuple.id.clone() {\r\n                    transaction.delete(\u0026table_name, tuple_id)?;\r\n                }\r\n            }\r\n        }\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple = tuple_builder.push_result(\"DELETE SUCCESS\", \u0026format!(\"{}\", input.len()))?;\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":23,"coverable":32},{"path":["E:","\\","sql-layer","src","execution","executor","dml","insert.rs"],"content":"use crate::catalog::TableName;\r\nuse crate::errors::*;\r\nuse crate::execution::executor::{build, Executor, Source};\r\nuse crate::planner::operator::insert::InsertOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::index::Index;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::tuple_builder::TupleBuilder;\r\nuse crate::types::value::DataValue;\r\n\r\nuse std::collections::HashMap;\r\nuse std::sync::Arc;\r\n\r\npub struct Insert {\r\n    table_name: TableName,\r\n    input: LogicalPlan,\r\n    is_overwrite: bool,\r\n}\r\n\r\nimpl From\u003c(InsertOperator, LogicalPlan)\u003e for Insert {\r\n    fn from(\r\n        (\r\n            InsertOperator {\r\n                table_name,\r\n                is_overwrite,\r\n            },\r\n            input,\r\n        ): (InsertOperator, LogicalPlan),\r\n    ) -\u003e Self {\r\n        Insert {\r\n            table_name,\r\n            input,\r\n            is_overwrite,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Insert {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let Insert {\r\n            table_name,\r\n            mut input,\r\n            is_overwrite,\r\n        } = self;\r\n        let schema = input.output_schema().clone();\r\n        let input = build(input, transaction)?;\r\n        let mut primary_key_index = None;\r\n        let mut unique_values = HashMap::new();\r\n        if let Some(table_catalog) = transaction.table(table_name.clone()) {\r\n            for tuple in input.iter() {\r\n                let Tuple { values, .. } = tuple;\r\n                let mut tuple_map = HashMap::new();\r\n                for (i, value) in values.iter().enumerate() {\r\n                    let col = \u0026schema[i];\r\n\r\n                    if let Some(col_id) = col.id() {\r\n                        tuple_map.insert(col_id, value.clone());\r\n                    }\r\n                }\r\n                let primary_col_id = primary_key_index.get_or_insert_with(|| {\r\n                    schema\r\n                        .iter()\r\n                        .find(|col| col.desc.is_primary)\r\n                        .map(|col| col.id().unwrap())\r\n                });\r\n                let all_columns = table_catalog.all_columns_with_id();\r\n                let tuple_id = match primary_col_id {\r\n                    Some(primary_col_id) =\u003e tuple_map.get(primary_col_id).cloned(),\r\n                    None =\u003e None,\r\n                };\r\n\r\n                // tuple_map.get(primary_col_id).cloned().unwrap();\r\n                let mut tuple = Tuple {\r\n                    id: tuple_id.clone(),\r\n                    values: Vec::with_capacity(all_columns.len()),\r\n                };\r\n                for (col_id, col) in all_columns {\r\n                    let value = tuple_map\r\n                        .remove(col_id)\r\n                        .or_else(|| col.default_value())\r\n                        .unwrap_or_else(|| Arc::new(DataValue::none(col.datatype())));\r\n\r\n                    if col.desc.is_unique \u0026\u0026 !value.is_null() {\r\n                        unique_values\r\n                            .entry(col.id())\r\n                            .or_insert_with(Vec::new)\r\n                            .push((tuple_id.clone(), value.clone()))\r\n                    }\r\n                    if value.is_null() \u0026\u0026 !col.nullable {\r\n                        return Err(DatabaseError::InternalError(format!(\r\n                            \"Non-null fields do not allow null values to be passed in: {:?}\",\r\n                            col\r\n                        )));\r\n                    }\r\n\r\n                    tuple.values.push(value)\r\n                }\r\n\r\n                transaction.append(\u0026table_name, tuple, is_overwrite)?;\r\n            }\r\n            // Unique Index\r\n            for (col_id, values) in unique_values {\r\n                if let Some(index_meta) = table_catalog.get_unique_index(\u0026col_id.unwrap()) {\r\n                    for (tuple_id, value) in values {\r\n                        let index = Index {\r\n                            id: index_meta.id,\r\n                            column_values: vec![value],\r\n                        };\r\n\r\n                        transaction.add_index(\u0026table_name, index, vec![tuple_id.unwrap()], true)?;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple = tuple_builder.push_result(\"INSERT SUCCESS\", \u0026format!(\"{}\", input.len()))?;\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":5188146770730811392},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6341068275337658368},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null}],"covered":42,"coverable":55},{"path":["E:","\\","sql-layer","src","execution","executor","dml","mod.rs"],"content":"pub(crate) mod copy;\r\npub(crate) mod delete;\r\npub(crate) mod insert;\r\npub(crate) mod update;\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","execution","executor","dml","update.rs"],"content":"use crate::catalog::{ColumnCatalog, TableName};\r\n\r\nuse crate::execution::executor::{build, Executor, Source};\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::update::UpdateOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::index::Index;\r\nuse crate::types::tuple_builder::TupleBuilder;\r\n\r\nuse std::collections::HashSet;\r\nuse std::sync::Arc;\r\n\r\npub struct Update {\r\n    table_name: TableName,\r\n    input: LogicalPlan, //select source for update\r\n    columns: Vec\u003cArc\u003cColumnCatalog\u003e\u003e,\r\n    set_expr: Vec\u003cScalarExpression\u003e,\r\n}\r\n\r\nimpl From\u003c(UpdateOperator, LogicalPlan)\u003e for Update {\r\n    fn from(\r\n        (\r\n            UpdateOperator {\r\n                columns,\r\n                set_expr,\r\n                table_name,\r\n            },\r\n            input,\r\n        ): (UpdateOperator, LogicalPlan),\r\n    ) -\u003e Self {\r\n        Update {\r\n            table_name,\r\n            input,\r\n            columns,\r\n            set_expr,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Update {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let Update {\r\n            table_name,\r\n            mut input,\r\n            columns,\r\n            set_expr,\r\n        } = self;\r\n        let schema = input.output_schema().clone();\r\n        let input = build(input, transaction)?;\r\n        let input_len = input.len();\r\n\r\n        if let Some(table_catalog) = transaction.table(table_name.clone()) {\r\n            //halloween\r\n            let mut update_col = HashSet::new();\r\n            let mut update_batch = vec![];\r\n            let mut index_update_batch = vec![];\r\n\r\n            for col in columns.iter() {\r\n                update_col.insert(col.id());\r\n            }\r\n\r\n            //Seqscan\r\n            for tuple in input {\r\n                let mut is_overwrite = true;\r\n\r\n                let mut tuple = tuple;\r\n                // eprintln!(\"tuple:{}\", tuple);\r\n\r\n                for (i, column) in schema\r\n                    .iter()\r\n                    .filter(|col| update_col.contains(\u0026col.id()))\r\n                    .enumerate()\r\n                {\r\n                    let value = set_expr[i].eval(\u0026tuple, \u0026schema)?;\r\n\r\n                    if column.desc.is_primary {\r\n                        //refuse to update primary key\r\n                        let old_key = tuple.id.replace(value.clone()).unwrap();\r\n                        transaction.delete(\u0026table_name, old_key)?;\r\n                        is_overwrite = false;\r\n                        // return Err(DatabaseError::InternalError(\"Update Primary key\".into()));\r\n                    }\r\n                    //\r\n                    if column.desc.is_unique \u0026\u0026 value != tuple.values[column.id().unwrap() as usize]\r\n                    {\r\n                        if let Some(index_meta) =\r\n                            table_catalog.get_unique_index(\u0026column.id().unwrap())\r\n                        {\r\n                            let mut index = Index {\r\n                                id: index_meta.id,\r\n                                column_values: vec![tuple.values[i].clone()],\r\n                            };\r\n                            transaction.del_index(\u0026table_name, \u0026index)?;\r\n\r\n                            if !value.is_null() {\r\n                                index.column_values[0] = value.clone();\r\n                                // transaction.add_index(\r\n                                //     \u0026table_name,\r\n                                //     index,\r\n                                //     vec![tuple.id.clone().unwrap()],\r\n                                //     true,\r\n                                // )?;\r\n                                index_update_batch.push((\r\n                                    index,\r\n                                    vec![tuple.id.clone().unwrap()],\r\n                                    true,\r\n                                ));\r\n                            }\r\n                        }\r\n                    }\r\n                    // transaction.delete(\u0026table_name, tuple.id.clone().unwrap())?;\r\n                    tuple.values[column.id().unwrap() as usize] = value.clone();\r\n                }\r\n                update_batch.push((tuple, is_overwrite));\r\n                // transaction.append(\u0026table_name, tuple.clone(), is_overwrite)?;\r\n            }\r\n            for index_item in index_update_batch {\r\n                transaction.add_index(\u0026table_name, index_item.0, index_item.1, index_item.2)?;\r\n            }\r\n            for tuple in update_batch {\r\n                transaction.append(\u0026table_name, tuple.0, tuple.1)?;\r\n            }\r\n        }\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple = tuple_builder.push_result(\"DELETE SUCCESS\", \u0026format!(\"{}\", input_len))?;\r\n\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null}],"covered":33,"coverable":50},{"path":["E:","\\","sql-layer","src","execution","executor","dql","agg","avg.rs"],"content":"use crate::errors::*;\r\nuse crate::expression::BinaryOperator;\r\nuse crate::types::value::{DataValue, ValueRef};\r\nuse crate::types::LogicalType;\r\nuse std::sync::Arc;\r\n\r\nuse super::sum::SumAccumulator;\r\nuse super::Accumulator;\r\n\r\npub struct AvgAccumulator {\r\n    inner: SumAccumulator,\r\n    count: usize,\r\n}\r\n\r\nimpl AvgAccumulator {\r\n    pub fn new(ty: \u0026LogicalType) -\u003e Self {\r\n        Self {\r\n            inner: SumAccumulator::new(ty),\r\n            count: 0,\r\n        }\r\n    }\r\n}\r\n\r\nimpl Accumulator for AvgAccumulator {\r\n    fn update_value(\u0026mut self, value: \u0026ValueRef) -\u003e Result\u003c()\u003e {\r\n        if !value.is_null() {\r\n            self.inner.update_value(value)?;\r\n            self.count += 1;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn evaluate(\u0026self) -\u003e Result\u003cValueRef\u003e {\r\n        let value = self.inner.evaluate()?;\r\n\r\n        let quantity = if value.logical_type().is_signed_numeric() {\r\n            DataValue::Int64(Some(self.count as i64))\r\n        } else {\r\n            DataValue::UInt32(Some(self.count as u32))\r\n        };\r\n\r\n        Ok(Arc::new(DataValue::binary_op(\r\n            \u0026value,\r\n            \u0026quantity,\r\n            \u0026BinaryOperator::Divide,\r\n        )?))\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":11,"coverable":12},{"path":["E:","\\","sql-layer","src","execution","executor","dql","agg","count.rs"],"content":"use crate::types::value::{DataValue, ValueRef};\r\nuse ahash::RandomState;\r\nuse std::collections::HashSet;\r\nuse std::sync::Arc;\r\n\r\nuse super::Accumulator;\r\nuse crate::errors::*;\r\n\r\npub struct CountAccumulator {\r\n    result: i32,\r\n}\r\n\r\nimpl CountAccumulator {\r\n    pub fn new() -\u003e Self {\r\n        Self { result: 0 }\r\n    }\r\n}\r\n\r\nimpl Accumulator for CountAccumulator {\r\n    fn update_value(\u0026mut self, value: \u0026ValueRef) -\u003e Result\u003c()\u003e {\r\n        if !value.is_null() {\r\n            self.result += 1;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn evaluate(\u0026self) -\u003e Result\u003cValueRef\u003e {\r\n        Ok(Arc::new(DataValue::Int32(Some(self.result))))\r\n    }\r\n}\r\n\r\npub struct DistinctCountAccumulator {\r\n    distinct_values: HashSet\u003cValueRef, RandomState\u003e,\r\n}\r\n\r\nimpl DistinctCountAccumulator {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            distinct_values: HashSet::default(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Accumulator for DistinctCountAccumulator {\r\n    fn update_value(\u0026mut self, value: \u0026ValueRef) -\u003e Result\u003c()\u003e {\r\n        if !value.is_null() {\r\n            self.distinct_values.insert(value.clone());\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn evaluate(\u0026self) -\u003e Result\u003cValueRef\u003e {\r\n        Ok(Arc::new(DataValue::Int32(Some(\r\n            self.distinct_values.len() as i32\r\n        ))))\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":16,"coverable":16},{"path":["E:","\\","sql-layer","src","execution","executor","dql","agg","hash_agg.rs"],"content":"use crate::execution::executor::{build, Executor, Source};\r\n\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::aggregate::AggregateOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::value::ValueRef;\r\nuse ahash::{HashMap, HashMapExt};\r\n\r\nuse itertools::Itertools;\r\n\r\nuse super::create_accumulators;\r\n\r\npub struct HashAggExecutor {\r\n    pub agg_calls: Vec\u003cScalarExpression\u003e,\r\n    pub groupby_exprs: Vec\u003cScalarExpression\u003e,\r\n    pub input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(AggregateOperator, LogicalPlan)\u003e for HashAggExecutor {\r\n    fn from(\r\n        (\r\n            AggregateOperator {\r\n                agg_calls,\r\n                groupby_exprs,\r\n                ..\r\n            },\r\n            input,\r\n        ): (AggregateOperator, LogicalPlan),\r\n    ) -\u003e Self {\r\n        HashAggExecutor {\r\n            agg_calls,\r\n            groupby_exprs,\r\n            input,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for HashAggExecutor {\r\n    fn execute\u003c'a\u003e(self, transaction: \u0026mut T) -\u003e Source {\r\n        let HashAggExecutor {\r\n            agg_calls,\r\n            groupby_exprs,\r\n            mut input,\r\n        } = self;\r\n        let schema = input.output_schema().clone();\r\n        let input = build(input, transaction)?;\r\n        let mut group_and_agg_columns_option = None;\r\n        let mut group_hash_accs = HashMap::new();\r\n        let mut tuples = Vec::new();\r\n\r\n        for tuple in input {\r\n            // 1. build group and agg columns for hash_agg columns.\r\n            // Tips: AggCall First\r\n            group_and_agg_columns_option.get_or_insert_with(|| {\r\n                agg_calls\r\n                    .iter()\r\n                    .chain(groupby_exprs.iter())\r\n                    .map(|expr| expr.output_columns())\r\n                    .collect_vec()\r\n            });\r\n\r\n            // 2.1 evaluate agg exprs and collect the result values for later accumulators.\r\n            let values: Vec\u003cValueRef\u003e = agg_calls\r\n                .iter()\r\n                .map(|expr| {\r\n                    if let ScalarExpression::AggCall { args, .. } = expr {\r\n                        args[0].eval(\u0026tuple, \u0026schema)\r\n                    } else {\r\n                        unreachable!()\r\n                    }\r\n                })\r\n                .try_collect()?;\r\n\r\n            let group_keys: Vec\u003cValueRef\u003e = groupby_exprs\r\n                .iter()\r\n                .map(|expr| expr.eval(\u0026tuple, \u0026schema))\r\n                .try_collect()?;\r\n\r\n            for (acc, value) in group_hash_accs\r\n                .entry(group_keys)\r\n                .or_insert_with(|| create_accumulators(\u0026agg_calls))\r\n                .iter_mut()\r\n                .zip_eq(values.iter())\r\n            {\r\n                acc.update_value(value)?;\r\n            }\r\n        }\r\n        if let Some(_group_and_agg_columns) = group_and_agg_columns_option {\r\n            for (group_keys, accs) in group_hash_accs {\r\n                // Tips: Accumulator First\r\n                let values: Vec\u003cValueRef\u003e = accs\r\n                    .iter()\r\n                    .map(|acc| acc.evaluate())\r\n                    .chain(group_keys.into_iter().map(Ok))\r\n                    .try_collect()?;\r\n                tuples.push(Tuple { id: None, values });\r\n            }\r\n        }\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":216172782113791793},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":216172782113791793},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":216172782113791793},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":216172782113791793},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":216172782113791793},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":216172782113791793},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":216172782113791793},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":432345564227583586},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1369094286720646754},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":576460752303431473},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":576460752303431473},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null}],"covered":30,"coverable":39},{"path":["E:","\\","sql-layer","src","execution","executor","dql","agg","min_max.rs"],"content":"use crate::expression::BinaryOperator;\r\nuse crate::types::value::{DataValue, ValueRef};\r\nuse crate::types::LogicalType;\r\nuse std::sync::Arc;\r\n\r\nuse super::Accumulator;\r\nuse crate::errors::*;\r\n\r\npub struct MinMaxAccumulator {\r\n    inner: Option\u003cValueRef\u003e,\r\n    op: BinaryOperator,\r\n    ty: LogicalType,\r\n}\r\n\r\nimpl MinMaxAccumulator {\r\n    pub fn new(ty: \u0026LogicalType, is_max: bool) -\u003e Self {\r\n        let op = if is_max {\r\n            BinaryOperator::Lt\r\n        } else {\r\n            BinaryOperator::Gt\r\n        };\r\n\r\n        Self {\r\n            inner: None,\r\n            op,\r\n            ty: *ty,\r\n        }\r\n    }\r\n}\r\n\r\nimpl Accumulator for MinMaxAccumulator {\r\n    fn update_value(\u0026mut self, value: \u0026ValueRef) -\u003e Result\u003c()\u003e {\r\n        if !value.is_null() {\r\n            if let Some(inner_value) = \u0026self.inner {\r\n                if let DataValue::Boolean(Some(result)) =\r\n                    DataValue::binary_op(inner_value, value, \u0026self.op)?\r\n                {\r\n                    result\r\n                } else {\r\n                    unreachable!()\r\n                }\r\n            } else {\r\n                true\r\n            }\r\n            .then(|| self.inner = Some(value.clone()));\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn evaluate(\u0026self) -\u003e Result\u003cValueRef\u003e {\r\n        Ok(self\r\n            .inner\r\n            .clone()\r\n            .unwrap_or_else(|| Arc::new(DataValue::none(\u0026self.ty))))\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":504403158265495827},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1008806316530991654},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037928211},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null}],"covered":17,"coverable":18},{"path":["E:","\\","sql-layer","src","execution","executor","dql","agg","mod.rs"],"content":"mod avg;\r\nmod count;\r\npub mod hash_agg;\r\nmod min_max;\r\npub mod simple_agg;\r\nmod sum;\r\nuse crate::errors::*;\r\n\r\nuse crate::expression::agg::Aggregate;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::types::value::ValueRef;\r\n\r\nuse self::{\r\n    avg::AvgAccumulator,\r\n    count::{CountAccumulator, DistinctCountAccumulator},\r\n    min_max::MinMaxAccumulator,\r\n    sum::{DistinctSumAccumulator, SumAccumulator},\r\n};\r\n\r\n/// Tips: Idea for sqlrs\r\n/// An accumulator represents a stateful object that lives throughout the evaluation of multiple\r\n/// rows and generically accumulates values.\r\npub trait Accumulator: Send + Sync {\r\n    /// updates the accumulator's state from a vector of arrays.\r\n    fn update_value(\u0026mut self, value: \u0026ValueRef) -\u003e Result\u003c()\u003e;\r\n\r\n    /// returns its value based on its current state.\r\n    fn evaluate(\u0026self) -\u003e Result\u003cValueRef\u003e;\r\n}\r\n\r\nfn create_accumulator(expr: \u0026ScalarExpression) -\u003e Box\u003cdyn Accumulator\u003e {\r\n    if let ScalarExpression::AggCall {\r\n        kind, ty, distinct, ..\r\n    } = expr\r\n    {\r\n        match (kind, distinct) {\r\n            (Aggregate::Count, false) =\u003e Box::new(CountAccumulator::new()),\r\n            (Aggregate::Count, true) =\u003e Box::new(DistinctCountAccumulator::new()),\r\n            (Aggregate::Sum, false) =\u003e Box::new(SumAccumulator::new(ty)),\r\n            (Aggregate::Sum, true) =\u003e Box::new(DistinctSumAccumulator::new(ty)),\r\n            (Aggregate::Min, _) =\u003e Box::new(MinMaxAccumulator::new(ty, false)),\r\n            (Aggregate::Max, _) =\u003e Box::new(MinMaxAccumulator::new(ty, true)),\r\n            (Aggregate::Avg, _) =\u003e Box::new(AvgAccumulator::new(ty)),\r\n        }\r\n    } else {\r\n        unreachable!(\r\n            \"create_accumulator called with non-aggregate expression {:?}\",\r\n            expr\r\n        );\r\n    }\r\n}\r\n\r\nfn create_accumulators(exprs: \u0026[ScalarExpression]) -\u003e Vec\u003cBox\u003cdyn Accumulator\u003e\u003e {\r\n    exprs.iter().map(create_accumulator).collect()\r\n}\r\n","traces":[{"line":53,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null}],"covered":2,"coverable":2},{"path":["E:","\\","sql-layer","src","execution","executor","dql","agg","simple_agg.rs"],"content":"use crate::execution::executor::{build, Executor, Source};\r\n\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::aggregate::AggregateOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::value::ValueRef;\r\n\r\nuse itertools::Itertools;\r\n\r\nuse super::create_accumulators;\r\n\r\npub struct SimpleAggExecutor {\r\n    pub agg_calls: Vec\u003cScalarExpression\u003e,\r\n    pub input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(AggregateOperator, LogicalPlan)\u003e for SimpleAggExecutor {\r\n    fn from(\r\n        (AggregateOperator { agg_calls, .. }, input): (AggregateOperator, LogicalPlan),\r\n    ) -\u003e Self {\r\n        SimpleAggExecutor { agg_calls, input }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for SimpleAggExecutor {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let SimpleAggExecutor {\r\n            agg_calls,\r\n            mut input,\r\n        } = self;\r\n\r\n        let mut accs = create_accumulators(\u0026agg_calls);\r\n        let mut columns_option = None;\r\n        let mut tuples = Vec::new();\r\n        let schema = input.output_schema().clone();\r\n        let input = build(input, transaction)?;\r\n        for tuple in input {\r\n            columns_option.get_or_insert_with(|| {\r\n                agg_calls\r\n                    .iter()\r\n                    .map(|expr| expr.output_columns())\r\n                    .collect_vec()\r\n            });\r\n\r\n            let values: Vec\u003cValueRef\u003e = agg_calls\r\n                .iter()\r\n                .map(|expr| match expr {\r\n                    ScalarExpression::AggCall { args, .. } =\u003e args[0].eval(\u0026tuple, \u0026schema),\r\n                    _ =\u003e unreachable!(),\r\n                })\r\n                .try_collect()?;\r\n\r\n            for (acc, value) in accs.iter_mut().zip_eq(values.iter()) {\r\n                acc.update_value(value)?;\r\n            }\r\n        }\r\n        if let Some(_columns) = columns_option {\r\n            let values: Vec\u003cValueRef\u003e = accs.into_iter().map(|acc| acc.evaluate()).try_collect()?;\r\n            tuples.push(Tuple { id: None, values });\r\n        }\r\n\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1801439850948198400},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null}],"covered":26,"coverable":27},{"path":["E:","\\","sql-layer","src","execution","executor","dql","agg","sum.rs"],"content":"use crate::errors::*;\r\nuse crate::expression::BinaryOperator;\r\nuse crate::types::value::{DataValue, ValueRef};\r\nuse crate::types::LogicalType;\r\nuse ahash::RandomState;\r\nuse std::collections::HashSet;\r\nuse std::sync::Arc;\r\n\r\nuse super::Accumulator;\r\n\r\npub struct SumAccumulator {\r\n    result: DataValue,\r\n}\r\n\r\nimpl SumAccumulator {\r\n    pub fn new(ty: \u0026LogicalType) -\u003e Self {\r\n        assert!(ty.is_numeric());\r\n\r\n        Self {\r\n            result: DataValue::init(ty),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Accumulator for SumAccumulator {\r\n    fn update_value(\u0026mut self, value: \u0026ValueRef) -\u003e Result\u003c()\u003e {\r\n        if !value.is_null() {\r\n            self.result = DataValue::binary_op(\u0026self.result, value, \u0026BinaryOperator::Plus)?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn evaluate(\u0026self) -\u003e Result\u003cValueRef\u003e {\r\n        Ok(Arc::new(self.result.clone()))\r\n    }\r\n}\r\n\r\npub struct DistinctSumAccumulator {\r\n    distinct_values: HashSet\u003cValueRef, RandomState\u003e,\r\n    inner: SumAccumulator,\r\n}\r\n\r\nimpl DistinctSumAccumulator {\r\n    pub fn new(ty: \u0026LogicalType) -\u003e Self {\r\n        Self {\r\n            distinct_values: HashSet::default(),\r\n            inner: SumAccumulator::new(ty),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Accumulator for DistinctSumAccumulator {\r\n    fn update_value(\u0026mut self, value: \u0026ValueRef) -\u003e Result\u003c()\u003e {\r\n        if !self.distinct_values.contains(value) {\r\n            self.distinct_values.insert(value.clone());\r\n            self.inner.update_value(value)?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn evaluate(\u0026self) -\u003e Result\u003cValueRef\u003e {\r\n        self.inner.evaluate()\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":19,"coverable":19},{"path":["E:","\\","sql-layer","src","execution","executor","dql","describe.rs"],"content":"use crate::catalog::{ColumnCatalog, TableName};\r\nuse crate::execution::executor::{DatabaseError, Executor, Source};\r\nuse crate::planner::operator::describe::DescribeOperator;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::value::{DataValue, ValueRef};\r\nuse lazy_static::lazy_static;\r\n\r\nuse std::sync::Arc;\r\n\r\nlazy_static! {\r\n    static ref PRIMARY_KEY_TYPE: ValueRef =\r\n        Arc::new(DataValue::Utf8(Some(String::from(\"PRIMARY\"))));\r\n    static ref UNIQUE_KEY_TYPE: ValueRef = Arc::new(DataValue::Utf8(Some(String::from(\"UNIQUE\"))));\r\n    static ref EMPTY_KEY_TYPE: ValueRef = Arc::new(DataValue::Utf8(Some(String::from(\"EMPTY\"))));\r\n}\r\n\r\npub struct Describe {\r\n    table_name: TableName,\r\n}\r\n\r\nimpl From\u003cDescribeOperator\u003e for Describe {\r\n    fn from(op: DescribeOperator) -\u003e Self {\r\n        Describe {\r\n            table_name: op.table_name,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Describe {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let table = transaction\r\n            .table(self.table_name.clone())\r\n            .ok_or(DatabaseError::TableNotFound)?;\r\n        let key_fn = |column: \u0026ColumnCatalog| {\r\n            if column.desc.is_primary {\r\n                PRIMARY_KEY_TYPE.clone()\r\n            } else if column.desc.is_unique {\r\n                UNIQUE_KEY_TYPE.clone()\r\n            } else {\r\n                EMPTY_KEY_TYPE.clone()\r\n            }\r\n        };\r\n        let mut tuples = vec![];\r\n        // let schema=vec![\r\n        //     Arc::new(ColumnCatalog::new_dummy(\"FIELD\".to_string())),\r\n        //     Arc::new(ColumnCatalog::new_dummy(\"TYPE\".to_string())),\r\n        //     Arc::new(ColumnCatalog::new_dummy(\"NULL\".to_string())),\r\n        //     Arc::new(ColumnCatalog::new_dummy(\"Key\".to_string())),\r\n        //     Arc::new(ColumnCatalog::new_dummy(\"DEFAULT\".to_string())),\r\n        // ];\r\n        for column in table.all_columns() {\r\n            let values = vec![\r\n                Arc::new(DataValue::Utf8(Some(column.name().to_string()))),\r\n                Arc::new(DataValue::Utf8(Some(column.datatype().to_string()))),\r\n                Arc::new(DataValue::Utf8(Some(column.nullable.to_string()))),\r\n                key_fn(\u0026column),\r\n                column\r\n                    .default_value()\r\n                    .unwrap_or_else(|| Arc::new(DataValue::none(column.datatype()))),\r\n            ];\r\n            tuples.push(Tuple { id: None, values });\r\n        }\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":47},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":24},{"path":["E:","\\","sql-layer","src","execution","executor","dql","dummy.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\n\r\npub struct Dummy {}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Dummy {\r\n    fn execute(self, _transaction: \u0026mut T) -\u003e Source {\r\n        Ok(vec![Tuple {\r\n            id: None,\r\n            values: vec![],\r\n        }])\r\n    }\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["E:","\\","sql-layer","src","execution","executor","dql","explain.rs"],"content":"use std::sync::Arc;\r\n\r\nuse crate::{\r\n    execution::executor::{Executor, Source},\r\n    planner::LogicalPlan,\r\n    storage::Transaction,\r\n    types::{tuple::Tuple, value::DataValue},\r\n};\r\n\r\npub struct Explain {\r\n    plan: LogicalPlan,\r\n}\r\nimpl From\u003cLogicalPlan\u003e for Explain {\r\n    fn from(plan: LogicalPlan) -\u003e Self {\r\n        Explain { plan }\r\n    }\r\n}\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Explain {\r\n    fn execute(self, _: \u0026mut T) -\u003e Source {\r\n        let values = vec![Arc::new(DataValue::Utf8(Some(self.plan.explain(0))))];\r\n        Ok(vec![Tuple { id: None, values }])\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["E:","\\","sql-layer","src","execution","executor","dql","filter.rs"],"content":"use crate::execution::executor::{build, Executor, Source};\r\n\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::filter::FilterOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\nuse crate::types::value::DataValue;\r\n\r\npub struct Filter {\r\n    predicate: ScalarExpression,\r\n    input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(FilterOperator, LogicalPlan)\u003e for Filter {\r\n    fn from((FilterOperator { predicate, .. }, input): (FilterOperator, LogicalPlan)) -\u003e Self {\r\n        Filter { predicate, input }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Filter {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let Filter {\r\n            predicate,\r\n            mut input,\r\n        } = self;\r\n        let mut tuples = Vec::new();\r\n        let schema = input.output_schema().clone();\r\n        let input = build(input, transaction)?;\r\n        for tuple in input {\r\n            if let DataValue::Boolean(option) = predicate.eval(\u0026tuple, \u0026schema)?.as_ref() {\r\n                if let Some(true) = option {\r\n                    tuples.push(tuple.clone());\r\n                } else {\r\n                    continue;\r\n                }\r\n            } else {\r\n                unreachable!(\"only bool\");\r\n            }\r\n        }\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":864691128455135233},"fn_name":null}],"covered":1,"coverable":1},{"path":["E:","\\","sql-layer","src","execution","executor","dql","index_scan.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::errors::*;\r\nuse crate::planner::operator::scan::ScanOperator;\r\nuse crate::storage::{Iter, Transaction};\r\n\r\npub(crate) struct IndexScan {\r\n    op: ScanOperator,\r\n}\r\n\r\nimpl From\u003cScanOperator\u003e for IndexScan {\r\n    fn from(op: ScanOperator) -\u003e Self {\r\n        IndexScan { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for IndexScan {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let ScanOperator {\r\n            table_name,\r\n            columns,\r\n\r\n            index_by,\r\n            ..\r\n        } = self.op;\r\n\r\n        let (index_meta, binaries) = index_by.ok_or(DatabaseError::InvalidType)?;\r\n        let mut iter = transaction.read_by_index(table_name, columns, index_meta, binaries)?;\r\n        let tuples = iter.fetch_tuple()?;\r\n        match tuples {\r\n            Some(tuple) =\u003e Ok(tuple),\r\n            None =\u003e Ok(vec![]),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":12,"coverable":14},{"path":["E:","\\","sql-layer","src","execution","executor","dql","join","hash_join.rs"],"content":"use crate::planner::operator::join::JoinType;\r\n\r\nuse crate::catalog::{ColumnCatalog, ColumnRef, SchemaRef};\r\nuse crate::execution::executor::{build, Executor, Source};\r\n\r\nuse crate::errors::*;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::join::{JoinCondition, JoinOperator};\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::value::DataValue;\r\nuse ahash::{HashMap, HashMapExt, HashSet, HashSetExt, RandomState};\r\n\r\nuse itertools::Itertools;\r\nuse std::sync::Arc;\r\n\r\nuse super::joins_nullable;\r\n/// R  S  tuples  Join   \r\n/// Join Attributes  Join Attributes  hash function   \r\n/// Join  tables  hash  tuples  Join   \r\npub struct HashJoin {\r\n    on: JoinCondition,\r\n    ty: JoinType,\r\n    left_input: LogicalPlan,\r\n    right_input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(JoinOperator, LogicalPlan, LogicalPlan)\u003e for HashJoin {\r\n    fn from(\r\n        (JoinOperator { on, join_type }, left_input, right_input): (\r\n            JoinOperator,\r\n            LogicalPlan,\r\n            LogicalPlan,\r\n        ),\r\n    ) -\u003e Self {\r\n        HashJoin {\r\n            on,\r\n            ty: join_type,\r\n            left_input,\r\n            right_input,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for HashJoin {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let mut tuples = Vec::new();\r\n        let HashJoin {\r\n            on,\r\n            ty,\r\n            mut left_input,\r\n            mut right_input,\r\n        } = self;\r\n        let left_schema = left_input.output_schema().clone();\r\n        let right_schema = right_input.output_schema().clone();\r\n        let left_input = build(left_input, transaction)?;\r\n        let right_input = build(right_input, transaction)?;\r\n        // println!(\"right_input len: {}\", right_input.len());\r\n        // println!(\"type: {}\", ty);\r\n        if ty == JoinType::Cross {\r\n            unreachable!(\"Cross join should not be in HashJoinExecutor\");\r\n        }\r\n        let ((on_left_keys, on_right_keys), filter): (\r\n            (Vec\u003cScalarExpression\u003e, Vec\u003cScalarExpression\u003e),\r\n            _,\r\n        ) = match on {\r\n            JoinCondition::On { on, filter } =\u003e (on.into_iter().unzip(), filter),\r\n            JoinCondition::None =\u003e unreachable!(\"HashJoin must has on condition\"),\r\n        };\r\n\r\n        let mut join_columns = Vec::new();\r\n        let mut used_set = HashSet::\u003cu64\u003e::new();\r\n        let mut left_map = HashMap::new();\r\n\r\n        let hash_random_state = RandomState::with_seeds(0, 0, 0, 0);\r\n        let (left_force_nullable, right_force_nullable) = joins_nullable(\u0026ty);\r\n        //Outer Table\r\n        // build phase:\r\n        // 1.construct hashtable, one hash key may contains multiple rows indices.\r\n        // 2.merged all left tuples.\r\n        let mut left_init_flag = false;\r\n        for tuple in left_input {\r\n            let hash = Self::hash_row(\u0026on_left_keys, \u0026left_schema, \u0026hash_random_state, \u0026tuple)?;\r\n\r\n            if !left_init_flag {\r\n                Self::columns_filling(\u0026left_schema, \u0026mut join_columns, left_force_nullable);\r\n                left_init_flag = true;\r\n                // for iter in join_columns.iter() {\r\n                //     println!(\"left join_columns: {}\", iter);\r\n                // }\r\n            }\r\n\r\n            left_map.entry(hash).or_insert(Vec::new()).push(tuple);\r\n        }\r\n        // println!(\"left_map: {:#?}\", left_map);\r\n        // probe phase\r\n        Self::columns_filling(\u0026right_schema, \u0026mut join_columns, right_force_nullable);\r\n        // for iter in join_columns.iter() {\r\n        //     println!(\"right join_columns: {}\", iter);\r\n        // }\r\n\r\n        for tuple in right_input {\r\n            let right_cols_len = right_schema.len();\r\n            //hash\r\n            let hash = Self::hash_row(\u0026on_right_keys, \u0026right_schema, \u0026hash_random_state, \u0026tuple)?;\r\n            //join columns\r\n\r\n            let mut join_tuples = if let Some(tuples) = left_map.get(\u0026hash) {\r\n                let _ = used_set.insert(hash);\r\n\r\n                tuples\r\n                    .iter()\r\n                    .map(|Tuple { values, .. }| {\r\n                        let full_values = values\r\n                            .iter()\r\n                            .cloned()\r\n                            .chain(tuple.values.clone())\r\n                            .collect_vec();\r\n\r\n                        Tuple {\r\n                            id: None,\r\n                            values: full_values,\r\n                        }\r\n                    })\r\n                    .collect_vec()\r\n            } else if matches!(ty, JoinType::Right | JoinType::Full) {\r\n                let empty_len = join_columns.len() - right_cols_len;\r\n                let values = join_columns[..empty_len]\r\n                    .iter()\r\n                    .map(|col| Arc::new(DataValue::none(col.datatype())))\r\n                    .chain(tuple.values)\r\n                    .collect_vec();\r\n\r\n                vec![Tuple { id: None, values }]\r\n            } else {\r\n                vec![]\r\n            };\r\n\r\n            // on filter\r\n            if let (Some(expr), false) = (\r\n                \u0026filter,\r\n                join_tuples.is_empty() || matches!(ty, JoinType::Full | JoinType::Cross),\r\n            ) {\r\n                let mut filter_tuples = Vec::with_capacity(join_tuples.len());\r\n\r\n                for mut tuple in join_tuples {\r\n                    if let DataValue::Boolean(option) = expr.eval(\u0026tuple, \u0026join_columns)?.as_ref() {\r\n                        if let Some(false) | None = option {\r\n                            let full_cols_len = join_columns.len();\r\n                            let left_cols_len = full_cols_len - right_cols_len;\r\n\r\n                            match ty {\r\n                                JoinType::Left =\u003e {\r\n                                    for i in left_cols_len..full_cols_len {\r\n                                        let value_type = join_columns[i].datatype();\r\n\r\n                                        tuple.values[i] = Arc::new(DataValue::none(value_type))\r\n                                    }\r\n                                    filter_tuples.push(tuple)\r\n                                }\r\n                                JoinType::Right =\u003e {\r\n                                    for i in 0..left_cols_len {\r\n                                        let value_type = left_schema[i].datatype();\r\n\r\n                                        tuple.values[i] = Arc::new(DataValue::none(value_type))\r\n                                    }\r\n                                    filter_tuples.push(tuple)\r\n                                }\r\n                                _ =\u003e (),\r\n                            }\r\n                        } else {\r\n                            filter_tuples.push(tuple)\r\n                        }\r\n                    } else {\r\n                        unreachable!(\"only bool\");\r\n                    }\r\n                }\r\n\r\n                join_tuples = filter_tuples;\r\n            }\r\n\r\n            for tuple in join_tuples {\r\n                tuples.push(tuple);\r\n            }\r\n        }\r\n\r\n        if matches!(ty, JoinType::Left | JoinType::Full) {\r\n            // println!(\"reach\");\r\n\r\n            for (hash, tuple) in left_map {\r\n                if used_set.contains(\u0026hash) {\r\n                    continue;\r\n                }\r\n\r\n                for Tuple { mut values, .. } in tuple {\r\n                    let mut right_empties = join_columns[left_schema.len()..]\r\n                        .iter()\r\n                        .map(|col| Arc::new(DataValue::none(col.datatype())))\r\n                        .collect_vec();\r\n\r\n                    values.append(\u0026mut right_empties);\r\n                    tuples.push(Tuple { id: None, values });\r\n                }\r\n            }\r\n        }\r\n        // for iter in tuples.iter() {\r\n        //     println!(\"tuples: {}\", iter);\r\n        // }\r\n        Ok(tuples)\r\n    }\r\n}\r\n\r\nimpl HashJoin {\r\n    pub(super) fn columns_filling(\r\n        schema: \u0026SchemaRef,\r\n        join_columns: \u0026mut Vec\u003cColumnRef\u003e,\r\n        force_nullable: bool,\r\n    ) {\r\n        let mut new_columns = schema\r\n            .iter()\r\n            .cloned()\r\n            .map(|col| {\r\n                let mut new_catalog = ColumnCatalog::clone(\u0026col);\r\n                new_catalog.nullable = force_nullable;\r\n\r\n                Arc::new(new_catalog)\r\n            })\r\n            .collect_vec();\r\n\r\n        join_columns.append(\u0026mut new_columns);\r\n    }\r\n\r\n    pub(super) fn hash_row(\r\n        on_keys: \u0026[ScalarExpression],\r\n        schema: \u0026SchemaRef,\r\n        hash_random_state: \u0026RandomState,\r\n        tuple: \u0026Tuple,\r\n    ) -\u003e Result\u003cu64\u003e {\r\n        let mut values = Vec::with_capacity(on_keys.len());\r\n\r\n        for expr in on_keys {\r\n            values.push(expr.eval(tuple, schema)?);\r\n        }\r\n\r\n        Ok(hash_random_state.hash_one(values))\r\n    }\r\n}\r\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":288230376151711826},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":576460752303423490},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2594073385365405698},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1152921504606846977},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":5188146770730811392},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null}],"covered":56,"coverable":100},{"path":["E:","\\","sql-layer","src","execution","executor","dql","join","nested_loop_join.rs"],"content":"use crate::catalog::{ColumnCatalog, ColumnRef, Schema, SchemaRef};\r\nuse crate::errors::*;\r\nuse crate::execution::executor::dql::projection::Projection;\r\nuse crate::execution::executor::{build, Executor, Source};\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::join::{JoinCondition, JoinOperator, JoinType};\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::value::{DataValue, NULL_VALUE};\r\nuse itertools::Itertools;\r\nuse std::sync::Arc;\r\n\r\nuse super::joins_nullable;\r\n\r\n/// Equivalent condition\r\nstruct EqualCondition {\r\n    on_left_keys: Vec\u003cScalarExpression\u003e,\r\n    on_right_keys: Vec\u003cScalarExpression\u003e,\r\n    left_schema: SchemaRef,\r\n    right_schema: SchemaRef,\r\n}\r\n\r\nimpl EqualCondition {\r\n    /// Constructs a new `EqualCondition`\r\n    /// If the `on_left_keys` and `on_right_keys` are empty, it means no equivalent condition\r\n    /// Note: `on_left_keys` and `on_right_keys` are either all empty or none of them.\r\n    fn new(\r\n        on_left_keys: Vec\u003cScalarExpression\u003e,\r\n        on_right_keys: Vec\u003cScalarExpression\u003e,\r\n        left_schema: Arc\u003cSchema\u003e,\r\n        right_schema: Arc\u003cSchema\u003e,\r\n    ) -\u003e EqualCondition {\r\n        if !on_left_keys.is_empty() \u0026\u0026 on_left_keys.len() != on_right_keys.len() {\r\n            unreachable!(\"Unexpected join on condition.\")\r\n        }\r\n        EqualCondition {\r\n            on_left_keys,\r\n            on_right_keys,\r\n            left_schema,\r\n            right_schema,\r\n        }\r\n    }\r\n\r\n    /// Compare left tuple and right tuple on equivalent condition\r\n    /// `left_tuple` must be from the [`NestedLoopJoin::left_input`]\r\n    /// `right_tuple` must be from the [`NestedLoopJoin::right_input`]\r\n    fn equals(\u0026self, left_tuple: \u0026Tuple, right_tuple: \u0026Tuple) -\u003e Result\u003cbool\u003e {\r\n        if self.on_left_keys.is_empty() {\r\n            return Ok(true);\r\n        }\r\n        let left_values =\r\n            Projection::projection(left_tuple, \u0026self.on_left_keys, \u0026self.left_schema)?;\r\n        let right_values =\r\n            Projection::projection(right_tuple, \u0026self.on_right_keys, \u0026self.right_schema)?;\r\n\r\n        Ok(left_values == right_values)\r\n    }\r\n}\r\n\r\n/// NestedLoopJoin using nested loop join algorithm to execute a join operation.\r\n/// One input will be selected to be the inner table and the other will be the outer\r\n/// | JoinType                       |  Inner-table   |   Outer-table  |  \r\n/// |--------------------------------|----------------|----------------|  \r\n/// | Inner/Left                     |    right       |      left      |  \r\n/// |--------------------------------|----------------|----------------|  \r\n/// | Right                          |    left        |      right     |  \r\n/// |--------------------------------|----------------|----------------|  \r\n/// | Full                           |  not supported |  not supported |  \r\npub struct NestedLoopJoin {\r\n    left_input: LogicalPlan,\r\n    right_input: LogicalPlan,\r\n    output_schema_ref: SchemaRef,\r\n    ty: JoinType,\r\n    filter: Option\u003cScalarExpression\u003e,\r\n    eq_cond: EqualCondition,\r\n}\r\n\r\nimpl From\u003c(JoinOperator, LogicalPlan, LogicalPlan)\u003e for NestedLoopJoin {\r\n    fn from(\r\n        (JoinOperator { on, join_type, .. }, left_input, right_input): (\r\n            JoinOperator,\r\n            LogicalPlan,\r\n            LogicalPlan,\r\n        ),\r\n    ) -\u003e Self {\r\n        let ((mut on_left_keys, mut on_right_keys), filter) = match on {\r\n            JoinCondition::On { on, filter } =\u003e (on.into_iter().unzip(), filter),\r\n            JoinCondition::None =\u003e ((vec![], vec![]), None),\r\n        };\r\n\r\n        let (mut left_input, mut right_input) = (left_input, right_input);\r\n        let mut left_schema = left_input.output_schema().clone();\r\n        let mut right_schema = right_input.output_schema().clone();\r\n        let output_schema_ref = Self::merge_schema(\u0026left_schema, \u0026right_schema, join_type);\r\n\r\n        if matches!(join_type, JoinType::Right) {\r\n            std::mem::swap(\u0026mut left_input, \u0026mut right_input);\r\n            std::mem::swap(\u0026mut on_left_keys, \u0026mut on_right_keys);\r\n            std::mem::swap(\u0026mut left_schema, \u0026mut right_schema);\r\n        }\r\n\r\n        let eq_cond = EqualCondition::new(\r\n            on_left_keys,\r\n            on_right_keys,\r\n            left_schema.clone(),\r\n            right_schema.clone(),\r\n        );\r\n\r\n        NestedLoopJoin {\r\n            ty: join_type,\r\n            left_input,\r\n            right_input,\r\n            output_schema_ref,\r\n            filter,\r\n            eq_cond,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for NestedLoopJoin {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let NestedLoopJoin {\r\n            ty,\r\n            left_input,\r\n            right_input,\r\n            output_schema_ref,\r\n            filter,\r\n            eq_cond,\r\n            ..\r\n        } = self;\r\n        if matches!(self.ty, JoinType::Full) {\r\n            unreachable!(\"{} cannot be handled in nested loop join\", self.ty)\r\n        }\r\n        let mut tuples = vec![];\r\n        let right_schema_len = eq_cond.right_schema.len();\r\n        let left_tuples = build(left_input, transaction)?;\r\n        let right_tuples = build(right_input.clone(), transaction)?;\r\n\r\n        for left_tuple in left_tuples {\r\n            let mut has_matched = false;\r\n\r\n            for right_tuple in right_tuples.iter() {\r\n                let tuple = match (filter.as_ref(), eq_cond.equals(\u0026left_tuple, right_tuple)?) {\r\n                    (None, true) if matches!(ty, JoinType::Right) =\u003e {\r\n                        Self::emit_tuple(right_tuple, \u0026left_tuple, ty, true)\r\n                    }\r\n                    (None, true) =\u003e Self::emit_tuple(\u0026left_tuple, right_tuple, ty, true),\r\n                    (Some(filter), true) =\u003e {\r\n                        let new_tuple = Self::merge_tuple(\u0026left_tuple, right_tuple, \u0026ty);\r\n                        let value = filter.eval(\u0026new_tuple, \u0026output_schema_ref)?;\r\n                        match value.as_ref() {\r\n                            DataValue::Boolean(Some(true)) =\u003e {\r\n                                let tuple = match ty {\r\n                                    JoinType::Right =\u003e {\r\n                                        Self::emit_tuple(right_tuple, \u0026left_tuple, ty, true)\r\n                                    }\r\n                                    _ =\u003e Self::emit_tuple(\u0026left_tuple, right_tuple, ty, true),\r\n                                };\r\n                                has_matched = true;\r\n                                tuple\r\n                            }\r\n                            DataValue::Boolean(Some(_) | None) =\u003e None,\r\n                            _ =\u003e return Err(DatabaseError::InvalidType),\r\n                        }\r\n                    }\r\n                    _ =\u003e None,\r\n                };\r\n\r\n                if let Some(tuple) = tuple {\r\n                    tuples.push(tuple);\r\n                }\r\n\r\n            }\r\n\r\n            // handle no matched tuple case\r\n            let tuple = match ty {\r\n                JoinType::Left | JoinType::Right if !has_matched =\u003e {\r\n                    let right_tuple = Tuple {\r\n                        id: None,\r\n                        values: vec![NULL_VALUE.clone(); right_schema_len],\r\n                    };\r\n                    if matches!(ty, JoinType::Right) {\r\n                        Self::emit_tuple(\u0026right_tuple, \u0026left_tuple, ty, false)\r\n                    } else {\r\n                        Self::emit_tuple(\u0026left_tuple, \u0026right_tuple, ty, false)\r\n                    }\r\n                }\r\n                _ =\u003e None,\r\n            };\r\n            if let Some(tuple) = tuple {\r\n                tuples.push(tuple);\r\n            }\r\n        }\r\n        tuples.iter().for_each(|tuple|println!(\"tuple: {}\", tuple));\r\n        Ok(tuples)\r\n    }\r\n}\r\n\r\nimpl NestedLoopJoin {\r\n    /// Emit a tuple according to the join type.\r\n    ///\r\n    /// `left_tuple`: left tuple to be included.\r\n    /// `right_tuple` right tuple to be included.\r\n    /// `ty`: the type of join\r\n    /// `is_match`: whether [`NestedLoopJoin::left_input`] and [`NestedLoopJoin::right_input`] are matched\r\n    fn emit_tuple(\r\n        left_tuple: \u0026Tuple,\r\n        right_tuple: \u0026Tuple,\r\n        ty: JoinType,\r\n        is_matched: bool,\r\n    ) -\u003e Option\u003cTuple\u003e {\r\n        let left_len = left_tuple.values.len();\r\n        let mut values = left_tuple\r\n            .values\r\n            .iter()\r\n            .cloned()\r\n            .chain(right_tuple.values.clone())\r\n            .collect_vec();\r\n        match ty {\r\n            JoinType::Inner | JoinType::Cross if !is_matched =\u003e values.clear(),\r\n            JoinType::Left if !is_matched =\u003e {\r\n                values\r\n                    .iter_mut()\r\n                    .skip(left_len)\r\n                    .for_each(|v| *v = NULL_VALUE.clone());\r\n            }\r\n            JoinType::Right if !is_matched =\u003e {\r\n                (0..left_len).for_each(|i| {\r\n                    values[i] = NULL_VALUE.clone();\r\n                });\r\n            }\r\n            JoinType::Full =\u003e todo!(\"Not support now.\"),\r\n            _ =\u003e (),\r\n        };\r\n\r\n        if values.is_empty() {\r\n            return None;\r\n        }\r\n\r\n        Some(Tuple { id: None, values })\r\n    }\r\n\r\n    /// Merge the two tuples.\r\n    /// `left_tuple` must be from the `NestedLoopJoin.left_input`\r\n    /// `right_tuple` must be from the `NestedLoopJoin.right_input`\r\n    fn merge_tuple(left_tuple: \u0026Tuple, right_tuple: \u0026Tuple, ty: \u0026JoinType) -\u003e Tuple {\r\n        match ty {\r\n            JoinType::Right =\u003e Tuple {\r\n                id: None,\r\n                values: right_tuple\r\n                    .values\r\n                    .iter()\r\n                    .cloned()\r\n                    .chain(left_tuple.clone().values)\r\n                    .collect_vec(),\r\n            },\r\n            _ =\u003e Tuple {\r\n                id: None,\r\n                values: left_tuple\r\n                    .values\r\n                    .iter()\r\n                    .cloned()\r\n                    .chain(right_tuple.clone().values)\r\n                    .collect_vec(),\r\n            },\r\n        }\r\n    }\r\n\r\n    fn merge_schema(\r\n        left_schema: \u0026[ColumnRef],\r\n        right_schema: \u0026[ColumnRef],\r\n        ty: JoinType,\r\n    ) -\u003e Arc\u003cVec\u003cColumnRef\u003e\u003e {\r\n        let (left_force_nullable, right_force_nullable) = joins_nullable(\u0026ty);\r\n\r\n        let mut join_schema = vec![];\r\n        for column in left_schema.iter() {\r\n            let mut temp = ColumnCatalog::clone(column);\r\n            temp.nullable = left_force_nullable;\r\n            join_schema.push(Arc::new(temp));\r\n        }\r\n        for column in right_schema.iter() {\r\n            let mut temp = ColumnCatalog::clone(column);\r\n            temp.nullable = right_force_nullable;\r\n            join_schema.push(Arc::new(temp));\r\n        }\r\n        Arc::new(join_schema)\r\n    }\r\n}\r\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":102},{"path":["E:","\\","sql-layer","src","execution","executor","dql","join.rs"],"content":"use crate::planner::operator::join::JoinType;\r\n\r\npub(crate) mod hash_join;\r\npub(crate) mod nested_loop_join;\r\n\r\n\r\n\r\npub fn joins_nullable(join_type: \u0026JoinType) -\u003e (bool, bool) {\r\n    match join_type {\r\n        JoinType::Inner =\u003e (false, false),\r\n        JoinType::Left =\u003e (false, true),\r\n        JoinType::Right =\u003e (true, false),\r\n        JoinType::Full =\u003e (true, true),\r\n        JoinType::Cross =\u003e (true, true),\r\n    }\r\n}\r\n\r\n\r\n\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":6,"coverable":7},{"path":["E:","\\","sql-layer","src","execution","executor","dql","limit.rs"],"content":"use crate::execution::executor::{build, Executor, Source};\r\n\r\nuse crate::planner::operator::limit::LimitOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\npub struct Limit {\r\n    offset: Option\u003cusize\u003e,\r\n    limit: Option\u003cusize\u003e,\r\n    input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(LimitOperator, LogicalPlan)\u003e for Limit {\r\n    fn from((LimitOperator { offset, limit }, input): (LimitOperator, LogicalPlan)) -\u003e Self {\r\n        Limit {\r\n            offset,\r\n            limit,\r\n            input,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Limit {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let mut tuples = Vec::new();\r\n        let Limit {\r\n            offset,\r\n            limit,\r\n            input,\r\n        } = self;\r\n        let input = build(input, transaction)?;\r\n        if limit.is_some() \u0026\u0026 limit.unwrap_or(0) == 0 {\r\n            return Ok(tuples);\r\n        }\r\n        // println!(\"limit input tuple {}\", input.len());\r\n\r\n        let offset_val = offset.unwrap_or(0);\r\n        let limit = limit.unwrap_or(usize::MAX);\r\n        // debug!(\"offset  {}\", offset_val);\r\n        // debug!(\"limit  {}\", limit);\r\n\r\n        for (i, tuple) in input.iter().skip(offset_val).enumerate() {\r\n            if i \u003e= limit {\r\n                break;\r\n            }\r\n            tuples.push(tuple.clone());\r\n        }\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":18},{"path":["E:","\\","sql-layer","src","execution","executor","dql","mod.rs"],"content":"pub(crate) mod agg;\r\npub(crate) mod describe;\r\npub(crate) mod dummy;\r\npub(crate) mod explain;\r\npub(crate) mod filter;\r\npub(crate) mod index_scan;\r\npub(crate) mod join;\r\npub(crate) mod limit;\r\npub(crate) mod projection;\r\npub(crate) mod seq_scan;\r\npub(crate) mod sort;\r\npub(crate) mod values;\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","execution","executor","dql","projection.rs"],"content":"\r\n\r\nuse crate::catalog::ColumnRef;\r\nuse crate::errors::*;\r\nuse crate::execution::executor::{build, Executor, Source};\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::project::ProjectOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::value::ValueRef;\r\n\r\npub struct Projection {\r\n    pub(crate) exprs: Vec\u003cScalarExpression\u003e,\r\n    input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(ProjectOperator, LogicalPlan)\u003e for Projection {\r\n    fn from((ProjectOperator { exprs }, input): (ProjectOperator, LogicalPlan)) -\u003e Self {\r\n        Projection { exprs, input }\r\n    }\r\n}\r\nimpl Projection {\r\n    pub fn projection(\r\n        tuple: \u0026Tuple,\r\n        exprs: \u0026[ScalarExpression],\r\n        schmea: \u0026[ColumnRef],\r\n    ) -\u003e Result\u003cVec\u003cValueRef\u003e\u003e {\r\n        let mut values = Vec::with_capacity(exprs.len());\r\n        // println!(\"exprs:{}\",exprs.iter().map(|expr|expr.to_string()).join(\",\"));\r\n        for expr in exprs.iter() {\r\n            values.push(expr.eval(tuple, schmea)?);\r\n        }\r\n        Ok(values)\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Projection {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let Projection { exprs, mut input } = self;\r\n        let mut tuples = Vec::new();\r\n        let schema = input.output_schema().clone();\r\n        let mut data_source = build(input, transaction)?;\r\n        for tuple in data_source.iter_mut() {\r\n            // println!(\"projection before: {}\", tuple);\r\n            // let tuple = tuple;\r\n            let values = Self::projection(tuple, \u0026exprs, \u0026schema)?;\r\n            // println!(\"projection after: {}\",values.iter().map(|v| v.to_string()).join(\",\"));\r\n\r\n            tuple.values = values;\r\n            tuples.push(tuple.clone());\r\n        }\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":17437937757178560512},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2233785415175766070},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2233785415175766070},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2233785415175766070},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2233785415175766070},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4467570830351532140},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":9943947977234055168},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":9943947977234055168},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null}],"covered":14,"coverable":16},{"path":["E:","\\","sql-layer","src","execution","executor","dql","seq_scan.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::planner::operator::scan::ScanOperator;\r\nuse crate::storage::{Iter, Transaction};\r\n\r\npub(crate) struct SeqScan {\r\n    op: ScanOperator,\r\n}\r\n\r\nimpl From\u003cScanOperator\u003e for SeqScan {\r\n    fn from(op: ScanOperator) -\u003e Self {\r\n        SeqScan { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for SeqScan {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let ScanOperator {\r\n            table_name,\r\n            columns,\r\n            limit,\r\n            ..\r\n        } = self.op;\r\n        let mut iter = transaction.read(table_name, limit, columns)?;\r\n        let tuples = iter.fetch_tuple()?.unwrap_or(vec![]);\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":5044031582654955520},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":5044031582654955520},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null}],"covered":11,"coverable":11},{"path":["E:","\\","sql-layer","src","execution","executor","dql","sort.rs"],"content":"use crate::execution::executor::{build, Executor, Source};\r\n\r\nuse crate::planner::operator::sort::{SortField, SortOperator};\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\n\r\nuse std::cmp::Ordering;\r\n\r\npub struct Sort {\r\n    sort_fields: Vec\u003cSortField\u003e,\r\n    limit: Option\u003cusize\u003e,\r\n    input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(SortOperator, LogicalPlan)\u003e for Sort {\r\n    fn from((SortOperator { sort_fields, limit }, input): (SortOperator, LogicalPlan)) -\u003e Self {\r\n        Sort {\r\n            sort_fields,\r\n            limit,\r\n            input,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Sort {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let Sort {\r\n            sort_fields,\r\n            limit,\r\n            mut input,\r\n        } = self;\r\n        let mut tuples: Vec\u003cTuple\u003e = vec![];\r\n        let schema = input.output_schema().clone();\r\n        let input = build(input, transaction)?;\r\n        for tuple in input {\r\n            tuples.push(tuple);\r\n        }\r\n        tuples.sort_by(|tuple_1, tuple_2| {\r\n            let mut ordering = Ordering::Equal;\r\n\r\n            for SortField {\r\n                expr,\r\n                asc,\r\n                nulls_first,\r\n            } in \u0026sort_fields\r\n            {\r\n                let value_1 = expr.eval(tuple_1, \u0026schema).unwrap();\r\n                let value_2 = expr.eval(tuple_2, \u0026schema).unwrap();\r\n\r\n                ordering = value_1.partial_cmp(\u0026value_2).unwrap_or_else(|| {\r\n                    match (value_1.is_null(), value_2.is_null()) {\r\n                        (false, true) =\u003e {\r\n                            if *nulls_first {\r\n                                Ordering::Less\r\n                            } else {\r\n                                Ordering::Greater\r\n                            }\r\n                        }\r\n                        (true, false) =\u003e {\r\n                            if *nulls_first {\r\n                                Ordering::Greater\r\n                            } else {\r\n                                Ordering::Less\r\n                            }\r\n                        }\r\n                        _ =\u003e Ordering::Equal,\r\n                    }\r\n                });\r\n\r\n                if !*asc {\r\n                    ordering = ordering.reverse();\r\n                }\r\n\r\n                if ordering != Ordering::Equal {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            ordering\r\n        });\r\n        let len = limit.unwrap_or(tuples.len());\r\n        tuples = tuples.drain(..len).collect();\r\n\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":24,"coverable":40},{"path":["E:","\\","sql-layer","src","execution","executor","dql","values.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::planner::operator::values::ValuesOperator;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\n\r\nuse itertools::Itertools;\r\n\r\npub struct Values {\r\n    op: ValuesOperator,\r\n}\r\n\r\nimpl From\u003cValuesOperator\u003e for Values {\r\n    fn from(op: ValuesOperator) -\u003e Self {\r\n        Values { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Values {\r\n    fn execute(self, _transaction: \u0026mut T) -\u003e Source {\r\n        let ValuesOperator { columns: _, rows } = self.op;\r\n        // eprintln!(\"values executor result :{:#?}\",columns);\r\n\r\n        Ok(rows\r\n            .iter()\r\n            .map(|val| Tuple {\r\n                id: None,\r\n                values: val.clone(),\r\n            })\r\n            .collect_vec())\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null}],"covered":9,"coverable":9},{"path":["E:","\\","sql-layer","src","execution","executor","mod.rs"],"content":"pub(crate) mod ddl;\r\npub(crate) mod dml;\r\npub(crate) mod dql;\r\npub(crate) mod set;\r\npub(crate) mod show;\r\nuse crate::{\r\n    planner::{\r\n        operator::{join::JoinCondition, Operator},\r\n        LogicalPlan,\r\n    },\r\n    storage::Transaction,\r\n    types::tuple::Tuple,\r\n};\r\n\r\nuse self::{\r\n    ddl::{\r\n        alter_table::{AddColumn, DropColumn},\r\n        create_index::CreateIndex,\r\n        create_table::CreateTable,\r\n        drop_index::DropIndex,\r\n        drop_table::DropTable,\r\n    },\r\n    dml::{copy::CopyFromFile, delete::Delete, insert::Insert, update::Update},\r\n    dql::{\r\n        agg::{hash_agg::HashAggExecutor, simple_agg::SimpleAggExecutor},\r\n        describe::Describe,\r\n        dummy::Dummy,\r\n        explain::Explain,\r\n        filter::Filter,\r\n        index_scan::IndexScan,\r\n        join::*,\r\n        limit::Limit,\r\n        projection::Projection,\r\n        seq_scan::SeqScan,\r\n        sort::Sort,\r\n        values::Values,\r\n    },\r\n    hash_join::HashJoin,\r\n    nested_loop_join::NestedLoopJoin,\r\n    set::SetVariable,\r\n    show::ShowTables,\r\n};\r\nuse crate::errors::*;\r\n\r\npub type Source = Result\u003cVec\u003cTuple\u003e\u003e;\r\n\r\npub trait Executor\u003cT: Transaction\u003e {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source;\r\n}\r\npub fn build\u003cT: Transaction\u003e(plan: LogicalPlan, transaction: \u0026mut T) -\u003e Source {\r\n    let LogicalPlan {\r\n        operator,\r\n        mut childrens,\r\n        ..\r\n    } = plan;\r\n\r\n    match operator {\r\n        Operator::Dummy =\u003e Dummy {}.execute(transaction),\r\n        Operator::Aggregate(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n            // let input = build(childrens.remove(0), transaction);\r\n\r\n            if op.groupby_exprs.is_empty() {\r\n                SimpleAggExecutor::from((op, input)).execute(transaction)\r\n            } else {\r\n                HashAggExecutor::from((op, input)).execute(transaction)\r\n            }\r\n        }\r\n        Operator::Filter(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n\r\n            Filter::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::Join(op) =\u003e {\r\n            let right_input = childrens.pop().unwrap();\r\n            let left_input = childrens.pop().unwrap();\r\n            match \u0026op.on {\r\n                JoinCondition::On { on, .. } if !on.is_empty() =\u003e {\r\n                    HashJoin::from((op, left_input, right_input)).execute(transaction)\r\n                }\r\n                _ =\u003e NestedLoopJoin::from((op, left_input, right_input)).execute(transaction),\r\n            }\r\n        }\r\n        Operator::Project(op) =\u003e {\r\n            // let input = build(childrens.remove(0), transaction);\r\n            let input = childrens.pop().unwrap();\r\n\r\n            Projection::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::Scan(op) =\u003e {\r\n            if op.index_by.is_some() {\r\n                // println!(\"build index scan\");\r\n                IndexScan::from(op).execute(transaction)\r\n            } else {\r\n                // println!(\"build seq scan\");\r\n\r\n                SeqScan::from(op).execute(transaction)\r\n            }\r\n        }\r\n        Operator::Sort(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n\r\n            Sort::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::Limit(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n\r\n            Limit::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::Insert(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n            Insert::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::Update(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n            // let values = build(childrens.remove(0), transaction);\r\n\r\n            Update::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::Delete(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n\r\n            Delete::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::Values(op) =\u003e Values::from(op).execute(transaction),\r\n        Operator::AddColumn(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n            AddColumn::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::DropColumn(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n            DropColumn::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::CreateTable(op) =\u003e CreateTable::from(op).execute(transaction),\r\n        Operator::DropTable(op) =\u003e DropTable::from(op).execute(transaction),\r\n        Operator::CreateIndex(op) =\u003e CreateIndex::from(op).execute(transaction),\r\n        Operator::Explain =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n\r\n            Explain::from(input).execute(transaction)\r\n        }\r\n        Operator::DropIndex(op) =\u003e DropIndex::from(op).execute(transaction),\r\n        Operator::Show =\u003e ShowTables.execute(transaction),\r\n        Operator::SetVar(op) =\u003e SetVariable::from(op).execute(transaction),\r\n        Operator::CopyFromFile(op) =\u003e CopyFromFile::from(op).execute(transaction),\r\n        Operator::Describe(op) =\u003e Describe::from(op).execute(transaction),\r\n    }\r\n}\r\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":44,"coverable":62},{"path":["E:","\\","sql-layer","src","execution","executor","set","mod.rs"],"content":"use crate::{planner::operator::set_var::SetVarOperator, storage::Transaction};\r\n\r\nuse super::{Executor, Source};\r\n\r\npub struct SetVariable {\r\n    op: SetVarOperator,\r\n}\r\n\r\nimpl From\u003cSetVarOperator\u003e for SetVariable {\r\n    fn from(op: SetVarOperator) -\u003e Self {\r\n        SetVariable { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for SetVariable {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        if self.op.value == \"serializable\" {\r\n            transaction.set_isolation(true)?;\r\n        } else {\r\n            transaction.set_isolation(false)?;\r\n        }\r\n\r\n        Ok(vec![])\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["E:","\\","sql-layer","src","execution","executor","show","mod.rs"],"content":"use std::sync::Arc;\r\n\r\nuse crate::{\r\n    storage::Transaction,\r\n    types::{tuple::Tuple, value::DataValue},\r\n};\r\n\r\nuse super::{Executor, Source};\r\n\r\npub struct ShowTables;\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for ShowTables {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let metas = transaction.show_tables()?;\r\n        let mut tuples = Vec::new();\r\n        for meta in metas {\r\n            let values = vec![Arc::new(DataValue::Utf8(Some(meta)))];\r\n            tuples.push(Tuple { id: None, values })\r\n        }\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":6,"coverable":7},{"path":["E:","\\","sql-layer","src","execution","mod.rs"],"content":"pub mod executor;\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","expression","agg.rs"],"content":"use serde::{Deserialize, Serialize};\r\n\r\n#[derive(Debug, PartialEq, Eq, Clone, Hash, Serialize, Deserialize)]\r\n\r\npub enum Aggregate {\r\n    Avg,\r\n    Max,\r\n    Min,\r\n    Sum,\r\n    Count,\r\n}\r\nimpl Aggregate {\r\n    pub fn allow_distinct(\u0026self) -\u003e bool {\r\n        match self {\r\n            Aggregate::Avg =\u003e false,\r\n            Aggregate::Max =\u003e false,\r\n            Aggregate::Min =\u003e false,\r\n            Aggregate::Sum =\u003e true,\r\n            Aggregate::Count =\u003e true,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":5476377146882523136},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":5476377146882523136},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null}],"covered":7,"coverable":7},{"path":["E:","\\","sql-layer","src","expression","evaluator.rs"],"content":"use crate::catalog::ColumnRef;\r\nuse crate::errors::*;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::value::{DataValue, ValueRef};\r\nuse itertools::Itertools;\r\nuse lazy_static::lazy_static;\r\nuse std::sync::Arc;\r\n\r\nlazy_static! {\r\n    static ref NULL_VALUE: ValueRef = Arc::new(DataValue::Null);\r\n}\r\n\r\nimpl ScalarExpression {\r\n    ///  \r\n    ///\r\n    pub fn eval(\u0026self, tuple: \u0026Tuple, schema: \u0026[ColumnRef]) -\u003e Result\u003cValueRef\u003e {\r\n        // \r\n        // if let Some(value) = Self::eval_with_name(tuple, self.output_columns().name(), schema) {\r\n        //     return Ok(value.clone());\r\n        // }\r\n        if let Some(value) = schema\r\n            .iter()\r\n            .find_position(|tul_col| tul_col.summary() == self.output_columns().summary())\r\n            .map(|(i, _)| \u0026tuple.values[i])\r\n        {\r\n            return Ok(value.clone());\r\n        }\r\n        match \u0026self {\r\n            ScalarExpression::Constant(val) =\u003e Ok(val.clone()),\r\n            ScalarExpression::ColumnRef(col) =\u003e {\r\n                // println!(\"schema:{:?}\", schema);\r\n                // println!(\"col:{:?}\", col.summary());\r\n                let value = schema\r\n                    .iter()\r\n                    .find_position(|tul_col| tul_col.summary() == col.summary())\r\n                    .map(|(i, _)| \u0026tuple.values[i])\r\n                    .unwrap_or(\u0026NULL_VALUE)\r\n                    .clone();\r\n                Ok(value)\r\n            }\r\n            ScalarExpression::Alias { expr, alias } =\u003e {\r\n                if let Some(value) = Self::eval_with_name(tuple, alias, schema) {\r\n                    return Ok(value.clone());\r\n                }\r\n\r\n                expr.eval(tuple, schema)\r\n            }\r\n            ScalarExpression::TypeCast { expr, ty, .. } =\u003e {\r\n                let value = expr.eval(tuple, schema)?;\r\n\r\n                Ok(Arc::new(DataValue::clone(\u0026value).cast(ty)?))\r\n            }\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                op,\r\n                ..\r\n            } =\u003e {\r\n                let left = left_expr.eval(tuple, schema)?;\r\n                let right = right_expr.eval(tuple, schema)?;\r\n\r\n                Ok(Arc::new(DataValue::binary_op(\u0026left, \u0026right, op)?))\r\n            }\r\n            ScalarExpression::IsNull { expr, negated } =\u003e {\r\n                let mut is_null = expr.eval(tuple, schema)?.is_null();\r\n                if *negated {\r\n                    is_null = !is_null;\r\n                }\r\n                Ok(Arc::new(DataValue::Boolean(Some(is_null))))\r\n            }\r\n            ScalarExpression::In {\r\n                expr,\r\n                args,\r\n                negated,\r\n            } =\u003e {\r\n                let value = expr.eval(tuple, schema)?;\r\n                let mut is_in = false;\r\n                for arg in args {\r\n                    if arg.eval(tuple, schema)? == value {\r\n                        is_in = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if *negated {\r\n                    is_in = !is_in;\r\n                }\r\n                Ok(Arc::new(DataValue::Boolean(Some(is_in))))\r\n            }\r\n            ScalarExpression::Unary { expr, op, .. } =\u003e {\r\n                let value = expr.eval(tuple, schema)?;\r\n\r\n                Ok(Arc::new(DataValue::unary_op(\u0026value, op)?))\r\n            }\r\n            ScalarExpression::AggCall { .. } =\u003e {\r\n                // println!(\"{}\",schema.iter().map(|item|item.to_string()).join(\",\"));\r\n                // schema.iter().for_each(|item|)\r\n                let value = schema\r\n                    .iter()\r\n                    .find_position(|tul_col| tul_col.summary() == self.output_columns().summary())\r\n                    .map(|(i, _)| \u0026tuple.values[i])\r\n                    .unwrap_or(\u0026NULL_VALUE)\r\n                    .clone();\r\n                Ok(value)\r\n            }\r\n        }\r\n    }\r\n\r\n    fn eval_with_name\u003c'a\u003e(\r\n        tuple: \u0026'a Tuple,\r\n        name: \u0026str,\r\n        schema: \u0026[ColumnRef],\r\n    ) -\u003e Option\u003c\u0026'a ValueRef\u003e {\r\n        schema\r\n            .iter()\r\n            .find_position(|tul_col| tul_col.name() == name)\r\n            .map(|(i, _)| \u0026tuple.values[i])\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1224979098644774917},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":12898309332789100551},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":14987979559889010698},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":14123288431433875473},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":7998392938210000899},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":3674937295934324736},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":288230376151711747},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null}],"covered":18,"coverable":53},{"path":["E:","\\","sql-layer","src","expression","mod.rs"],"content":"use itertools::Itertools;\r\nuse serde::{Deserialize, Serialize};\r\nuse std::fmt::{self};\r\nuse std::fmt::{Debug, Formatter};\r\nuse std::sync::Arc;\r\n\r\nuse sqlparser::ast::{BinaryOperator as SqlBinaryOperator, UnaryOperator as SqlUnaryOperator};\r\n\r\nuse self::agg::Aggregate;\r\nuse crate::catalog::{ColumnCatalog, ColumnDesc, ColumnRef};\r\n\r\nuse crate::types::value::ValueRef;\r\nuse crate::types::LogicalType;\r\n\r\npub mod agg;\r\nmod evaluator;\r\npub mod simplify;\r\npub mod value_compute;\r\n\r\n#[derive(Debug, PartialEq, Eq, Clone, Hash)]\r\npub enum AliasType {\r\n    Name(String),\r\n    Expr(Box\u003cScalarExpression\u003e),\r\n}\r\n\r\n/// ScalarExpression represnet all scalar expression in SQL.\r\n/// SELECT a+1, b FROM t1.\r\n/// a+1 -\u003e ScalarExpression::Unary(a + 1)\r\n/// b   -\u003e ScalarExpression::ColumnRef()\r\n#[derive(Debug, PartialEq, Eq, Clone, Hash, Serialize, Deserialize)]\r\npub enum ScalarExpression {\r\n    Constant(ValueRef),\r\n    ColumnRef(ColumnRef),\r\n    Alias {\r\n        expr: Box\u003cScalarExpression\u003e,\r\n        alias: String,\r\n    },\r\n    TypeCast {\r\n        expr: Box\u003cScalarExpression\u003e,\r\n        ty: LogicalType,\r\n    },\r\n    IsNull {\r\n        negated: bool,\r\n        expr: Box\u003cScalarExpression\u003e,\r\n    },\r\n    Unary {\r\n        op: UnaryOperator,\r\n        expr: Box\u003cScalarExpression\u003e,\r\n        ty: LogicalType,\r\n    },\r\n    Binary {\r\n        op: BinaryOperator,\r\n        left_expr: Box\u003cScalarExpression\u003e,\r\n        right_expr: Box\u003cScalarExpression\u003e,\r\n        ty: LogicalType,\r\n    },\r\n    AggCall {\r\n        distinct: bool,\r\n        kind: Aggregate,\r\n        args: Vec\u003cScalarExpression\u003e,\r\n        ty: LogicalType,\r\n    },\r\n    In {\r\n        negated: bool,\r\n        expr: Box\u003cScalarExpression\u003e,\r\n        args: Vec\u003cScalarExpression\u003e,\r\n    },\r\n}\r\n\r\nimpl ScalarExpression {\r\n    pub fn unpack_alias(\u0026self) -\u003e \u0026ScalarExpression {\r\n        if let ScalarExpression::Alias { expr, .. } = self {\r\n            expr.unpack_alias()\r\n        } else {\r\n            self\r\n        }\r\n    }\r\n\r\n    pub fn has_count_star(\u0026self) -\u003e bool {\r\n        match self {\r\n            ScalarExpression::Alias { expr, .. } =\u003e expr.has_count_star(),\r\n            ScalarExpression::TypeCast { expr, .. } =\u003e expr.has_count_star(),\r\n            ScalarExpression::IsNull { expr, .. } =\u003e expr.has_count_star(),\r\n            ScalarExpression::Unary { expr, .. } =\u003e expr.has_count_star(),\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                ..\r\n            } =\u003e left_expr.has_count_star() || right_expr.has_count_star(),\r\n            ScalarExpression::AggCall { args, .. } =\u003e args.iter().any(Self::has_count_star),\r\n            _ =\u003e false,\r\n        }\r\n    }\r\n\r\n    pub fn return_type(\u0026self) -\u003e LogicalType {\r\n        match self {\r\n            Self::Constant(v) =\u003e v.logical_type(),\r\n            Self::ColumnRef(col) =\u003e *col.datatype(),\r\n            Self::Binary {\r\n                ty: return_type, ..\r\n            } =\u003e *return_type,\r\n            Self::Unary {\r\n                ty: return_type, ..\r\n            } =\u003e *return_type,\r\n            Self::TypeCast {\r\n                ty: return_type, ..\r\n            } =\u003e *return_type,\r\n            Self::AggCall {\r\n                ty: return_type, ..\r\n            } =\u003e *return_type,\r\n            Self::IsNull { .. } | Self::In { .. } =\u003e LogicalType::Boolean,\r\n            Self::Alias { expr, .. } =\u003e expr.return_type(),\r\n        }\r\n    }\r\n\r\n    pub fn referenced_columns(\u0026self, only_column_ref: bool) -\u003e Vec\u003cColumnRef\u003e {\r\n        fn columns_collect(\r\n            expr: \u0026ScalarExpression,\r\n            vec: \u0026mut Vec\u003cColumnRef\u003e,\r\n            only_column_ref: bool,\r\n        ) {\r\n            // When `ScalarExpression` is a complex type, it itself is also a special Column\r\n            if !only_column_ref {\r\n                vec.push(expr.output_columns());\r\n            }\r\n            match expr {\r\n                ScalarExpression::ColumnRef(col) =\u003e {\r\n                    vec.push(col.clone());\r\n                }\r\n                ScalarExpression::Alias { expr, .. } =\u003e columns_collect(expr, vec, only_column_ref),\r\n                ScalarExpression::TypeCast { expr, .. } =\u003e {\r\n                    columns_collect(expr, vec, only_column_ref)\r\n                }\r\n                ScalarExpression::IsNull { expr, .. } =\u003e {\r\n                    columns_collect(expr, vec, only_column_ref)\r\n                }\r\n                ScalarExpression::Unary { expr, .. } =\u003e columns_collect(expr, vec, only_column_ref),\r\n                ScalarExpression::Binary {\r\n                    left_expr,\r\n                    right_expr,\r\n                    ..\r\n                } =\u003e {\r\n                    columns_collect(left_expr, vec, only_column_ref);\r\n                    columns_collect(right_expr, vec, only_column_ref);\r\n                }\r\n                ScalarExpression::AggCall { args, .. } =\u003e {\r\n                    for expr in args {\r\n                        columns_collect(expr, vec, only_column_ref)\r\n                    }\r\n                }\r\n                ScalarExpression::In { expr, args, .. } =\u003e {\r\n                    columns_collect(expr, vec, only_column_ref);\r\n                    for arg in args {\r\n                        columns_collect(arg, vec, only_column_ref)\r\n                    }\r\n                }\r\n                _ =\u003e (),\r\n            }\r\n        }\r\n        let mut exprs = Vec::new();\r\n\r\n        columns_collect(self, \u0026mut exprs, only_column_ref);\r\n\r\n        exprs\r\n    }\r\n\r\n    pub fn has_agg_call(\u0026self) -\u003e bool {\r\n        match self {\r\n            ScalarExpression::AggCall { .. } =\u003e true,\r\n            ScalarExpression::Constant(_) =\u003e false,\r\n            ScalarExpression::ColumnRef(_) =\u003e false,\r\n            ScalarExpression::Alias { expr, .. } =\u003e expr.has_agg_call(),\r\n            ScalarExpression::TypeCast { expr, .. } =\u003e expr.has_agg_call(),\r\n            ScalarExpression::IsNull { expr, .. } =\u003e expr.has_agg_call(),\r\n            ScalarExpression::Unary { expr, .. } =\u003e expr.has_agg_call(),\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                ..\r\n            } =\u003e left_expr.has_agg_call() || right_expr.has_agg_call(),\r\n            ScalarExpression::In { expr, args, .. } =\u003e {\r\n                expr.has_agg_call() || args.iter().any(|arg| arg.has_agg_call())\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn output_columns(\u0026self) -\u003e ColumnRef {\r\n        match self {\r\n            ScalarExpression::ColumnRef(col) =\u003e col.clone(),\r\n            ScalarExpression::Constant(value) =\u003e Arc::new(ColumnCatalog::new(\r\n                format!(\"{}\", value),\r\n                true,\r\n                ColumnDesc::new(value.logical_type(), false, false, None),\r\n                // Some(self.clone()),\r\n            )),\r\n            ScalarExpression::Alias { expr, alias } =\u003e Arc::new(ColumnCatalog::new(\r\n                alias.to_string(),\r\n                true,\r\n                ColumnDesc::new(expr.return_type(), false, false, None),\r\n                // Some(self.clone()),\r\n            )),\r\n            ScalarExpression::AggCall {\r\n                kind,\r\n                args,\r\n                ty,\r\n                distinct,\r\n            } =\u003e {\r\n                let args_str = args\r\n                    .iter()\r\n                    .map(|expr| expr.output_columns().name().to_string())\r\n                    .join(\", \");\r\n                let op = |allow_distinct, distinct| {\r\n                    if allow_distinct \u0026\u0026 distinct {\r\n                        \"DISTINCT \"\r\n                    } else {\r\n                        \"\"\r\n                    }\r\n                };\r\n                let column_name = format!(\r\n                    \"{:?}({}{})\",\r\n                    kind,\r\n                    op(kind.allow_distinct(), *distinct),\r\n                    args_str\r\n                );\r\n\r\n                Arc::new(ColumnCatalog::new(\r\n                    column_name,\r\n                    true,\r\n                    ColumnDesc::new(*ty, false, false, None),\r\n                    // Some(self.clone()),\r\n                ))\r\n            }\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                op,\r\n                ty,\r\n            } =\u003e {\r\n                let column_name = format!(\r\n                    \"({} {} {})\",\r\n                    left_expr.output_columns().name(),\r\n                    op,\r\n                    right_expr.output_columns().name(),\r\n                );\r\n\r\n                Arc::new(ColumnCatalog::new(\r\n                    column_name,\r\n                    true,\r\n                    ColumnDesc::new(*ty, false, false, None),\r\n                    // Some(self.clone()),\r\n                ))\r\n            }\r\n            ScalarExpression::Unary { expr, op, ty } =\u003e {\r\n                let column_name = format!(\"{}{}\", op, expr.output_columns().name());\r\n                Arc::new(ColumnCatalog::new(\r\n                    column_name,\r\n                    true,\r\n                    ColumnDesc::new(*ty, false, false, None),\r\n                    // Some(self.clone()),\r\n                ))\r\n            }\r\n            ScalarExpression::IsNull { negated, expr } =\u003e {\r\n                let suffix = if *negated { \"is not null\" } else { \"is null\" };\r\n                Arc::new(ColumnCatalog::new(\r\n                    format!(\"{} {}\", expr.output_columns().name(), suffix),\r\n                    true,\r\n                    ColumnDesc::new(LogicalType::Boolean, false, false, None),\r\n                    // Some(self.clone()),\r\n                ))\r\n            }\r\n            ScalarExpression::In {\r\n                negated,\r\n                expr,\r\n                args,\r\n            } =\u003e {\r\n                let args_string = args\r\n                    .iter()\r\n                    .map(|arg| arg.output_columns().name().to_string())\r\n                    .join(\", \");\r\n                let op_string = if *negated { \"not in\" } else { \"in\" };\r\n                Arc::new(ColumnCatalog::new(\r\n                    format!(\r\n                        \"{} {} ({})\",\r\n                        expr.output_columns().name(),\r\n                        op_string,\r\n                        args_string\r\n                    ),\r\n                    true,\r\n                    ColumnDesc::new(LogicalType::Boolean, false, false, None),\r\n                    // Some(self.clone()),\r\n                ))\r\n            }\r\n            ScalarExpression::TypeCast { expr, ty } =\u003e Arc::new(ColumnCatalog::new(\r\n                format!(\"CAST({} as {})\", expr.output_columns().name(), ty),\r\n                true,\r\n                ColumnDesc::new(*ty, false, false, None),\r\n                // Some(self.clone()),\r\n            )),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\r\npub enum UnaryOperator {\r\n    Plus,\r\n    Minus,\r\n    Not,\r\n}\r\n\r\nimpl From\u003cSqlUnaryOperator\u003e for UnaryOperator {\r\n    fn from(value: SqlUnaryOperator) -\u003e Self {\r\n        match value {\r\n            SqlUnaryOperator::Plus =\u003e UnaryOperator::Plus,\r\n            SqlUnaryOperator::Minus =\u003e UnaryOperator::Minus,\r\n            SqlUnaryOperator::Not =\u003e UnaryOperator::Not,\r\n            _ =\u003e unimplemented!(\"not support!\"),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\r\npub enum BinaryOperator {\r\n    Plus,\r\n    Minus,\r\n    Multiply,\r\n    Divide,\r\n\r\n    Modulo,\r\n    StringConcat,\r\n\r\n    Gt,\r\n    Lt,\r\n    GtEq,\r\n    LtEq,\r\n    Spaceship,\r\n    Eq,\r\n    NotEq,\r\n    Like,\r\n    NotLike,\r\n\r\n    And,\r\n    Or,\r\n    Xor,\r\n}\r\n\r\nimpl fmt::Display for ScalarExpression {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"{}\", self.output_columns().name())\r\n    }\r\n}\r\n\r\nimpl fmt::Display for BinaryOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        match self {\r\n            BinaryOperator::Plus =\u003e write!(f, \"+\"),\r\n            BinaryOperator::Minus =\u003e write!(f, \"-\"),\r\n            BinaryOperator::Multiply =\u003e write!(f, \"*\"),\r\n            BinaryOperator::Divide =\u003e write!(f, \"/\"),\r\n            BinaryOperator::Modulo =\u003e write!(f, \"mod\"),\r\n            BinaryOperator::StringConcat =\u003e write!(f, \"\u0026\"),\r\n            BinaryOperator::Gt =\u003e write!(f, \"\u003e\"),\r\n            BinaryOperator::Lt =\u003e write!(f, \"\u003c\"),\r\n            BinaryOperator::GtEq =\u003e write!(f, \"\u003e=\"),\r\n            BinaryOperator::LtEq =\u003e write!(f, \"\u003c=\"),\r\n            BinaryOperator::Spaceship =\u003e write!(f, \"\u003c=\u003e\"),\r\n            BinaryOperator::Eq =\u003e write!(f, \"=\"),\r\n            BinaryOperator::NotEq =\u003e write!(f, \"!=\"),\r\n            BinaryOperator::And =\u003e write!(f, \"\u0026\u0026\"),\r\n            BinaryOperator::Or =\u003e write!(f, \"||\"),\r\n            BinaryOperator::Xor =\u003e write!(f, \"^\"),\r\n            BinaryOperator::Like =\u003e write!(f, \"like\"),\r\n            BinaryOperator::NotLike =\u003e write!(f, \"not like\"),\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for UnaryOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        match self {\r\n            UnaryOperator::Plus =\u003e write!(f, \"+\"),\r\n            UnaryOperator::Minus =\u003e write!(f, \"-\"),\r\n            UnaryOperator::Not =\u003e write!(f, \"!\"),\r\n        }\r\n    }\r\n}\r\n\r\nimpl From\u003cSqlBinaryOperator\u003e for BinaryOperator {\r\n    fn from(value: SqlBinaryOperator) -\u003e Self {\r\n        match value {\r\n            SqlBinaryOperator::Plus =\u003e BinaryOperator::Plus,\r\n            SqlBinaryOperator::Minus =\u003e BinaryOperator::Minus,\r\n            SqlBinaryOperator::Multiply =\u003e BinaryOperator::Multiply,\r\n            SqlBinaryOperator::Divide =\u003e BinaryOperator::Divide,\r\n            SqlBinaryOperator::Modulo =\u003e BinaryOperator::Modulo,\r\n            SqlBinaryOperator::StringConcat =\u003e BinaryOperator::StringConcat,\r\n            SqlBinaryOperator::Gt =\u003e BinaryOperator::Gt,\r\n            SqlBinaryOperator::Lt =\u003e BinaryOperator::Lt,\r\n            SqlBinaryOperator::GtEq =\u003e BinaryOperator::GtEq,\r\n            SqlBinaryOperator::LtEq =\u003e BinaryOperator::LtEq,\r\n            SqlBinaryOperator::Spaceship =\u003e BinaryOperator::Spaceship,\r\n            SqlBinaryOperator::Eq =\u003e BinaryOperator::Eq,\r\n            SqlBinaryOperator::NotEq =\u003e BinaryOperator::NotEq,\r\n            SqlBinaryOperator::And =\u003e BinaryOperator::And,\r\n            SqlBinaryOperator::Or =\u003e BinaryOperator::Or,\r\n            SqlBinaryOperator::Xor =\u003e BinaryOperator::Xor,\r\n            _ =\u003e unimplemented!(\"not support!\"),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":12465963768561532928},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":9007199254740992000},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":9655717601082343424},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":12465963768561532928},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":13330654897016668160},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":14339461213547659264},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":14339461213547659264},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":14339461213547659264},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":14339461213547659264},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":14339461213547659264},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":14339461213547659264},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":14699749183737298944},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":17870283321406128128},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":14699749183737298944},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":13258597302978740224},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":13258597302978740224},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":13835058055282163712},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":13402712491054596096},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":14771806777775226880},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":5044031582654955520},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":5044031582654955520},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":5332261958806667276},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":11385099857992613866},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":11385099857992613866},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":11385099857992613866},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":11385099857992613866},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":792633534417207305},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":792633534417207305},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":792633534417207305},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":792633534417207305},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":16429131440647569410},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":10952754293765046273},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":720575940379279359},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":5908722711110090752},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":1801439850948198400},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":129,"coverable":187},{"path":["E:","\\","sql-layer","src","expression","simplify.rs"],"content":"use crate::catalog::ColumnRef;\r\nuse crate::errors::*;\r\nuse crate::expression::{BinaryOperator, ScalarExpression, UnaryOperator};\r\nuse crate::types::value::{DataValue, ValueRef, NULL_VALUE};\r\nuse crate::types::{ColumnId, LogicalType};\r\nuse ahash::RandomState;\r\nuse itertools::Itertools;\r\nuse std::cmp::Ordering;\r\nuse std::collections::{Bound, HashSet};\r\nuse std::fmt::{self, Formatter};\r\nuse std::mem;\r\nuse std::sync::Arc;\r\n\r\n#[derive(Debug, PartialEq, Eq, Clone, Hash)]\r\npub enum ConstantBinary {\r\n    Scope {\r\n        min: Bound\u003cValueRef\u003e,\r\n        max: Bound\u003cValueRef\u003e,\r\n    },\r\n    Eq(ValueRef),\r\n    NotEq(ValueRef),\r\n\r\n    // ConstantBinary in And can only be Scope\\Eq\\NotEq\r\n    And(Vec\u003cConstantBinary\u003e),\r\n    // ConstantBinary in Or can only be Scope\\Eq\\NotEq\\And\r\n    Or(Vec\u003cConstantBinary\u003e),\r\n}\r\n\r\nimpl ConstantBinary {\r\n    #[allow(dead_code)]\r\n    fn is_null(\u0026self) -\u003e Result\u003cbool\u003e {\r\n        match self {\r\n            ConstantBinary::Scope { min, max } =\u003e {\r\n                let op = |bound: \u0026Bound\u003cValueRef\u003e| {\r\n                    if let Bound::Included(val) | Bound::Excluded(val) = bound {\r\n                        val.is_null()\r\n                    } else {\r\n                        false\r\n                    }\r\n                };\r\n                if op(min) || op(max) {\r\n                    return Ok(true);\r\n                }\r\n\r\n                Ok(matches!((min, max), (Bound::Unbounded, Bound::Unbounded)))\r\n            }\r\n            ConstantBinary::Eq(val) | ConstantBinary::NotEq(val) =\u003e Ok(val.is_null()),\r\n            _ =\u003e Err(DatabaseError::InvalidType),\r\n        }\r\n    }\r\n\r\n    pub fn rearrange(self) -\u003e Result\u003cVec\u003cConstantBinary\u003e\u003e {\r\n        match self {\r\n            ConstantBinary::Or(binaries) =\u003e {\r\n                if binaries.is_empty() {\r\n                    return Ok(vec![]);\r\n                }\r\n\r\n                let mut condition_binaries = Vec::new();\r\n\r\n                for binary in binaries {\r\n                    match binary {\r\n                        ConstantBinary::Or(_) =\u003e return Err(DatabaseError::InvalidType),\r\n                        ConstantBinary::And(mut and_binaries) =\u003e {\r\n                            condition_binaries.append(\u0026mut and_binaries);\r\n                        }\r\n                        ConstantBinary::Scope {\r\n                            min: Bound::Unbounded,\r\n                            max: Bound::Unbounded,\r\n                        } =\u003e (),\r\n                        source =\u003e condition_binaries.push(source),\r\n                    }\r\n                }\r\n                // Sort\r\n                condition_binaries.sort_by(|a, b| {\r\n                    let op = |binary: \u0026ConstantBinary| match binary {\r\n                        ConstantBinary::Scope { min, .. } =\u003e min.clone(),\r\n                        ConstantBinary::Eq(val) =\u003e Bound::Included(val.clone()),\r\n                        ConstantBinary::NotEq(val) =\u003e Bound::Excluded(val.clone()),\r\n                        _ =\u003e unreachable!(),\r\n                    };\r\n\r\n                    Self::bound_compared(\u0026op(a), \u0026op(b), true).unwrap_or(Ordering::Equal)\r\n                });\r\n\r\n                let mut merged_binaries: Vec\u003cConstantBinary\u003e = Vec::new();\r\n\r\n                for condition in condition_binaries {\r\n                    let op = |binary: \u0026ConstantBinary| match binary {\r\n                        ConstantBinary::Scope { min, max } =\u003e (min.clone(), max.clone()),\r\n                        ConstantBinary::Eq(val) =\u003e (Bound::Unbounded, Bound::Included(val.clone())),\r\n                        ConstantBinary::NotEq(val) =\u003e {\r\n                            (Bound::Unbounded, Bound::Excluded(val.clone()))\r\n                        }\r\n                        _ =\u003e unreachable!(),\r\n                    };\r\n                    let mut is_push = merged_binaries.is_empty();\r\n\r\n                    for binary in merged_binaries.iter_mut().rev() {\r\n                        if let ConstantBinary::Scope { max, .. } = binary {\r\n                            let (condition_min, condition_max) = op(\u0026condition);\r\n                            let is_lt_min = Self::bound_compared(max, \u0026condition_min, false)\r\n                                .unwrap_or(Ordering::Equal)\r\n                                .is_lt();\r\n                            let is_lt_max = Self::bound_compared(max, \u0026condition_max, false)\r\n                                .unwrap_or(Ordering::Equal)\r\n                                .is_lt();\r\n\r\n                            if !is_lt_min \u0026\u0026 is_lt_max {\r\n                                let _ = mem::replace(max, condition_max);\r\n                            } else if !matches!(condition, ConstantBinary::Scope { .. }) {\r\n                                is_push = is_lt_max;\r\n                            } else if is_lt_min \u0026\u0026 is_lt_max {\r\n                                is_push = true\r\n                            }\r\n\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if is_push {\r\n                        merged_binaries.push(condition);\r\n                    }\r\n                }\r\n\r\n                Ok(merged_binaries)\r\n            }\r\n            ConstantBinary::And(binaries) =\u003e Ok(binaries),\r\n            source =\u003e Ok(vec![source]),\r\n        }\r\n    }\r\n\r\n    pub fn scope_aggregation(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        match self {\r\n            // `Or` is allowed to contain And, `Scope`, `Eq/NotEq`\r\n            // Tips: Only single-level `And`\r\n            ConstantBinary::Or(binaries) =\u003e {\r\n                let mut or_binaries = Vec::new();\r\n                for binary in binaries {\r\n                    match binary {\r\n                        ConstantBinary::And(and_binaries) =\u003e {\r\n                            or_binaries.append(\u0026mut Self::and_scope_aggregation(and_binaries)?);\r\n                        }\r\n                        ConstantBinary::Or(_) =\u003e {\r\n                            unreachable!(\"`Or` does not allow nested `Or`\")\r\n                        }\r\n                        cb =\u003e {\r\n                            or_binaries.push(cb.clone());\r\n                        }\r\n                    }\r\n                }\r\n                let or_binaries = Self::or_scope_aggregation(\u0026or_binaries);\r\n                let _ = mem::replace(self, ConstantBinary::Or(or_binaries));\r\n            }\r\n            // `And` is allowed to contain Scope, `Eq/NotEq`\r\n            ConstantBinary::And(binaries) =\u003e {\r\n                let and_binaries = Self::and_scope_aggregation(binaries)?;\r\n                let _ = mem::replace(self, ConstantBinary::And(and_binaries));\r\n            }\r\n            _ =\u003e (),\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn bound_compared(\r\n        left_bound: \u0026Bound\u003cValueRef\u003e,\r\n        right_bound: \u0026Bound\u003cValueRef\u003e,\r\n        is_min: bool,\r\n    ) -\u003e Option\u003cOrdering\u003e {\r\n        let op = |is_min, order: Ordering| {\r\n            if is_min {\r\n                order\r\n            } else {\r\n                order.reverse()\r\n            }\r\n        };\r\n\r\n        match (left_bound, right_bound) {\r\n            (Bound::Unbounded, Bound::Unbounded) =\u003e Some(Ordering::Equal),\r\n            (Bound::Unbounded, _) =\u003e Some(op(is_min, Ordering::Less)),\r\n            (_, Bound::Unbounded) =\u003e Some(op(is_min, Ordering::Greater)),\r\n            (Bound::Included(left), Bound::Included(right)) =\u003e left.partial_cmp(right),\r\n            (Bound::Included(left), Bound::Excluded(right)) =\u003e left\r\n                .partial_cmp(right)\r\n                .map(|order| order.then(op(is_min, Ordering::Less))),\r\n            (Bound::Excluded(left), Bound::Excluded(right)) =\u003e left.partial_cmp(right),\r\n            (Bound::Excluded(left), Bound::Included(right)) =\u003e left\r\n                .partial_cmp(right)\r\n                .map(|order| order.then(op(is_min, Ordering::Greater))),\r\n        }\r\n    }\r\n\r\n    // Tips: It only makes sense if the condition is and aggregation\r\n    fn and_scope_aggregation(binaries: \u0026[ConstantBinary]) -\u003e Result\u003cVec\u003cConstantBinary\u003e\u003e {\r\n        if binaries.is_empty() {\r\n            return Ok(vec![]);\r\n        }\r\n\r\n        let mut scope_min = Bound::Unbounded;\r\n        let mut scope_max = Bound::Unbounded;\r\n        let mut eq_set = HashSet::with_hasher(RandomState::new());\r\n\r\n        let sort_op = |binary: \u0026\u0026ConstantBinary| match binary {\r\n            ConstantBinary::Scope { .. } =\u003e 3,\r\n            ConstantBinary::NotEq(_) =\u003e 2,\r\n            ConstantBinary::Eq(_) =\u003e 1,\r\n            ConstantBinary::And(_) | ConstantBinary::Or(_) =\u003e 0,\r\n        };\r\n\r\n        // Aggregate various ranges to get the minimum range\r\n        for binary in binaries.iter().sorted_by_key(sort_op) {\r\n            match binary {\r\n                ConstantBinary::Scope { min, max } =\u003e {\r\n                    // Skip if eq or noteq exists\r\n                    if !eq_set.is_empty() {\r\n                        continue;\r\n                    }\r\n\r\n                    if let Some(order) = Self::bound_compared(\u0026scope_min, min, true) {\r\n                        if order.is_lt() {\r\n                            scope_min = min.clone();\r\n                        }\r\n                    }\r\n\r\n                    if let Some(order) = Self::bound_compared(\u0026scope_max, max, false) {\r\n                        if order.is_gt() {\r\n                            scope_max = max.clone();\r\n                        }\r\n                    }\r\n                }\r\n                ConstantBinary::Eq(val) =\u003e {\r\n                    let _ = eq_set.insert(val.clone());\r\n                }\r\n                ConstantBinary::NotEq(val) =\u003e {\r\n                    let _ = eq_set.remove(val);\r\n                }\r\n                ConstantBinary::Or(_) | ConstantBinary::And(_) =\u003e {\r\n                    return Err(DatabaseError::InvalidType)\r\n                }\r\n            }\r\n        }\r\n\r\n        let eq_option = eq_set\r\n            .into_iter()\r\n            .sorted_by(|a, b| a.partial_cmp(b).unwrap_or(Ordering::Equal))\r\n            .next()\r\n            .map(ConstantBinary::Eq);\r\n\r\n        if let Some(eq) = eq_option {\r\n            Ok(vec![eq])\r\n        } else if !matches!(\r\n            (\u0026scope_min, \u0026scope_max),\r\n            (Bound::Unbounded, Bound::Unbounded)\r\n        ) {\r\n            let scope_binary = ConstantBinary::Scope {\r\n                min: scope_min,\r\n                max: scope_max,\r\n            };\r\n\r\n            Ok(vec![scope_binary])\r\n        } else {\r\n            Ok(vec![])\r\n        }\r\n    }\r\n\r\n    // Tips: It only makes sense if the condition is or aggregation\r\n    fn or_scope_aggregation(binaries: \u0026Vec\u003cConstantBinary\u003e) -\u003e Vec\u003cConstantBinary\u003e {\r\n        if binaries.is_empty() {\r\n            return vec![];\r\n        }\r\n        let mut scopes = Vec::new();\r\n        let mut eqs = Vec::new();\r\n\r\n        let mut scope_margin = None;\r\n\r\n        for binary in binaries {\r\n            if matches!(scope_margin, Some((Bound::Unbounded, Bound::Unbounded))) {\r\n                break;\r\n            }\r\n            match binary {\r\n                ConstantBinary::Scope {\r\n                    min: Bound::Unbounded,\r\n                    max: Bound::Unbounded,\r\n                } =\u003e {\r\n                    scope_margin = Some((Bound::Unbounded, Bound::Unbounded));\r\n                    break;\r\n                }\r\n                ConstantBinary::Scope { min, max } =\u003e {\r\n                    if let Some((scope_min, scope_max)) = \u0026mut scope_margin {\r\n                        if matches!(\r\n                            Self::bound_compared(scope_min, min, true).map(Ordering::is_gt),\r\n                            Some(true)\r\n                        ) {\r\n                            let _ = mem::replace(scope_min, min.clone());\r\n                        }\r\n                        if matches!(\r\n                            Self::bound_compared(scope_max, max, false).map(Ordering::is_lt),\r\n                            Some(true)\r\n                        ) {\r\n                            let _ = mem::replace(scope_max, max.clone());\r\n                        }\r\n                    } else {\r\n                        scope_margin = Some((min.clone(), max.clone()))\r\n                    }\r\n\r\n                    scopes.push((min, max))\r\n                }\r\n                ConstantBinary::Eq(val) =\u003e eqs.push(val),\r\n                _ =\u003e (),\r\n            }\r\n        }\r\n        if matches!(\r\n            scope_margin,\r\n            Some((Bound::Unbounded, Bound::Unbounded)) | None\r\n        ) {\r\n            return vec![];\r\n        }\r\n\r\n        let mut merge_scopes: Vec\u003c(Bound\u003cValueRef\u003e, Bound\u003cValueRef\u003e)\u003e = Vec::new();\r\n\r\n        match scope_margin {\r\n            Some((Bound::Unbounded, _)) =\u003e {\r\n                if let Some((_, max)) = scopes.iter().max_by(|(_, max_a), (_, max_b)| {\r\n                    Self::bound_compared(max_a, max_b, false).unwrap()\r\n                }) {\r\n                    merge_scopes.push((Bound::Unbounded, (**max).clone()))\r\n                }\r\n            }\r\n            Some((_, Bound::Unbounded)) =\u003e {\r\n                if let Some((min, _)) = scopes.iter().min_by(|(min_a, _), (min_b, _)| {\r\n                    Self::bound_compared(min_a, min_b, true).unwrap()\r\n                }) {\r\n                    merge_scopes.push(((**min).clone(), Bound::Unbounded))\r\n                }\r\n            }\r\n            _ =\u003e {\r\n                scopes.sort_by(|(min_a, _), (min_b, _)| {\r\n                    Self::bound_compared(min_a, min_b, true).unwrap()\r\n                });\r\n\r\n                for i in 0..scopes.len() {\r\n                    let (min, max) = scopes[i];\r\n                    if merge_scopes.is_empty() {\r\n                        merge_scopes.push((min.clone(), max.clone()));\r\n                        continue;\r\n                    }\r\n\r\n                    let last_pos = merge_scopes.len() - 1;\r\n                    let last_scope: \u0026mut _ = \u0026mut merge_scopes[last_pos];\r\n                    if Self::bound_compared(\u0026last_scope.0, min, true)\r\n                        .unwrap()\r\n                        .is_gt()\r\n                    {\r\n                        merge_scopes.push((min.clone(), max.clone()));\r\n                    } else if Self::bound_compared(\u0026last_scope.1, max, false)\r\n                        .unwrap()\r\n                        .is_lt()\r\n                    {\r\n                        last_scope.1 = max.clone();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        merge_scopes\r\n            .into_iter()\r\n            .map(|(min, max)| ConstantBinary::Scope {\r\n                min: min.clone(),\r\n                max: max.clone(),\r\n            })\r\n            .chain(eqs.into_iter().map(|val| ConstantBinary::Eq(val.clone())))\r\n            .collect_vec()\r\n    }\r\n    fn join_write(f: \u0026mut Formatter, binaries: \u0026[ConstantBinary], op: \u0026str) -\u003e fmt::Result {\r\n        let binaries = binaries.iter().map(|binary| format!(\"{}\", binary)).join(op);\r\n        write!(f, \" {} \", binaries)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nenum Replace {\r\n    Binary(ReplaceBinary),\r\n    Unary(ReplaceUnary),\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct ReplaceBinary {\r\n    column_expr: ScalarExpression,\r\n    val_expr: ScalarExpression,\r\n    op: BinaryOperator,\r\n    ty: LogicalType,\r\n    is_column_left: bool,\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct ReplaceUnary {\r\n    child_expr: ScalarExpression,\r\n    op: UnaryOperator,\r\n    ty: LogicalType,\r\n}\r\n\r\nimpl ScalarExpression {\r\n    pub fn exist_column(\u0026self, col_id: \u0026ColumnId) -\u003e bool {\r\n        match self {\r\n            ScalarExpression::ColumnRef(col) =\u003e col.id() == Some(*col_id),\r\n            ScalarExpression::Alias { expr, .. } =\u003e expr.exist_column(col_id),\r\n            ScalarExpression::TypeCast { expr, .. } =\u003e expr.exist_column(col_id),\r\n            ScalarExpression::IsNull { expr, .. } =\u003e expr.exist_column(col_id),\r\n            ScalarExpression::Unary { expr, .. } =\u003e expr.exist_column(col_id),\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                ..\r\n            } =\u003e left_expr.exist_column(col_id) || right_expr.exist_column(col_id),\r\n            ScalarExpression::In { expr, args, .. } =\u003e {\r\n                expr.exist_column(col_id) || args.iter().any(|expr| expr.exist_column(col_id))\r\n            }\r\n\r\n            _ =\u003e false,\r\n        }\r\n    }\r\n\r\n    fn unpack_val(\u0026self) -\u003e Option\u003cValueRef\u003e {\r\n        match self {\r\n            ScalarExpression::Constant(val) =\u003e Some(val.clone()),\r\n            ScalarExpression::Alias { expr, .. } =\u003e expr.unpack_val(),\r\n            ScalarExpression::TypeCast { expr, ty, .. } =\u003e expr\r\n                .unpack_val()\r\n                .and_then(|val| DataValue::clone(\u0026val).cast(ty).ok().map(Arc::new)),\r\n            ScalarExpression::IsNull { expr, .. } =\u003e {\r\n                let is_null = expr.unpack_val().map(|val| val.is_null());\r\n\r\n                Some(Arc::new(DataValue::Boolean(is_null)))\r\n            }\r\n            ScalarExpression::Unary { expr, op, .. } =\u003e {\r\n                let val = expr.unpack_val()?;\r\n\r\n                DataValue::unary_op(\u0026val, op).ok().map(Arc::new)\r\n            }\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                op,\r\n                ..\r\n            } =\u003e {\r\n                let left = left_expr.unpack_val()?;\r\n                let right = right_expr.unpack_val()?;\r\n\r\n                DataValue::binary_op(\u0026left, \u0026right, op).ok().map(Arc::new)\r\n            }\r\n            _ =\u003e None,\r\n        }\r\n    }\r\n\r\n    fn unpack_col(\u0026self, is_deep: bool) -\u003e Option\u003cColumnRef\u003e {\r\n        match self {\r\n            ScalarExpression::ColumnRef(col) =\u003e Some(col.clone()),\r\n            ScalarExpression::Alias { expr, .. } =\u003e expr.unpack_col(is_deep),\r\n            ScalarExpression::Unary { expr, .. } =\u003e expr.unpack_col(is_deep),\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                ..\r\n            } =\u003e {\r\n                if !is_deep {\r\n                    return None;\r\n                }\r\n\r\n                left_expr\r\n                    .unpack_col(true)\r\n                    .or_else(|| right_expr.unpack_col(true))\r\n            }\r\n            _ =\u003e None,\r\n        }\r\n    }\r\n\r\n    pub fn simplify(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        self._simplify(\u0026mut Vec::new())\r\n    }\r\n\r\n    pub fn constant_calculation(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        match self {\r\n            ScalarExpression::Unary { expr, op, .. } =\u003e {\r\n                expr.constant_calculation()?;\r\n\r\n                if let ScalarExpression::Constant(unary_val) = expr.as_ref() {\r\n                    let value = DataValue::unary_op(unary_val, op)?;\r\n                    let _ = mem::replace(self, ScalarExpression::Constant(Arc::new(value)));\r\n                }\r\n            }\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                op,\r\n                ..\r\n            } =\u003e {\r\n                left_expr.constant_calculation()?;\r\n                right_expr.constant_calculation()?;\r\n\r\n                if let (\r\n                    ScalarExpression::Constant(left_val),\r\n                    ScalarExpression::Constant(right_val),\r\n                ) = (left_expr.as_ref(), right_expr.as_ref())\r\n                {\r\n                    let value = DataValue::binary_op(left_val, right_val, op)?;\r\n                    let _ = mem::replace(self, ScalarExpression::Constant(Arc::new(value)));\r\n                }\r\n            }\r\n            ScalarExpression::Alias { expr, .. } =\u003e expr.constant_calculation()?,\r\n            ScalarExpression::TypeCast { expr, .. } =\u003e expr.constant_calculation()?,\r\n            ScalarExpression::IsNull { expr, .. } =\u003e expr.constant_calculation()?,\r\n            ScalarExpression::AggCall { args, .. } =\u003e {\r\n                for expr in args {\r\n                    expr.constant_calculation()?;\r\n                }\r\n            }\r\n            _ =\u003e (),\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    // Tips: Indirect expressions like `ScalarExpression:Alias` will be lost\r\n    fn _simplify(\u0026mut self, replaces: \u0026mut Vec\u003cReplace\u003e) -\u003e Result\u003c()\u003e {\r\n        match self {\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                op,\r\n                ty,\r\n            } =\u003e {\r\n                Self::fix_expr(replaces, left_expr, right_expr, op)?;\r\n\r\n                // `(c1 - 1) and (c1 + 2)` cannot fix!\r\n                Self::fix_expr(replaces, right_expr, left_expr, op)?;\r\n\r\n                if Self::is_arithmetic(op) {\r\n                    match (left_expr.unpack_col(false), right_expr.unpack_col(false)) {\r\n                        (Some(col), None) =\u003e {\r\n                            replaces.push(Replace::Binary(ReplaceBinary {\r\n                                column_expr: ScalarExpression::ColumnRef(col),\r\n                                val_expr: right_expr.as_ref().clone(),\r\n                                op: *op,\r\n                                ty: *ty,\r\n                                is_column_left: true,\r\n                            }));\r\n                        }\r\n                        (None, Some(col)) =\u003e {\r\n                            replaces.push(Replace::Binary(ReplaceBinary {\r\n                                column_expr: ScalarExpression::ColumnRef(col),\r\n                                val_expr: left_expr.as_ref().clone(),\r\n                                op: *op,\r\n                                ty: *ty,\r\n                                is_column_left: false,\r\n                            }));\r\n                        }\r\n                        (None, None) =\u003e {\r\n                            if replaces.is_empty() {\r\n                                return Ok(());\r\n                            }\r\n\r\n                            match (left_expr.unpack_col(true), right_expr.unpack_col(true)) {\r\n                                (Some(col), None) =\u003e {\r\n                                    replaces.push(Replace::Binary(ReplaceBinary {\r\n                                        column_expr: ScalarExpression::ColumnRef(col),\r\n                                        val_expr: right_expr.as_ref().clone(),\r\n                                        op: *op,\r\n                                        ty: *ty,\r\n                                        is_column_left: true,\r\n                                    }));\r\n                                }\r\n                                (None, Some(col)) =\u003e {\r\n                                    replaces.push(Replace::Binary(ReplaceBinary {\r\n                                        column_expr: ScalarExpression::ColumnRef(col),\r\n                                        val_expr: left_expr.as_ref().clone(),\r\n                                        op: *op,\r\n                                        ty: *ty,\r\n                                        is_column_left: false,\r\n                                    }));\r\n                                }\r\n                                _ =\u003e (),\r\n                            }\r\n                        }\r\n                        _ =\u003e (),\r\n                    }\r\n                }\r\n            }\r\n            ScalarExpression::In {\r\n                expr,\r\n                negated,\r\n                args,\r\n            } =\u003e {\r\n                if args.is_empty() {\r\n                    return Ok(());\r\n                }\r\n\r\n                let (op_1, op_2) = if *negated {\r\n                    (BinaryOperator::NotEq, BinaryOperator::And)\r\n                } else {\r\n                    (BinaryOperator::Eq, BinaryOperator::Or)\r\n                };\r\n                let mut new_expr = ScalarExpression::Binary {\r\n                    op: op_1,\r\n                    left_expr: expr.clone(),\r\n                    right_expr: Box::new(args.remove(0)),\r\n                    ty: LogicalType::Boolean,\r\n                };\r\n\r\n                for arg in args.drain(..) {\r\n                    new_expr = ScalarExpression::Binary {\r\n                        op: op_2,\r\n                        left_expr: Box::new(ScalarExpression::Binary {\r\n                            op: op_1,\r\n                            left_expr: expr.clone(),\r\n                            right_expr: Box::new(arg),\r\n                            ty: LogicalType::Boolean,\r\n                        }),\r\n                        right_expr: Box::new(new_expr),\r\n                        ty: LogicalType::Boolean,\r\n                    }\r\n                }\r\n\r\n                let _ = mem::replace(self, new_expr);\r\n            }\r\n\r\n            ScalarExpression::Alias { expr, .. } =\u003e expr._simplify(replaces)?,\r\n            ScalarExpression::TypeCast { expr, .. } =\u003e {\r\n                if let Some(val) = expr.unpack_val() {\r\n                    let _ = mem::replace(self, ScalarExpression::Constant(val));\r\n                }\r\n            }\r\n            ScalarExpression::IsNull { expr, .. } =\u003e {\r\n                if let Some(val) = expr.unpack_val() {\r\n                    let _ = mem::replace(\r\n                        self,\r\n                        ScalarExpression::Constant(Arc::new(DataValue::Boolean(Some(\r\n                            val.is_null(),\r\n                        )))),\r\n                    );\r\n                }\r\n            }\r\n            ScalarExpression::Unary { expr, op, ty } =\u003e {\r\n                if let Some(val) = expr.unpack_val() {\r\n                    let new_expr =\r\n                        ScalarExpression::Constant(Arc::new(DataValue::unary_op(\u0026val, op)?));\r\n                    let _ = mem::replace(self, new_expr);\r\n                } else {\r\n                    replaces.push(Replace::Unary(ReplaceUnary {\r\n                        child_expr: expr.as_ref().clone(),\r\n                        op: *op,\r\n                        ty: *ty,\r\n                    }));\r\n                }\r\n            }\r\n            _ =\u003e (),\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn is_arithmetic(op: \u0026mut BinaryOperator) -\u003e bool {\r\n        matches!(\r\n            op,\r\n            BinaryOperator::Plus\r\n                | BinaryOperator::Divide\r\n                | BinaryOperator::Minus\r\n                | BinaryOperator::Multiply\r\n        )\r\n    }\r\n\r\n    fn fix_expr(\r\n        replaces: \u0026mut Vec\u003cReplace\u003e,\r\n        left_expr: \u0026mut Box\u003cScalarExpression\u003e,\r\n        right_expr: \u0026mut Box\u003cScalarExpression\u003e,\r\n        op: \u0026mut BinaryOperator,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        left_expr._simplify(replaces)?;\r\n\r\n        if Self::is_arithmetic(op) {\r\n            return Ok(());\r\n        }\r\n        while let Some(replace) = replaces.pop() {\r\n            match replace {\r\n                Replace::Binary(binary) =\u003e Self::fix_binary(binary, left_expr, right_expr, op),\r\n                Replace::Unary(unary) =\u003e {\r\n                    Self::fix_unary(unary, left_expr, right_expr, op);\r\n                    Self::fix_expr(replaces, left_expr, right_expr, op)?;\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn fix_unary(\r\n        replace_unary: ReplaceUnary,\r\n        col_expr: \u0026mut Box\u003cScalarExpression\u003e,\r\n        val_expr: \u0026mut Box\u003cScalarExpression\u003e,\r\n        op: \u0026mut BinaryOperator,\r\n    ) {\r\n        let ReplaceUnary {\r\n            child_expr,\r\n            op: fix_op,\r\n            ty: fix_ty,\r\n        } = replace_unary;\r\n        let _ = mem::replace(col_expr, Box::new(child_expr));\r\n        let _ = mem::replace(\r\n            val_expr,\r\n            Box::new(ScalarExpression::Unary {\r\n                op: fix_op,\r\n                expr: val_expr.clone(),\r\n                ty: fix_ty,\r\n            }),\r\n        );\r\n        let _ = mem::replace(\r\n            op,\r\n            match fix_op {\r\n                UnaryOperator::Plus =\u003e *op,\r\n                UnaryOperator::Minus =\u003e match *op {\r\n                    BinaryOperator::Plus =\u003e BinaryOperator::Minus,\r\n                    BinaryOperator::Minus =\u003e BinaryOperator::Plus,\r\n                    BinaryOperator::Multiply =\u003e BinaryOperator::Divide,\r\n                    BinaryOperator::Divide =\u003e BinaryOperator::Multiply,\r\n                    BinaryOperator::Gt =\u003e BinaryOperator::Lt,\r\n                    BinaryOperator::Lt =\u003e BinaryOperator::Gt,\r\n                    BinaryOperator::GtEq =\u003e BinaryOperator::LtEq,\r\n                    BinaryOperator::LtEq =\u003e BinaryOperator::GtEq,\r\n                    source_op =\u003e source_op,\r\n                },\r\n                UnaryOperator::Not =\u003e match *op {\r\n                    BinaryOperator::Gt =\u003e BinaryOperator::Lt,\r\n                    BinaryOperator::Lt =\u003e BinaryOperator::Gt,\r\n                    BinaryOperator::GtEq =\u003e BinaryOperator::LtEq,\r\n                    BinaryOperator::LtEq =\u003e BinaryOperator::GtEq,\r\n                    source_op =\u003e source_op,\r\n                },\r\n            },\r\n        );\r\n    }\r\n\r\n    fn fix_binary(\r\n        replace_binary: ReplaceBinary,\r\n        left_expr: \u0026mut Box\u003cScalarExpression\u003e,\r\n        right_expr: \u0026mut Box\u003cScalarExpression\u003e,\r\n        op: \u0026mut BinaryOperator,\r\n    ) {\r\n        let ReplaceBinary {\r\n            column_expr,\r\n            val_expr,\r\n            op: fix_op,\r\n            ty: fix_ty,\r\n            is_column_left,\r\n        } = replace_binary;\r\n        let op_flip = |op: BinaryOperator| match op {\r\n            BinaryOperator::Plus =\u003e BinaryOperator::Minus,\r\n            BinaryOperator::Minus =\u003e BinaryOperator::Plus,\r\n            BinaryOperator::Multiply =\u003e BinaryOperator::Divide,\r\n            BinaryOperator::Divide =\u003e BinaryOperator::Multiply,\r\n            _ =\u003e unreachable!(),\r\n        };\r\n        let comparison_flip = |op: BinaryOperator| match op {\r\n            BinaryOperator::Gt =\u003e BinaryOperator::Lt,\r\n            BinaryOperator::GtEq =\u003e BinaryOperator::LtEq,\r\n            BinaryOperator::Lt =\u003e BinaryOperator::Gt,\r\n            BinaryOperator::LtEq =\u003e BinaryOperator::GtEq,\r\n            source_op =\u003e source_op,\r\n        };\r\n        let (fixed_op, fixed_left_expr, fixed_right_expr) = if is_column_left {\r\n            (op_flip(fix_op), right_expr.clone(), Box::new(val_expr))\r\n        } else {\r\n            if matches!(fix_op, BinaryOperator::Minus | BinaryOperator::Multiply) {\r\n                let _ = mem::replace(op, comparison_flip(*op));\r\n            }\r\n            (fix_op, Box::new(val_expr), right_expr.clone())\r\n        };\r\n\r\n        let _ = mem::replace(left_expr, Box::new(column_expr));\r\n        let _ = mem::replace(\r\n            right_expr,\r\n            Box::new(ScalarExpression::Binary {\r\n                op: fixed_op,\r\n                left_expr: fixed_left_expr,\r\n                right_expr: fixed_right_expr,\r\n                ty: fix_ty,\r\n            }),\r\n        );\r\n    }\r\n\r\n    /// The definition of Or is not the Or in the Where condition.\r\n    /// The And and Or of ConstantBinary are concerned with the data range that needs to be aggregated.\r\n    /// - `ConstantBinary::And`: Aggregate the minimum range of all conditions in and\r\n    /// - `ConstantBinary::Or`: Rearrange and sort the range of each OR data\r\n    pub fn convert_binary(\u0026self, col_id: \u0026ColumnId) -\u003e Result\u003cOption\u003cConstantBinary\u003e\u003e {\r\n        match self {\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                op,\r\n                ..\r\n            } =\u003e {\r\n                match (\r\n                    left_expr.convert_binary(col_id)?,\r\n                    right_expr.convert_binary(col_id)?,\r\n                ) {\r\n                    (Some(left_binary), Some(right_binary)) =\u003e match (left_binary, right_binary) {\r\n                        (ConstantBinary::And(mut left), ConstantBinary::And(mut right)) =\u003e match op\r\n                        {\r\n                            BinaryOperator::And =\u003e {\r\n                                left.append(\u0026mut right);\r\n\r\n                                Ok(Some(ConstantBinary::And(left)))\r\n                            }\r\n                            BinaryOperator::Or =\u003e Ok(Some(ConstantBinary::Or(vec![\r\n                                ConstantBinary::And(left),\r\n                                ConstantBinary::And(right),\r\n                            ]))),\r\n                            BinaryOperator::Xor =\u003e todo!(),\r\n                            _ =\u003e unreachable!(),\r\n                        },\r\n                        (ConstantBinary::Or(mut left), ConstantBinary::Or(mut right)) =\u003e match op {\r\n                            BinaryOperator::And | BinaryOperator::Or =\u003e {\r\n                                left.append(\u0026mut right);\r\n\r\n                                Ok(Some(ConstantBinary::Or(left)))\r\n                            }\r\n                            BinaryOperator::Xor =\u003e todo!(),\r\n                            _ =\u003e unreachable!(),\r\n                        },\r\n                        (ConstantBinary::And(mut left), ConstantBinary::Or(mut right)) =\u003e {\r\n                            right.append(\u0026mut left);\r\n\r\n                            Ok(Some(ConstantBinary::Or(right)))\r\n                        }\r\n                        (ConstantBinary::Or(mut left), ConstantBinary::And(mut right)) =\u003e {\r\n                            left.append(\u0026mut right);\r\n\r\n                            Ok(Some(ConstantBinary::Or(left)))\r\n                        }\r\n                        (ConstantBinary::And(mut binaries), binary)\r\n                        | (binary, ConstantBinary::And(mut binaries)) =\u003e {\r\n                            binaries.push(binary);\r\n\r\n                            Ok(Some(ConstantBinary::And(binaries)))\r\n                        }\r\n                        (ConstantBinary::Or(mut binaries), binary)\r\n                        | (binary, ConstantBinary::Or(mut binaries)) =\u003e {\r\n                            binaries.push(binary);\r\n\r\n                            Ok(Some(ConstantBinary::Or(binaries)))\r\n                        }\r\n                        (left, right) =\u003e match op {\r\n                            BinaryOperator::And =\u003e Ok(Some(ConstantBinary::And(vec![left, right]))),\r\n                            BinaryOperator::Or =\u003e Ok(Some(ConstantBinary::Or(vec![left, right]))),\r\n                            BinaryOperator::Xor =\u003e todo!(),\r\n                            _ =\u003e Ok(None),\r\n                        },\r\n                    },\r\n                    (None, None) =\u003e {\r\n                        if let (Some(col), Some(val)) =\r\n                            (left_expr.unpack_col(false), right_expr.unpack_val())\r\n                        {\r\n                            return Ok(Self::new_binary(col_id, *op, col, val, false));\r\n                        }\r\n                        if let (Some(val), Some(col)) =\r\n                            (left_expr.unpack_val(), right_expr.unpack_col(false))\r\n                        {\r\n                            return Ok(Self::new_binary(col_id, *op, col, val, true));\r\n                        }\r\n\r\n                        Ok(None)\r\n                    }\r\n                    (Some(binary), None) =\u003e Ok(Self::check_or(col_id, right_expr, op, binary)),\r\n                    (None, Some(binary)) =\u003e Ok(Self::check_or(col_id, left_expr, op, binary)),\r\n                }\r\n            }\r\n            ScalarExpression::Alias { expr, .. }\r\n            | ScalarExpression::TypeCast { expr, .. }\r\n            | ScalarExpression::In { expr, .. }\r\n            | ScalarExpression::Unary { expr, .. } =\u003e expr.convert_binary(col_id),\r\n            ScalarExpression::IsNull { expr, negated } =\u003e match expr.as_ref() {\r\n                ScalarExpression::ColumnRef(column) =\u003e {\r\n                    if let Some(id) = column.id() {\r\n                        if id == *col_id {\r\n                            return Ok(Some(if *negated {\r\n                                ConstantBinary::NotEq(NULL_VALUE.clone())\r\n                            } else {\r\n                                ConstantBinary::Eq(NULL_VALUE.clone())\r\n                            }));\r\n                        }\r\n                    }\r\n\r\n                    Ok(None)\r\n                }\r\n                ScalarExpression::Constant(_)\r\n                | ScalarExpression::Alias { .. }\r\n                | ScalarExpression::TypeCast { .. }\r\n                | ScalarExpression::IsNull { .. }\r\n                | ScalarExpression::Unary { .. }\r\n                | ScalarExpression::Binary { .. }\r\n                | ScalarExpression::AggCall { .. }\r\n                | ScalarExpression::In { .. } =\u003e expr.convert_binary(col_id),\r\n            },\r\n            _ =\u003e Ok(None),\r\n        }\r\n    }\r\n\r\n    /// check if: c1 \u003e c2 or c1 \u003e 1\r\n    /// this case it makes no sense to just extract c1 \u003e 1\r\n    fn check_or(\r\n        col_id: \u0026ColumnId,\r\n        right_expr: \u0026ScalarExpression,\r\n        op: \u0026BinaryOperator,\r\n        binary: ConstantBinary,\r\n    ) -\u003e Option\u003cConstantBinary\u003e {\r\n        if matches!(op, BinaryOperator::Or) \u0026\u0026 right_expr.exist_column(col_id) {\r\n            return None;\r\n        }\r\n\r\n        Some(binary)\r\n    }\r\n\r\n    fn new_binary(\r\n        col_id: \u0026ColumnId,\r\n        mut op: BinaryOperator,\r\n        col: ColumnRef,\r\n        val: ValueRef,\r\n        is_flip: bool,\r\n    ) -\u003e Option\u003cConstantBinary\u003e {\r\n        if col.id() != Some(*col_id) {\r\n            return None;\r\n        }\r\n\r\n        if is_flip {\r\n            op = match op {\r\n                BinaryOperator::Gt =\u003e BinaryOperator::Lt,\r\n                BinaryOperator::Lt =\u003e BinaryOperator::Gt,\r\n                BinaryOperator::GtEq =\u003e BinaryOperator::LtEq,\r\n                BinaryOperator::LtEq =\u003e BinaryOperator::GtEq,\r\n                source_op =\u003e source_op,\r\n            };\r\n        }\r\n\r\n        match op {\r\n            BinaryOperator::Gt =\u003e Some(ConstantBinary::Scope {\r\n                min: Bound::Excluded(val.clone()),\r\n                max: Bound::Unbounded,\r\n            }),\r\n            BinaryOperator::Lt =\u003e Some(ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(val.clone()),\r\n            }),\r\n            BinaryOperator::GtEq =\u003e Some(ConstantBinary::Scope {\r\n                min: Bound::Included(val.clone()),\r\n                max: Bound::Unbounded,\r\n            }),\r\n            BinaryOperator::LtEq =\u003e Some(ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Included(val.clone()),\r\n            }),\r\n            BinaryOperator::Eq | BinaryOperator::Spaceship =\u003e Some(ConstantBinary::Eq(val.clone())),\r\n            BinaryOperator::NotEq =\u003e Some(ConstantBinary::NotEq(val.clone())),\r\n            _ =\u003e None,\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for ConstantBinary {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        match self {\r\n            ConstantBinary::Scope { min, max } =\u003e {\r\n                match min {\r\n                    Bound::Unbounded =\u003e write!(f, \"-\")?,\r\n                    Bound::Included(value) =\u003e write!(f, \"[{}\", value)?,\r\n                    Bound::Excluded(value) =\u003e write!(f, \"({}\", value)?,\r\n                }\r\n\r\n                write!(f, \", \")?;\r\n\r\n                match max {\r\n                    Bound::Unbounded =\u003e write!(f, \"+\")?,\r\n                    Bound::Included(value) =\u003e write!(f, \"{}]\", value)?,\r\n                    Bound::Excluded(value) =\u003e write!(f, \"{})\", value)?,\r\n                }\r\n\r\n                Ok(())\r\n            }\r\n            ConstantBinary::Eq(value) =\u003e write!(f, \"{}\", value),\r\n            ConstantBinary::NotEq(value) =\u003e write!(f, \"!{}\", value),\r\n            ConstantBinary::And(binaries) =\u003e Self::join_write(f, binaries, \" AND \"),\r\n            ConstantBinary::Or(binaries) =\u003e Self::join_write(f, binaries, \" OR \"),\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n    use crate::catalog::{ColumnCatalog, ColumnDesc, ColumnSummary};\r\n    use crate::expression::simplify::ConstantBinary;\r\n    use crate::expression::{BinaryOperator, ScalarExpression};\r\n    use crate::types::value::DataValue;\r\n    use crate::types::LogicalType;\r\n    use std::collections::Bound;\r\n    use std::sync::Arc;\r\n\r\n    #[test]\r\n    fn test_convert_binary_simple() -\u003e Result\u003c()\u003e {\r\n        let col_1 = Arc::new(ColumnCatalog {\r\n            summary: ColumnSummary {\r\n                id: Some(0),\r\n                name: \"c1\".to_string(),\r\n                table_name: None,\r\n                \r\n            },\r\n            nullable: false,\r\n            desc: ColumnDesc {\r\n                column_datatype: LogicalType::Integer,\r\n                is_primary: false,\r\n                is_unique: false,\r\n                default: None,\r\n            },\r\n            // ref_expr: None,\r\n        });\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n\r\n        let binary_eq = ScalarExpression::Binary {\r\n            op: BinaryOperator::Eq,\r\n            left_expr: Box::new(ScalarExpression::Constant(val_1.clone())),\r\n            right_expr: Box::new(ScalarExpression::ColumnRef(col_1.clone())),\r\n            ty: LogicalType::Boolean,\r\n        }\r\n        .convert_binary(\u00260)?\r\n        .unwrap();\r\n\r\n        assert_eq!(binary_eq, ConstantBinary::Eq(val_1.clone()));\r\n\r\n        let binary_not_eq = ScalarExpression::Binary {\r\n            op: BinaryOperator::NotEq,\r\n            left_expr: Box::new(ScalarExpression::Constant(val_1.clone())),\r\n            right_expr: Box::new(ScalarExpression::ColumnRef(col_1.clone())),\r\n            ty: LogicalType::Boolean,\r\n        }\r\n        .convert_binary(\u00260)?\r\n        .unwrap();\r\n\r\n        assert_eq!(binary_not_eq, ConstantBinary::NotEq(val_1.clone()));\r\n\r\n        let binary_lt = ScalarExpression::Binary {\r\n            op: BinaryOperator::Lt,\r\n            left_expr: Box::new(ScalarExpression::ColumnRef(col_1.clone())),\r\n            right_expr: Box::new(ScalarExpression::Constant(val_1.clone())),\r\n            ty: LogicalType::Boolean,\r\n        }\r\n        .convert_binary(\u00260)?\r\n        .unwrap();\r\n\r\n        assert_eq!(\r\n            binary_lt,\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(val_1.clone())\r\n            }\r\n        );\r\n\r\n        let binary_lteq = ScalarExpression::Binary {\r\n            op: BinaryOperator::LtEq,\r\n            left_expr: Box::new(ScalarExpression::ColumnRef(col_1.clone())),\r\n            right_expr: Box::new(ScalarExpression::Constant(val_1.clone())),\r\n            ty: LogicalType::Boolean,\r\n        }\r\n        .convert_binary(\u00260)?\r\n        .unwrap();\r\n\r\n        assert_eq!(\r\n            binary_lteq,\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Included(val_1.clone())\r\n            }\r\n        );\r\n\r\n        let binary_gt = ScalarExpression::Binary {\r\n            op: BinaryOperator::Gt,\r\n            left_expr: Box::new(ScalarExpression::ColumnRef(col_1.clone())),\r\n            right_expr: Box::new(ScalarExpression::Constant(val_1.clone())),\r\n            ty: LogicalType::Boolean,\r\n        }\r\n        .convert_binary(\u00260)?\r\n        .unwrap();\r\n\r\n        assert_eq!(\r\n            binary_gt,\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Unbounded\r\n            }\r\n        );\r\n\r\n        let binary_gteq = ScalarExpression::Binary {\r\n            op: BinaryOperator::GtEq,\r\n            left_expr: Box::new(ScalarExpression::ColumnRef(col_1.clone())),\r\n            right_expr: Box::new(ScalarExpression::Constant(val_1.clone())),\r\n            ty: LogicalType::Boolean,\r\n        }\r\n        .convert_binary(\u00260)?\r\n        .unwrap();\r\n\r\n        assert_eq!(\r\n            binary_gteq,\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_1.clone()),\r\n                max: Bound::Unbounded\r\n            }\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_eq_noteq() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(0)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n        let val_2 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_3 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::And(vec![\r\n            ConstantBinary::Eq(val_0.clone()),\r\n            ConstantBinary::NotEq(val_1.clone()),\r\n            ConstantBinary::Eq(val_2.clone()),\r\n            ConstantBinary::NotEq(val_3.clone()),\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(binary, ConstantBinary::And(vec![ConstantBinary::Eq(val_0)]));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_eq_noteq_cover() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(0)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n        let val_2 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_3 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::And(vec![\r\n            ConstantBinary::Eq(val_0.clone()),\r\n            ConstantBinary::NotEq(val_1.clone()),\r\n            ConstantBinary::Eq(val_2.clone()),\r\n            ConstantBinary::NotEq(val_3.clone()),\r\n            ConstantBinary::NotEq(val_0.clone()),\r\n            ConstantBinary::NotEq(val_1.clone()),\r\n            ConstantBinary::NotEq(val_2.clone()),\r\n            ConstantBinary::NotEq(val_3.clone()),\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(binary, ConstantBinary::And(vec![]));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_scope() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(0)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n        let val_2 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_3 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::And(vec![\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_0.clone()),\r\n                max: Bound::Included(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_1.clone()),\r\n                max: Bound::Excluded(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Included(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Excluded(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Unbounded,\r\n            },\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(\r\n            binary,\r\n            ConstantBinary::And(vec![ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Excluded(val_2.clone()),\r\n            }])\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_mixed() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(0)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n        let val_2 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_3 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::And(vec![\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_0.clone()),\r\n                max: Bound::Included(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_1.clone()),\r\n                max: Bound::Excluded(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Included(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Excluded(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Unbounded,\r\n            },\r\n            ConstantBinary::Eq(val_1.clone()),\r\n            ConstantBinary::Eq(val_0.clone()),\r\n            ConstantBinary::NotEq(val_1.clone()),\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(\r\n            binary,\r\n            ConstantBinary::And(vec![ConstantBinary::Eq(val_0.clone())])\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_or() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(0)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n        let val_2 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_3 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::Or(vec![\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_0.clone()),\r\n                max: Bound::Included(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_1.clone()),\r\n                max: Bound::Excluded(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Included(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Excluded(val_3.clone()),\r\n            },\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(\r\n            binary,\r\n            ConstantBinary::Or(vec![ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Included(val_3.clone()),\r\n            }])\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_or_unbounded() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(0)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n        let val_2 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_3 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::Or(vec![\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Included(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Unbounded,\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Unbounded,\r\n            },\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(binary, ConstantBinary::Or(vec![]));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_or_lower_unbounded() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::Or(vec![\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(val_0.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Included(val_0.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(val_1.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Included(val_1.clone()),\r\n            },\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(\r\n            binary,\r\n            ConstantBinary::Or(vec![ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Included(val_1.clone()),\r\n            }])\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_or_upper_unbounded() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::Or(vec![\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_0.clone()),\r\n                max: Bound::Unbounded,\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Unbounded,\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Unbounded,\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_1.clone()),\r\n                max: Bound::Unbounded,\r\n            },\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(\r\n            binary,\r\n            ConstantBinary::Or(vec![ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Unbounded,\r\n            }])\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_rearrange() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(0)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n        let val_2 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_3 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let val_5 = Arc::new(DataValue::Int32(Some(5)));\r\n\r\n        let val_6 = Arc::new(DataValue::Int32(Some(6)));\r\n        let val_7 = Arc::new(DataValue::Int32(Some(7)));\r\n        let val_8 = Arc::new(DataValue::Int32(Some(8)));\r\n\r\n        let val_10 = Arc::new(DataValue::Int32(Some(10)));\r\n\r\n        let binary = ConstantBinary::Or(vec![\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_6.clone()),\r\n                max: Bound::Included(val_10.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_0.clone()),\r\n                max: Bound::Included(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_1.clone()),\r\n                max: Bound::Excluded(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Included(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Excluded(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_6.clone()),\r\n                max: Bound::Included(val_7.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Unbounded,\r\n            },\r\n            ConstantBinary::NotEq(val_8.clone()),\r\n            ConstantBinary::Eq(val_5.clone()),\r\n            ConstantBinary::Eq(val_0.clone()),\r\n            ConstantBinary::Eq(val_1.clone()),\r\n        ]);\r\n\r\n        assert_eq!(\r\n            binary.rearrange()?,\r\n            vec![\r\n                ConstantBinary::Scope {\r\n                    min: Bound::Included(val_0.clone()),\r\n                    max: Bound::Included(val_3.clone()),\r\n                },\r\n                ConstantBinary::Eq(val_5.clone()),\r\n                ConstantBinary::Scope {\r\n                    min: Bound::Included(val_6.clone()),\r\n                    max: Bound::Included(val_10.clone()),\r\n                }\r\n            ]\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2954361355555045376},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":11457157452030541824},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":5836665117072162816},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":11745387828182253568},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":11745387828182253568},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":7277816997830721536},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":3098476543630901248},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":13186539708940812288},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":13186539708940812288},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":11601272640106397696},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":11601272640106397696},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":2161727821137838066},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":15852670688344145921},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":10664523917613334519},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":11601272640106397708},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":2377900603251621888},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":1008806316530991105},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":7493989779944505344},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":7493989779944505344},"fn_name":null},{"line":673,"address":[],"length":0,"stats":{"Line":11529215046068469762},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":11529215046068469763},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":11529215046068469761},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":4755801206503243776},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":11961560610296037378},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":1152921504606846977},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":1152921504606846977},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":1152921504606846978},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":6773413839565225984},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":710,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":749,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":751,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":755,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":756,"address":[],"length":0,"stats":{"Line":2377900603251621888},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":764,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":766,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":800,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":808,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":831,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":832,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":837,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":843,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":847,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":849,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":857,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":861,"address":[],"length":0,"stats":{"Line":5044031582654955520},"fn_name":null},{"line":862,"address":[],"length":0,"stats":{"Line":6413125869375586304},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":5044031582654955520},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":875,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":879,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":880,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":881,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":883,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":884,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":886,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":887,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":903,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":905,"address":[],"length":0,"stats":{"Line":12249790986447749120},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":918,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":921,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":5980780305148018688},"fn_name":null},{"line":931,"address":[],"length":0,"stats":{"Line":5980780305148018688},"fn_name":null},{"line":932,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":935,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":936,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":937,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":938,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":939,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":940,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":941,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":945,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":946,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":947,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":948,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":950,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":951,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":952,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":954,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":955,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":958,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":959,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":960,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":962,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":963,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":964,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":970,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":971,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":972,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":973,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":974,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":975,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":979,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":981,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":982,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":983,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":987,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":989,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":992,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":392,"coverable":517},{"path":["E:","\\","sql-layer","src","expression","value_compute.rs"],"content":"use crate::errors::*;\r\nuse crate::expression::{BinaryOperator, UnaryOperator};\r\nuse crate::types::value::DataValue;\r\nuse crate::types::LogicalType;\r\nuse regex::Regex;\r\n\r\nfn unpack_i32(value: DataValue) -\u003e Option\u003ci32\u003e {\r\n    match value {\r\n        DataValue::Int32(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_i64(value: DataValue) -\u003e Option\u003ci64\u003e {\r\n    match value {\r\n        DataValue::Int64(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_u32(value: DataValue) -\u003e Option\u003cu32\u003e {\r\n    match value {\r\n        DataValue::UInt32(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_u64(value: DataValue) -\u003e Option\u003cu64\u003e {\r\n    match value {\r\n        DataValue::UInt64(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_f64(value: DataValue) -\u003e Option\u003cf64\u003e {\r\n    match value {\r\n        DataValue::Float64(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_f32(value: DataValue) -\u003e Option\u003cf32\u003e {\r\n    match value {\r\n        DataValue::Float32(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_bool(value: DataValue) -\u003e Option\u003cbool\u003e {\r\n    match value {\r\n        DataValue::Boolean(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_date(value: DataValue) -\u003e Option\u003ci64\u003e {\r\n    match value {\r\n        DataValue::Date64(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_utf8(value: DataValue) -\u003e Option\u003cString\u003e {\r\n    match value {\r\n        DataValue::Utf8(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\nimpl DataValue {\r\n    pub fn unary_op(value: \u0026DataValue, op: \u0026UnaryOperator) -\u003e Result\u003cDataValue\u003e {\r\n        let mut value_type = value.logical_type();\r\n        let mut value = value.clone();\r\n\r\n        if value_type.is_numeric() \u0026\u0026 matches!(op, UnaryOperator::Plus | UnaryOperator::Minus) {\r\n            if value_type.is_unsigned_numeric() {\r\n                match value_type {\r\n                    LogicalType::UTinyint =\u003e value_type = LogicalType::Tinyint,\r\n                    LogicalType::USmallint =\u003e value_type = LogicalType::Smallint,\r\n                    LogicalType::UInteger =\u003e value_type = LogicalType::Integer,\r\n                    LogicalType::UBigint =\u003e value_type = LogicalType::Bigint,\r\n                    _ =\u003e unreachable!(),\r\n                };\r\n                value = value.cast(\u0026value_type)?;\r\n            }\r\n\r\n            let result = match op {\r\n                UnaryOperator::Plus =\u003e value,\r\n                UnaryOperator::Minus =\u003e match value {\r\n                    DataValue::Float32(option) =\u003e DataValue::Float32(option.map(|v| -v)),\r\n                    DataValue::Float64(option) =\u003e DataValue::Float64(option.map(|v| -v)),\r\n                    DataValue::Int8(option) =\u003e DataValue::Int8(option.map(|v| -v)),\r\n                    DataValue::Int16(option) =\u003e DataValue::Int16(option.map(|v| -v)),\r\n                    DataValue::Int32(option) =\u003e DataValue::Int32(option.map(|v| -v)),\r\n                    DataValue::Int64(option) =\u003e DataValue::Int64(option.map(|v| -v)),\r\n                    _ =\u003e unreachable!(),\r\n                },\r\n                _ =\u003e unreachable!(),\r\n            };\r\n\r\n            Ok(result)\r\n        } else if matches!((value_type, op), (LogicalType::Boolean, UnaryOperator::Not)) {\r\n            match value {\r\n                DataValue::Boolean(option) =\u003e Ok(DataValue::Boolean(option.map(|v| !v))),\r\n                _ =\u003e unreachable!(),\r\n            }\r\n        } else {\r\n            Err(DatabaseError::InvalidType)\r\n        }\r\n    }\r\n\r\n    /// Tips:\r\n    /// - Null values operate as null values\r\n    pub fn binary_op(\r\n        left: \u0026DataValue,\r\n        right: \u0026DataValue,\r\n        op: \u0026BinaryOperator,\r\n    ) -\u003e Result\u003cDataValue\u003e {\r\n        if matches!(op, BinaryOperator::Like | BinaryOperator::NotLike) {\r\n            let value_option = unpack_utf8(left.clone().cast(\u0026LogicalType::Varchar(None))?);\r\n            let pattern_option = unpack_utf8(right.clone().cast(\u0026LogicalType::Varchar(None))?);\r\n\r\n            let mut is_match = if let (Some(value), Some(pattern)) = (value_option, pattern_option)\r\n            {\r\n                let regex_pattern = pattern.replace('%', \".*\").replace('_', \".\");\r\n\r\n                Regex::new(\u0026regex_pattern).unwrap().is_match(\u0026value)\r\n            } else {\r\n                unreachable!(\"The left and right values calculated by Like cannot be Null values.\")\r\n            };\r\n            if op == \u0026BinaryOperator::NotLike {\r\n                is_match = !is_match;\r\n            }\r\n            return Ok(DataValue::Boolean(Some(is_match)));\r\n        }\r\n        let unified_type =\r\n            LogicalType::max_logical_type(\u0026left.logical_type(), \u0026right.logical_type())?;\r\n\r\n        let value = match \u0026unified_type {\r\n            LogicalType::Integer =\u003e {\r\n                let left_value = unpack_i32(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_i32(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Plus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 + v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Int32(value)\r\n                    }\r\n                    BinaryOperator::Minus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 - v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Int32(value)\r\n                    }\r\n                    BinaryOperator::Multiply =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 * v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Int32(value)\r\n                    }\r\n                    BinaryOperator::Divide =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 as f64 / v2 as f64)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::Bigint =\u003e {\r\n                let left_value = unpack_i64(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_i64(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Plus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 + v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Int64(value)\r\n                    }\r\n                    BinaryOperator::Minus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 - v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Int64(value)\r\n                    }\r\n                    BinaryOperator::Multiply =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 * v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Int64(value)\r\n                    }\r\n                    BinaryOperator::Divide =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 as f64 / v2 as f64)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::UInteger =\u003e {\r\n                let left_value = unpack_u32(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_u32(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Plus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 + v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::UInt32(value)\r\n                    }\r\n                    BinaryOperator::Minus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 - v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::UInt32(value)\r\n                    }\r\n                    BinaryOperator::Multiply =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 * v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::UInt32(value)\r\n                    }\r\n                    BinaryOperator::Divide =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 as f64 / v2 as f64)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::UBigint =\u003e {\r\n                let left_value = unpack_u64(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_u64(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Plus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 + v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::UInt64(value)\r\n                    }\r\n                    BinaryOperator::Minus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 - v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::UInt64(value)\r\n                    }\r\n                    BinaryOperator::Multiply =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 * v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::UInt64(value)\r\n                    }\r\n                    BinaryOperator::Divide =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 as f64 / v2 as f64)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::Double =\u003e {\r\n                let left_value = unpack_f64(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_f64(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Plus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 + v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n                    BinaryOperator::Minus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 - v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n                    BinaryOperator::Multiply =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 * v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n                    BinaryOperator::Divide =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 / v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::Boolean =\u003e {\r\n                let left_value = unpack_bool(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_bool(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::And =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u0026\u0026 v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Or =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 || v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::Float =\u003e {\r\n                let left_value = unpack_f32(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_f32(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Plus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 + v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float32(value)\r\n                    }\r\n                    BinaryOperator::Minus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 - v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float32(value)\r\n                    }\r\n                    BinaryOperator::Multiply =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 * v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float32(value)\r\n                    }\r\n                    BinaryOperator::Divide =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 as f64 / v2 as f64)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::SqlNull =\u003e DataValue::Boolean(None),\r\n            LogicalType::DateTime =\u003e {\r\n                let left_value = unpack_date(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_date(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::Decimal(_, _) =\u003e {\r\n                let left_value = left.clone().cast(\u0026unified_type)?;\r\n                let right_value = right.clone().cast(\u0026unified_type)?;\r\n\r\n                match op {\r\n                    BinaryOperator::Plus =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 + v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Decimal(value)\r\n                    }\r\n                    BinaryOperator::Minus =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 - v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Decimal(value)\r\n                    }\r\n                    BinaryOperator::Multiply =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 * v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Decimal(value)\r\n                    }\r\n                    BinaryOperator::Divide =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 / v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Decimal(value)\r\n                    }\r\n\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 \u003e v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 \u003c v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 \u003e= v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 \u003c= v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\u003e {\r\n                                Some(v1 == v2)\r\n                            }\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\u003e {\r\n                                Some(v1 != v2)\r\n                            }\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e return Err(DatabaseError::UnsupportedBinaryOperator(unified_type, *op)),\r\n                }\r\n            }\r\n            LogicalType::Varchar(None) =\u003e {\r\n                let left_value = unpack_utf8(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_utf8(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            // Utf8\r\n            _ =\u003e todo!(\"unsupported data type\"),\r\n        };\r\n\r\n        Ok(value)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n    use crate::expression::BinaryOperator;\r\n    use crate::types::value::DataValue;\r\n\r\n    #[test]\r\n    fn test_binary_op_arithmetic_plus() -\u003e Result\u003c()\u003e {\r\n        let plus_i32_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_i32_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_i32_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_i32_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n\r\n        assert_eq!(plus_i32_1, plus_i32_2);\r\n        assert_eq!(plus_i32_2, plus_i32_3);\r\n        assert_eq!(plus_i32_4, DataValue::Int32(Some(2)));\r\n\r\n        let plus_i64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_i64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_i64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_i64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n\r\n        assert_eq!(plus_i64_1, plus_i64_2);\r\n        assert_eq!(plus_i64_2, plus_i64_3);\r\n        assert_eq!(plus_i64_4, DataValue::Int64(Some(2)));\r\n\r\n        let plus_f64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_f64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_f64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_f64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n\r\n        assert_eq!(plus_f64_1, plus_f64_2);\r\n        assert_eq!(plus_f64_2, plus_f64_3);\r\n        assert_eq!(plus_f64_4, DataValue::Float64(Some(2.0)));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_arithmetic_minus() -\u003e Result\u003c()\u003e {\r\n        let minus_i32_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_i32_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_i32_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_i32_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n\r\n        assert_eq!(minus_i32_1, minus_i32_2);\r\n        assert_eq!(minus_i32_2, minus_i32_3);\r\n        assert_eq!(minus_i32_4, DataValue::Int32(Some(0)));\r\n\r\n        let minus_i64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_i64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_i64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_i64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n\r\n        assert_eq!(minus_i64_1, minus_i64_2);\r\n        assert_eq!(minus_i64_2, minus_i64_3);\r\n        assert_eq!(minus_i64_4, DataValue::Int64(Some(0)));\r\n\r\n        let minus_f64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_f64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_f64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_f64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n\r\n        assert_eq!(minus_f64_1, minus_f64_2);\r\n        assert_eq!(minus_f64_2, minus_f64_3);\r\n        assert_eq!(minus_f64_4, DataValue::Float64(Some(0.0)));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_arithmetic_multiply() -\u003e Result\u003c()\u003e {\r\n        let multiply_i32_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_i32_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_i32_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_i32_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n\r\n        assert_eq!(multiply_i32_1, multiply_i32_2);\r\n        assert_eq!(multiply_i32_2, multiply_i32_3);\r\n        assert_eq!(multiply_i32_4, DataValue::Int32(Some(1)));\r\n\r\n        let multiply_i64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_i64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_i64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_i64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n\r\n        assert_eq!(multiply_i64_1, multiply_i64_2);\r\n        assert_eq!(multiply_i64_2, multiply_i64_3);\r\n        assert_eq!(multiply_i64_4, DataValue::Int64(Some(1)));\r\n\r\n        let multiply_f64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_f64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_f64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_f64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n\r\n        assert_eq!(multiply_f64_1, multiply_f64_2);\r\n        assert_eq!(multiply_f64_2, multiply_f64_3);\r\n        assert_eq!(multiply_f64_4, DataValue::Float64(Some(1.0)));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_arithmetic_divide() -\u003e Result\u003c()\u003e {\r\n        let divide_i32_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_i32_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_i32_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_i32_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n\r\n        assert_eq!(divide_i32_1, divide_i32_2);\r\n        assert_eq!(divide_i32_2, divide_i32_3);\r\n        assert_eq!(divide_i32_4, DataValue::Float64(Some(1.0)));\r\n\r\n        let divide_i64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_i64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_i64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_i64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n\r\n        assert_eq!(divide_i64_1, divide_i64_2);\r\n        assert_eq!(divide_i64_2, divide_i64_3);\r\n        assert_eq!(divide_i64_4, DataValue::Float64(Some(1.0)));\r\n\r\n        let divide_f64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_f64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_f64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_f64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n\r\n        assert_eq!(divide_f64_1, divide_f64_2);\r\n        assert_eq!(divide_f64_2, divide_f64_3);\r\n        assert_eq!(divide_f64_4, DataValue::Float64(Some(1.0)));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_cast() -\u003e Result\u003c()\u003e {\r\n        let i32_cast_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int8(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let i32_cast_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int16(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n\r\n        assert_eq!(i32_cast_1, i32_cast_2);\r\n\r\n        let i64_cast_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int8(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let i64_cast_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int16(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let i64_cast_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n\r\n        assert_eq!(i64_cast_1, i64_cast_2);\r\n        assert_eq!(i64_cast_2, i64_cast_3);\r\n\r\n        let f64_cast_1 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float32(Some(1.0)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        assert_eq!(f64_cast_1, DataValue::Float64(Some(2.0)));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_i32_compare() -\u003e Result\u003c()\u003e {\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026DataValue::Int32(Some(0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026DataValue::Int32(Some(0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(None),\r\n                \u0026DataValue::Int32(Some(0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(None),\r\n                \u0026DataValue::Int32(Some(0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(None),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(None),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(None),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(None),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(None),\r\n                \u0026DataValue::Int32(None),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_i64_compare() -\u003e Result\u003c()\u003e {\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026DataValue::Int64(Some(0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026DataValue::Int64(Some(0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(None),\r\n                \u0026DataValue::Int64(Some(0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(None),\r\n                \u0026DataValue::Int64(Some(0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(None),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(None),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(None),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(None),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(None),\r\n                \u0026DataValue::Int64(None),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_f64_compare() -\u003e Result\u003c()\u003e {\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026DataValue::Float64(Some(0.0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026DataValue::Float64(Some(0.0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(None),\r\n                \u0026DataValue::Float64(Some(0.0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(None),\r\n                \u0026DataValue::Float64(Some(0.0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(None),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(None),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(None),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(None),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(None),\r\n                \u0026DataValue::Float64(None),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_f32_compare() -\u003e Result\u003c()\u003e {\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026DataValue::Float32(Some(0.0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026DataValue::Float32(Some(0.0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(None),\r\n                \u0026DataValue::Float32(Some(0.0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(None),\r\n                \u0026DataValue::Float32(Some(0.0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(None),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(None),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(None),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(None),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(None),\r\n                \u0026DataValue::Float32(None),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_bool_compare() -\u003e Result\u003c()\u003e {\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026BinaryOperator::And\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(Some(false)),\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026BinaryOperator::And\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(Some(false)),\r\n                \u0026DataValue::Boolean(Some(false)),\r\n                \u0026BinaryOperator::And\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(None),\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026BinaryOperator::And\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026BinaryOperator::Or\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(Some(false)),\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026BinaryOperator::Or\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(Some(false)),\r\n                \u0026DataValue::Boolean(Some(false)),\r\n                \u0026BinaryOperator::Or\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(None),\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026BinaryOperator::Or\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_utf8_compare() -\u003e Result\u003c()\u003e {\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026DataValue::Utf8(Some(\"b\".to_string())),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026DataValue::Utf8(Some(\"b\".to_string())),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(None),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(None),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(None),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(None),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(None),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":4323455642275676160},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":4323455642275676160},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":4323455642275676160},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":4539628424389459968},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":15276209936040722432},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":11240984669916758016},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":15204152342002794496},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":4539628424389459968},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":4323455642275676160},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":662,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":747,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":766,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":768,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":775,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":831,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":840,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":843,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":857,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":863,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":877,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":880,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":888,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":890,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":892,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":900,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":906,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":914,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":918,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":926,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":935,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":936,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":938,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":943,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":947,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":948,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":952,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":953,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":955,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":961,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":962,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":964,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":970,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":971,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":973,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":979,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":980,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":982,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":988,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":989,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":998,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":1000,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":205,"coverable":370},{"path":["E:","\\","sql-layer","src","lib.rs"],"content":"pub mod binder;\r\npub mod catalog;\r\npub mod db;\r\npub mod errors;\r\npub mod execution;\r\npub mod expression;\r\npub mod optimizer;\r\npub mod parser;\r\npub mod planner;\r\npub mod server;\r\npub mod storage;\r\npub mod types;\r\n\r\n\r\nuse lazy_static::lazy_static;\r\nlazy_static! {\r\n    pub static ref CONFIG_MAP: std::collections::HashMap\u003cString, String\u003e = config::Config::builder()\r\n        .add_source(config::File::with_name(\"config/Settings.toml\"))\r\n        .build()\r\n        .unwrap()\r\n        .try_deserialize()\r\n        .unwrap();\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","main.rs"],"content":"use std::path::PathBuf;\r\n\r\nuse piggysql::{\r\n    server::Server,\r\n    storage::{engine::piggykv::lsm_storage::LsmStorageOptions, piggy_stroage::PiggyKVStroage},\r\n    CONFIG_MAP,\r\n};\r\nuse tracing::Level;\r\n\r\nuse tracing_subscriber::FmtSubscriber;\r\n\r\n#[tokio::main(worker_threads = 8)]\r\nasync fn main() {\r\n    let log_level = CONFIG_MAP.get(\"log_level\").unwrap();\r\n    let log_level = match log_level.to_lowercase().as_str() {\r\n        \"info\" =\u003e Level::INFO,\r\n        \"debug\" =\u003e Level::DEBUG,\r\n        \"warn\" =\u003e Level::WARN,\r\n        \"error\" =\u003e Level::ERROR,\r\n        \"trace\" =\u003e Level::TRACE,\r\n        _ =\u003e Level::INFO,\r\n    };\r\n    let file_appender = tracing_appender::rolling::hourly(\"./\", \"db.log\");\r\n    let (non_blocking, _guard) = tracing_appender::non_blocking(file_appender);\r\n\r\n    let subscriber = FmtSubscriber::builder()\r\n        // all spans/events with a level higher than TRACE (e.g, debug, info, warn, etc.)\r\n        // will be written to stdout.\r\n        .with_max_level(log_level)\r\n        .with_writer(non_blocking)\r\n        // completes the builder.\r\n        .finish();\r\n\r\n    tracing::subscriber::set_global_default(subscriber).expect(\"setting default subscriber failed\");\r\n    let filename = CONFIG_MAP.get(\"filename\").unwrap();\r\n    let bloom_false_positive_rate = CONFIG_MAP\r\n        .get(\"bloom_false_positive_rate\")\r\n        .cloned()\r\n        .unwrap_or(\"0.01\".to_string())\r\n        .parse::\u003cf64\u003e()\r\n        .unwrap_or(0.01);\r\n    let compaction = CONFIG_MAP.get(\"compaction\").unwrap().clone();\r\n    let option = match compaction.to_lowercase().as_str() {\r\n        \"leveled\" =\u003e LsmStorageOptions::leveled_compaction()\r\n            .with_bloom_false_positive_rate(bloom_false_positive_rate),\r\n        \"simple\" =\u003e {\r\n            LsmStorageOptions::default().with_bloom_false_positive_rate(bloom_false_positive_rate)\r\n        }\r\n        _ =\u003e LsmStorageOptions::no_compaction()\r\n            .with_bloom_false_positive_rate(bloom_false_positive_rate),\r\n    };\r\n    let store = PiggyKVStroage::new(PathBuf::from(filename), Some(option));\r\n    let server = Server::new(store).await.unwrap();\r\n    Server::run(server).await;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","optimizer","core","mod.rs"],"content":"pub(crate) mod pattern;\r\npub(crate) mod rule;\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","optimizer","core","pattern.rs"],"content":"use crate::planner::operator::Operator;\r\n\r\npub enum PatternChildrenPredicate {\r\n    /// all childrens nodes match all\r\n    Recursive,\r\n    /// match many pattern at the time\r\n    Predicate(Vec\u003cPattern\u003e),\r\n    /// childrens jump out match\r\n    None,\r\n}\r\n\r\n/// The pattern tree to match a plan tree. It defined in `Rule` and used in `PatternMatcher`.\r\npub struct Pattern {\r\n    /// The root node predicate, not contains the children.\r\n    pub predicate: fn(\u0026Operator) -\u003e bool,\r\n    /// The children's predicate of current node.\r\n    pub children: PatternChildrenPredicate,\r\n}\r\n\r\npub trait PatternMatcher {\r\n    fn match_opt_expr(\u0026self) -\u003e bool;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","optimizer","core","rule.rs"],"content":"use crate::errors::*;\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\n\r\nuse super::pattern::Pattern;\r\n\r\n/// A rule is to transform logically equivalent expression\r\npub trait Rule {\r\n    /// The pattern to determine whether the rule can be applied.\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern;\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","optimizer","heuristic","batch.rs"],"content":"use crate::optimizer::rule::RuleImpl;\r\n\r\n/// A batch of rules.\r\n#[derive(Clone)]\r\npub struct HepBatch {\r\n    pub name: String,\r\n    pub strategy: HepBatchStrategy,\r\n    pub rules: Vec\u003cRuleImpl\u003e,\r\n}\r\n\r\nimpl HepBatch {\r\n    pub fn new(name: String, strategy: HepBatchStrategy, rules: Vec\u003cRuleImpl\u003e) -\u003e Self {\r\n        Self {\r\n            name,\r\n            strategy,\r\n            rules,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Clone)]\r\npub struct HepBatchStrategy {\r\n    /// An execution_ap strategy for rules that indicates the maximum number of executions. If the\r\n    /// execution_ap reaches fix point (i.e. converge) before maxIterations, it will stop.\r\n    ///\r\n    /// Fix Point means that plan tree not changed after applying all rules.\r\n    pub max_iteration: usize,\r\n    /// An order to traverse the plan tree nodes.\r\n    pub match_order: HepMatchOrder,\r\n}\r\n\r\nimpl HepBatchStrategy {\r\n    pub fn once_topdown() -\u003e Self {\r\n        HepBatchStrategy {\r\n            max_iteration: 1,\r\n            match_order: HepMatchOrder::TopDown,\r\n        }\r\n    }\r\n\r\n    pub fn fix_point_topdown(max_iteration: usize) -\u003e Self {\r\n        HepBatchStrategy {\r\n            max_iteration,\r\n            match_order: HepMatchOrder::TopDown,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Clone, Copy)]\r\npub enum HepMatchOrder {\r\n    /// Match from root down. A match attempt at an ancestor always precedes all match attempts at\r\n    /// its descendants.\r\n    TopDown,\r\n    /// Match from leaves up. A match attempt at a descendant precedes all match attempts at its\r\n    /// ancestors.\r\n    #[allow(dead_code)]\r\n    BottomUp,\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":5620492334958379009},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":12970366926827028480},"fn_name":null}],"covered":3,"coverable":3},{"path":["E:","\\","sql-layer","src","optimizer","heuristic","graph.rs"],"content":"use crate::optimizer::heuristic::batch::HepMatchOrder;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse itertools::Itertools;\r\nuse petgraph::stable_graph::{NodeIndex, StableDiGraph};\r\nuse petgraph::visit::{Bfs, EdgeRef};\r\nuse std::mem;\r\npub type OptExprNodeId = usize;\r\n\r\n/// HepNodeId is used in optimizer to identify a node.\r\npub type HepNodeId = NodeIndex\u003cOptExprNodeId\u003e;\r\n\r\n#[derive(Debug)]\r\npub struct HepGraph {\r\n    graph: StableDiGraph\u003cOperator, usize, usize\u003e,\r\n    root_index: HepNodeId,\r\n    pub version: usize,\r\n}\r\n\r\nimpl HepGraph {\r\n    pub fn new(root: LogicalPlan) -\u003e Self {\r\n        fn graph_filling(\r\n            graph: \u0026mut StableDiGraph\u003cOperator, usize, usize\u003e,\r\n            LogicalPlan {\r\n                operator,\r\n                childrens,\r\n                ..\r\n            }: LogicalPlan,\r\n        ) -\u003e HepNodeId {\r\n            let index = graph.add_node(operator);\r\n\r\n            for (order, child) in childrens.into_iter().enumerate() {\r\n                let child_index = graph_filling(graph, child);\r\n                let _ = graph.add_edge(index, child_index, order);\r\n            }\r\n\r\n            index\r\n        }\r\n\r\n        let mut graph = StableDiGraph::\u003cOperator, usize, usize\u003e::default();\r\n\r\n        let root_index = graph_filling(\u0026mut graph, root);\r\n\r\n        HepGraph {\r\n            graph,\r\n            root_index,\r\n            version: 0,\r\n        }\r\n    }\r\n\r\n    pub fn parent_id(\u0026self, node_id: HepNodeId) -\u003e Option\u003cHepNodeId\u003e {\r\n        self.graph\r\n            .neighbors_directed(node_id, petgraph::Direction::Incoming)\r\n            .next()\r\n    }\r\n\r\n    pub fn eldest_child_at(\u0026self, id: HepNodeId) -\u003e Option\u003cHepNodeId\u003e {\r\n        self.graph\r\n            .edges(id)\r\n            .min_by_key(|edge| edge.weight())\r\n            .map(|edge| edge.target())\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    pub fn add_root(\u0026mut self, new_node: Operator) {\r\n        let old_root_id = mem::replace(\u0026mut self.root_index, self.graph.add_node(new_node));\r\n\r\n        self.graph.add_edge(self.root_index, old_root_id, 0);\r\n        self.version += 1;\r\n    }\r\n\r\n    pub fn add_node(\r\n        \u0026mut self,\r\n        source_id: HepNodeId,\r\n        children_option: Option\u003cHepNodeId\u003e,\r\n        new_node: Operator,\r\n    ) {\r\n        let new_index = self.graph.add_node(new_node);\r\n        let mut order = self.graph.edges(source_id).count();\r\n\r\n        if let Some((children_id, old_edge_id)) = children_option.and_then(|children_id| {\r\n            self.graph\r\n                .find_edge(source_id, children_id)\r\n                .map(|old_edge_id| (children_id, old_edge_id))\r\n        }) {\r\n            order = self.graph.remove_edge(old_edge_id).unwrap_or(0);\r\n\r\n            self.graph.add_edge(new_index, children_id, 0);\r\n        }\r\n\r\n        self.graph.add_edge(source_id, new_index, order);\r\n        self.version += 1;\r\n    }\r\n\r\n    pub fn replace_node(\u0026mut self, source_id: HepNodeId, new_node: Operator) {\r\n        self.graph[source_id] = new_node;\r\n        self.version += 1;\r\n    }\r\n\r\n    pub fn swap_node(\u0026mut self, a: HepNodeId, b: HepNodeId) {\r\n        let tmp = self.graph[a].clone();\r\n\r\n        self.graph[a] = mem::replace(\u0026mut self.graph[b], tmp);\r\n        self.version += 1;\r\n    }\r\n\r\n    pub fn remove_node(\u0026mut self, source_id: HepNodeId, with_childrens: bool) -\u003e Option\u003cOperator\u003e {\r\n        if !with_childrens {\r\n            let children_ids = self\r\n                .graph\r\n                .edges(source_id)\r\n                .sorted_by_key(|edge_ref| edge_ref.weight())\r\n                .map(|edge_ref| edge_ref.target())\r\n                .collect_vec();\r\n\r\n            if let Some(parent_id) = self.parent_id(source_id) {\r\n                if let Some(edge) = self.graph.find_edge(parent_id, source_id) {\r\n                    let weight = *self.graph.edge_weight(edge).unwrap_or(\u00260);\r\n\r\n                    for (order, children_id) in children_ids.into_iter().enumerate() {\r\n                        let _ = self.graph.add_edge(parent_id, children_id, weight + order);\r\n                    }\r\n                }\r\n            } else {\r\n                assert!(children_ids.len() \u003c 2);\r\n                self.root_index = children_ids[0];\r\n            }\r\n        }\r\n\r\n        self.version += 1;\r\n        self.graph.remove_node(source_id)\r\n    }\r\n\r\n    /// Traverse the graph in BFS order.\r\n    fn bfs(\u0026self, start: HepNodeId) -\u003e Vec\u003cHepNodeId\u003e {\r\n        let mut ids = Vec::with_capacity(self.graph.node_count());\r\n        let mut iter = Bfs::new(\u0026self.graph, start);\r\n        while let Some(node_id) = iter.next(\u0026self.graph) {\r\n            ids.push(node_id);\r\n        }\r\n        ids\r\n    }\r\n\r\n    /// Use bfs to traverse the graph and return node ids\r\n    pub fn nodes_iter(\r\n        \u0026self,\r\n        order: HepMatchOrder,\r\n        start_option: Option\u003cHepNodeId\u003e,\r\n    ) -\u003e Box\u003cdyn Iterator\u003cItem = HepNodeId\u003e\u003e {\r\n        let ids = self.bfs(start_option.unwrap_or(self.root_index));\r\n        match order {\r\n            HepMatchOrder::TopDown =\u003e Box::new(ids.into_iter()),\r\n            HepMatchOrder::BottomUp =\u003e Box::new(ids.into_iter().rev()),\r\n        }\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    pub fn node(\u0026self, node_id: HepNodeId) -\u003e Option\u003c\u0026Operator\u003e {\r\n        self.graph.node_weight(node_id)\r\n    }\r\n\r\n    pub fn operator(\u0026self, node_id: HepNodeId) -\u003e \u0026Operator {\r\n        \u0026self.graph[node_id]\r\n    }\r\n\r\n    pub fn operator_mut(\u0026mut self, node_id: HepNodeId) -\u003e \u0026mut Operator {\r\n        \u0026mut self.graph[node_id]\r\n    }\r\n\r\n    pub fn to_plan(\u0026self) -\u003e LogicalPlan {\r\n        self.to_plan_with_index(self.root_index)\r\n    }\r\n\r\n    /// If input node is join, we use the edge weight to control the join chilren order.\r\n    pub fn children_at(\u0026self, id: HepNodeId) -\u003e Vec\u003cHepNodeId\u003e {\r\n        self.graph\r\n            .edges(id)\r\n            .sorted_by_key(|edge| edge.weight())\r\n            .map(|edge| edge.target())\r\n            .collect_vec()\r\n    }\r\n\r\n    pub fn to_plan_with_index(\u0026self, start_index: HepNodeId) -\u003e LogicalPlan {\r\n        let mut root_plan = LogicalPlan {\r\n            operator: self.operator(start_index).clone(),\r\n            childrens: vec![],\r\n            _output_schema_ref: None,\r\n        };\r\n\r\n        self.build_childrens(\u0026mut root_plan, start_index);\r\n\r\n        root_plan\r\n    }\r\n\r\n    fn build_childrens(\u0026self, plan: \u0026mut LogicalPlan, start: HepNodeId) {\r\n        for child_id in self.children_at(start) {\r\n            let mut child_plan = LogicalPlan {\r\n                operator: self.operator(child_id).clone(),\r\n                childrens: vec![],\r\n                _output_schema_ref: None,\r\n            };\r\n\r\n            self.build_childrens(\u0026mut child_plan, child_id);\r\n            plan.childrens.push(child_plan);\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::binder::test::select_sql_run;\r\n    use crate::errors::*;\r\n    use crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\n    use crate::planner::operator::Operator;\r\n    use petgraph::stable_graph::{EdgeIndex, NodeIndex};\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_for_plan() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let graph = HepGraph::new(plan);\r\n\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(1), NodeIndex::new(2)));\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(1), NodeIndex::new(3)));\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(0), NodeIndex::new(1)));\r\n\r\n        assert_eq!(graph.graph.edge_weight(EdgeIndex::new(0)), Some(\u00260));\r\n        assert_eq!(graph.graph.edge_weight(EdgeIndex::new(1)), Some(\u00261));\r\n        assert_eq!(graph.graph.edge_weight(EdgeIndex::new(2)), Some(\u00260));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_add_node() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let mut graph = HepGraph::new(plan);\r\n\r\n        graph.add_node(HepNodeId::new(1), None, Operator::Dummy);\r\n\r\n        graph.add_node(HepNodeId::new(1), Some(HepNodeId::new(4)), Operator::Dummy);\r\n\r\n        graph.add_node(HepNodeId::new(5), None, Operator::Dummy);\r\n\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(5), NodeIndex::new(4)));\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(1), NodeIndex::new(5)));\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(5), NodeIndex::new(6)));\r\n\r\n        assert_eq!(graph.graph.edge_weight(EdgeIndex::new(3)), Some(\u00260));\r\n        assert_eq!(graph.graph.edge_weight(EdgeIndex::new(4)), Some(\u00262));\r\n        assert_eq!(graph.graph.edge_weight(EdgeIndex::new(5)), Some(\u00261));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_replace_node() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let mut graph = HepGraph::new(plan);\r\n\r\n        graph.replace_node(HepNodeId::new(1), Operator::Dummy);\r\n\r\n        assert!(matches!(graph.operator(HepNodeId::new(1)), Operator::Dummy));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_remove_middle_node_by_single() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let mut graph = HepGraph::new(plan);\r\n\r\n        graph.remove_node(HepNodeId::new(1), false);\r\n\r\n        assert_eq!(graph.graph.edge_count(), 2);\r\n\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(0), NodeIndex::new(2)));\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(0), NodeIndex::new(3)));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_remove_middle_node_with_childrens() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let mut graph = HepGraph::new(plan);\r\n\r\n        graph.remove_node(HepNodeId::new(1), true);\r\n\r\n        assert_eq!(graph.graph.edge_count(), 0);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_swap_node() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let mut graph = HepGraph::new(plan);\r\n\r\n        let before_op_0 = graph.operator(HepNodeId::new(0)).clone();\r\n        let before_op_1 = graph.operator(HepNodeId::new(1)).clone();\r\n\r\n        graph.swap_node(HepNodeId::new(0), HepNodeId::new(1));\r\n\r\n        let op_0 = graph.operator(HepNodeId::new(0));\r\n        let op_1 = graph.operator(HepNodeId::new(1));\r\n\r\n        assert_eq!(op_0, \u0026before_op_1);\r\n        assert_eq!(op_1, \u0026before_op_0);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_add_root() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let mut graph = HepGraph::new(plan);\r\n\r\n        graph.add_root(Operator::Dummy);\r\n\r\n        assert_eq!(graph.graph.edge_count(), 4);\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(4), NodeIndex::new(0)));\r\n        assert_eq!(graph.graph.edge_weight(EdgeIndex::new(3)), Some(\u00260));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_to_plan() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let graph = HepGraph::new(plan.clone());\r\n\r\n        let plan_for_graph = graph.to_plan();\r\n\r\n        assert_eq!(plan, plan_for_graph);\r\n\r\n        let plan_by_index = graph.to_plan_with_index(HepNodeId::new(1));\r\n\r\n        assert_eq!(plan.childrens[0], plan_by_index);\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":6124895493223874561},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":5980780305148018689},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":5980780305148018689},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":11889503016258109441},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":18302628885633695745},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":18302628885633695745},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":5980780305148018689},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":6124895493223874561},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":6124895493223874561},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":9655717601082343424},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":9655717601082343424},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":9655717601082343424},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":2594073385365405717},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":16140901064495857671},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":9511602413006487570},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":9511602413006487570},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":9511602413006487570},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":9511602413006487563},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":15924728282382073856},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":15924728282382073856},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":432345564227567634},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":432345564227567634},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":5620492334958379013},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":5620492334958379013},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":17509995351216488448},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":17509995351216488448},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":17509995351216488448},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":6773413839565225984},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":14627691589699371008},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":5692549928996306951},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":5692549928996306951},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":5692549928996306951},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":5692549928996306951},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":5692549928996306951},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":16645304222761353216},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":10952754293765046272},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":10952754293765046272},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":10952754293765046272},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":10952754293765046272},"fn_name":null}],"covered":83,"coverable":87},{"path":["E:","\\","sql-layer","src","optimizer","heuristic","matcher.rs"],"content":"use crate::optimizer::core::pattern::{Pattern, PatternChildrenPredicate, PatternMatcher};\r\nuse crate::optimizer::heuristic::batch::HepMatchOrder;\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\n\r\n/// Use pattern to determines which rule can be applied\r\npub struct HepMatcher\u003c'a, 'b\u003e {\r\n    pattern: \u0026'a Pattern,\r\n    start_id: HepNodeId,\r\n    graph: \u0026'b HepGraph,\r\n}\r\n\r\nimpl\u003c'a, 'b\u003e HepMatcher\u003c'a, 'b\u003e {\r\n    pub(crate) fn new(pattern: \u0026'a Pattern, start_id: HepNodeId, graph: \u0026'b HepGraph) -\u003e Self {\r\n        Self {\r\n            pattern,\r\n            start_id,\r\n            graph,\r\n        }\r\n    }\r\n}\r\n\r\nimpl PatternMatcher for HepMatcher\u003c'_, '_\u003e {\r\n    fn match_opt_expr(\u0026self) -\u003e bool {\r\n        let op = self.graph.operator(self.start_id);\r\n        // check the root node predicate\r\n        if !(self.pattern.predicate)(op) {\r\n            return false;\r\n        }\r\n\r\n        match \u0026self.pattern.children {\r\n            PatternChildrenPredicate::Recursive =\u003e {\r\n                // check\r\n                for node_id in self\r\n                    .graph\r\n                    .nodes_iter(HepMatchOrder::TopDown, Some(self.start_id))\r\n                {\r\n                    if !(self.pattern.predicate)(self.graph.operator(node_id)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            PatternChildrenPredicate::Predicate(patterns) =\u003e {\r\n                for node_id in self.graph.children_at(self.start_id) {\r\n                    for pattern in patterns {\r\n                        if !HepMatcher::new(pattern, node_id, self.graph).match_opt_expr() {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            PatternChildrenPredicate::None =\u003e (),\r\n        }\r\n\r\n        true\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":14411518807585587216},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":14411518807585587216},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":14411518807585587216},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":11673330234144325648},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":17726168133330272268},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":8863084066665136140},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":8863084066665136140},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4035225266123964418},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":14771806777775226888},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":9727775195120271360},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":792633534417207300},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1945555039024054278},"fn_name":null}],"covered":17,"coverable":17},{"path":["E:","\\","sql-layer","src","optimizer","heuristic","mod.rs"],"content":"pub(crate) mod batch;\r\npub(crate) mod graph;\r\npub(crate) mod matcher;\r\npub mod optimizer;\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","optimizer","heuristic","optimizer.rs"],"content":"use crate::errors::*;\r\nuse crate::optimizer::core::pattern::PatternMatcher;\r\nuse crate::optimizer::core::rule::Rule;\r\nuse crate::optimizer::heuristic::batch::{HepBatch, HepBatchStrategy};\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\nuse crate::optimizer::heuristic::matcher::HepMatcher;\r\nuse crate::optimizer::rule::RuleImpl;\r\nuse crate::planner::LogicalPlan;\r\n\r\npub struct HepOptimizer {\r\n    batches: Vec\u003cHepBatch\u003e,\r\n    pub graph: HepGraph,\r\n}\r\n\r\nimpl HepOptimizer {\r\n    pub fn new(root: LogicalPlan) -\u003e Self {\r\n        Self {\r\n            batches: vec![],\r\n            graph: HepGraph::new(root),\r\n        }\r\n    }\r\n\r\n    pub fn batch(mut self, name: String, strategy: HepBatchStrategy, rules: Vec\u003cRuleImpl\u003e) -\u003e Self {\r\n        self.batches.push(HepBatch::new(name, strategy, rules));\r\n        self\r\n    }\r\n\r\n    pub fn find_best(\u0026mut self) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let batches = self.batches.clone();\r\n\r\n        for batch in batches {\r\n            let mut batch_over = false;\r\n            let mut iteration = 1usize;\r\n\r\n            while iteration \u003c= batch.strategy.max_iteration \u0026\u0026 !batch_over {\r\n                if self.apply_batch(\u0026batch)? {\r\n                    iteration += 1;\r\n                } else {\r\n                    batch_over = true\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(self.graph.to_plan())\r\n    }\r\n\r\n    fn apply_batch(\r\n        \u0026mut self,\r\n        HepBatch {\r\n            rules, strategy, ..\r\n        }: \u0026HepBatch,\r\n    ) -\u003e Result\u003cbool\u003e {\r\n        let start_ver = self.graph.version;\r\n\r\n        for rule in rules {\r\n            for node_id in self.graph.nodes_iter(strategy.match_order, None) {\r\n                if self.apply_rule(rule, node_id)? {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(start_ver != self.graph.version)\r\n    }\r\n\r\n    fn apply_rule(\u0026mut self, rule: \u0026RuleImpl, node_id: HepNodeId) -\u003e Result\u003cbool\u003e {\r\n        let after_version = self.graph.version;\r\n\r\n        if HepMatcher::new(rule.pattern(), node_id, \u0026self.graph).match_opt_expr() {\r\n            rule.apply(node_id, \u0026mut self.graph)?;\r\n        }\r\n\r\n        Ok(after_version != self.graph.version)\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":5548434740920451073},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":5548434740920451073},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":5548434740920451073},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":5548434740920451073},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":5548434740920451073},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":5836665117072162818},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":13763000461244235782},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":12610078956637388803},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":9727775195120271362},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":5548434740920451072},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":11168927075878830080},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":11168927075878830080},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":12465963768561532932},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":12393906174523604994},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":8935141660703064066},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":11168927075878830084},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":12393906174523605004},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":12393906174523605004},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":12393906174523605004},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":9655717601082343440},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null}],"covered":26,"coverable":26},{"path":["E:","\\","sql-layer","src","optimizer","mod.rs"],"content":"use std::time::Instant;\r\n\r\nuse tracing::{trace};\r\n\r\nuse crate::{optimizer::heuristic::optimizer::HepOptimizer, planner::LogicalPlan};\r\n\r\nuse self::{heuristic::batch::HepBatchStrategy, rule::RuleImpl};\r\nuse crate::errors::*;\r\nmod core;\r\npub mod heuristic;\r\npub mod rule;\r\n\r\npub fn apply_optimization(plan: LogicalPlan) -\u003e Result\u003cLogicalPlan\u003e {\r\n    let before = Instant::now();\r\n    let plan = HepOptimizer::new(plan)\r\n        .batch(\r\n            \"Column Pruning\".to_string(),\r\n            HepBatchStrategy::once_topdown(),\r\n            vec![RuleImpl::ColumnPruning],\r\n        )\r\n        .batch(\r\n            \"Simplify Filter\".to_string(),\r\n            HepBatchStrategy::fix_point_topdown(10),\r\n            vec![\r\n                RuleImpl::SimplifyFilter,\r\n                RuleImpl::ConstantFolder,\r\n                RuleImpl::CollapseProject,\r\n            ],\r\n        )\r\n        .batch(\r\n            \"Predicate Pushdown\".to_string(),\r\n            HepBatchStrategy::fix_point_topdown(10),\r\n            vec![\r\n                RuleImpl::PushPredicateThroughJoin,\r\n                RuleImpl::PushPredicateIntoScan,\r\n            ],\r\n        )\r\n        .batch(\r\n            \"Combine Operators\".to_string(),\r\n            HepBatchStrategy::fix_point_topdown(10),\r\n            vec![RuleImpl::CollapseProject, RuleImpl::CombineFilter],\r\n        )\r\n        .batch(\r\n            \"Limit Pushdown\".to_string(),\r\n            HepBatchStrategy::fix_point_topdown(10),\r\n            vec![\r\n                RuleImpl::LimitProjectTranspose,\r\n                RuleImpl::PushLimitThroughJoin,\r\n                RuleImpl::PushLimitIntoTableScan,\r\n                RuleImpl::EliminateLimits,\r\n            ],\r\n        )\r\n        .find_best();\r\n    let after = Instant::now();\r\n    trace!(\r\n        \"apply optimization cost time : {} us\",\r\n        after.duration_since(before).as_micros()\r\n    );\r\n    plan\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null}],"covered":30,"coverable":31},{"path":["E:","\\","sql-layer","src","optimizer","rule","column_pruning.rs"],"content":"use crate::catalog::ColumnSummary;\r\nuse crate::errors::*;\r\nuse crate::expression::agg::Aggregate;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::optimizer::core::pattern::{Pattern, PatternChildrenPredicate};\r\nuse crate::optimizer::core::rule::Rule;\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\nuse crate::planner::operator::Operator;\r\nuse crate::types::value::DataValue;\r\nuse crate::types::LogicalType;\r\nuse lazy_static::lazy_static;\r\nuse std::collections::HashSet;\r\nuse std::sync::Arc;\r\n\r\nlazy_static! {\r\n    static ref COLUMN_PRUNING_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |_| true,\r\n            children: PatternChildrenPredicate::None,\r\n        }\r\n    };\r\n}\r\n\r\nmacro_rules! trans_references {\r\n    ($columns:expr) =\u003e {{\r\n        let mut column_references = HashSet::with_capacity($columns.len());\r\n        for column in $columns {\r\n            column_references.insert(column.summary());\r\n        }\r\n        column_references\r\n    }};\r\n}\r\n\r\n#[derive(Clone)]\r\npub struct ColumnPruning;\r\n\r\nimpl ColumnPruning {\r\n    fn clear_exprs(column_references: \u0026HashSet\u003c\u0026ColumnSummary\u003e, exprs: \u0026mut Vec\u003cScalarExpression\u003e) {\r\n        exprs.retain(|expr| {\r\n            if column_references.contains(expr.output_columns().summary()) {\r\n                return true;\r\n            }\r\n            expr.referenced_columns(false)\r\n                .iter()\r\n                .any(|column| column_references.contains(column.summary()))\r\n        })\r\n    }\r\n\r\n    fn _apply(\r\n        column_references: HashSet\u003c\u0026ColumnSummary\u003e,\r\n        all_referenced: bool,\r\n        node_id: HepNodeId,\r\n        graph: \u0026mut HepGraph,\r\n    ) {\r\n        let operator = graph.operator_mut(node_id);\r\n\r\n        match operator {\r\n            Operator::Aggregate(op) =\u003e {\r\n                // Aggregate  COUNT(*) \r\n                if !all_referenced {\r\n                    Self::clear_exprs(\u0026column_references, \u0026mut op.agg_calls);\r\n\r\n                    if op.agg_calls.is_empty() \u0026\u0026 op.groupby_exprs.is_empty() {\r\n                        let value = Arc::new(DataValue::Utf8(Some(\"*\".to_string())));\r\n                        // only single COUNT(*) is not depend on any column\r\n                        // removed all expressions from the aggregate: push a COUNT(*)\r\n                        op.agg_calls.push(ScalarExpression::AggCall {\r\n                            distinct: false,\r\n                            kind: Aggregate::Count,\r\n                            args: vec![ScalarExpression::Constant(value)],\r\n                            ty: LogicalType::Integer,\r\n                        })\r\n                    }\r\n                }\r\n                let is_distinct = op.is_distinct;\r\n                let referenced_columns = operator.referenced_columns(false);\r\n                let mut new_column_references = trans_references!(\u0026referenced_columns);\r\n                // on distinct\r\n                if is_distinct {\r\n                    for summary in column_references {\r\n                        new_column_references.insert(summary);\r\n                    }\r\n                }\r\n\r\n                Self::recollect_apply(new_column_references, false, node_id, graph);\r\n            }\r\n            Operator::Project(op) =\u003e {\r\n                // Project \r\n\r\n                let has_count_star = op.exprs.iter().any(ScalarExpression::has_count_star);\r\n                if !has_count_star {\r\n                    if !all_referenced {\r\n                        Self::clear_exprs(\u0026column_references, \u0026mut op.exprs);\r\n                    }\r\n                    let referenced_columns = operator.referenced_columns(false);\r\n                    let new_column_references = trans_references!(\u0026referenced_columns);\r\n\r\n                    Self::recollect_apply(new_column_references, false, node_id, graph);\r\n                }\r\n            }\r\n            Operator::Sort(_) | Operator::Limit(_) | Operator::Join(_) | Operator::Filter(_) =\u003e {\r\n                let temp_columns = operator.referenced_columns(false);\r\n                let mut column_references = column_references;\r\n                for column in temp_columns.iter() {\r\n                    column_references.insert(column.summary());\r\n                }\r\n                for child_id in graph.children_at(node_id) {\r\n                    let copy_references = column_references.clone();\r\n\r\n                    Self::_apply(copy_references, all_referenced, child_id, graph);\r\n                }\r\n            }\r\n            Operator::Scan(op) =\u003e {\r\n                if !all_referenced {\r\n                    Self::clear_exprs(\u0026column_references, \u0026mut op.columns);\r\n                }\r\n            }\r\n\r\n            // Last Operator\r\n            Operator::Dummy | Operator::Values(_) =\u003e (),\r\n            // DDL Based on Other Plan\r\n            Operator::Insert(_) | Operator::Update(_) | Operator::Delete(_) =\u003e {\r\n                let referenced_columns = operator.referenced_columns(false);\r\n                let new_column_references = trans_references!(\u0026referenced_columns);\r\n\r\n                if let Some(child_id) = graph.eldest_child_at(node_id) {\r\n                    Self::recollect_apply(new_column_references, true, child_id, graph);\r\n                } else {\r\n                    unreachable!();\r\n                }\r\n            }\r\n            // DDL Single Plan\r\n            Operator::Explain =\u003e {\r\n                if let Some(child_id) = graph.eldest_child_at(node_id) {\r\n                    Self::_apply(column_references, true, child_id, graph);\r\n                } else {\r\n                    unreachable!()\r\n                }\r\n            }\r\n\r\n            _ =\u003e (),\r\n        }\r\n    }\r\n\r\n    fn recollect_apply(\r\n        referenced_columns: HashSet\u003c\u0026ColumnSummary\u003e,\r\n        all_referenced: bool,\r\n        node_id: HepNodeId,\r\n        graph: \u0026mut HepGraph,\r\n    ) {\r\n        for child_id in graph.children_at(node_id) {\r\n            let copy_references: HashSet\u003c\u0026ColumnSummary\u003e = referenced_columns.clone();\r\n\r\n            Self::_apply(copy_references, all_referenced, child_id, graph);\r\n        }\r\n\r\n        // for child_id in graph.children_at(node_id) {\r\n        //     let new_references: HashSet\u003c\u0026ColumnSummary\u003e = referenced_columns\r\n        //         .iter()\r\n        //         .map(|column| column.summary())\r\n        //         .collect();\r\n\r\n        //     Self::_apply(new_references, all_referenced, child_id, graph);\r\n        // }\r\n    }\r\n}\r\n\r\nimpl Rule for ColumnPruning {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026COLUMN_PRUNING_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        Self::_apply(HashSet::new(), true, node_id, graph);\r\n        // mark changed to skip this rule batch\r\n        graph.version += 1;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::binder::test::select_sql_run;\r\n    use crate::errors::DatabaseError;\r\n    use crate::optimizer::heuristic::batch::HepBatchStrategy;\r\n    use crate::optimizer::heuristic::optimizer::HepOptimizer;\r\n    use crate::optimizer::rule::RuleImpl;\r\n    use crate::planner::operator::join::JoinCondition;\r\n    use crate::planner::operator::Operator;\r\n\r\n    #[tokio::test]\r\n    async fn test_column_pruning() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan = select_sql_run(\"select c1, c3 from t1 left join t2 on c1 = c3\").await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan.clone())\r\n            .batch(\r\n                \"test_column_pruning\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::ColumnPruning],\r\n            )\r\n            .find_best()?;\r\n\r\n        assert_eq!(best_plan.childrens.len(), 1);\r\n        match best_plan.operator {\r\n            Operator::Project(op) =\u003e {\r\n                assert_eq!(op.exprs.len(), 2);\r\n            }\r\n            _ =\u003e unreachable!(\"Should be a project operator\"),\r\n        }\r\n        match \u0026best_plan.childrens[0].operator {\r\n            Operator::Join(op) =\u003e match \u0026op.on {\r\n                JoinCondition::On { on, filter } =\u003e {\r\n                    assert_eq!(on.len(), 1);\r\n                    assert!(filter.is_none());\r\n                }\r\n                _ =\u003e unreachable!(\"Should be a on condition\"),\r\n            },\r\n            _ =\u003e unreachable!(\"Should be a join operator\"),\r\n        }\r\n\r\n        assert_eq!(best_plan.childrens[0].childrens.len(), 2);\r\n\r\n        for grandson_plan in \u0026best_plan.childrens[0].childrens {\r\n            match \u0026grandson_plan.operator {\r\n                Operator::Scan(op) =\u003e {\r\n                    assert_eq!(op.columns.len(), 1);\r\n                }\r\n                _ =\u003e unreachable!(\"Should be a scan operator\"),\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":13258597302978743076},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":9799832789158202148},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2089670227099912996},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2089670227099912996},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":6269010681299733284},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":8142508126285856768},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":8142508126285856768},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":8142508126285856768},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":8935141660703064064},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":4179340454199820288},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":5548434740920451072},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2666130979403333632},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":3674937295934324736},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":10304235947423694848},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null}],"covered":49,"coverable":57},{"path":["E:","\\","sql-layer","src","optimizer","rule","combine_operators.rs"],"content":"use crate::errors::*;\r\nuse crate::expression::{BinaryOperator, ScalarExpression};\r\nuse crate::optimizer::core::pattern::{Pattern, PatternChildrenPredicate};\r\nuse crate::optimizer::core::rule::Rule;\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\nuse crate::planner::operator::filter::FilterOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::types::LogicalType;\r\nuse lazy_static::lazy_static;\r\n\r\nuse super::is_subset_exprs;\r\n\r\nlazy_static! {\r\n    static ref COLLAPSE_PROJECT_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Project(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Project(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n    static ref COMBINE_FILTERS_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Filter(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Filter(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n}\r\n\r\n/// Combine two adjacent project operators into one.\r\npub struct CollapseProject;\r\n\r\nimpl Rule for CollapseProject {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026COLLAPSE_PROJECT_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Operator::Project(op) = graph.operator(node_id) {\r\n            let child_id = graph.children_at(node_id)[0];\r\n            if let Operator::Project(child_op) = graph.operator(child_id) {\r\n                if is_subset_exprs(\u0026op.exprs, \u0026child_op.exprs) {\r\n                    graph.remove_node(child_id, false);\r\n                } else {\r\n                    graph.remove_node(node_id, false);\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n/// Combine two adjacent filter operators into one.\r\npub struct CombineFilter;\r\n\r\nimpl Rule for CombineFilter {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026COMBINE_FILTERS_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Operator::Filter(op) = graph.operator(node_id) {\r\n            let child_id = graph.children_at(node_id)[0];\r\n            if let Operator::Filter(child_op) = graph.operator(child_id) {\r\n                let new_filter_op = FilterOperator {\r\n                    predicate: ScalarExpression::Binary {\r\n                        op: BinaryOperator::And,\r\n                        left_expr: Box::new(op.predicate.clone()),\r\n                        right_expr: Box::new(child_op.predicate.clone()),\r\n                        ty: LogicalType::Boolean,\r\n                    },\r\n                    having: op.having || child_op.having,\r\n                };\r\n                graph.replace_node(node_id, Operator::Filter(new_filter_op));\r\n                graph.remove_node(child_id, false);\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::binder::test::select_sql_run;\r\n    use crate::errors::DatabaseError;\r\n    use crate::expression::ScalarExpression::Constant;\r\n    use crate::expression::{BinaryOperator, ScalarExpression};\r\n    use crate::optimizer::heuristic::batch::HepBatchStrategy;\r\n    use crate::optimizer::heuristic::graph::HepNodeId;\r\n    use crate::optimizer::heuristic::optimizer::HepOptimizer;\r\n    use crate::optimizer::rule::RuleImpl;\r\n    use crate::planner::operator::Operator;\r\n    use crate::types::value::DataValue;\r\n    use crate::types::LogicalType;\r\n    use std::sync::Arc;\r\n\r\n    #[tokio::test]\r\n    async fn test_combine_filter() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan = select_sql_run(\"select * from t1 where c1 \u003e 1\").await?;\r\n\r\n        let mut optimizer = HepOptimizer::new(plan.clone()).batch(\r\n            \"test_combine_filter\".to_string(),\r\n            HepBatchStrategy::once_topdown(),\r\n            vec![RuleImpl::CombineFilter],\r\n        );\r\n\r\n        let mut new_filter_op = optimizer.graph.operator(HepNodeId::new(1)).clone();\r\n\r\n        if let Operator::Filter(op) = \u0026mut new_filter_op {\r\n            op.predicate = ScalarExpression::Binary {\r\n                op: BinaryOperator::Eq,\r\n                left_expr: Box::new(Constant(Arc::new(DataValue::Int8(Some(1))))),\r\n                right_expr: Box::new(Constant(Arc::new(DataValue::Int8(Some(1))))),\r\n                ty: LogicalType::Boolean,\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        optimizer\r\n            .graph\r\n            .add_node(HepNodeId::new(0), Some(HepNodeId::new(1)), new_filter_op);\r\n\r\n        let best_plan = optimizer.find_best()?;\r\n\r\n        if let Operator::Filter(op) = \u0026best_plan.childrens[0].operator {\r\n            if let ScalarExpression::Binary { op, .. } = \u0026op.predicate {\r\n                assert_eq!(op, \u0026BinaryOperator::And);\r\n            } else {\r\n                unreachable!(\"Should be a and operator\")\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":12249790986447749126},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":17149707381026848770},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":8574853690513424384},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":8574853690513424384},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":16,"coverable":20},{"path":["E:","\\","sql-layer","src","optimizer","rule","constant_folder.rs"],"content":"use crate::errors::*;\r\nuse crate::{\r\n    optimizer::{\r\n        core::{\r\n            pattern::{Pattern, PatternChildrenPredicate},\r\n            rule::Rule,\r\n        },\r\n        heuristic::graph::{HepGraph, HepNodeId},\r\n    },\r\n    planner::operator::{join::JoinCondition, Operator},\r\n};\r\nuse lazy_static::lazy_static;\r\n\r\nlazy_static! {\r\n    static ref CONSTANT_CALCULATION_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |_| true,\r\n            children: PatternChildrenPredicate::None,\r\n        }\r\n    };\r\n}\r\n\r\n#[derive(Copy, Clone)]\r\npub struct ConstantFolder;\r\n\r\nimpl ConstantFolder {\r\n    fn _apply(node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        let operator = graph.operator_mut(node_id);\r\n\r\n        match operator {\r\n            Operator::Aggregate(op) =\u003e {\r\n                for expr in op.agg_calls.iter_mut().chain(op.groupby_exprs.iter_mut()) {\r\n                    expr.constant_calculation()?;\r\n                }\r\n            }\r\n            Operator::Filter(op) =\u003e {\r\n                op.predicate.constant_calculation()?;\r\n            }\r\n            Operator::Join(op) =\u003e {\r\n                if let JoinCondition::On { on, filter } = \u0026mut op.on {\r\n                    for (left_expr, right_expr) in on {\r\n                        left_expr.constant_calculation()?;\r\n                        right_expr.constant_calculation()?;\r\n                    }\r\n                    if let Some(expr) = filter {\r\n                        expr.constant_calculation()?;\r\n                    }\r\n                }\r\n            }\r\n            Operator::Project(op) =\u003e {\r\n                for expr in \u0026mut op.exprs {\r\n                    expr.constant_calculation()?;\r\n                }\r\n            }\r\n            Operator::Scan(op) =\u003e {\r\n                for expr in \u0026mut op.columns {\r\n                    expr.constant_calculation()?;\r\n                }\r\n            }\r\n            Operator::Sort(op) =\u003e {\r\n                for field in \u0026mut op.sort_fields {\r\n                    field.expr.constant_calculation()?;\r\n                }\r\n            }\r\n            _ =\u003e (),\r\n        }\r\n        for child_id in graph.children_at(node_id) {\r\n            Self::_apply(child_id, graph)?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl Rule for ConstantFolder {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026Pattern {\r\n            predicate: |_| true,\r\n            children: PatternChildrenPredicate::None,\r\n        }\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        Self::_apply(node_id, graph)?;\r\n        // mark changed to skip this rule batch\r\n        graph.version += 1;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":10736581511651262464},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":10736581511651262464},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":10736581511651262464},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":7926335344172072954},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":10808639105689190403},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":10808639105689190403},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":8718968878589280260},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":8718968878589280264},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":5764607523034234879},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":8646911284551352318},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2882303761517117439},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":10592466323575406599},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":9007199254740992001},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":11601272640106397698},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":720575940379279361},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":3602879701896396806},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":7421932185906577414},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":15132094747964866564},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":10736581511651262464},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":14051230837395947520},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":14051230837395947520},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":9655717601082366189},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":14051230837395947520},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":14051230837395947521},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":14051230837395947522},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":14051230837395947520},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":14051230837395947520},"fn_name":null}],"covered":31,"coverable":37},{"path":["E:","\\","sql-layer","src","optimizer","rule","mod.rs"],"content":"use crate::expression::ScalarExpression;\r\nmod column_pruning;\r\nmod combine_operators;\r\nmod constant_folder;\r\nmod pushdown_limit;\r\nmod pushdown_predicates;\r\nmod simplification;\r\nuse crate::errors::*;\r\n\r\nuse self::{\r\n    column_pruning::ColumnPruning,\r\n    combine_operators::{CollapseProject, CombineFilter},\r\n    constant_folder::ConstantFolder,\r\n    pushdown_limit::{\r\n        EliminateLimits, LimitProjectTranspose, PushLimitIntoScan, PushLimitThroughJoin,\r\n    },\r\n    pushdown_predicates::{PushPredicateIntoScan, PushPredicateThroughJoin},\r\n    simplification::SimplifyFilter,\r\n};\r\n\r\nuse super::{\r\n    core::{pattern::Pattern, rule::Rule},\r\n    heuristic::graph::{HepGraph, HepNodeId},\r\n};\r\n\r\n#[derive(Debug, Copy, Clone)]\r\npub enum RuleImpl {\r\n    ColumnPruning,\r\n    // Combine operators\r\n    CollapseProject,\r\n    CombineFilter,\r\n    SimplifyFilter,\r\n\r\n    PushLimitIntoTableScan,\r\n    EliminateLimits,\r\n    LimitProjectTranspose,\r\n    PushLimitThroughJoin,\r\n    // PushDown predicates\r\n    PushPredicateIntoScan,\r\n    PushPredicateThroughJoin,\r\n\r\n    ConstantFolder,\r\n}\r\n\r\nimpl Rule for RuleImpl {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        match self {\r\n            RuleImpl::ColumnPruning =\u003e ColumnPruning.pattern(),\r\n            RuleImpl::PushLimitIntoTableScan =\u003e PushLimitIntoScan.pattern(),\r\n            RuleImpl::PushPredicateIntoScan =\u003e PushPredicateIntoScan.pattern(),\r\n            RuleImpl::ConstantFolder =\u003e ConstantFolder.pattern(),\r\n            RuleImpl::PushPredicateThroughJoin =\u003e PushPredicateThroughJoin.pattern(),\r\n            RuleImpl::CollapseProject =\u003e CollapseProject.pattern(),\r\n            RuleImpl::CombineFilter =\u003e CombineFilter.pattern(),\r\n            RuleImpl::SimplifyFilter =\u003e SimplifyFilter.pattern(),\r\n            RuleImpl::EliminateLimits =\u003e EliminateLimits.pattern(),\r\n            RuleImpl::LimitProjectTranspose =\u003e LimitProjectTranspose.pattern(),\r\n            RuleImpl::PushLimitThroughJoin =\u003e PushLimitThroughJoin.pattern(),\r\n        }\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        match self {\r\n            RuleImpl::ColumnPruning =\u003e ColumnPruning.apply(node_id, graph),\r\n            RuleImpl::PushLimitIntoTableScan =\u003e PushLimitIntoScan.apply(node_id, graph),\r\n            RuleImpl::PushPredicateIntoScan =\u003e PushPredicateIntoScan.apply(node_id, graph),\r\n            RuleImpl::ConstantFolder =\u003e ConstantFolder.apply(node_id, graph),\r\n            RuleImpl::PushPredicateThroughJoin =\u003e PushPredicateThroughJoin.apply(node_id, graph),\r\n            RuleImpl::CollapseProject =\u003e CollapseProject.apply(node_id, graph),\r\n            RuleImpl::CombineFilter =\u003e CombineFilter.apply(node_id, graph),\r\n            RuleImpl::SimplifyFilter =\u003e SimplifyFilter.apply(node_id, graph),\r\n            RuleImpl::EliminateLimits =\u003e EliminateLimits.apply(node_id, graph),\r\n            RuleImpl::LimitProjectTranspose =\u003e LimitProjectTranspose.apply(node_id, graph),\r\n            RuleImpl::PushLimitThroughJoin =\u003e PushLimitThroughJoin.apply(node_id, graph),\r\n        }\r\n    }\r\n}\r\n\r\n/// Return true when left is subset of right\r\npub fn is_subset_exprs(left: \u0026[ScalarExpression], right: \u0026[ScalarExpression]) -\u003e bool {\r\n    left.iter().all(|l| right.contains(l))\r\n}\r\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3314649325744685033},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":8646911284551352324},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":9007199254740992000},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":14051230837395947520},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":504403158265495566},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":8574853690513424389},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6629298651489370112},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":8574853690513424384},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":9655717601082343425},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":9655717601082343425},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3314649325744685055},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":14051230837395947520},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":28,"coverable":28},{"path":["E:","\\","sql-layer","src","optimizer","rule","pushdown_limit.rs"],"content":"use std::cmp;\r\n\r\nuse crate::optimizer::core::pattern::Pattern;\r\nuse crate::optimizer::core::pattern::PatternChildrenPredicate;\r\nuse crate::optimizer::core::rule::Rule;\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\n\r\nuse crate::errors::*;\r\n\r\nuse crate::planner::operator::join::JoinType;\r\nuse crate::planner::operator::limit::LimitOperator;\r\nuse crate::planner::operator::Operator;\r\nuse lazy_static::lazy_static;\r\n\r\nlazy_static! {\r\n    static ref LIMIT_PROJECT_TRANSPOSE_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Limit(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Project(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n    static ref PUSH_LIMIT_INTO_TABLE_SCAN_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Limit(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Scan(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n    static ref ELIMINATE_LIMITS_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Limit(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Limit(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n    static ref PUSH_LIMIT_THROUGH_JOIN_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Limit(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Join(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n}\r\n/// Push down `Limit` past a `Scan`.\r\npub struct PushLimitIntoScan;\r\n\r\nimpl Rule for PushLimitIntoScan {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026PUSH_LIMIT_INTO_TABLE_SCAN_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Operator::Limit(limit_op) = graph.operator(node_id) {\r\n            let child_index = graph.children_at(node_id)[0];\r\n            if let Operator::Scan(scan_op) = graph.operator(child_index) {\r\n                let mut new_scan_op = scan_op.clone();\r\n\r\n                new_scan_op.limit = (limit_op.offset, limit_op.limit);\r\n\r\n                graph.remove_node(node_id, false);\r\n                graph.replace_node(child_index, Operator::Scan(new_scan_op));\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\npub struct PushLimitThroughJoin;\r\n\r\nimpl Rule for PushLimitThroughJoin {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026PUSH_LIMIT_THROUGH_JOIN_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Operator::Limit(op) = graph.operator(node_id) {\r\n            if let Some(child_id) = graph.eldest_child_at(node_id) {\r\n                let join_type = if let Operator::Join(op) = graph.operator(child_id) {\r\n                    Some(op.join_type)\r\n                } else {\r\n                    None\r\n                };\r\n\r\n                if let Some(ty) = join_type {\r\n                    let children = graph.children_at(child_id);\r\n\r\n                    if let Some(grandson_id) = match ty {\r\n                        JoinType::Left =\u003e children.first(),\r\n                        JoinType::Right =\u003e children.last(),\r\n                        _ =\u003e None,\r\n                    } {\r\n                        graph.add_node(child_id, Some(*grandson_id), Operator::Limit(op.clone()));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\npub struct LimitProjectTranspose;\r\n\r\nimpl Rule for LimitProjectTranspose {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026LIMIT_PROJECT_TRANSPOSE_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Some(child_id) = graph.eldest_child_at(node_id) {\r\n            graph.swap_node(node_id, child_id);\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n/// Combines two adjacent Limit operators into one, merging the expressions into one single\r\n/// expression.\r\npub struct EliminateLimits;\r\n\r\nimpl Rule for EliminateLimits {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026ELIMINATE_LIMITS_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Operator::Limit(op) = graph.operator(node_id) {\r\n            if let Some(child_id) = graph.eldest_child_at(node_id) {\r\n                if let Operator::Limit(child_op) = graph.operator(child_id) {\r\n                    let offset = Self::binary_options(op.offset, child_op.offset, |a, b| a + b);\r\n                    let limit = Self::binary_options(op.limit, child_op.limit, cmp::min);\r\n\r\n                    let new_limit_op = LimitOperator { offset, limit };\r\n\r\n                    graph.remove_node(child_id, false);\r\n                    graph.replace_node(node_id, Operator::Limit(new_limit_op));\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl EliminateLimits {\r\n    fn binary_options\u003cF: Fn(usize, usize) -\u003e usize\u003e(\r\n        a: Option\u003cusize\u003e,\r\n        b: Option\u003cusize\u003e,\r\n        _fn: F,\r\n    ) -\u003e Option\u003cusize\u003e {\r\n        match (a, b) {\r\n            (Some(a), Some(b)) =\u003e Some(_fn(a, b)),\r\n            (Some(a), None) =\u003e Some(a),\r\n            (None, Some(b)) =\u003e Some(b),\r\n            (None, None) =\u003e None,\r\n        }\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::binder::test::select_sql_run;\r\n    use crate::errors::DatabaseError;\r\n    use crate::optimizer::heuristic::batch::HepBatchStrategy;\r\n    use crate::optimizer::heuristic::optimizer::HepOptimizer;\r\n    use crate::optimizer::rule::RuleImpl;\r\n    use crate::planner::operator::limit::LimitOperator;\r\n    use crate::planner::operator::Operator;\r\n\r\n    #[tokio::test]\r\n    async fn test_limit_project_transpose() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan = select_sql_run(\"select c1, c2 from t1 limit 1\").await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan.clone())\r\n            .batch(\r\n                \"test_limit_project_transpose\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::LimitProjectTranspose],\r\n            )\r\n            .find_best()?;\r\n\r\n        if let Operator::Project(_) = \u0026best_plan.operator {\r\n        } else {\r\n            unreachable!(\"Should be a project operator\")\r\n        }\r\n\r\n        if let Operator::Limit(_) = \u0026best_plan.childrens[0].operator {\r\n        } else {\r\n            unreachable!(\"Should be a limit operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_eliminate_limits() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan = select_sql_run(\"select c1, c2 from t1 limit 1 offset 1\").await?;\r\n\r\n        let mut optimizer = HepOptimizer::new(plan.clone()).batch(\r\n            \"test_eliminate_limits\".to_string(),\r\n            HepBatchStrategy::once_topdown(),\r\n            vec![RuleImpl::EliminateLimits],\r\n        );\r\n\r\n        let new_limit_op = LimitOperator {\r\n            offset: Some(2),\r\n            limit: Some(1),\r\n        };\r\n\r\n        optimizer.graph.add_root(Operator::Limit(new_limit_op));\r\n\r\n        let best_plan = optimizer.find_best()?;\r\n\r\n        if let Operator::Limit(op) = \u0026best_plan.operator {\r\n            assert_eq!(op.limit, Some(1));\r\n            assert_eq!(op.offset, Some(3));\r\n        } else {\r\n            unreachable!(\"Should be a project operator\")\r\n        }\r\n\r\n        if let Operator::Limit(_) = \u0026best_plan.childrens[0].operator {\r\n            unreachable!(\"Should not be a limit operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_push_limit_through_join() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3 limit 1\").await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan.clone())\r\n            .batch(\r\n                \"test_push_limit_through_join\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![\r\n                    RuleImpl::LimitProjectTranspose,\r\n                    RuleImpl::PushLimitThroughJoin,\r\n                ],\r\n            )\r\n            .find_best()?;\r\n\r\n        if let Operator::Join(_) = \u0026best_plan.childrens[0].childrens[0].operator {\r\n        } else {\r\n            unreachable!(\"Should be a join operator\")\r\n        }\r\n\r\n        if let Operator::Limit(op) = \u0026best_plan.childrens[0].childrens[0].childrens[0].operator {\r\n            assert_eq!(op.limit, Some(1));\r\n        } else {\r\n            unreachable!(\"Should be a limit operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_push_limit_into_table_scan() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan = select_sql_run(\"select * from t1 limit 1 offset 1\").await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan.clone())\r\n            .batch(\r\n                \"test_push_limit_into_table_scan\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![\r\n                    RuleImpl::LimitProjectTranspose,\r\n                    RuleImpl::PushLimitIntoTableScan,\r\n                ],\r\n            )\r\n            .find_best()?;\r\n\r\n        if let Operator::Scan(op) = \u0026best_plan.childrens[0].operator {\r\n            assert_eq!(op.limit, (Some(1), Some(1)))\r\n        } else {\r\n            unreachable!(\"Should be a project operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":17293822569102704640},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":17293822569102704640},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":17149707381026848768},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":17437937757178560512},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":8574853690513424384},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":8574853690513424384},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":49,"coverable":55},{"path":["E:","\\","sql-layer","src","optimizer","rule","pushdown_predicates.rs"],"content":"use crate::catalog::ColumnRef;\r\nuse crate::errors::*;\r\nuse crate::expression::{BinaryOperator, ScalarExpression};\r\nuse crate::optimizer::core::pattern::Pattern;\r\nuse crate::optimizer::core::pattern::PatternChildrenPredicate;\r\nuse crate::optimizer::core::rule::Rule;\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\nuse crate::planner::operator::filter::FilterOperator;\r\nuse crate::planner::operator::join::JoinType;\r\nuse crate::planner::operator::Operator;\r\nuse crate::types::LogicalType;\r\nuse itertools::Itertools;\r\nuse lazy_static::lazy_static;\r\n\r\nlazy_static! {\r\n    static ref PUSH_PREDICATE_THROUGH_JOIN: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Filter(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Join(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n    static ref PUSH_PREDICATE_INTO_SCAN: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Filter(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Scan(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n}\r\n\r\nfn split_conjunctive_predicates(expr: \u0026ScalarExpression) -\u003e Vec\u003cScalarExpression\u003e {\r\n    match expr {\r\n        ScalarExpression::Binary {\r\n            op: BinaryOperator::And,\r\n            left_expr,\r\n            right_expr,\r\n            ..\r\n        } =\u003e split_conjunctive_predicates(left_expr)\r\n            .into_iter()\r\n            .chain(split_conjunctive_predicates(right_expr))\r\n            .collect_vec(),\r\n        _ =\u003e vec![expr.clone()],\r\n    }\r\n}\r\n\r\n/// reduce filters into a filter, and then build a new LogicalFilter node with input child.\r\n/// if filters is empty, return the input child.\r\nfn reduce_filters(filters: Vec\u003cScalarExpression\u003e, having: bool) -\u003e Option\u003cFilterOperator\u003e {\r\n    filters\r\n        .into_iter()\r\n        .reduce(|a, b| ScalarExpression::Binary {\r\n            op: BinaryOperator::And,\r\n            left_expr: Box::new(a),\r\n            right_expr: Box::new(b),\r\n            ty: LogicalType::Boolean,\r\n        })\r\n        .map(|f| FilterOperator {\r\n            predicate: f,\r\n            having,\r\n        })\r\n}\r\n\r\n/// Return true when left is subset of right, only compare table_id and column_id, so it's safe to\r\n/// used for join output cols with nullable columns.\r\n/// If left equals right, return true.\r\npub fn is_subset_cols(left: \u0026[ColumnRef], right: \u0026[ColumnRef]) -\u003e bool {\r\n    left.iter().all(|l| right.contains(l))\r\n}\r\n\r\npub struct PushPredicateIntoScan;\r\n\r\nimpl Rule for PushPredicateIntoScan {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026PUSH_PREDICATE_INTO_SCAN\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Operator::Filter(op) = graph.operator(node_id) {\r\n            let child_id = graph.children_at(node_id)[0];\r\n            if let Operator::Scan(child_op) = graph.operator(child_id) {\r\n                if child_op.index_by.is_some() {\r\n                    return Ok(());\r\n                }\r\n\r\n                //FIXME: now only support unique\r\n                for meta in \u0026child_op.index_metas {\r\n                    let mut option = op.predicate.convert_binary(\u0026meta.column_ids[0])?;\r\n\r\n                    if let Some(mut binary) = option.take() {\r\n                        binary.scope_aggregation()?;\r\n                        let rearrange_binaries = binary.rearrange()?;\r\n\r\n                        if rearrange_binaries.is_empty() {\r\n                            continue;\r\n                        }\r\n                        let mut scan_by_index = child_op.clone();\r\n                        scan_by_index.index_by = Some((meta.clone(), rearrange_binaries));\r\n\r\n                        // The constant expression extracted in prewhere is used to\r\n                        // reduce the data scanning range and cannot replace the role of Filter.\r\n                        graph.replace_node(child_id, Operator::Scan(scan_by_index));\r\n\r\n                        return Ok(());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\npub struct PushPredicateThroughJoin;\r\n\r\nimpl Rule for PushPredicateThroughJoin {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026PUSH_PREDICATE_THROUGH_JOIN\r\n    }\r\n\r\n    // TODO: pushdown_predicates need to consider output columns\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        let child_id = graph.children_at(node_id)[0];\r\n        //\r\n        if let Operator::Join(child_op) = graph.operator(child_id) {\r\n            //\r\n            if !matches!(\r\n                child_op.join_type,\r\n                JoinType::Inner | JoinType::Left | JoinType::Right\r\n            ) {\r\n                return Ok(());\r\n            }\r\n\r\n            let join_childs = graph.children_at(child_id);\r\n            let left_columns = graph.operator(join_childs[0]).referenced_columns(true);\r\n            let right_columns = graph.operator(join_childs[1]).referenced_columns(true);\r\n\r\n            let mut new_ops = (None, None, None);\r\n            //\r\n            if let Operator::Filter(op) = graph.operator(node_id) {\r\n                //\r\n                let filter_exprs = split_conjunctive_predicates(\u0026op.predicate);\r\n\r\n                let (left_filters, rest): (Vec\u003c_\u003e, Vec\u003c_\u003e) = filter_exprs\r\n                    .into_iter()\r\n                    .partition(|f| is_subset_cols(\u0026f.referenced_columns(true), \u0026left_columns));\r\n                let (right_filters, common_filters): (Vec\u003c_\u003e, Vec\u003c_\u003e) = rest\r\n                    .into_iter()\r\n                    .partition(|f| is_subset_cols(\u0026f.referenced_columns(true), \u0026right_columns));\r\n\r\n                let replace_filters = match child_op.join_type {\r\n                    JoinType::Inner =\u003e {\r\n                        if !left_filters.is_empty() {\r\n                            if let Some(left_filter_op) = reduce_filters(left_filters, op.having) {\r\n                                new_ops.0 = Some(Operator::Filter(left_filter_op));\r\n                            }\r\n                        }\r\n\r\n                        if !right_filters.is_empty() {\r\n                            if let Some(right_filter_op) = reduce_filters(right_filters, op.having)\r\n                            {\r\n                                new_ops.1 = Some(Operator::Filter(right_filter_op));\r\n                            }\r\n                        }\r\n\r\n                        common_filters\r\n                    }\r\n                    JoinType::Left =\u003e {\r\n                        if !left_filters.is_empty() {\r\n                            if let Some(left_filter_op) = reduce_filters(left_filters, op.having) {\r\n                                new_ops.0 = Some(Operator::Filter(left_filter_op));\r\n                            }\r\n                        }\r\n\r\n                        common_filters\r\n                            .into_iter()\r\n                            .chain(right_filters)\r\n                            .collect_vec()\r\n                    }\r\n                    JoinType::Right =\u003e {\r\n                        if !right_filters.is_empty() {\r\n                            if let Some(right_filter_op) = reduce_filters(right_filters, op.having)\r\n                            {\r\n                                new_ops.1 = Some(Operator::Filter(right_filter_op));\r\n                            }\r\n                        }\r\n\r\n                        common_filters.into_iter().chain(left_filters).collect_vec()\r\n                    }\r\n                    _ =\u003e vec![],\r\n                };\r\n\r\n                if !replace_filters.is_empty() {\r\n                    if let Some(replace_filter_op) = reduce_filters(replace_filters, op.having) {\r\n                        new_ops.2 = Some(Operator::Filter(replace_filter_op));\r\n                    }\r\n                }\r\n            }\r\n\r\n            if let Some(left_op) = new_ops.0 {\r\n                graph.add_node(child_id, Some(join_childs[0]), left_op);\r\n            }\r\n\r\n            if let Some(right_op) = new_ops.1 {\r\n                graph.add_node(child_id, Some(join_childs[1]), right_op);\r\n            }\r\n\r\n            if let Some(common_op) = new_ops.2 {\r\n                graph.replace_node(node_id, common_op);\r\n            } else {\r\n                graph.remove_node(node_id, false);\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::binder::test::select_sql_run;\r\n    use crate::errors::DatabaseError;\r\n    use crate::expression::simplify::ConstantBinary::Scope;\r\n    use crate::expression::{BinaryOperator, ScalarExpression};\r\n    use crate::optimizer::heuristic::batch::HepBatchStrategy;\r\n    use crate::optimizer::heuristic::optimizer::HepOptimizer;\r\n    use crate::optimizer::rule::RuleImpl;\r\n    use crate::planner::operator::Operator;\r\n    use crate::types::value::DataValue;\r\n    use crate::types::LogicalType;\r\n    use std::collections::Bound;\r\n    use std::sync::Arc;\r\n\r\n    #[tokio::test]\r\n    async fn test_push_predicate_into_scan() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        // 1 - c2 \u003c 0 =\u003e c2 \u003e 1\r\n        let plan = select_sql_run(\"select * from t1 where -(1 - c2) \u003e 0\").await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan)\r\n            .batch(\r\n                \"simplify_filter\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::SimplifyFilter],\r\n            )\r\n            .batch(\r\n                \"test_push_predicate_into_scan\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::PushPredicateIntoScan],\r\n            )\r\n            .find_best()?;\r\n\r\n        if let Operator::Scan(op) = \u0026best_plan.childrens[0].childrens[0].operator {\r\n            let mock_binaries = vec![Scope {\r\n                min: Bound::Excluded(Arc::new(DataValue::Int32(Some(1)))),\r\n                max: Bound::Unbounded,\r\n            }];\r\n\r\n            assert_eq!(op.index_by.clone().unwrap().1, mock_binaries);\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_push_predicate_through_join_in_left_join() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan =\r\n            select_sql_run(\"select * from t1 left join t2 on c1 = c3 where c1 \u003e 1 and c3 \u003c 2\")\r\n                .await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan)\r\n            .batch(\r\n                \"test_push_predicate_through_join\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::PushPredicateThroughJoin],\r\n            )\r\n            .find_best()?;\r\n\r\n        if let Operator::Filter(op) = \u0026best_plan.childrens[0].operator {\r\n            match op.predicate {\r\n                ScalarExpression::Binary {\r\n                    op: BinaryOperator::Lt,\r\n                    ty: LogicalType::Boolean,\r\n                    ..\r\n                } =\u003e (),\r\n                _ =\u003e unreachable!(),\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        if let Operator::Filter(op) = \u0026best_plan.childrens[0].childrens[0].childrens[0].operator {\r\n            match op.predicate {\r\n                ScalarExpression::Binary {\r\n                    op: BinaryOperator::Gt,\r\n                    ty: LogicalType::Boolean,\r\n                    ..\r\n                } =\u003e (),\r\n                _ =\u003e unreachable!(),\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_push_predicate_through_join_in_right_join() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan =\r\n            select_sql_run(\"select * from t1 right join t2 on c1 = c3 where c1 \u003e 1 and c3 \u003c 2\")\r\n                .await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan)\r\n            .batch(\r\n                \"test_push_predicate_through_join\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::PushPredicateThroughJoin],\r\n            )\r\n            .find_best()?;\r\n\r\n        if let Operator::Filter(op) = \u0026best_plan.childrens[0].operator {\r\n            match op.predicate {\r\n                ScalarExpression::Binary {\r\n                    op: BinaryOperator::Gt,\r\n                    ty: LogicalType::Boolean,\r\n                    ..\r\n                } =\u003e (),\r\n                _ =\u003e unreachable!(),\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        if let Operator::Filter(op) = \u0026best_plan.childrens[0].childrens[0].childrens[1].operator {\r\n            match op.predicate {\r\n                ScalarExpression::Binary {\r\n                    op: BinaryOperator::Lt,\r\n                    ty: LogicalType::Boolean,\r\n                    ..\r\n                } =\u003e (),\r\n                _ =\u003e unreachable!(),\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_push_predicate_through_join_in_inner_join() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan =\r\n            select_sql_run(\"select * from t1 inner join t2 on c1 = c3 where c1 \u003e 1 and c3 \u003c 2\")\r\n                .await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan)\r\n            .batch(\r\n                \"test_push_predicate_through_join\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::PushPredicateThroughJoin],\r\n            )\r\n            .find_best()?;\r\n\r\n        if let Operator::Join(_) = \u0026best_plan.childrens[0].operator {\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        if let Operator::Filter(op) = \u0026best_plan.childrens[0].childrens[0].operator {\r\n            match op.predicate {\r\n                ScalarExpression::Binary {\r\n                    op: BinaryOperator::Gt,\r\n                    ty: LogicalType::Boolean,\r\n                    ..\r\n                } =\u003e (),\r\n                _ =\u003e unreachable!(),\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        if let Operator::Filter(op) = \u0026best_plan.childrens[0].childrens[1].operator {\r\n            match op.predicate {\r\n                ScalarExpression::Binary {\r\n                    op: BinaryOperator::Lt,\r\n                    ty: LogicalType::Boolean,\r\n                    ..\r\n                } =\u003e (),\r\n                _ =\u003e unreachable!(),\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":18014398509481984000},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":9007199254740992000},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":9007199254740992000},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":4107282860161892352},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1801439850948198400},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null}],"covered":72,"coverable":80},{"path":["E:","\\","sql-layer","src","optimizer","rule","simplification.rs"],"content":"use crate::errors::*;\r\nuse crate::optimizer::core::pattern::{Pattern, PatternChildrenPredicate};\r\nuse crate::optimizer::core::rule::Rule;\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\n\r\nuse crate::planner::operator::Operator;\r\nuse lazy_static::lazy_static;\r\nlazy_static! {\r\n    static ref SIMPLIFY_FILTER_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Filter(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| !matches!(op, Operator::Aggregate(_)),\r\n                children: PatternChildrenPredicate::Recursive,\r\n            }]),\r\n        }\r\n    };\r\n}\r\n#[derive(Copy, Clone)]\r\npub struct SimplifyFilter;\r\n\r\nimpl Rule for SimplifyFilter {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026SIMPLIFY_FILTER_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Operator::Filter(mut filter_op) = graph.operator(node_id).clone() {\r\n            filter_op.predicate.simplify()?;\r\n            filter_op.predicate.constant_calculation()?;\r\n\r\n            graph.replace_node(node_id, Operator::Filter(filter_op))\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::binder::test::select_sql_run;\r\n    use crate::catalog::{ColumnCatalog, ColumnDesc, ColumnSummary};\r\n\r\n    use crate::expression::simplify::ConstantBinary;\r\n    use crate::expression::{BinaryOperator, ScalarExpression, UnaryOperator};\r\n    use crate::optimizer::heuristic::batch::HepBatchStrategy;\r\n    use crate::optimizer::heuristic::optimizer::HepOptimizer;\r\n    use crate::optimizer::rule::{simplification::*, RuleImpl};\r\n    use crate::planner::operator::filter::FilterOperator;\r\n    use crate::planner::operator::Operator;\r\n    use crate::planner::LogicalPlan;\r\n    use crate::types::value::DataValue;\r\n    use crate::types::LogicalType;\r\n    use std::collections::Bound;\r\n    use std::sync::Arc;\r\n\r\n    #[tokio::test]\r\n    async fn test_constant_calculation_omitted() -\u003e Result\u003c()\u003e {\r\n        // (2 + (-1)) \u003c -(c1 + 1)\r\n        let plan =\r\n            select_sql_run(\"select c1 + (2 + 1), 2 + 1 from t1 where (2 + (-1)) \u003c -(c1 + 1)\")\r\n                .await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan)\r\n            .batch(\r\n                \"test_simplification\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::SimplifyFilter, RuleImpl::ConstantFolder],\r\n            )\r\n            .find_best()?;\r\n        if let Operator::Project(project_op) = best_plan.clone().operator {\r\n            let constant_expr = ScalarExpression::Constant(Arc::new(DataValue::Int32(Some(3))));\r\n            if let ScalarExpression::Binary { right_expr, .. } = \u0026project_op.exprs[0] {\r\n                assert_eq!(right_expr.as_ref(), \u0026constant_expr);\r\n            } else {\r\n                unreachable!();\r\n            }\r\n            assert_eq!(\u0026project_op.exprs[1], \u0026constant_expr);\r\n        } else {\r\n            unreachable!();\r\n        }\r\n        if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n            let column_binary = filter_op.predicate.convert_binary(\u00260).unwrap();\r\n            let final_binary = ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(Arc::new(DataValue::Int32(Some(-2)))),\r\n            };\r\n            assert_eq!(column_binary, Some(final_binary));\r\n        } else {\r\n            unreachable!();\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_single_column() -\u003e Result\u003c()\u003e {\r\n        // c1 + 1 \u003c -1 =\u003e c1 \u003c -2\r\n        let plan_1 = select_sql_run(\"select * from t1 where -(c1 + 1) \u003e 1\").await?;\r\n        // 1 - c1 \u003c -1 =\u003e c1 \u003e 2\r\n        let plan_2 = select_sql_run(\"select * from t1 where -(1 - c1) \u003e 1\").await?;\r\n        // c1 \u003c -1\r\n        let plan_3 = select_sql_run(\"select * from t1 where -c1 \u003e 1\").await?;\r\n        // c1 \u003e 0\r\n        let plan_4 = select_sql_run(\"select * from t1 where c1 + 1 \u003e 1\").await?;\r\n\r\n        // c1 + 1 \u003c -1 =\u003e c1 \u003c -2\r\n        let plan_5 = select_sql_run(\"select * from t1 where 1 \u003c -(c1 + 1)\").await?;\r\n        // 1 - c1 \u003c -1 =\u003e c1 \u003e 2\r\n        let plan_6 = select_sql_run(\"select * from t1 where 1 \u003c -(1 - c1)\").await?;\r\n        // c1 \u003c -1\r\n        let plan_7 = select_sql_run(\"select * from t1 where 1 \u003c -c1\").await?;\r\n        // c1 \u003e 0\r\n        let plan_8 = select_sql_run(\"select * from t1 where 1 \u003c c1 + 1\").await?;\r\n\r\n        // c1 \u003c 24\r\n        let plan_9 = select_sql_run(\"select * from t1 where (-1 - c1) + 1 \u003e 24\").await?;\r\n\r\n        // c1 \u003c 24\r\n        let plan_10 = select_sql_run(\"select * from t1 where 24 \u003c (-1 - c1) + 1\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cConstantBinary\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\r\n                    \"{expr}: {:#?}\",\r\n                    filter_op.predicate.convert_binary(\u00260).unwrap()\r\n                );\r\n\r\n                Ok(filter_op.predicate.convert_binary(\u00260).unwrap())\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"-(c1 + 1) \u003e 1\")?;\r\n        let op_2 = op(plan_2, \"-(1 - c1) \u003e 1\")?;\r\n        let op_3 = op(plan_3, \"-c1 \u003e 1\")?;\r\n        let op_4 = op(plan_4, \"c1 + 1 \u003e 1\")?;\r\n        let op_5 = op(plan_9, \"(-1 - c1) + 1 \u003e 24\")?;\r\n\r\n        assert!(op_1.is_some());\r\n        assert!(op_2.is_some());\r\n        assert!(op_3.is_some());\r\n        assert!(op_4.is_some());\r\n        assert!(op_5.is_some());\r\n\r\n        assert_eq!(op_1, op(plan_5, \"1 \u003c -(c1 + 1)\")?);\r\n        assert_eq!(op_2, op(plan_6, \"1 \u003c -(1 - c1)\")?);\r\n        assert_eq!(op_3, op(plan_7, \"1 \u003c -c1\")?);\r\n        assert_eq!(op_4, op(plan_8, \"1 \u003c c1 + 1\")?);\r\n        assert_eq!(op_5, op(plan_10, \"24 \u003c (-1 - c1) + 1\")?);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_repeating_column() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 where -(c1 + 1) \u003e c2\").await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan.clone())\r\n            .batch(\r\n                \"test_simplify_filter\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::SimplifyFilter],\r\n            )\r\n            .find_best()?;\r\n        if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n            let c1_col = ColumnCatalog {\r\n                summary: ColumnSummary {\r\n                    id: Some(0),\r\n                    name: \"c1\".to_string(),\r\n                    table_name: Some(Arc::new(\"t1\".to_string())),\r\n                },\r\n                nullable: false,\r\n                desc: ColumnDesc {\r\n                    column_datatype: LogicalType::Integer,\r\n                    is_primary: true,\r\n                    is_unique: false,\r\n                    default: None,\r\n                },\r\n                // ref_expr: None,\r\n            };\r\n            let c2_col = ColumnCatalog {\r\n                summary: ColumnSummary {\r\n                    id: Some(1),\r\n                    name: \"c2\".to_string(),\r\n                    table_name: Some(Arc::new(\"t1\".to_string())),\r\n                },\r\n                nullable: false,\r\n                desc: ColumnDesc {\r\n                    column_datatype: LogicalType::Integer,\r\n                    is_primary: false,\r\n                    is_unique: true,\r\n                    default: None,\r\n                },\r\n                // ref_expr: None,\r\n            };\r\n\r\n            // -(c1 + 1) \u003e c2 =\u003e c1 \u003c -c2 - 1\r\n            assert_eq!(\r\n                filter_op.predicate,\r\n                ScalarExpression::Binary {\r\n                    op: BinaryOperator::Gt,\r\n                    left_expr: Box::new(ScalarExpression::Unary {\r\n                        op: UnaryOperator::Minus,\r\n                        expr: Box::new(ScalarExpression::Binary {\r\n                            op: BinaryOperator::Plus,\r\n                            left_expr: Box::new(ScalarExpression::ColumnRef(Arc::new(c1_col))),\r\n                            right_expr: Box::new(ScalarExpression::Constant(Arc::new(\r\n                                DataValue::Int32(Some(1))\r\n                            ))),\r\n                            ty: LogicalType::Integer,\r\n                        }),\r\n                        ty: LogicalType::Integer,\r\n                    }),\r\n                    right_expr: Box::new(ScalarExpression::ColumnRef(Arc::new(c2_col))),\r\n                    ty: LogicalType::Boolean,\r\n                }\r\n            )\r\n        } else {\r\n            unreachable!()\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_multiple_column() -\u003e Result\u003c()\u003e {\r\n        // c1 + 1 \u003c -1 =\u003e c1 \u003c -2\r\n        let plan_1 =\r\n            select_sql_run(\"select * from t1 where -(c1 + 1) \u003e 1 and -(1 - c2) \u003e 1\").await?;\r\n        // 1 - c1 \u003c -1 =\u003e c1 \u003e 2\r\n        let plan_2 =\r\n            select_sql_run(\"select * from t1 where -(1 - c1) \u003e 1 and -(c2 + 1) \u003e 1\").await?;\r\n        // c1 \u003c -1\r\n        let plan_3 = select_sql_run(\"select * from t1 where -c1 \u003e 1 and c2 + 1 \u003e 1\").await?;\r\n        // c1 \u003e 0\r\n        let plan_4 = select_sql_run(\"select * from t1 where c1 + 1 \u003e 1 and -c2 \u003e 1\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cFilterOperator\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\"{expr}: {:#?}\", filter_op);\r\n\r\n                Ok(Some(filter_op))\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"-(c1 + 1) \u003e 1 and -(1 - c2) \u003e 1\")?.unwrap();\r\n        let op_2 = op(plan_2, \"-(1 - c1) \u003e 1 and -(c2 + 1) \u003e 1\")?.unwrap();\r\n        let op_3 = op(plan_3, \"-c1 \u003e 1 and c2 + 1 \u003e 1\")?.unwrap();\r\n        let op_4 = op(plan_4, \"c1 + 1 \u003e 1 and -c2 \u003e 1\")?.unwrap();\r\n\r\n        let cb_1_c1 = op_1.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_1 =\u003e c1: {:#?}\", cb_1_c1);\r\n        assert_eq!(\r\n            cb_1_c1,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(Arc::new(DataValue::Int32(Some(-2))))\r\n            })\r\n        );\r\n\r\n        let cb_1_c2 = op_1.predicate.convert_binary(\u00261).unwrap();\r\n        println!(\"op_1 =\u003e c2: {:#?}\", cb_1_c2);\r\n        assert_eq!(\r\n            cb_1_c2,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Excluded(Arc::new(DataValue::Int32(Some(2)))),\r\n                max: Bound::Unbounded\r\n            })\r\n        );\r\n\r\n        let cb_2_c1 = op_2.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_2 =\u003e c1: {:#?}\", cb_2_c1);\r\n        assert_eq!(\r\n            cb_2_c1,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Excluded(Arc::new(DataValue::Int32(Some(2)))),\r\n                max: Bound::Unbounded\r\n            })\r\n        );\r\n\r\n        let cb_2_c2 = op_2.predicate.convert_binary(\u00261).unwrap();\r\n        println!(\"op_2 =\u003e c2: {:#?}\", cb_2_c2);\r\n        assert_eq!(\r\n            cb_1_c1,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(Arc::new(DataValue::Int32(Some(-2))))\r\n            })\r\n        );\r\n\r\n        let cb_3_c1 = op_3.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_3 =\u003e c1: {:#?}\", cb_3_c1);\r\n        assert_eq!(\r\n            cb_3_c1,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(Arc::new(DataValue::Int32(Some(-1))))\r\n            })\r\n        );\r\n\r\n        let cb_3_c2 = op_3.predicate.convert_binary(\u00261).unwrap();\r\n        println!(\"op_3 =\u003e c2: {:#?}\", cb_3_c2);\r\n        assert_eq!(\r\n            cb_3_c2,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Excluded(Arc::new(DataValue::Int32(Some(0)))),\r\n                max: Bound::Unbounded\r\n            })\r\n        );\r\n\r\n        let cb_4_c1 = op_4.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_4 =\u003e c1: {:#?}\", cb_4_c1);\r\n        assert_eq!(\r\n            cb_4_c1,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Excluded(Arc::new(DataValue::Int32(Some(0)))),\r\n                max: Bound::Unbounded\r\n            })\r\n        );\r\n\r\n        let cb_4_c2 = op_4.predicate.convert_binary(\u00261).unwrap();\r\n        println!(\"op_4 =\u003e c2: {:#?}\", cb_4_c2);\r\n        assert_eq!(\r\n            cb_4_c2,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(Arc::new(DataValue::Int32(Some(-1))))\r\n            })\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_multiple_column_in_or() -\u003e Result\u003c()\u003e {\r\n        // c1 + 1 \u003c -1 =\u003e c1 \u003c -2\r\n        let plan_1 = select_sql_run(\"select * from t1 where c1 \u003e c2 or c1 \u003e 1\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cFilterOperator\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\"{expr}: {:#?}\", filter_op);\r\n\r\n                Ok(Some(filter_op))\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"c1 \u003e c2 or c1 \u003e 1\")?.unwrap();\r\n\r\n        let cb_1_c1 = op_1.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_1 =\u003e c1: {:#?}\", cb_1_c1);\r\n        assert_eq!(cb_1_c1, None);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_multiple_dispersed_same_column_in_or() -\u003e Result\u003c()\u003e {\r\n        let plan_1 = select_sql_run(\"select * from t1 where c1 = 4 and c1 \u003e c2 or c1 \u003e 1\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cFilterOperator\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\"{expr}: {:#?}\", filter_op);\r\n\r\n                Ok(Some(filter_op))\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"c1 = 4 and c2 \u003e c1 or c1 \u003e 1\")?.unwrap();\r\n\r\n        let cb_1_c1 = op_1.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_1 =\u003e c1: {:#?}\", cb_1_c1);\r\n        assert_eq!(\r\n            cb_1_c1,\r\n            Some(ConstantBinary::Or(vec![\r\n                ConstantBinary::Eq(Arc::new(DataValue::Int32(Some(4)))),\r\n                ConstantBinary::Scope {\r\n                    min: Bound::Excluded(Arc::new(DataValue::Int32(Some(1)))),\r\n                    max: Bound::Unbounded\r\n                }\r\n            ]))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_column_is_null() -\u003e Result\u003c()\u003e {\r\n        let plan_1 = select_sql_run(\"select * from t1 where c1 is null\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cFilterOperator\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\"{expr}: {:#?}\", filter_op);\r\n\r\n                Ok(Some(filter_op))\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"c1 is null\")?.unwrap();\r\n\r\n        let cb_1_c1 = op_1.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_1 =\u003e c1: {:#?}\", cb_1_c1);\r\n        assert_eq!(cb_1_c1, Some(ConstantBinary::Eq(Arc::new(DataValue::Null))));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_column_is_not_null() -\u003e Result\u003c()\u003e {\r\n        let plan_1 = select_sql_run(\"select * from t1 where c1 is not null\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cFilterOperator\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\"{expr}: {:#?}\", filter_op);\r\n\r\n                Ok(Some(filter_op))\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"c1 is not null\")?.unwrap();\r\n\r\n        let cb_1_c1 = op_1.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_1 =\u003e c1: {:#?}\", cb_1_c1);\r\n        assert_eq!(\r\n            cb_1_c1,\r\n            Some(ConstantBinary::NotEq(Arc::new(DataValue::Null)))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_column_in() -\u003e Result\u003c()\u003e {\r\n        let plan_1 = select_sql_run(\"select * from t1 where c1 in (1, 2, 3)\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cFilterOperator\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\"{expr}: {:#?}\", filter_op);\r\n\r\n                Ok(Some(filter_op))\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"c1 in (1, 2, 3)\")?.unwrap();\r\n\r\n        let cb_1_c1 = op_1.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_1 =\u003e c1: {:#?}\", cb_1_c1);\r\n        assert_eq!(\r\n            cb_1_c1,\r\n            Some(ConstantBinary::Or(vec![\r\n                ConstantBinary::Eq(Arc::new(DataValue::Int32(Some(2)))),\r\n                ConstantBinary::Eq(Arc::new(DataValue::Int32(Some(1)))),\r\n                ConstantBinary::Eq(Arc::new(DataValue::Int32(Some(3)))),\r\n            ]))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_column_not_in() -\u003e Result\u003c()\u003e {\r\n        let plan_1 = select_sql_run(\"select * from t1 where c1 not in (1, 2, 3)\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cFilterOperator\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\"{expr}: {:#?}\", filter_op);\r\n\r\n                Ok(Some(filter_op))\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"c1 not in (1, 2, 3)\")?.unwrap();\r\n\r\n        let cb_1_c1 = op_1.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_1 =\u003e c1: {:#?}\", cb_1_c1);\r\n        assert_eq!(\r\n            cb_1_c1,\r\n            Some(ConstantBinary::And(vec![\r\n                ConstantBinary::NotEq(Arc::new(DataValue::Int32(Some(2)))),\r\n                ConstantBinary::NotEq(Arc::new(DataValue::Int32(Some(1)))),\r\n                ConstantBinary::NotEq(Arc::new(DataValue::Int32(Some(3)))),\r\n            ]))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":13258597302978740228},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":1441151880758558730},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":6629298651489370112},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":6629298651489370112},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":8863084066665136132},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":17726168133330272264},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":8863084066665136132},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null}],"covered":9,"coverable":10},{"path":["E:","\\","sql-layer","src","parser.rs"],"content":"use sqlparser::dialect::PostgreSqlDialect;\r\nuse sqlparser::parser::ParserError;\r\nuse sqlparser::{ast::Statement as SqlStatement, parser::Parser};\r\nconst DIALECT: PostgreSqlDialect = PostgreSqlDialect {};\r\n\r\npub fn parse(sql: \u0026str) -\u003e Result\u003cVec\u003cSqlStatement\u003e, ParserError\u003e {\r\n    Parser::parse_sql(\u0026DIALECT, sql)\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n    #[test]\r\n    fn test_parser() {\r\n        let sql = \"select a, b, c, d from x join y on a = c;        \";\r\n        let ast = parse(sql);\r\n        println!(\"{:#?}\", ast);\r\n    }\r\n}\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null}],"covered":2,"coverable":2},{"path":["E:","\\","sql-layer","src","planner","mod.rs"],"content":"use std::sync::Arc;\r\n\r\nuse itertools::Itertools;\r\n\r\nuse crate::catalog::{ColumnCatalog, SchemaRef, TableName};\r\n\r\nuse self::operator::{values::ValuesOperator, Operator};\r\n\r\npub mod operator;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct LogicalPlan {\r\n    pub operator: Operator,\r\n    pub childrens: Vec\u003cLogicalPlan\u003e,\r\n    pub(crate) _output_schema_ref: Option\u003cSchemaRef\u003e,\r\n}\r\n\r\nimpl LogicalPlan {\r\n    pub fn new(operator: Operator, childrens: Vec\u003cLogicalPlan\u003e) -\u003e Self {\r\n        LogicalPlan {\r\n            operator,\r\n            childrens,\r\n            _output_schema_ref: None,\r\n        }\r\n    }\r\n    pub fn child(\u0026self, index: usize) -\u003e Option\u003c\u0026LogicalPlan\u003e {\r\n        self.childrens.get(index)\r\n    }\r\n\r\n    pub fn referenced_table(\u0026self) -\u003e Vec\u003cTableName\u003e {\r\n        fn collect_table(plan: \u0026LogicalPlan, results: \u0026mut Vec\u003cTableName\u003e) {\r\n            if let Operator::Scan(op) = \u0026plan.operator {\r\n                results.push(op.table_name.clone());\r\n            }\r\n            for child in \u0026plan.childrens {\r\n                collect_table(child, results);\r\n            }\r\n        }\r\n\r\n        let mut tables = Vec::new();\r\n        collect_table(self, \u0026mut tables);\r\n        tables\r\n    }\r\n    pub fn explain(\u0026self, indentation: usize) -\u003e String {\r\n        let mut result = format!(\"{:indent$}{}\", \"\", self.operator, indent = indentation);\r\n\r\n        for child in \u0026self.childrens {\r\n            result.push('\\n');\r\n            result.push_str(\u0026child.explain(indentation + 2));\r\n        }\r\n\r\n        result\r\n    }\r\n    pub fn output_schema(\u0026mut self) -\u003e \u0026SchemaRef {\r\n        self._output_schema_ref\r\n            .get_or_insert_with(|| match \u0026self.operator {\r\n                Operator::Filter(_) | Operator::Sort(_) | Operator::Limit(_) =\u003e {\r\n                    self.childrens[0].output_schema().clone()\r\n                }\r\n                Operator::Aggregate(op) =\u003e {\r\n                    let out_columns = op\r\n                        .agg_calls\r\n                        .iter()\r\n                        .chain(op.groupby_exprs.iter())\r\n                        .map(|expr| expr.output_columns())\r\n                        .collect_vec();\r\n                    Arc::new(out_columns)\r\n                }\r\n                Operator::Join(_op) =\u003e {\r\n                    // if matches!(op.join_type, JoinType::Left) {\r\n                    //     return self.childrens[0].output_schema().clone();\r\n                    // }\r\n                    let out_columns = self\r\n                        .childrens\r\n                        .iter_mut()\r\n                        .flat_map(|children| Vec::clone(children.output_schema()))\r\n                        .collect_vec();\r\n                    // for iter in out_columns.iter(){\r\n                    //     println!(\"out_columns: {}\", iter);\r\n                    // }\r\n                    Arc::new(out_columns)\r\n                }\r\n                Operator::Project(op) =\u003e {\r\n                    let out_columns = op\r\n                        .exprs\r\n                        .iter()\r\n                        .map(|expr| expr.output_columns())\r\n                        .collect_vec();\r\n                    Arc::new(out_columns)\r\n                }\r\n                Operator::Scan(op) =\u003e {\r\n                    let out_columns = op\r\n                        .columns\r\n                        .iter()\r\n                        .map(|column| column.output_columns())\r\n                        .collect_vec();\r\n                    Arc::new(out_columns)\r\n                }\r\n                Operator::Values(ValuesOperator { columns, .. }) =\u003e Arc::new(columns.clone()),\r\n                Operator::Dummy =\u003e Arc::new(vec![]),\r\n                Operator::Show =\u003e Arc::new(vec![\r\n                    Arc::new(ColumnCatalog::new_dummy(\"TABLE\".to_string())),\r\n                    // Arc::new(ColumnCatalog::new_dummy(\"COLUMN_METAS_LEN\".to_string())),\r\n                ]),\r\n                Operator::Explain =\u003e {\r\n                    Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\"PLAN\".to_string()))])\r\n                }\r\n                Operator::Describe(_) =\u003e Arc::new(vec![\r\n                    Arc::new(ColumnCatalog::new_dummy(\"FIELD\".to_string())),\r\n                    Arc::new(ColumnCatalog::new_dummy(\"TYPE\".to_string())),\r\n                    Arc::new(ColumnCatalog::new_dummy(\"NULL\".to_string())),\r\n                    Arc::new(ColumnCatalog::new_dummy(\"Key\".to_string())),\r\n                    Arc::new(ColumnCatalog::new_dummy(\"DEFAULT\".to_string())),\r\n                ]),\r\n                Operator::Insert(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"INSERTED\".to_string(),\r\n                ))]),\r\n                Operator::Update(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"UPDATED\".to_string(),\r\n                ))]),\r\n                Operator::Delete(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"DELETED\".to_string(),\r\n                ))]),\r\n                Operator::AddColumn(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"ADD COLUMN SUCCESS\".to_string(),\r\n                ))]),\r\n                Operator::DropColumn(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"DROP COLUMN SUCCESS\".to_string(),\r\n                ))]),\r\n                Operator::CreateTable(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"CREATE TABLE SUCCESS\".to_string(),\r\n                ))]),\r\n                Operator::DropTable(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"DROP TABLE SUCCESS\".to_string(),\r\n                ))]),\r\n                // Operator::Truncate(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                //     \"TRUNCATE TABLE SUCCESS\".to_string(),\r\n                // ))]),\r\n                Operator::CopyFromFile(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"COPY FROM SOURCE\".to_string(),\r\n                ))]),\r\n                Operator::SetVar(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"SET SUCCESS\".to_string(),\r\n                ))]),\r\n                Operator::CreateIndex(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"CREATE INDEX SUCCESS\".to_string(),\r\n                ))]),\r\n                Operator::DropIndex(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"DROP INDEX SUCCESS\".to_string(),\r\n                ))]),\r\n            })\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":18302628885633695744},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":9727775195120271360},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":9727775195120271360},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":18014398509481984000},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2666130979403333632},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":11240984669916758016},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":12970366926827028480},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":47,"coverable":84},{"path":["E:","\\","sql-layer","src","planner","operator","aggregate.rs"],"content":"use std::fmt::{self, Formatter};\r\n\r\nuse itertools::Itertools;\r\nuse serde::{Deserialize, Serialize};\r\n\r\nuse crate::planner::LogicalPlan;\r\nuse crate::{expression::ScalarExpression, planner::operator::Operator};\r\n\r\n#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]\r\npub struct AggregateOperator {\r\n    pub groupby_exprs: Vec\u003cScalarExpression\u003e,\r\n    pub agg_calls: Vec\u003cScalarExpression\u003e,\r\n    pub is_distinct: bool,\r\n}\r\n\r\nimpl AggregateOperator {\r\n    pub fn build(\r\n        children: LogicalPlan,\r\n        agg_calls: Vec\u003cScalarExpression\u003e,\r\n        groupby_exprs: Vec\u003cScalarExpression\u003e,\r\n        is_distinct: bool,\r\n    ) -\u003e LogicalPlan {\r\n        LogicalPlan::new(\r\n            Operator::Aggregate(Self {\r\n                groupby_exprs,\r\n                agg_calls,\r\n                is_distinct,\r\n            }),\r\n            vec![children],\r\n        )\r\n    }\r\n}\r\n\r\nimpl fmt::Display for AggregateOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        let calls = self\r\n            .agg_calls\r\n            .iter()\r\n            .map(|call| format!(\"{}\", call))\r\n            .join(\", \");\r\n        write!(f, \"Aggregate [{}]\", calls)?;\r\n\r\n        if !self.groupby_exprs.is_empty() {\r\n            let groupbys = self\r\n                .groupby_exprs\r\n                .iter()\r\n                .map(|groupby| format!(\"{}\", groupby))\r\n                .join(\", \");\r\n            write!(f, \" -\u003e Group By [{}]\", groupbys)?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":6,"coverable":17},{"path":["E:","\\","sql-layer","src","planner","operator","alter_table.rs"],"content":"use std::fmt::{self, Formatter};\r\n\r\nuse crate::catalog::{ColumnCatalog, TableName};\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct AddColumnOperator {\r\n    pub table_name: TableName,\r\n    pub if_not_exists: bool,\r\n    pub column: ColumnCatalog,\r\n}\r\nimpl fmt::Display for AddColumnOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(\r\n            f,\r\n            \"Add {} -\u003e {}, If Not Exists: {}\",\r\n            self.column.name(),\r\n            self.table_name,\r\n            self.if_not_exists\r\n        )?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct DropColumnOperator {\r\n    pub table_name: TableName,\r\n    pub column_name: String,\r\n    pub if_exists: bool,\r\n}\r\n\r\nimpl fmt::Display for DropColumnOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(\r\n            f,\r\n            \"Drop {} -\u003e {}, If Exists: {}\",\r\n            self.column_name, self.table_name, self.if_exists\r\n        )?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["E:","\\","sql-layer","src","planner","operator","copy_from_file.rs"],"content":"use crate::binder::copy::ExtSource;\r\nuse crate::catalog::ColumnRef;\r\nuse itertools::Itertools;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Eq, Clone, Hash)]\r\npub struct CopyFromFileOperator {\r\n    pub table: String,\r\n    pub source: ExtSource,\r\n    pub schema_ref: Vec\u003cColumnRef\u003e,\r\n}\r\n\r\nimpl fmt::Display for CopyFromFileOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        let columns = self\r\n            .schema_ref\r\n            .iter()\r\n            .map(|column| column.name().to_string())\r\n            .join(\", \");\r\n        write!(\r\n            f,\r\n            \"Copy {} -\u003e {} [{}]\",\r\n            self.source.path.display(),\r\n            self.table,\r\n            columns\r\n        )?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["E:","\\","sql-layer","src","planner","operator","create_index.rs"],"content":"use std::fmt::{self, Formatter};\r\n\r\nuse crate::catalog::{IndexName, TableName};\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct CreateIndexOperator {\r\n    pub table_name: TableName,\r\n    pub index_name: IndexName,\r\n    pub col_name: String,\r\n}\r\n\r\nimpl fmt::Display for CreateIndexOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(\r\n            f,\r\n            \"Create Index {} on {}.{}\",\r\n            self.index_name, self.table_name, self.col_name\r\n        )?;\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":636},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":636},"fn_name":null}],"covered":5,"coverable":5},{"path":["E:","\\","sql-layer","src","planner","operator","create_table.rs"],"content":"use crate::catalog::{ColumnCatalog, TableName};\r\nuse itertools::Itertools;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct CreateTableOperator {\r\n    /// Table name to insert to\r\n    pub table_name: TableName,\r\n    /// List of columns of the table\r\n    pub columns: Vec\u003cColumnCatalog\u003e,\r\n    pub if_not_exists: bool,\r\n}\r\nimpl fmt::Display for CreateTableOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        let columns = self\r\n            .columns\r\n            .iter()\r\n            .map(|column| column.name().to_string())\r\n            .join(\", \");\r\n        write!(\r\n            f,\r\n            \"Create {} -\u003e [{}], If Not Exists: {}\",\r\n            self.table_name, columns, self.if_not_exists\r\n        )?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["E:","\\","sql-layer","src","planner","operator","delete.rs"],"content":"use crate::catalog::TableName;\r\n\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct DeleteOperator {\r\n    pub table_name: TableName,\r\n}\r\nimpl fmt::Display for DeleteOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"Delete {}\", self.table_name)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["E:","\\","sql-layer","src","planner","operator","describe.rs"],"content":"use crate::catalog::TableName;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Eq, Clone, Hash)]\r\npub struct DescribeOperator {\r\n    pub table_name: TableName,\r\n}\r\n\r\nimpl fmt::Display for DescribeOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"Describe {}\", self.table_name)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["E:","\\","sql-layer","src","planner","operator","drop_index.rs"],"content":"use core::fmt;\r\nuse std::fmt::Formatter;\r\n\r\nuse crate::catalog::{IndexName, TableName};\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct DropIndexOperator {\r\n    pub table_name: TableName,\r\n    pub index_name: IndexName,\r\n    pub if_exists: bool,\r\n}\r\n\r\nimpl fmt::Display for DropIndexOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(\r\n            f,\r\n            \"Drop Index {} of {} If Not Exists: {}\",\r\n            self.index_name, self.table_name, self.if_exists\r\n        )?;\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["E:","\\","sql-layer","src","planner","operator","drop_table.rs"],"content":"use crate::catalog::TableName;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct DropTableOperator {\r\n    /// Table name to insert to\r\n    pub table_name: TableName,\r\n    pub if_exists: bool,\r\n}\r\nimpl fmt::Display for DropTableOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"Drop {}, If Exists: {}\", self.table_name, self.if_exists)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["E:","\\","sql-layer","src","planner","operator","filter.rs"],"content":"use super::Operator;\r\nuse crate::{expression::ScalarExpression, planner::LogicalPlan};\r\nuse std::fmt::Formatter;\r\nuse std::{fmt, vec};\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct FilterOperator {\r\n    pub predicate: ScalarExpression,\r\n    pub having: bool,\r\n}\r\n\r\nimpl FilterOperator {\r\n    pub fn build(predicate: ScalarExpression, children: LogicalPlan, having: bool) -\u003e LogicalPlan {\r\n        LogicalPlan::new(\r\n            Operator::Filter(FilterOperator { predicate, having }),\r\n            vec![children],\r\n        )\r\n    }\r\n}\r\n\r\nimpl fmt::Display for FilterOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"Filter {}, Is Having: {}\", self.predicate, self.having)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":2810246167479189507},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":2810246167479189507},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":2810246167479189507},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":6},{"path":["E:","\\","sql-layer","src","planner","operator","insert.rs"],"content":"use crate::catalog::TableName;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct InsertOperator {\r\n    pub table_name: TableName,\r\n    pub is_overwrite: bool,\r\n}\r\nimpl fmt::Display for InsertOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(\r\n            f,\r\n            \"Insert {}, Is Overwrite: {}\",\r\n            self.table_name, self.is_overwrite\r\n        )?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["E:","\\","sql-layer","src","planner","operator","join.rs"],"content":"use crate::{expression::ScalarExpression, planner::LogicalPlan};\r\nuse itertools::Itertools;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\nuse strum_macros::Display;\r\n\r\nuse super::Operator;\r\n\r\n#[derive(Debug, PartialEq, Display, Clone, Copy)]\r\npub enum JoinType {\r\n    Inner,\r\n    Left,\r\n    Right,\r\n    Full,\r\n    Cross,\r\n}\r\n#[derive(Debug, Clone, PartialEq)]\r\npub enum JoinCondition {\r\n    On {\r\n        /// Equijoin clause expressed as pairs of (left, right) join columns\r\n        on: Vec\u003c(ScalarExpression, ScalarExpression)\u003e,\r\n        /// Filters applied during join (non-equi conditions)\r\n        filter: Option\u003cScalarExpression\u003e,\r\n    },\r\n    None,\r\n}\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct JoinOperator {\r\n    pub on: JoinCondition,\r\n    pub join_type: JoinType,\r\n}\r\n\r\nimpl JoinOperator {\r\n    pub fn build(\r\n        left: LogicalPlan,\r\n        right: LogicalPlan,\r\n        on: JoinCondition,\r\n        join_type: JoinType,\r\n    ) -\u003e LogicalPlan {\r\n        LogicalPlan::new(\r\n            Operator::Join(JoinOperator { on, join_type }),\r\n            vec![left, right],\r\n        )\r\n    }\r\n}\r\n\r\nimpl fmt::Display for JoinOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"{} Join On {}\", self.join_type, self.on)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl fmt::Display for JoinCondition {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        match self {\r\n            JoinCondition::On { on, filter } =\u003e {\r\n                let on = on\r\n                    .iter()\r\n                    .map(|(v1, v2)| format!(\"{} = {}\", v1, v2))\r\n                    .join(\" AND \");\r\n\r\n                write!(f, \"{}\", on)?;\r\n                if let Some(filter) = filter {\r\n                    write!(f, \"Where {}\", filter)?;\r\n                }\r\n            }\r\n            JoinCondition::None =\u003e {\r\n                write!(f, \"Nothing\")?;\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":16},{"path":["E:","\\","sql-layer","src","planner","operator","limit.rs"],"content":"use crate::planner::LogicalPlan;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\nuse super::Operator;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct LimitOperator {\r\n    pub offset: Option\u003cusize\u003e,\r\n    pub limit: Option\u003cusize\u003e,\r\n}\r\n\r\nimpl LimitOperator {\r\n    pub fn build(\r\n        offset: Option\u003cusize\u003e,\r\n        limit: Option\u003cusize\u003e,\r\n        children: LogicalPlan,\r\n    ) -\u003e LogicalPlan {\r\n        LogicalPlan::new(\r\n            Operator::Limit(LimitOperator { offset, limit }),\r\n            vec![children],\r\n        )\r\n    }\r\n}\r\nimpl fmt::Display for LimitOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        if let Some(limit) = self.limit {\r\n            write!(f, \"Limit {}\", limit)?;\r\n        }\r\n        if self.limit.is_some() \u0026\u0026 self.offset.is_some() {\r\n            write!(f, \", \")?;\r\n        }\r\n        if let Some(offset) = self.offset {\r\n            write!(f, \"Offset {}\", offset)?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":360287970189639687},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":360287970189639687},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":360287970189639687},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":11},{"path":["E:","\\","sql-layer","src","planner","operator","mod.rs"],"content":"use itertools::Itertools;\r\n\r\nuse self::{\r\n    aggregate::AggregateOperator,\r\n    alter_table::{AddColumnOperator, DropColumnOperator},\r\n    copy_from_file::CopyFromFileOperator,\r\n    create_index::CreateIndexOperator,\r\n    create_table::CreateTableOperator,\r\n    delete::DeleteOperator,\r\n    describe::DescribeOperator,\r\n    drop_index::DropIndexOperator,\r\n    drop_table::DropTableOperator,\r\n    filter::FilterOperator,\r\n    insert::InsertOperator,\r\n    join::{JoinCondition, JoinOperator},\r\n    limit::LimitOperator,\r\n    project::ProjectOperator,\r\n    scan::ScanOperator,\r\n    set_var::SetVarOperator,\r\n    sort::SortOperator,\r\n    update::UpdateOperator,\r\n    values::ValuesOperator,\r\n};\r\nuse crate::catalog::ColumnRef;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\npub mod aggregate;\r\npub mod alter_table;\r\npub mod copy_from_file;\r\npub mod create_index;\r\npub mod create_table;\r\npub mod delete;\r\npub mod describe;\r\npub mod drop_index;\r\npub mod drop_table;\r\npub mod filter;\r\npub mod insert;\r\npub mod join;\r\npub mod limit;\r\npub mod project;\r\npub mod scan;\r\npub mod set_var;\r\npub mod sort;\r\npub mod update;\r\npub mod values;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub enum Operator {\r\n    // DQL\r\n    Dummy,\r\n    Aggregate(AggregateOperator),\r\n    Filter(FilterOperator),\r\n    Join(JoinOperator),\r\n    Project(ProjectOperator),\r\n    Scan(ScanOperator),\r\n    Sort(SortOperator),\r\n    Limit(LimitOperator),\r\n    Values(ValuesOperator),\r\n    Explain,\r\n    Show,\r\n    SetVar(SetVarOperator),\r\n    Describe(DescribeOperator),\r\n    // DML\r\n    Insert(InsertOperator),\r\n    Update(UpdateOperator),\r\n    Delete(DeleteOperator),\r\n    // DDL\r\n    AddColumn(AddColumnOperator),\r\n    DropColumn(DropColumnOperator),\r\n    CreateTable(CreateTableOperator),\r\n    DropTable(DropTableOperator),\r\n    CreateIndex(CreateIndexOperator),\r\n    DropIndex(DropIndexOperator),\r\n    CopyFromFile(CopyFromFileOperator),\r\n}\r\nimpl Operator {\r\n    pub fn referenced_columns(\u0026self, only_column_ref: bool) -\u003e Vec\u003cColumnRef\u003e {\r\n        match self {\r\n            Operator::Aggregate(op) =\u003e op\r\n                .agg_calls\r\n                .iter()\r\n                .chain(op.groupby_exprs.iter())\r\n                .flat_map(|expr| expr.referenced_columns(only_column_ref))\r\n                .collect_vec(),\r\n            Operator::Filter(op) =\u003e op.predicate.referenced_columns(only_column_ref),\r\n            Operator::Join(op) =\u003e {\r\n                let mut exprs = Vec::new();\r\n\r\n                if let JoinCondition::On { on, filter } = \u0026op.on {\r\n                    for (left_expr, right_expr) in on {\r\n                        exprs.append(\u0026mut left_expr.referenced_columns(only_column_ref));\r\n                        exprs.append(\u0026mut right_expr.referenced_columns(only_column_ref));\r\n                    }\r\n\r\n                    if let Some(filter_expr) = filter {\r\n                        exprs.append(\u0026mut filter_expr.referenced_columns(only_column_ref));\r\n                    }\r\n                }\r\n                exprs\r\n            }\r\n            Operator::Project(op) =\u003e op\r\n                .exprs\r\n                .iter()\r\n                .flat_map(|expr| expr.referenced_columns(only_column_ref))\r\n                .collect_vec(),\r\n            Operator::Scan(op) =\u003e op\r\n                .columns\r\n                .iter()\r\n                .flat_map(|expr| expr.referenced_columns(only_column_ref))\r\n                .collect_vec(),\r\n            Operator::Sort(op) =\u003e op\r\n                .sort_fields\r\n                .iter()\r\n                .map(|field| \u0026field.expr)\r\n                .flat_map(|expr| expr.referenced_columns(only_column_ref))\r\n                .collect_vec(),\r\n            Operator::Values(op) =\u003e op.columns.clone(),\r\n            _ =\u003e vec![],\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Operator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        match self {\r\n            Operator::Dummy =\u003e write!(f, \"Dummy\"),\r\n            Operator::Aggregate(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Filter(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Join(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Project(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Scan(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Sort(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Limit(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Values(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Explain =\u003e unreachable!(),\r\n            Operator::Insert(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Update(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::AddColumn(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::DropColumn(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::CreateTable(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::DropTable(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Delete(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::CreateIndex(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::DropIndex(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Show =\u003e write!(f, \"Show Tables\"),\r\n            Operator::SetVar(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::CopyFromFile(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Describe(op) =\u003e write!(f, \"{}\", op),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":78,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":26,"coverable":52},{"path":["E:","\\","sql-layer","src","planner","operator","project.rs"],"content":"use crate::catalog::ColumnRef;\r\nuse crate::expression::ScalarExpression;\r\nuse itertools::Itertools;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct ProjectOperator {\r\n    pub exprs: Vec\u003cScalarExpression\u003e,\r\n}\r\n\r\nimpl ProjectOperator {\r\n    pub fn ouput_schema(\u0026self) -\u003e Vec\u003cColumnRef\u003e {\r\n        self.exprs\r\n            .iter()\r\n            .map(|expr| expr.output_columns())\r\n            .collect()\r\n    }\r\n}\r\n\r\nimpl fmt::Display for ProjectOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        let exprs = self.exprs.iter().map(|expr| format!(\"{}\", expr)).join(\", \");\r\n\r\n        write!(f, \"Projection [{}]\", exprs)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["E:","\\","sql-layer","src","planner","operator","scan.rs"],"content":"use super::Operator;\r\nuse crate::catalog::{TableCatalog, TableName};\r\nuse crate::expression::simplify::ConstantBinary;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Bounds;\r\nuse crate::types::index::IndexMetaRef;\r\nuse itertools::Itertools;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct ScanOperator {\r\n    pub index_metas: Vec\u003cIndexMetaRef\u003e,\r\n\r\n    pub table_name: TableName,\r\n    pub columns: Vec\u003cScalarExpression\u003e,\r\n    // Support push down limit.\r\n    pub limit: Bounds,\r\n\r\n    // IndexScan only\r\n    // Support push down predicate.\r\n    // If pre_where is simple predicate, for example:  a \u003e 1 then can calculate directly when read data.\r\n    pub index_by: Option\u003c(IndexMetaRef, Vec\u003cConstantBinary\u003e)\u003e,\r\n}\r\nimpl ScanOperator {\r\n    pub fn build(table_name: TableName, table_catalog: \u0026TableCatalog) -\u003e LogicalPlan {\r\n        // Fill all Columns in TableCatalog by default\r\n        let columns = table_catalog\r\n            .all_columns()\r\n            .into_iter()\r\n            .map(ScalarExpression::ColumnRef)\r\n            .collect_vec();\r\n        LogicalPlan::new(\r\n            Operator::Scan(ScanOperator {\r\n                index_metas: table_catalog.indexes.clone(),\r\n                table_name,\r\n                columns,\r\n\r\n                limit: (None, None),\r\n                index_by: None,\r\n            }),\r\n            vec![],\r\n        )\r\n    }\r\n}\r\nimpl fmt::Display for ScanOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        let projection_columns = self\r\n            .columns\r\n            .iter()\r\n            .map(|column| format!(\"{}\", column))\r\n            .join(\", \");\r\n        let (offset, limit) = self.limit;\r\n        if let Some(index) = \u0026self.index_by {\r\n            write!(\r\n                f,\r\n                \"IndexScan {} by {} -\u003e [{}]\",\r\n                self.table_name, index.0.name, projection_columns\r\n            )?;\r\n        } else {\r\n            write!(f, \"Scan {} -\u003e [{}]\", self.table_name, projection_columns)?;\r\n        }\r\n        if let Some(limit) = limit {\r\n            write!(f, \", Limit: {}\", limit)?;\r\n        }\r\n        if let Some(offset) = offset {\r\n            write!(f, \", Offset: {}\", offset)?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":10,"coverable":22},{"path":["E:","\\","sql-layer","src","planner","operator","set_var.rs"],"content":"use std::fmt;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct SetVarOperator {\r\n    pub variable: String,\r\n    pub value: String,\r\n}\r\nimpl fmt::Display for SetVarOperator {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        write!(f, \"Set {} = {}\", self.variable, self.value)?;\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["E:","\\","sql-layer","src","planner","operator","sort.rs"],"content":"use crate::expression::ScalarExpression;\r\nuse itertools::Itertools;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct SortField {\r\n    pub expr: ScalarExpression,\r\n    pub asc: bool,\r\n    pub nulls_first: bool,\r\n}\r\n\r\nimpl SortField {\r\n    pub fn new(expr: ScalarExpression, asc: bool, nulls_first: bool) -\u003e Self {\r\n        SortField {\r\n            expr,\r\n            asc,\r\n            nulls_first,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct SortOperator {\r\n    pub sort_fields: Vec\u003cSortField\u003e,\r\n    /// Support push down limit to sort plan.\r\n    pub limit: Option\u003cusize\u003e,\r\n}\r\n\r\nimpl fmt::Display for SortOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        let sort_fields = self\r\n            .sort_fields\r\n            .iter()\r\n            .map(|sort_field| format!(\"{}\", sort_field))\r\n            .join(\", \");\r\n        write!(f, \"Sort By {}\", sort_fields)?;\r\n\r\n        if let Some(limit) = self.limit {\r\n            write!(f, \", Limit {}\", limit)?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl fmt::Display for SortField {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"{}\", self.expr)?;\r\n        if self.asc {\r\n            write!(f, \" Asc\")?;\r\n        } else {\r\n            write!(f, \" Desc\")?;\r\n        }\r\n        if self.nulls_first {\r\n            write!(f, \" Nulls First\")?;\r\n        } else {\r\n            write!(f, \" Nulls Last\")?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":18},{"path":["E:","\\","sql-layer","src","planner","operator","update.rs"],"content":"use std::fmt;\r\nuse std::fmt::Formatter;\r\nuse std::sync::Arc;\r\n\r\nuse crate::{\r\n    catalog::{ColumnCatalog, TableName},\r\n    expression::ScalarExpression,\r\n};\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct UpdateOperator {\r\n    pub columns: Vec\u003cArc\u003cColumnCatalog\u003e\u003e,\r\n    pub set_expr: Vec\u003cScalarExpression\u003e,\r\n    pub table_name: TableName,\r\n}\r\nimpl fmt::Display for UpdateOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"Update {}\", self.table_name)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["E:","\\","sql-layer","src","planner","operator","values.rs"],"content":"use crate::catalog::ColumnRef;\r\nuse crate::types::value::ValueRef;\r\nuse itertools::Itertools;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct ValuesOperator {\r\n    pub rows: Vec\u003cVec\u003cValueRef\u003e\u003e,\r\n    pub columns: Vec\u003cColumnRef\u003e,\r\n}\r\nimpl fmt::Display for ValuesOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        let columns = self\r\n            .columns\r\n            .iter()\r\n            .map(|column| column.name().to_string())\r\n            .join(\", \");\r\n\r\n        write!(f, \"Values [{}], RowsLen: {}\", columns, self.rows.len())?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["E:","\\","sql-layer","src","server.rs"],"content":"use std::{io, sync::Arc};\r\n\r\nuse async_trait::async_trait;\r\nuse futures::stream;\r\nuse rust_decimal::prelude::ToPrimitive;\r\n\r\nuse pgwire::{\r\n    api::{\r\n        auth::{noop::NoopStartupHandler, StartupHandler},\r\n        portal::{Format, Portal},\r\n        query::{ExtendedQueryHandler, SimpleQueryHandler, StatementOrPortal},\r\n        results::{DataRowEncoder, DescribeResponse, FieldInfo, QueryResponse, Response, Tag},\r\n        stmt::NoopQueryParser,\r\n        ClientInfo, MakeHandler, StatelessMakeHandler, Type,\r\n    },\r\n    error::{ErrorInfo, PgWireError, PgWireResult},\r\n    tokio::process_socket,\r\n};\r\nuse tokio::{net::TcpListener, sync::Mutex};\r\nuse tracing::debug;\r\n\r\nuse crate::{\r\n    catalog::SchemaRef,\r\n    db::{DBTransaction, Database},\r\n    errors::*,\r\n    planner::operator::Operator,\r\n    storage::{piggy_stroage::PiggyKVStroage},\r\n    types::{tuple::Tuple, LogicalType},\r\n};\r\n\r\npub struct Session {\r\n    inner: Arc\u003cDatabase\u003cPiggyKVStroage\u003e\u003e,\r\n    tx: Mutex\u003cOption\u003cDBTransaction\u003cPiggyKVStroage\u003e\u003e\u003e,\r\n}\r\npub struct Server {\r\n    pub(crate) inner: Arc\u003cDatabase\u003cPiggyKVStroage\u003e\u003e,\r\n}\r\n\r\nimpl MakeHandler for Server {\r\n    type Handler = Arc\u003cSession\u003e;\r\n\r\n    fn make(\u0026self) -\u003e Self::Handler {\r\n        Arc::new(Session {\r\n            inner: Arc::clone(\u0026self.inner),\r\n            tx: Mutex::new(None),\r\n        })\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl ExtendedQueryHandler for Session {\r\n    type Statement = String;\r\n\r\n    type QueryParser = NoopQueryParser;\r\n\r\n    fn query_parser(\u0026self) -\u003e Arc\u003cSelf::QueryParser\u003e {\r\n        Arc::new(NoopQueryParser::new())\r\n    }\r\n    async fn do_describe\u003cC\u003e(\r\n        \u0026self,\r\n        _client: \u0026mut C,\r\n        target: StatementOrPortal\u003c'_, Self::Statement\u003e,\r\n    ) -\u003e PgWireResult\u003cDescribeResponse\u003e\r\n    where\r\n        C: ClientInfo + Unpin + Send + Sync,\r\n    {\r\n        match target {\r\n            StatementOrPortal::Statement(stmt) =\u003e {\r\n                let plan = self.inner.prepare_sql(\u0026stmt.statement).await.unwrap();\r\n                // debug!(\"plan: {:?}\", plan);\r\n                if let Operator::Project(op) = plan.operator {\r\n                    let filed = op\r\n                        .ouput_schema()\r\n                        .iter()\r\n                        .enumerate()\r\n                        .map(|(idx, col)| {\r\n                            let name = col.name();\r\n                            let data_type = col.datatype();\r\n                            FieldInfo::new(\r\n                                name.to_string(),\r\n                                None,\r\n                                None,\r\n                                into_pg_type(data_type).unwrap(),\r\n                                Format::UnifiedText.format_for(idx),\r\n                            )\r\n                        })\r\n                        .collect::\u003cVec\u003c_\u003e\u003e();\r\n                    // debug!(\"filed: {:?}\", filed);\r\n                    Ok(DescribeResponse::new(None, filed))\r\n                } else {\r\n                    Ok(DescribeResponse::new(None, vec![]))\r\n                }\r\n            }\r\n            StatementOrPortal::Portal(portal) =\u003e {\r\n                let plan = self\r\n                    .inner\r\n                    .prepare_sql(\u0026portal.statement.statement)\r\n                    .await\r\n                    .unwrap();\r\n                // debug!(\"plan: {:?}\", plan);\r\n                if let Operator::Project(op) = plan.operator {\r\n                    let filed = op\r\n                        .ouput_schema()\r\n                        .iter()\r\n                        .enumerate()\r\n                        .map(|(idx, col)| {\r\n                            let name = col.name();\r\n                            let data_type = col.datatype();\r\n                            FieldInfo::new(\r\n                                name.to_string(),\r\n                                None,\r\n                                None,\r\n                                into_pg_type(data_type).unwrap(),\r\n                                Format::UnifiedText.format_for(idx),\r\n                            )\r\n                        })\r\n                        .collect::\u003cVec\u003c_\u003e\u003e();\r\n                    // debug!(\"filed: {:?}\", filed);\r\n                    Ok(DescribeResponse::new(None, filed))\r\n                } else {\r\n                    Ok(DescribeResponse::new(None, vec![]))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    async fn do_query\u003c'a, C\u003e(\r\n        \u0026self,\r\n        _client: \u0026mut C,\r\n        portal: \u0026'a Portal\u003cSelf::Statement\u003e,\r\n        _max_rows: usize,\r\n    ) -\u003e PgWireResult\u003cResponse\u003c'a\u003e\u003e\r\n    where\r\n        C: ClientInfo + Unpin + Send + Sync,\r\n    {\r\n        let query = \u0026portal.statement.statement;\r\n        //  debug!(\"query: {}\", query);\r\n        match query.to_uppercase().as_str() {\r\n            \"BEGIN;\" | \"BEGIN\" | \"START TRANSACTION;\" | \"START TRANSACTION\" =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                if guard.is_some() {\r\n                    return Err(PgWireError::ApiError(Box::new(\r\n                        DatabaseError::TransactionAlreadyExists,\r\n                    )));\r\n                }\r\n                let transaction = self\r\n                    .inner\r\n                    .new_transaction()\r\n                    .await\r\n                    .map_err(|e| PgWireError::ApiError(Box::new(e)))?;\r\n                guard.replace(transaction);\r\n\r\n                Ok(Response::Execution(Tag::new(\"BEGIN\")))\r\n            }\r\n            \"COMMIT;\" | \"COMMIT\" =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                if let Some(transaction) = guard.take() {\r\n                    transaction\r\n                        .commit()\r\n                        .await\r\n                        .map_err(|e| PgWireError::ApiError(Box::new(e)))?;\r\n\r\n                    Ok(Response::Execution(Tag::new(\"COMMIT\")))\r\n                } else {\r\n                    Err(PgWireError::ApiError(Box::new(\r\n                        DatabaseError::NoTransactionBegin,\r\n                    )))\r\n                }\r\n            }\r\n            \"ROLLBACK;\" | \"ROLLBACK\" =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                if guard.is_none() {\r\n                    return Err(PgWireError::ApiError(Box::new(\r\n                        DatabaseError::NoTransactionBegin,\r\n                    )));\r\n                }\r\n                drop(guard.take());\r\n\r\n                Ok(Response::Execution(Tag::new(\"ROLLBACK\")))\r\n            }\r\n            _ =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                let (schema, tuples) = if let Some(transaction) = guard.as_mut() {\r\n                    transaction.run(query).await\r\n                } else {\r\n                    self.inner.run(query).await\r\n                }\r\n                .map_err(|e| PgWireError::ApiError(Box::new(e)))?;\r\n                // debug!(\"tuples: {:?}\", tuples);\r\n                Ok(Response::Query(encode_tuples(schema, tuples)?))\r\n            }\r\n        }\r\n    }\r\n}\r\nfn row_desc_from_stmt(schema: SchemaRef, format: \u0026Format) -\u003e PgWireResult\u003cVec\u003cFieldInfo\u003e\u003e {\r\n    return schema\r\n        .iter()\r\n        .enumerate()\r\n        .map(|(idx, col)| {\r\n            let datatype = col.datatype();\r\n            let name = col.name();\r\n\r\n            Ok(FieldInfo::new(\r\n                name.to_string(),\r\n                None,\r\n                None,\r\n                into_pg_type(datatype).unwrap(),\r\n                format.format_for(idx),\r\n            ))\r\n        })\r\n        .collect();\r\n}\r\n\r\n#[async_trait]\r\nimpl SimpleQueryHandler for Session {\r\n    async fn do_query\u003c'a, 'b: 'a, C\u003e(\r\n        \u0026'b self,\r\n        _client: \u0026mut C,\r\n        query: \u0026'a str,\r\n    ) -\u003e PgWireResult\u003cVec\u003cResponse\u003c'a\u003e\u003e\u003e\r\n    where\r\n        C: ClientInfo + Unpin + Send + Sync,\r\n    {\r\n        match query.to_uppercase().as_str() {\r\n            \"BEGIN;\" | \"BEGIN\" =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                if guard.is_some() {\r\n                    return Err(PgWireError::ApiError(Box::new(\r\n                        DatabaseError::TransactionAlreadyExists,\r\n                    )));\r\n                }\r\n                let transaction = self\r\n                    .inner\r\n                    .new_transaction()\r\n                    .await\r\n                    .map_err(|e| PgWireError::ApiError(Box::new(e)))?;\r\n                guard.replace(transaction);\r\n\r\n                Ok(vec![Response::Execution(Tag::new(\"BEGIN\"))])\r\n            }\r\n            \"COMMIT;\" | \"COMMIT\" =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                if let Some(transaction) = guard.take() {\r\n                    transaction\r\n                        .commit()\r\n                        .await\r\n                        .map_err(|e| PgWireError::ApiError(Box::new(e)))?;\r\n\r\n                    Ok(vec![Response::Execution(Tag::new(\"COMMIT\"))])\r\n                } else {\r\n                    Err(PgWireError::ApiError(Box::new(\r\n                        DatabaseError::NoTransactionBegin,\r\n                    )))\r\n                }\r\n            }\r\n            \"ROLLBACK;\" | \"ROLLBACK\" =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                if guard.is_none() {\r\n                    return Err(PgWireError::ApiError(Box::new(\r\n                        DatabaseError::NoTransactionBegin,\r\n                    )));\r\n                }\r\n                drop(guard.take());\r\n\r\n                Ok(vec![Response::Execution(Tag::new(\"ROLLBACK\"))])\r\n            }\r\n            _ =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                let (schema, tuples) = if let Some(transaction) = guard.as_mut() {\r\n                    transaction.run(query).await\r\n                } else {\r\n                    self.inner.run(query).await\r\n                }\r\n                .map_err(|e| PgWireError::ApiError(Box::new(e)))?;\r\n\r\n                Ok(vec![Response::Query(encode_tuples(schema, tuples)?)])\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl Server {\r\n    pub async fn new(kv: PiggyKVStroage) -\u003e Result\u003cArc\u003cServer\u003e\u003e {\r\n        Ok(Arc::new(Server {\r\n            inner: Arc::new(Database::new(kv)?),\r\n        }))\r\n    }\r\n\r\n    pub async fn run(server: Arc\u003cSelf\u003e) {\r\n        // let backend = Server::new().await.unwrap();\r\n        let processor = server;\r\n\r\n\r\n        let authenticator = Arc::new(StatelessMakeHandler::new(Arc::new(NoopStartupHandler)));\r\n        let server_addr = format!(\"{}:{}\", \"127.0.0.1\", \"5432\");\r\n        let listener = TcpListener::bind(server_addr).await.unwrap();\r\n\r\n        tokio::select! {\r\n            res = server_run(processor.clone(), processor.clone(), authenticator, listener) =\u003e {\r\n                if let Err(err) = res {\r\n                    debug!(\"server run error: {}\", err);\r\n                }\r\n            }\r\n            _ = quit() =\u003e {\r\n                debug!(\"quit server\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npub(crate) async fn server_run\u003c\r\n    A: MakeHandler\u003cHandler = Arc\u003cimpl StartupHandler + 'static\u003e\u003e,\r\n    Q: MakeHandler\u003cHandler = Arc\u003cimpl SimpleQueryHandler + 'static\u003e\u003e,\r\n    EQ: MakeHandler\u003cHandler = Arc\u003cimpl ExtendedQueryHandler + 'static\u003e\u003e,\r\n\u003e(\r\n    processor: Arc\u003cQ\u003e,\r\n    placeholder: Arc\u003cEQ\u003e,\r\n    authenticator: Arc\u003cA\u003e,\r\n    listener: TcpListener,\r\n) -\u003e io::Result\u003c()\u003e {\r\n    loop {\r\n        let incoming_socket = listener.accept().await?;\r\n        let authenticator_ref = authenticator.make();\r\n        let processor_ref = processor.make();\r\n        let placeholder_ref = placeholder.make();\r\n\r\n        tokio::spawn(async move {\r\n            if let Err(err) = process_socket(\r\n                incoming_socket.0,\r\n                None,\r\n                authenticator_ref,\r\n                processor_ref,\r\n                placeholder_ref,\r\n            )\r\n            .await\r\n            {\r\n                debug!(\"process_socket error: {}\", err);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nasync fn quit() -\u003e io::Result\u003c()\u003e {\r\n    #[cfg(unix)]\r\n    {\r\n        let mut interrupt =\r\n            tokio::signal::unix::signal(tokio::signal::unix::SignalKind::interrupt())?;\r\n        let mut terminate =\r\n            tokio::signal::unix::signal(tokio::signal::unix::SignalKind::terminate())?;\r\n        tokio::select! {\r\n            _ = interrupt.recv() =\u003e (),\r\n            _ = terminate.recv() =\u003e (),\r\n        }\r\n        Ok(())\r\n    }\r\n    #[cfg(windows)]\r\n    {\r\n        let mut signal = tokio::signal::windows::ctrl_c()?;\r\n        let _ = signal.recv().await;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\nfn encode_tuples\u003c'a\u003e(schema: SchemaRef, tuples: Vec\u003cTuple\u003e) -\u003e PgWireResult\u003cQueryResponse\u003c'a\u003e\u003e {\r\n    // if tuples.is_empty() {\r\n    //     return Ok(QueryResponse::new(Arc::new(vec![]), stream::empty()));\r\n    // }\r\n    let schema = Arc::new(row_desc_from_stmt(schema, \u0026Format::UnifiedText)?);\r\n    let mut results = Vec::with_capacity(tuples.len());\r\n\r\n    for tuple in tuples {\r\n        let mut encoder = DataRowEncoder::new(schema.clone());\r\n        for value in tuple.values {\r\n            match value.logical_type() {\r\n                LogicalType::SqlNull =\u003e encoder.encode_field(\u0026None::\u003ci8\u003e),\r\n                LogicalType::Boolean =\u003e encoder.encode_field(\u0026value.bool()),\r\n                LogicalType::Tinyint =\u003e encoder.encode_field(\u0026value.i8()),\r\n                LogicalType::UTinyint =\u003e encoder.encode_field(\u0026value.u8().map(|v| v as i8)),\r\n                LogicalType::Smallint =\u003e encoder.encode_field(\u0026value.i16()),\r\n                LogicalType::USmallint =\u003e encoder.encode_field(\u0026value.u16().map(|v| v as i16)),\r\n                LogicalType::Integer =\u003e encoder.encode_field(\u0026value.i32()),\r\n                LogicalType::UInteger =\u003e encoder.encode_field(\u0026value.u32()),\r\n                LogicalType::Bigint =\u003e encoder.encode_field(\u0026value.i64()),\r\n                LogicalType::UBigint =\u003e encoder.encode_field(\u0026value.u64().map(|v| v as i64)),\r\n                LogicalType::Float =\u003e encoder.encode_field(\u0026value.float()),\r\n                LogicalType::Double =\u003e encoder.encode_field(\u0026value.double()),\r\n                LogicalType::Varchar(_) =\u003e encoder.encode_field(\u0026value.utf8()),\r\n                LogicalType::Date =\u003e encoder.encode_field(\u0026value.date()),\r\n                LogicalType::DateTime =\u003e encoder.encode_field(\u0026value.datetime()),\r\n                LogicalType::Decimal(_, _) =\u003e {\r\n                    encoder.encode_field(\u0026value.decimal().map(|v| v.to_f64()))\r\n                } //todo\r\n                _ =\u003e unreachable!(),\r\n            }?;\r\n        }\r\n\r\n        results.push(encoder.finish());\r\n    }\r\n    let iter = stream::iter(results);\r\n    Ok(QueryResponse::new(schema, iter))\r\n}\r\nfn into_pg_type(data_type: \u0026LogicalType) -\u003e PgWireResult\u003cType\u003e {\r\n    Ok(match data_type {\r\n        LogicalType::SqlNull =\u003e Type::UNKNOWN,\r\n        LogicalType::Boolean =\u003e Type::BOOL,\r\n        LogicalType::Tinyint | LogicalType::UTinyint =\u003e Type::CHAR,\r\n        LogicalType::Smallint | LogicalType::USmallint =\u003e Type::INT2,\r\n        LogicalType::Integer | LogicalType::UInteger =\u003e Type::INT4,\r\n        LogicalType::Bigint | LogicalType::UBigint =\u003e Type::INT8,\r\n        LogicalType::Float =\u003e Type::FLOAT4,\r\n        LogicalType::Double =\u003e Type::FLOAT8,\r\n        LogicalType::Varchar(_) =\u003e Type::VARCHAR,\r\n        LogicalType::Date | LogicalType::DateTime =\u003e Type::DATE,\r\n        LogicalType::Decimal(_, _) =\u003e Type::NUMERIC,\r\n        _ =\u003e {\r\n            return Err(PgWireError::UserError(Box::new(ErrorInfo::new(\r\n                \"ERROR\".to_owned(),\r\n                \"XX000\".to_owned(),\r\n                format!(\"Unsupported Datatype {data_type}\"),\r\n            ))));\r\n        }\r\n    })\r\n}\r\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":199},{"path":["E:","\\","sql-layer","src","storage","engine","mod.rs"],"content":"pub mod piggykv;\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","block","builder.rs"],"content":"use bytes::BufMut;\r\n\r\nuse crate::storage::engine::piggykv::key::{KeySlice, KeyVec};\r\n\r\nuse super::{Block, SIZEOF_U16};\r\n\r\n/// Builds a block.\r\npub struct BlockBuilder {\r\n    /// Offsets of each key-value entries.\r\n    offsets: Vec\u003cu16\u003e,\r\n    /// All serialized key-value pairs in the block.\r\n    data: Vec\u003cu8\u003e,\r\n    /// The expected block size.\r\n    block_size: usize,\r\n    /// The first key in the block\r\n    first_key: KeyVec,\r\n}\r\n\r\nfn compute_overlap(first_key: KeySlice, key: KeySlice) -\u003e usize {\r\n    let mut i = 0;\r\n    loop {\r\n        if i \u003e= first_key.key_len() || i \u003e= key.key_len() {\r\n            break;\r\n        }\r\n        if first_key.key_ref()[i] != key.key_ref()[i] {\r\n            break;\r\n        }\r\n        i += 1;\r\n    }\r\n    i\r\n}\r\n\r\nimpl BlockBuilder {\r\n    /// Creates a new block builder.\r\n    pub fn new(block_size: usize) -\u003e Self {\r\n        Self {\r\n            offsets: Vec::new(),\r\n            data: Vec::new(),\r\n            block_size,\r\n            first_key: KeyVec::new(),\r\n        }\r\n    }\r\n\r\n    fn estimated_size(\u0026self) -\u003e usize {\r\n        SIZEOF_U16 /* number of key-value pairs in the block */ +  self.offsets.len() * SIZEOF_U16 /* offsets */ + self.data.len()\r\n        // key-value pairs\r\n    }\r\n\r\n    /// Adds a key-value pair to the block. Returns false when the block is full.\r\n    #[must_use]\r\n    pub fn add(\u0026mut self, key: KeySlice, value: \u0026[u8]) -\u003e bool {\r\n        assert!(!key.is_empty(), \"key must not be empty\");\r\n        if self.estimated_size() + key.raw_len() + value.len() + SIZEOF_U16 * 3 /* key_len, value_len and offset */ \u003e self.block_size\r\n            \u0026\u0026 !self.is_empty()\r\n        {\r\n            return false;\r\n        }\r\n        // Add the offset of the data into the offset array.\r\n        self.offsets.push(self.data.len() as u16);\r\n        let overlap = compute_overlap(self.first_key.as_key_slice(), key);\r\n        // Encode key overlap.\r\n        self.data.put_u16(overlap as u16);\r\n        // Encode key length.\r\n        self.data.put_u16((key.key_len() - overlap) as u16);\r\n        // Encode key content.\r\n        self.data.put(\u0026key.key_ref()[overlap..]);\r\n        // Encode key ts\r\n        self.data.put_u64(key.ts());\r\n        // Encode value length.\r\n        self.data.put_u16(value.len() as u16);\r\n        // Encode value content.\r\n        self.data.put(value);\r\n\r\n        if self.first_key.is_empty() {\r\n            self.first_key = key.to_key_vec();\r\n        }\r\n\r\n        true\r\n    }\r\n\r\n    /// Check if there are no key-value pairs in the block.\r\n    pub fn is_empty(\u0026self) -\u003e bool {\r\n        self.offsets.is_empty()\r\n    }\r\n\r\n    /// Finalize the block.\r\n    pub fn build(self) -\u003e Block {\r\n        if self.is_empty() {\r\n            panic!(\"block should not be empty\");\r\n        }\r\n        Block {\r\n            data: self.data,\r\n            offsets: self.offsets,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":10592466323575406592},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":10592466323575406592},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":4755801206503236207},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":5332261958806677558},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":18158513697557830910},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":12898309332789101876},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":10592466323575416886},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":12970366926827029751},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":12970366926827029751},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":12970366926827029751},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":12970366926827029751},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":7638104968020361261},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":7638104968020361261},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":7638104968020362593},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":7638104968020363970},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":16861477004875137024},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":15492382718154506196},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":10592466323575406636},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":10592466323575406636},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":10592466323575406636},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":10592466323575406636},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":10592466323575406636},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":10592466323575406636},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":10592466323575406636},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":10592466323575406636},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":15852670688344145964},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":10592466323575406637},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":504403158265496839},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":504403158265496839},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":5188146770730811527},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":5188146770730811527},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":45},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":5188146770730811482},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":5188146770730811482},"fn_name":null}],"covered":37,"coverable":37},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","block","iterator.rs"],"content":"use std::sync::Arc;\r\n\r\nuse bytes::Buf;\r\n\r\nuse crate::storage::engine::piggykv::key::{KeySlice, KeyVec};\r\n\r\nuse super::{Block, SIZEOF_U16};\r\n\r\n/// Iterates on a block.\r\npub struct BlockIterator {\r\n    /// reference to the block\r\n    block: Arc\u003cBlock\u003e,\r\n    /// the current key at the iterator position\r\n    key: KeyVec,\r\n    /// the value range from the block\r\n    value_range: (usize, usize),\r\n    /// the current index at the iterator position\r\n    idx: usize,\r\n    /// the first key in the block\r\n    first_key: KeyVec,\r\n}\r\n\r\nimpl Block {\r\n    fn get_first_key(\u0026self) -\u003e KeyVec {\r\n        let mut buf = \u0026self.data[..];\r\n        buf.get_u16();\r\n        let key_len = buf.get_u16() as usize;\r\n        let key = \u0026buf[..key_len];\r\n        buf.advance(key_len);\r\n        KeyVec::from_vec_with_ts(key.to_vec(), buf.get_u64())\r\n    }\r\n}\r\n\r\nimpl BlockIterator {\r\n    fn new(block: Arc\u003cBlock\u003e) -\u003e Self {\r\n        Self {\r\n            first_key: block.get_first_key(),\r\n            block,\r\n            key: KeyVec::new(),\r\n            value_range: (0, 0),\r\n            idx: 0,\r\n        }\r\n    }\r\n\r\n    /// Creates a block iterator and seek to the first entry.\r\n    pub fn create_and_seek_to_first(block: Arc\u003cBlock\u003e) -\u003e Self {\r\n        let mut iter = Self::new(block);\r\n        iter.seek_to_first();\r\n        iter\r\n    }\r\n\r\n    /// Creates a block iterator and seek to the first key that \u003e= `key`.\r\n    pub fn create_and_seek_to_key(block: Arc\u003cBlock\u003e, key: KeySlice) -\u003e Self {\r\n        let mut iter = Self::new(block);\r\n        iter.seek_to_key(key);\r\n        iter\r\n    }\r\n\r\n    /// Returns the key of the current entry.\r\n    pub fn key(\u0026self) -\u003e KeySlice {\r\n        debug_assert!(!self.key.is_empty(), \"invalid iterator\");\r\n        self.key.as_key_slice()\r\n    }\r\n\r\n    /// Returns the value of the current entry.\r\n    pub fn value(\u0026self) -\u003e \u0026[u8] {\r\n        debug_assert!(!self.key.is_empty(), \"invalid iterator\");\r\n        \u0026self.block.data[self.value_range.0..self.value_range.1]\r\n    }\r\n\r\n    /// Returns true if the iterator is valid.\r\n    pub fn is_valid(\u0026self) -\u003e bool {\r\n        !self.key.is_empty()\r\n    }\r\n\r\n    /// Seeks to the first key in the block.\r\n    pub fn seek_to_first(\u0026mut self) {\r\n        self.seek_to(0);\r\n    }\r\n\r\n    /// Seeks to the idx-th key in the block.\r\n    fn seek_to(\u0026mut self, idx: usize) {\r\n        if idx \u003e= self.block.offsets.len() {\r\n            self.key.clear();\r\n            self.value_range = (0, 0);\r\n            return;\r\n        }\r\n        let offset = self.block.offsets[idx] as usize;\r\n        self.seek_to_offset(offset);\r\n        self.idx = idx;\r\n    }\r\n\r\n    /// Move to the next key in the block.\r\n    pub fn next(\u0026mut self) {\r\n        self.idx += 1;\r\n        self.seek_to(self.idx);\r\n    }\r\n\r\n    /// Seek to the specified position and update the current `key` and `value`\r\n    /// Index update will be handled by caller\r\n    fn seek_to_offset(\u0026mut self, offset: usize) {\r\n        let mut entry = \u0026self.block.data[offset..];\r\n        // Since `get_u16()` will automatically move the ptr 2 bytes ahead here,\r\n        // we don't need to manually advance it\r\n        let overlap_len = entry.get_u16() as usize;\r\n        let key_len = entry.get_u16() as usize;\r\n        let key = \u0026entry[..key_len];\r\n        self.key.clear();\r\n        self.key.append(\u0026self.first_key.key_ref()[..overlap_len]);\r\n        self.key.append(key);\r\n        entry.advance(key_len);\r\n        let ts = entry.get_u64();\r\n        self.key.set_ts(ts);\r\n        let value_len = entry.get_u16() as usize;\r\n        // REMEMBER TO CHANGE THIS every time you change the encoding!\r\n        let value_offset_begin =\r\n            offset + SIZEOF_U16 + SIZEOF_U16 + std::mem::size_of::\u003cu64\u003e() + key_len + SIZEOF_U16;\r\n        let value_offset_end = value_offset_begin + value_len;\r\n        self.value_range = (value_offset_begin, value_offset_end);\r\n        entry.advance(value_len);\r\n    }\r\n\r\n    /// Seek to the first key that is \u003e= `key`.\r\n    pub fn seek_to_key(\u0026mut self, key: KeySlice) {\r\n        let mut low = 0;\r\n        let mut high = self.block.offsets.len();\r\n        while low \u003c high {\r\n            let mid = low + (high - low) / 2;\r\n            self.seek_to(mid);\r\n            assert!(self.is_valid());\r\n            match self.key().cmp(\u0026key) {\r\n                std::cmp::Ordering::Less =\u003e low = mid + 1,\r\n                std::cmp::Ordering::Greater =\u003e high = mid,\r\n                std::cmp::Ordering::Equal =\u003e return,\r\n            }\r\n        }\r\n        self.seek_to(low);\r\n    }\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":720575940379279640},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":720575940379279640},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":720575940379279640},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":720575940379279640},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":576460752303423538},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":576460752303423538},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":576460752303423538},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":576460752303423538},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":5476377146882523366},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":10952754293765059037},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":5476377146882523366},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4395513236313616631},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":8791026472627223022},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":4395513236313616631},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":2666130979403335927},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2666130979403335927},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1080863910568931139},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1080863910568931139},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":9007199254740992050},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":9007199254740992050},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2305843009213696674},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2305843009213696674},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2305843009213696674},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":6701356245527295376},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":6701356245527295376},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":6701356245527295376},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":7421932185906577458},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":7421932185906577458},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":7421932185906577458},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":6701356245527299333},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":72057594037930608},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":72057594037930608},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":72057594037930608},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":504403158265499017},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":3602879701896399672},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":3602879701896399672},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":3602879701896399672},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":3602879701896399671},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":7998392938210001457},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":10880696699727118568},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":3170534137668829414},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":15348267530078650961},"fn_name":null}],"covered":69,"coverable":69},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","block.rs"],"content":"mod builder;\r\nmod iterator;\r\n\r\npub use builder::BlockBuilder;\r\nuse bytes::{Buf, BufMut, Bytes};\r\npub use iterator::BlockIterator;\r\n\r\npub(crate) const SIZEOF_U16: usize = std::mem::size_of::\u003cu16\u003e();\r\n\r\n/// A block is the smallest unit of read and caching in LSM tree. It is a collection of sorted\r\n/// key-value pairs.\r\npub struct Block {\r\n    pub(crate) data: Vec\u003cu8\u003e,\r\n    pub(crate) offsets: Vec\u003cu16\u003e,\r\n}\r\n\r\nimpl Block {\r\n    pub fn encode(\u0026self) -\u003e Bytes {\r\n        let mut buf = self.data.clone();\r\n        let offsets_len = self.offsets.len();\r\n        for offset in \u0026self.offsets {\r\n            buf.put_u16(*offset);\r\n        }\r\n        // Adds number of elements at the end of the block\r\n        buf.put_u16(offsets_len as u16);\r\n        buf.into()\r\n    }\r\n\r\n    pub fn decode(data: \u0026[u8]) -\u003e Self {\r\n        // get number of elements in the block\r\n        let entry_offsets_len = (\u0026data[data.len() - SIZEOF_U16..]).get_u16() as usize;\r\n        let data_end = data.len() - SIZEOF_U16 - entry_offsets_len * SIZEOF_U16;\r\n        let offsets_raw = \u0026data[data_end..data.len() - SIZEOF_U16];\r\n        // get offset array\r\n        let offsets = offsets_raw\r\n            .chunks(SIZEOF_U16)\r\n            .map(|mut x| x.get_u16())\r\n            .collect();\r\n        // retrieve data\r\n        let data = data[0..data_end].to_vec();\r\n        Self { data, offsets }\r\n    }\r\n}\r\n\r\n\r\n#[cfg(test)]\r\nmod test{\r\n    use std::sync::Arc;\r\n\r\nuse bytes::Bytes;\r\n\r\nuse crate::storage::engine::piggykv::key::{KeySlice, KeyVec};\r\n\r\nuse super::{Block, BlockBuilder, BlockIterator};\r\n\r\n\r\n#[test]\r\nfn test_block_build_single_key() {\r\n    let mut builder = BlockBuilder::new(16);\r\n    assert!(builder.add(KeySlice::for_testing_from_slice_no_ts(b\"233\"), b\"233333\"));\r\n    builder.build();\r\n}\r\n\r\n#[test]\r\nfn test_block_build_full() {\r\n    let mut builder = BlockBuilder::new(16);\r\n    assert!(builder.add(KeySlice::for_testing_from_slice_no_ts(b\"11\"), b\"11\"));\r\n    assert!(!builder.add(KeySlice::for_testing_from_slice_no_ts(b\"22\"), b\"22\"));\r\n    builder.build();\r\n}\r\n\r\n#[test]\r\nfn test_block_build_large_1() {\r\n    let mut builder = BlockBuilder::new(16);\r\n    assert!(builder.add(\r\n        KeySlice::for_testing_from_slice_no_ts(b\"11\"),\r\n        \u0026b\"1\".repeat(100)\r\n    ));\r\n    builder.build();\r\n}\r\n\r\n#[test]\r\nfn test_block_build_large_2() {\r\n    let mut builder = BlockBuilder::new(16);\r\n    assert!(builder.add(KeySlice::for_testing_from_slice_no_ts(b\"11\"), b\"1\"));\r\n    assert!(!builder.add(\r\n        KeySlice::for_testing_from_slice_no_ts(b\"11\"),\r\n        \u0026b\"1\".repeat(100)\r\n    ));\r\n}\r\n\r\nfn key_of(idx: usize) -\u003e KeyVec {\r\n    KeyVec::for_testing_from_vec_no_ts(format!(\"key_{:03}\", idx * 5).into_bytes())\r\n}\r\n\r\nfn value_of(idx: usize) -\u003e Vec\u003cu8\u003e {\r\n    format!(\"value_{:010}\", idx).into_bytes()\r\n}\r\n\r\nfn num_of_keys() -\u003e usize {\r\n    100\r\n}\r\n\r\nfn generate_block() -\u003e Block {\r\n    let mut builder = BlockBuilder::new(10000);\r\n    for idx in 0..num_of_keys() {\r\n        let key = key_of(idx);\r\n        let value = value_of(idx);\r\n        assert!(builder.add(key.as_key_slice(), \u0026value[..]));\r\n    }\r\n    builder.build()\r\n}\r\n\r\n#[test]\r\nfn test_block_build_all() {\r\n    generate_block();\r\n}\r\n\r\n#[test]\r\nfn test_block_encode() {\r\n    let block = generate_block();\r\n    block.encode();\r\n}\r\n\r\n#[test]\r\nfn test_block_decode() {\r\n    let block = generate_block();\r\n    let encoded = block.encode();\r\n    let decoded_block = Block::decode(\u0026encoded);\r\n    assert_eq!(block.offsets, decoded_block.offsets);\r\n    assert_eq!(block.data, decoded_block.data);\r\n}\r\n\r\nfn as_bytes(x: \u0026[u8]) -\u003e Bytes {\r\n    Bytes::copy_from_slice(x)\r\n}\r\n\r\n#[test]\r\nfn test_block_iterator() {\r\n    let block = Arc::new(generate_block());\r\n    let mut iter = BlockIterator::create_and_seek_to_first(block);\r\n    for _ in 0..5 {\r\n        for i in 0..num_of_keys() {\r\n            let key = iter.key();\r\n            let value = iter.value();\r\n            assert_eq!(\r\n                key.for_testing_key_ref(),\r\n                key_of(i).for_testing_key_ref(),\r\n                \"expected key: {:?}, actual key: {:?}\",\r\n                as_bytes(key_of(i).for_testing_key_ref()),\r\n                as_bytes(key.for_testing_key_ref())\r\n            );\r\n            assert_eq!(\r\n                value,\r\n                value_of(i),\r\n                \"expected value: {:?}, actual value: {:?}\",\r\n                as_bytes(\u0026value_of(i)),\r\n                as_bytes(value)\r\n            );\r\n            iter.next();\r\n        }\r\n        iter.seek_to_first();\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_block_seek_key() {\r\n    let block = Arc::new(generate_block());\r\n    let mut iter = BlockIterator::create_and_seek_to_key(block, key_of(0).as_key_slice());\r\n    for offset in 1..=5 {\r\n        for i in 0..num_of_keys() {\r\n            let key = iter.key();\r\n            let value = iter.value();\r\n            assert_eq!(\r\n                key.for_testing_key_ref(),\r\n                key_of(i).for_testing_key_ref(),\r\n                \"expected key: {:?}, actual key: {:?}\",\r\n                as_bytes(key_of(i).for_testing_key_ref()),\r\n                as_bytes(key.for_testing_key_ref())\r\n            );\r\n            assert_eq!(\r\n                value,\r\n                value_of(i),\r\n                \"expected value: {:?}, actual value: {:?}\",\r\n                as_bytes(\u0026value_of(i)),\r\n                as_bytes(value)\r\n            );\r\n            iter.seek_to_key(KeySlice::for_testing_from_slice_no_ts(\r\n                \u0026format!(\"key_{:03}\", i * 5 + offset).into_bytes(),\r\n            ));\r\n        }\r\n        iter.seek_to_key(KeySlice::for_testing_from_slice_no_ts(b\"k\"));\r\n    }\r\n}\r\n\r\n}","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":4755801206503244056},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":4755801206503244056},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":4755801206503244056},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":7710162562058289567},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":7133701809754865709},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":4755801206503244056},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":4755801206503244056},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":1441151880758560051},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1441151880758560051},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1441151880758560051},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1441151880758560051},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1441151880758560051},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1441151880758560051},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":7421932185906580070},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":1441151880758560051},"fn_name":null}],"covered":15,"coverable":15},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","compact","leveled.rs"],"content":"use std::collections::HashSet;\r\n\r\nuse serde::{Deserialize, Serialize};\r\nuse tracing::debug;\r\n\r\nuse crate::storage::engine::piggykv::lsm_storage::LsmStorageState;\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct LeveledCompactionTask {\r\n    // if upper_level is `None`, then it is L0 compaction\r\n    pub upper_level: Option\u003cusize\u003e,\r\n    pub upper_level_sst_ids: Vec\u003cusize\u003e,\r\n    pub lower_level: usize,\r\n    pub lower_level_sst_ids: Vec\u003cusize\u003e,\r\n    pub is_lower_level_bottom_level: bool,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\npub struct LeveledCompactionOptions {\r\n    pub level_size_multiplier: usize,\r\n    pub level0_file_num_compaction_trigger: usize,\r\n    pub max_levels: usize,\r\n    pub base_level_size_mb: usize,\r\n}\r\n\r\npub struct LeveledCompactionController {\r\n    options: LeveledCompactionOptions,\r\n}\r\n\r\nimpl LeveledCompactionController {\r\n    pub fn new(options: LeveledCompactionOptions) -\u003e Self {\r\n        Self { options }\r\n    }\r\n\r\n    fn find_overlapping_ssts(\r\n        \u0026self,\r\n        snapshot: \u0026LsmStorageState,\r\n        sst_ids: \u0026[usize],\r\n        in_level: usize,\r\n    ) -\u003e Vec\u003cusize\u003e {\r\n        let begin_key = sst_ids\r\n            .iter()\r\n            .map(|id| snapshot.sstables[id].first_key())\r\n            .min()\r\n            .cloned()\r\n            .unwrap();\r\n        let end_key = sst_ids\r\n            .iter()\r\n            .map(|id| snapshot.sstables[id].last_key())\r\n            .max()\r\n            .cloned()\r\n            .unwrap();\r\n        let mut overlap_ssts = Vec::new();\r\n        for sst_id in \u0026snapshot.levels[in_level - 1].1 {\r\n            let sst = \u0026snapshot.sstables[sst_id];\r\n            let first_key = sst.first_key();\r\n            let last_key = sst.last_key();\r\n            if !(last_key \u003c \u0026begin_key || first_key \u003e \u0026end_key) {\r\n                overlap_ssts.push(*sst_id);\r\n            }\r\n        }\r\n        overlap_ssts\r\n    }\r\n\r\n    pub fn generate_compaction_task(\r\n        \u0026self,\r\n        snapshot: \u0026LsmStorageState,\r\n    ) -\u003e Option\u003cLeveledCompactionTask\u003e {\r\n        // step 1: compute target level size\r\n        let mut target_level_size = (0..self.options.max_levels).map(|_| 0).collect::\u003cVec\u003c_\u003e\u003e(); // exclude level 0\r\n        let mut real_level_size = Vec::with_capacity(self.options.max_levels);\r\n        let mut base_level = self.options.max_levels;\r\n        for i in 0..self.options.max_levels {\r\n            real_level_size.push(\r\n                snapshot.levels[i]\r\n                    .1\r\n                    .iter()\r\n                    .map(|x| snapshot.sstables.get(x).unwrap().table_size())\r\n                    .sum::\u003cu64\u003e() as usize,\r\n            );\r\n        }\r\n        let base_level_size_bytes = self.options.base_level_size_mb * 1024 * 1024;\r\n\r\n        // select base level and compute target level size\r\n        target_level_size[self.options.max_levels - 1] =\r\n            real_level_size[self.options.max_levels - 1].max(base_level_size_bytes);\r\n        for i in (0..(self.options.max_levels - 1)).rev() {\r\n            let next_level_size = target_level_size[i + 1];\r\n            let this_level_size = next_level_size / self.options.level_size_multiplier;\r\n            if next_level_size \u003e base_level_size_bytes {\r\n                target_level_size[i] = this_level_size;\r\n            }\r\n            if target_level_size[i] \u003e 0 {\r\n                base_level = i + 1;\r\n            }\r\n        }\r\n\r\n        // Flush L0 SST is the top priority\r\n        if snapshot.l0_sstables.len() \u003e= self.options.level0_file_num_compaction_trigger {\r\n            debug!(\"flush L0 SST to base level {}\", base_level);\r\n            return Some(LeveledCompactionTask {\r\n                upper_level: None,\r\n                upper_level_sst_ids: snapshot.l0_sstables.clone(),\r\n                lower_level: base_level,\r\n                lower_level_sst_ids: self.find_overlapping_ssts(\r\n                    snapshot,\r\n                    \u0026snapshot.l0_sstables,\r\n                    base_level,\r\n                ),\r\n                is_lower_level_bottom_level: base_level == self.options.max_levels,\r\n            });\r\n        }\r\n        //\r\n        //\r\n        let mut priorities = Vec::with_capacity(self.options.max_levels);\r\n        for level in 0..self.options.max_levels {\r\n            let prio = real_level_size[level] as f64 / target_level_size[level] as f64;\r\n            //\r\n            if prio \u003e 1.0 {\r\n                //,\r\n                priorities.push((prio, level + 1));\r\n            }\r\n        }\r\n        priorities.sort_by(|a, b| a.partial_cmp(b).unwrap().reverse());\r\n        let priority = priorities.first(); //\r\n        if let Some((_, level)) = priority {\r\n            println!(\r\n                \"target level sizes: {:?}, real level sizes: {:?}, base_level: {}\",\r\n                target_level_size\r\n                    .iter()\r\n                    .map(|x| format!(\"{:.3}MB\", *x as f64 / 1024.0 / 1024.0))\r\n                    .collect::\u003cVec\u003c_\u003e\u003e(),\r\n                real_level_size\r\n                    .iter()\r\n                    .map(|x| format!(\"{:.3}MB\", *x as f64 / 1024.0 / 1024.0))\r\n                    .collect::\u003cVec\u003c_\u003e\u003e(),\r\n                base_level,\r\n            );\r\n            //\r\n            let level = *level;\r\n            // sst\r\n            let selected_sst = snapshot.levels[level - 1].1.iter().min().copied().unwrap();\r\n            println!(\r\n                \"compaction triggered by priority: {level} out of {:?}, select {selected_sst} for compaction\",\r\n                priorities\r\n            );\r\n            return Some(LeveledCompactionTask {\r\n                upper_level: Some(level),\r\n                upper_level_sst_ids: vec![selected_sst],\r\n                lower_level: level + 1,\r\n                lower_level_sst_ids: self.find_overlapping_ssts(\r\n                    snapshot,\r\n                    \u0026[selected_sst],\r\n                    level + 1,\r\n                ),\r\n                is_lower_level_bottom_level: level + 1 == self.options.max_levels,\r\n            });\r\n        }\r\n        None\r\n    }\r\n\r\n    pub fn apply_compaction_result(\r\n        \u0026self,\r\n        snapshot: \u0026LsmStorageState,\r\n        task: \u0026LeveledCompactionTask,\r\n        output: \u0026[usize],\r\n        in_recovery: bool,\r\n    ) -\u003e (LsmStorageState, Vec\u003cusize\u003e) {\r\n        let mut snapshot = snapshot.clone();\r\n        let mut files_to_remove = Vec::new();\r\n        let mut upper_level_sst_ids_set = task\r\n            .upper_level_sst_ids\r\n            .iter()\r\n            .copied()\r\n            .collect::\u003cHashSet\u003c_\u003e\u003e();\r\n        let mut lower_level_sst_ids_set = task\r\n            .lower_level_sst_ids\r\n            .iter()\r\n            .copied()\r\n            .collect::\u003cHashSet\u003c_\u003e\u003e();\r\n        if let Some(upper_level) = task.upper_level {\r\n            let new_upper_level_ssts = snapshot.levels[upper_level - 1]\r\n                .1\r\n                .iter()\r\n                .filter_map(|x| {\r\n                    if upper_level_sst_ids_set.remove(x) {\r\n                        return None;\r\n                    }\r\n                    Some(*x)\r\n                })\r\n                .collect::\u003cVec\u003c_\u003e\u003e();\r\n            assert!(upper_level_sst_ids_set.is_empty());\r\n            snapshot.levels[upper_level - 1].1 = new_upper_level_ssts;\r\n        } else {\r\n            let new_l0_ssts = snapshot\r\n                .l0_sstables\r\n                .iter()\r\n                .filter_map(|x| {\r\n                    if upper_level_sst_ids_set.remove(x) {\r\n                        return None;\r\n                    }\r\n                    Some(*x)\r\n                })\r\n                .collect::\u003cVec\u003c_\u003e\u003e();\r\n            assert!(upper_level_sst_ids_set.is_empty());\r\n            snapshot.l0_sstables = new_l0_ssts;\r\n        }\r\n\r\n        files_to_remove.extend(\u0026task.upper_level_sst_ids);\r\n        files_to_remove.extend(\u0026task.lower_level_sst_ids);\r\n\r\n        let mut new_lower_level_ssts = snapshot.levels[task.lower_level - 1]\r\n            .1\r\n            .iter()\r\n            .filter_map(|x| {\r\n                if lower_level_sst_ids_set.remove(x) {\r\n                    return None;\r\n                }\r\n                Some(*x)\r\n            })\r\n            .collect::\u003cVec\u003c_\u003e\u003e();\r\n        assert!(lower_level_sst_ids_set.is_empty());\r\n        new_lower_level_ssts.extend(output);\r\n        if !in_recovery {\r\n            new_lower_level_ssts.sort_by(|x, y| {\r\n                snapshot\r\n                    .sstables\r\n                    .get(x)\r\n                    .unwrap()\r\n                    .first_key()\r\n                    .cmp(snapshot.sstables.get(y).unwrap().first_key())\r\n            });\r\n        }\r\n        snapshot.levels[task.lower_level - 1].1 = new_lower_level_ssts;\r\n        (snapshot, files_to_remove)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n\r\n    use tempfile::tempdir;\r\n\r\n    use crate::storage::engine::piggykv::{compact::CompactionOptions, debug::{check_compaction_ratio, compaction_bench}, lsm_storage::LsmStorageOptions, PiggyKV};\r\n\r\n    use super::LeveledCompactionOptions;\r\n\r\n\r\n    #[test]\r\n    fn test_integration() {\r\n        let dir = tempdir().unwrap();\r\n        let storage = PiggyKV::open(\r\n            \u0026dir,\r\n            LsmStorageOptions::compaction_test(CompactionOptions::Leveled(\r\n                LeveledCompactionOptions {\r\n                    level0_file_num_compaction_trigger: 2,\r\n                    level_size_multiplier: 2,\r\n                    base_level_size_mb: 1,\r\n                    max_levels: 4,\r\n                },\r\n            )),\r\n        )\r\n        .unwrap();\r\n\r\n        compaction_bench(storage.clone());\r\n        check_compaction_ratio(storage.clone());\r\n    }\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4323455642275676160},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":4323455642275676160},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":6052837899185946624},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4755801206503243776},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":4755801206503243776},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":4755801206503243776},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":5908722711110090752},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":3891110078048108544},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":15060037153926938624},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":7998392938210000898},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":9871890383196127234},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":9871890383196127234},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":9871890383196127234},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2594073385365405698},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":11168927075878830080},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":11168927075878830080},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":18374686479671623681},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":7205759403792793601},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":18374686479671623680},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":2738188573441261570},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1585267068834414594},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1224979098644774918},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":10448351135499550720},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":3746994889972252672},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":3746994889972252672},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":8574853690513424384},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1297036692682702849},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1297036692682702849},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1297036692682702849},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1297036692682702849},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1297036692682702849},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1297036692682702849},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":1297036692682702849},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":2233785415175766018},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":5692549928996306944},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":5692549928996306944},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":4755801206503243776},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":6052837899185946624},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":4755801206503243776},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":4179340454199820288},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":6629298651489370112},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null}],"covered":97,"coverable":97},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","compact.rs"],"content":"mod leveled;\r\nuse std::collections::HashSet;\r\nuse std::sync::Arc;\r\nuse std::time::Duration;\r\n\r\nuse crate::errors::Result;\r\npub use leveled::{LeveledCompactionController, LeveledCompactionOptions, LeveledCompactionTask};\r\nuse serde::{Deserialize, Serialize};\r\nuse tracing::debug;\r\n\r\nuse super::iterators::concat_iterator::SstConcatIterator;\r\nuse super::iterators::merge_iterator::MergeIterator;\r\nuse super::iterators::two_merge_iterator::TwoMergeIterator;\r\nuse super::iterators::StorageIterator;\r\nuse super::key::KeySlice;\r\nuse super::lsm_storage::{LsmStorageInner, LsmStorageState};\r\nuse super::manifest::ManifestRecord;\r\nuse super::table::{SsTable, SsTableBuilder, SsTableIterator};\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub enum CompactionTask {\r\n    Leveled(LeveledCompactionTask),\r\n    ForceFullCompaction {\r\n        l0_sstables: Vec\u003cusize\u003e,\r\n        l1_sstables: Vec\u003cusize\u003e,\r\n    },\r\n}\r\n\r\nimpl CompactionTask {\r\n    fn compact_to_bottom_level(\u0026self) -\u003e bool {\r\n        match self {\r\n            CompactionTask::ForceFullCompaction { .. } =\u003e true,\r\n            CompactionTask::Leveled(task) =\u003e task.is_lower_level_bottom_level,\r\n        }\r\n    }\r\n}\r\n\r\npub(crate) enum CompactionController {\r\n    Leveled(LeveledCompactionController),\r\n    NoCompaction,\r\n}\r\n\r\nimpl CompactionController {\r\n    pub fn generate_compaction_task(\u0026self, snapshot: \u0026LsmStorageState) -\u003e Option\u003cCompactionTask\u003e {\r\n        match self {\r\n            CompactionController::Leveled(ctrl) =\u003e ctrl\r\n                .generate_compaction_task(snapshot)\r\n                .map(CompactionTask::Leveled),\r\n            CompactionController::NoCompaction =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    pub fn apply_compaction_result(\r\n        \u0026self,\r\n        snapshot: \u0026LsmStorageState,\r\n        task: \u0026CompactionTask,\r\n        output: \u0026[usize],\r\n        in_recovery: bool,\r\n    ) -\u003e (LsmStorageState, Vec\u003cusize\u003e) {\r\n        match (self, task) {\r\n            (CompactionController::Leveled(ctrl), CompactionTask::Leveled(task)) =\u003e {\r\n                ctrl.apply_compaction_result(snapshot, task, output, in_recovery)\r\n            }\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl CompactionController {\r\n    pub fn flush_to_l0(\u0026self) -\u003e bool {\r\n        matches!(self, Self::Leveled(_) | Self::NoCompaction)\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\npub enum CompactionOptions {\r\n    /// Leveled compaction with partial compaction + dynamic level support (= RocksDB's Leveled\r\n    /// Compaction)\r\n    Leveled(LeveledCompactionOptions),\r\n    /// In no compaction mode (week 1), always flush to L0\r\n    NoCompaction,\r\n}\r\n\r\nimpl LsmStorageInner {\r\n    fn compact_generate_sst_from_iter(\r\n        \u0026self,\r\n        mut iter: impl for\u003c'a\u003e StorageIterator\u003cKeyType\u003c'a\u003e = KeySlice\u003c'a\u003e\u003e,\r\n        compact_to_bottom_level: bool,\r\n    ) -\u003e Result\u003cVec\u003cArc\u003cSsTable\u003e\u003e\u003e {\r\n        let mut builder = None;\r\n        let mut new_sst = Vec::new();\r\n        let mut last_key = Vec::\u003cu8\u003e::new();\r\n        let watermark = self.mvcc().watermark();\r\n        let mut first_key_below_watermark = false;\r\n\r\n        while iter.is_valid() {\r\n            if builder.is_none() {\r\n                builder = Some(SsTableBuilder::new(self.options.block_size));\r\n            }\r\n            let same_as_last_key = iter.key().key_ref() == last_key;\r\n            if !same_as_last_key {\r\n                first_key_below_watermark = true;\r\n            }\r\n\r\n            if compact_to_bottom_level\r\n                \u0026\u0026 !same_as_last_key\r\n                \u0026\u0026 iter.key().ts() \u003c= watermark\r\n                \u0026\u0026 iter.value().is_empty()\r\n            {\r\n                last_key.clear();\r\n                last_key.extend(iter.key().key_ref());\r\n                iter._next()?;\r\n                first_key_below_watermark = false;\r\n                continue;\r\n            }\r\n\r\n            if same_as_last_key \u0026\u0026 iter.key().ts() \u003c= watermark {\r\n                if !first_key_below_watermark {\r\n                    iter._next()?;\r\n                    continue;\r\n                }\r\n                first_key_below_watermark = false;\r\n            }\r\n\r\n            let builder_inner = builder.as_mut().unwrap();\r\n            if builder_inner.estimated_size() \u003e= self.options.target_sst_size {\r\n                let sst_id = self.next_sst_id();\r\n                let old_builder = builder.take().unwrap();\r\n                let sst = Arc::new(old_builder.build(\r\n                    sst_id,\r\n                    Some(self.block_cache.clone()),\r\n                    self.options.bloom_false_positive_rate,\r\n                    self.path_of_sst(sst_id),\r\n                )?);\r\n                new_sst.push(sst);\r\n                builder = Some(SsTableBuilder::new(self.options.block_size));\r\n            }\r\n            let builder_inner = builder.as_mut().unwrap();\r\n            builder_inner.add(iter.key(), iter.value());\r\n\r\n            if !same_as_last_key {\r\n                last_key.clear();\r\n                last_key.extend(iter.key().key_ref());\r\n            }\r\n\r\n            iter._next()?;\r\n        }\r\n        if let Some(builder) = builder {\r\n            let sst_id = self.next_sst_id(); // lock dropped here\r\n            let sst = Arc::new(builder.build(\r\n                sst_id,\r\n                Some(self.block_cache.clone()),\r\n                self.options.bloom_false_positive_rate,\r\n                self.path_of_sst(sst_id),\r\n            )?);\r\n            new_sst.push(sst);\r\n        }\r\n        Ok(new_sst)\r\n    }\r\n\r\n    fn compact(\u0026self, task: \u0026CompactionTask) -\u003e Result\u003cVec\u003cArc\u003cSsTable\u003e\u003e\u003e {\r\n        let snapshot = {\r\n            let state = self.state.read();\r\n            state.clone()\r\n        };\r\n        match task {\r\n            CompactionTask::ForceFullCompaction {\r\n                l0_sstables,\r\n                l1_sstables,\r\n            } =\u003e {\r\n                let mut l0_iters = Vec::with_capacity(l0_sstables.len());\r\n                for id in l0_sstables.iter() {\r\n                    l0_iters.push(Box::new(SsTableIterator::create_and_seek_to_first(\r\n                        snapshot.sstables.get(id).unwrap().clone(),\r\n                    )?));\r\n                }\r\n                let mut l1_iters = Vec::with_capacity(l1_sstables.len());\r\n                for id in l1_sstables.iter() {\r\n                    l1_iters.push(snapshot.sstables.get(id).unwrap().clone());\r\n                }\r\n                let iter = TwoMergeIterator::create(\r\n                    MergeIterator::create(l0_iters),\r\n                    SstConcatIterator::create_and_seek_to_first(l1_iters)?,\r\n                )?;\r\n                self.compact_generate_sst_from_iter(iter, task.compact_to_bottom_level())\r\n            }\r\n            CompactionTask::Leveled(LeveledCompactionTask {\r\n                upper_level,\r\n                upper_level_sst_ids,\r\n                lower_level: _,\r\n                lower_level_sst_ids,\r\n                ..\r\n            }) =\u003e match upper_level {\r\n                Some(_) =\u003e {\r\n                    let mut upper_ssts = Vec::with_capacity(upper_level_sst_ids.len());\r\n                    for id in upper_level_sst_ids.iter() {\r\n                        upper_ssts.push(snapshot.sstables.get(id).unwrap().clone());\r\n                    }\r\n                    let upper_iter = SstConcatIterator::create_and_seek_to_first(upper_ssts)?;\r\n                    let mut lower_ssts = Vec::with_capacity(lower_level_sst_ids.len());\r\n                    for id in lower_level_sst_ids.iter() {\r\n                        lower_ssts.push(snapshot.sstables.get(id).unwrap().clone());\r\n                    }\r\n                    let lower_iter = SstConcatIterator::create_and_seek_to_first(lower_ssts)?;\r\n                    self.compact_generate_sst_from_iter(\r\n                        TwoMergeIterator::create(upper_iter, lower_iter)?,\r\n                        task.compact_to_bottom_level(),\r\n                    )\r\n                }\r\n                None =\u003e {\r\n                    let mut upper_iters = Vec::with_capacity(upper_level_sst_ids.len());\r\n                    for id in upper_level_sst_ids.iter() {\r\n                        upper_iters.push(Box::new(SsTableIterator::create_and_seek_to_first(\r\n                            snapshot.sstables.get(id).unwrap().clone(),\r\n                        )?));\r\n                    }\r\n                    let upper_iter = MergeIterator::create(upper_iters);\r\n                    let mut lower_ssts = Vec::with_capacity(lower_level_sst_ids.len());\r\n                    for id in lower_level_sst_ids.iter() {\r\n                        lower_ssts.push(snapshot.sstables.get(id).unwrap().clone());\r\n                    }\r\n                    let lower_iter = SstConcatIterator::create_and_seek_to_first(lower_ssts)?;\r\n                    self.compact_generate_sst_from_iter(\r\n                        TwoMergeIterator::create(upper_iter, lower_iter)?,\r\n                        task.compact_to_bottom_level(),\r\n                    )\r\n                }\r\n            },\r\n        }\r\n    }\r\n\r\n    pub fn force_full_compaction(\u0026self) -\u003e Result\u003c()\u003e {\r\n        let CompactionOptions::NoCompaction = self.options.compaction_options else {\r\n            panic!(\"full compaction can only be called with compaction is not enabled\")\r\n        };\r\n\r\n        let snapshot = {\r\n            let state = self.state.read();\r\n            state.clone()\r\n        };\r\n\r\n        let l0_sstables = snapshot.l0_sstables.clone();\r\n        let l1_sstables = snapshot.levels[0].1.clone();\r\n        let compaction_task = CompactionTask::ForceFullCompaction {\r\n            l0_sstables: l0_sstables.clone(),\r\n            l1_sstables: l1_sstables.clone(),\r\n        };\r\n\r\n        println!(\"force full compaction: {:?}\", compaction_task);\r\n\r\n        let sstables = self.compact(\u0026compaction_task)?;\r\n        let mut ids = Vec::with_capacity(sstables.len());\r\n\r\n        {\r\n            let state_lock = self.state_lock.lock();\r\n            let mut state = self.state.read().as_ref().clone();\r\n            for sst in l0_sstables.iter().chain(l1_sstables.iter()) {\r\n                let result = state.sstables.remove(sst);\r\n                assert!(result.is_some());\r\n            }\r\n            for new_sst in sstables {\r\n                ids.push(new_sst.sst_id());\r\n                let result = state.sstables.insert(new_sst.sst_id(), new_sst);\r\n                assert!(result.is_none());\r\n            }\r\n            assert_eq!(l1_sstables, state.levels[0].1);\r\n            state.levels[0].1 = ids.clone();\r\n            let mut l0_sstables_map = l0_sstables.iter().copied().collect::\u003cHashSet\u003c_\u003e\u003e();\r\n            state.l0_sstables = state\r\n                .l0_sstables\r\n                .iter()\r\n                .filter(|x| !l0_sstables_map.remove(x))\r\n                .copied()\r\n                .collect::\u003cVec\u003c_\u003e\u003e();\r\n            assert!(l0_sstables_map.is_empty());\r\n            *self.state.write() = Arc::new(state);\r\n            self.sync_dir()?;\r\n            self.manifest.as_ref().unwrap().add_record(\r\n                \u0026state_lock,\r\n                ManifestRecord::Compaction(compaction_task, ids.clone()),\r\n            )?;\r\n        }\r\n        for sst in l0_sstables.iter().chain(l1_sstables.iter()) {\r\n            std::fs::remove_file(self.path_of_sst(*sst))?;\r\n        }\r\n\r\n        println!(\"force full compaction done, new SSTs: {:?}\", ids);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn trigger_compaction(\u0026self) -\u003e Result\u003c()\u003e {\r\n        let snapshot = {\r\n            let state = self.state.read();\r\n            state.clone()\r\n        };\r\n        let task = self\r\n            .compaction_controller\r\n            .generate_compaction_task(\u0026snapshot);\r\n        let Some(task) = task else {\r\n            return Ok(());\r\n        };\r\n        // self.dump_structure();\r\n        debug!(\"running compaction task: {:?}\", task);\r\n        let sstables = self.compact(\u0026task)?;\r\n        let output = sstables.iter().map(|x| x.sst_id()).collect::\u003cVec\u003c_\u003e\u003e();\r\n        let ssts_to_remove = {\r\n            let state_lock = self.state_lock.lock();\r\n            let mut snapshot = self.state.read().as_ref().clone();\r\n            let mut new_sst_ids = Vec::new();\r\n            for file_to_add in sstables {\r\n                new_sst_ids.push(file_to_add.sst_id());\r\n                let result = snapshot.sstables.insert(file_to_add.sst_id(), file_to_add);\r\n                assert!(result.is_none());\r\n            }\r\n            let (mut snapshot, files_to_remove) = self\r\n                .compaction_controller\r\n                .apply_compaction_result(\u0026snapshot, \u0026task, \u0026output, false);\r\n            let mut ssts_to_remove = Vec::with_capacity(files_to_remove.len());\r\n            for file_to_remove in \u0026files_to_remove {\r\n                let result = snapshot.sstables.remove(file_to_remove);\r\n                assert!(result.is_some(), \"cannot remove {}.sst\", file_to_remove);\r\n                ssts_to_remove.push(result.unwrap());\r\n            }\r\n            let mut state = self.state.write();\r\n            *state = Arc::new(snapshot);\r\n            drop(state);\r\n            self.sync_dir()?;\r\n            self.manifest()\r\n                .add_record(\u0026state_lock, ManifestRecord::Compaction(task, new_sst_ids))?;\r\n            ssts_to_remove\r\n        };\r\n        debug!(\r\n            \"compaction finished: {} files removed, {} files added, output={:?}\",\r\n            ssts_to_remove.len(),\r\n            output.len(),\r\n            output\r\n        );\r\n        for sst in ssts_to_remove {\r\n            std::fs::remove_file(self.path_of_sst(sst.sst_id()))?;\r\n        }\r\n        self.sync_dir()?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub(crate) fn spawn_compaction_thread(\r\n        self: \u0026Arc\u003cSelf\u003e,\r\n        rx: crossbeam_channel::Receiver\u003c()\u003e,\r\n    ) -\u003e Result\u003cOption\u003cstd::thread::JoinHandle\u003c()\u003e\u003e\u003e {\r\n        if let CompactionOptions::Leveled(_) = self.options.compaction_options {\r\n            let this = self.clone();\r\n            let handle = std::thread::spawn(move || {\r\n                let ticker = crossbeam_channel::tick(Duration::from_millis(50));\r\n                loop {\r\n                    crossbeam_channel::select! {\r\n                        recv(ticker) -\u003e _ =\u003e if let Err(e) = this.trigger_compaction() {\r\n                            eprintln!(\"compaction failed: {}\", e);\r\n                        },\r\n                        recv(rx) -\u003e _ =\u003e return\r\n                    }\r\n                }\r\n            });\r\n            return Ok(Some(handle));\r\n        }\r\n        Ok(None)\r\n    }\r\n\r\n    fn trigger_flush(\u0026self) -\u003e Result\u003c()\u003e {\r\n        let res = {\r\n            let state = self.state.read();\r\n            state.imm_memtables.len() \u003e= self.options.num_memtable_limit\r\n        };\r\n        if res {\r\n            self.force_flush_next_imm_memtable()?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub(crate) fn spawn_flush_thread(\r\n        self: \u0026Arc\u003cSelf\u003e,\r\n        rx: crossbeam_channel::Receiver\u003c()\u003e,\r\n    ) -\u003e Result\u003cOption\u003cstd::thread::JoinHandle\u003c()\u003e\u003e\u003e {\r\n        let this = self.clone();\r\n        let handle = std::thread::spawn(move || {\r\n            let ticker = crossbeam_channel::tick(Duration::from_millis(50));\r\n            loop {\r\n                crossbeam_channel::select! {\r\n                    recv(ticker) -\u003e _ =\u003e if let Err(e) = this.trigger_flush() {\r\n                        eprintln!(\"flush failed: {}\", e);\r\n                    },\r\n                    recv(rx) -\u003e _ =\u003e return\r\n                }\r\n            }\r\n        });\r\n        Ok(Some(handle))\r\n    }\r\n}\r\n\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use std::{ops::Bound, path::Path, sync::Arc};\r\n\r\n    use bytes::Bytes;\r\n    use tempfile::tempdir;\r\n    use crate::storage::engine::piggykv::{debug::{check_iter_result_by_key, check_lsm_iter_result_by_key, construct_merge_iterator_over_storage, sync}, iterators::{concat_iterator::SstConcatIterator, StorageIterator}, key::{KeySlice, TS_ENABLED}, lsm_storage::{LsmStorageInner, LsmStorageOptions}, table::{bloom::Bloom, FileObject, SsTable, SsTableBuilder}};\r\n    #[test]\r\n    fn test_task1_full_compaction() {\r\n        // We do not use LSM iterator in this test because it's implemented as part of task 3\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(\u0026dir, LsmStorageOptions::default()).unwrap());\r\n        #[allow(clippy::let_unit_value)]\r\n        let _txn = storage.new_txn().unwrap();\r\n        storage.put(b\"0\", b\"v1\").unwrap();\r\n        sync(\u0026storage);\r\n        storage.put(b\"0\", b\"v2\").unwrap();\r\n        storage.put(b\"1\", b\"v2\").unwrap();\r\n        storage.put(b\"2\", b\"v2\").unwrap();\r\n        sync(\u0026storage);\r\n        storage.delete(b\"0\").unwrap();\r\n        storage.delete(b\"2\").unwrap();\r\n        sync(\u0026storage);\r\n        assert_eq!(storage.state.read().l0_sstables.len(), 3);\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.state.read());\r\n        if TS_ENABLED {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v1\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v2\")),\r\n                ],\r\n            );\r\n        } else {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"\")),\r\n                ],\r\n            );\r\n        }\r\n        storage.force_full_compaction().unwrap();\r\n        assert!(storage.state.read().l0_sstables.is_empty());\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.state.read());\r\n        if TS_ENABLED {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v1\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v2\")),\r\n                ],\r\n            );\r\n        } else {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![(Bytes::from_static(b\"1\"), Bytes::from_static(b\"v2\"))],\r\n            );\r\n        }\r\n        storage.put(b\"0\", b\"v3\").unwrap();\r\n        storage.put(b\"2\", b\"v3\").unwrap();\r\n        sync(\u0026storage);\r\n        storage.delete(b\"1\").unwrap();\r\n        sync(\u0026storage);\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.state.read());\r\n        if TS_ENABLED {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v3\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v1\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v3\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v2\")),\r\n                ],\r\n            );\r\n        } else {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v3\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v3\")),\r\n                ],\r\n            );\r\n        }\r\n        storage.force_full_compaction().unwrap();\r\n        assert!(storage.state.read().l0_sstables.is_empty());\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.state.read());\r\n        if TS_ENABLED {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v3\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v1\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v3\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v2\")),\r\n                ],\r\n            );\r\n        } else {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v3\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v3\")),\r\n                ],\r\n            );\r\n        }\r\n    }\r\n    \r\n    fn generate_concat_sst(\r\n        start_key: usize,\r\n        end_key: usize,\r\n        dir: impl AsRef\u003cPath\u003e,\r\n        id: usize,\r\n    ) -\u003e SsTable {\r\n        let mut builder = SsTableBuilder::new(128);\r\n        for idx in start_key..end_key {\r\n            let key = format!(\"{:05}\", idx);\r\n            builder.add(\r\n                KeySlice::for_testing_from_slice_no_ts(key.as_bytes()),\r\n                b\"test\",\r\n            );\r\n        }\r\n        let path = dir.as_ref().join(format!(\"{id}.sst\"));\r\n        builder.build_for_test(path).unwrap()\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task2_concat_iterator() {\r\n        let dir = tempdir().unwrap();\r\n        let mut sstables = Vec::new();\r\n        for i in 1..=10 {\r\n            sstables.push(Arc::new(generate_concat_sst(\r\n                i * 10,\r\n                (i + 1) * 10,\r\n                dir.path(),\r\n                i,\r\n            )));\r\n        }\r\n        for key in 0..120 {\r\n            let iter = SstConcatIterator::create_and_seek_to_key(\r\n                sstables.clone(),\r\n                KeySlice::for_testing_from_slice_no_ts(format!(\"{:05}\", key).as_bytes()),\r\n            )\r\n            .unwrap();\r\n            if key \u003c 10 {\r\n                assert!(iter.is_valid());\r\n                assert_eq!(iter.key().for_testing_key_ref(), b\"00010\");\r\n            } else if key \u003e= 110 {\r\n                assert!(!iter.is_valid());\r\n            } else {\r\n                assert!(iter.is_valid());\r\n                assert_eq!(\r\n                    iter.key().for_testing_key_ref(),\r\n                    format!(\"{:05}\", key).as_bytes()\r\n                );\r\n            }\r\n        }\r\n        let iter = SstConcatIterator::create_and_seek_to_first(sstables.clone()).unwrap();\r\n        assert!(iter.is_valid());\r\n        assert_eq!(iter.key().for_testing_key_ref(), b\"00010\");\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task3_integration() {\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(\u0026dir, LsmStorageOptions::default()).unwrap());\r\n        storage.put(b\"0\", b\"2333333\").unwrap();\r\n        storage.put(b\"00\", b\"2333333\").unwrap();\r\n        storage.put(b\"4\", b\"23\").unwrap();\r\n        sync(\u0026storage);\r\n    \r\n        storage.delete(b\"4\").unwrap();\r\n        sync(\u0026storage);\r\n    \r\n        storage.force_full_compaction().unwrap();\r\n        assert!(storage.state.read().l0_sstables.is_empty());\r\n        assert!(!storage.state.read().levels[0].1.is_empty());\r\n    \r\n        storage.put(b\"1\", b\"233\").unwrap();\r\n        storage.put(b\"2\", b\"2333\").unwrap();\r\n        sync(\u0026storage);\r\n    \r\n        storage.put(b\"00\", b\"2333\").unwrap();\r\n        storage.put(b\"3\", b\"23333\").unwrap();\r\n        storage.delete(b\"1\").unwrap();\r\n        sync(\u0026storage);\r\n        storage.force_full_compaction().unwrap();\r\n    \r\n        assert!(storage.state.read().l0_sstables.is_empty());\r\n        assert!(!storage.state.read().levels[0].1.is_empty());\r\n    \r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut storage.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"0\"), Bytes::from(\"2333333\")),\r\n                (Bytes::from(\"00\"), Bytes::from(\"2333\")),\r\n                (Bytes::from(\"2\"), Bytes::from(\"2333\")),\r\n                (Bytes::from(\"3\"), Bytes::from(\"23333\")),\r\n            ],\r\n        );\r\n    \r\n        assert_eq!(\r\n            storage.get(b\"0\").unwrap(),\r\n            Some(Bytes::from_static(b\"2333333\"))\r\n        );\r\n        assert_eq!(\r\n            storage.get(b\"00\").unwrap(),\r\n            Some(Bytes::from_static(b\"2333\"))\r\n        );\r\n        assert_eq!(\r\n            storage.get(b\"2\").unwrap(),\r\n            Some(Bytes::from_static(b\"2333\"))\r\n        );\r\n        assert_eq!(\r\n            storage.get(b\"3\").unwrap(),\r\n            Some(Bytes::from_static(b\"23333\"))\r\n        );\r\n        assert_eq!(storage.get(b\"4\").unwrap(), None);\r\n        assert_eq!(storage.get(b\"--\").unwrap(), None);\r\n        assert_eq!(storage.get(b\"555\").unwrap(), None);\r\n    }\r\n    \r\n}\r\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1945555039024054456},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1945555039024054456},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1945555039024054456},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1945555039024054456},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1945555039024054456},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1945555039024054456},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1945555039024054271},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":13186539708940812287},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":11961560610296036971},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":432345564227568511},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1152921504606847381},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1152921504606847381},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2305843009213694762},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1152921504606847381},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1152921504606847381},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":1152921504606847381},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1152921504606847381},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":3891110078048108544},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1801439850948198400},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":9871890383196127232},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":11168927075878830080},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":8574853690513424384},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":5908722711110090752},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":5908722711110090752},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":4539628424389459968},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":14627691589699371008},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":14627691589699371008},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":14627691589699371008},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":14627691589699371008},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":14627691589699371008},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":14627691589699371008},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":14843864371813154816},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null}],"covered":190,"coverable":200},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","debug.rs"],"content":"\r\nuse std::{collections::BTreeMap, ops::Bound, os::windows::fs::MetadataExt, path::Path, sync::Arc, time::Duration};\r\n\r\nuse bytes::Bytes;\r\nuse crate::{errors::{DatabaseError, Result}, storage::engine::piggykv::key::TS_ENABLED};\r\nuse super::{compact::{CompactionOptions, LeveledCompactionOptions}, iterators::{merge_iterator::MergeIterator, StorageIterator}, key::KeySlice, lsm_storage::{BlockCache, LsmStorageInner, LsmStorageState}, table::{SsTable, SsTableBuilder, SsTableIterator}, PiggyKV};\r\n\r\nimpl LsmStorageInner {\r\n    pub fn dump_structure(\u0026self) {\r\n        let snapshot = self.state.read();\r\n        if !snapshot.l0_sstables.is_empty() {\r\n            println!(\r\n                \"L0 ({}): {:?}\",\r\n                snapshot.l0_sstables.len(),\r\n                snapshot.l0_sstables,\r\n            );\r\n        }\r\n        for (level, files) in \u0026snapshot.levels {\r\n            println!(\"L{level} ({}): {:?}\", files.len(), files);\r\n        }\r\n    }\r\n}\r\n\r\nimpl PiggyKV {\r\n    pub fn dump_structure(\u0026self) {\r\n        self.inner.dump_structure()\r\n    }\r\n}\r\n\r\n#[derive(Clone)]\r\npub struct MockIterator {\r\n    pub data: Vec\u003c(Bytes, Bytes)\u003e,\r\n    pub error_when: Option\u003cusize\u003e,\r\n    pub index: usize,\r\n}\r\n\r\nimpl MockIterator {\r\n    pub fn new(data: Vec\u003c(Bytes, Bytes)\u003e) -\u003e Self {\r\n        Self {\r\n            data,\r\n            index: 0,\r\n            error_when: None,\r\n        }\r\n    }\r\n\r\n    pub fn new_with_error(data: Vec\u003c(Bytes, Bytes)\u003e, error_when: usize) -\u003e Self {\r\n        Self {\r\n            data,\r\n            index: 0,\r\n            error_when: Some(error_when),\r\n        }\r\n    }\r\n}\r\n\r\nimpl StorageIterator for MockIterator {\r\n    type KeyType\u003c'a\u003e = KeySlice\u003c'a\u003e;\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        if self.index \u003c self.data.len() {\r\n            self.index += 1;\r\n        }\r\n        if let Some(error_when) = self.error_when {\r\n            if self.index == error_when {\r\n                return Err(DatabaseError::InternalError(\"fake error!\".to_string()));\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn key(\u0026self) -\u003e KeySlice {\r\n        if let Some(error_when) = self.error_when {\r\n            if self.index \u003e= error_when {\r\n                panic!(\"invalid access after next returns an error!\");\r\n            }\r\n        }\r\n        KeySlice::for_testing_from_slice_no_ts(self.data[self.index].0.as_ref())\r\n    }\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        if let Some(error_when) = self.error_when {\r\n            if self.index \u003e= error_when {\r\n                panic!(\"invalid access after next returns an error!\");\r\n            }\r\n        }\r\n        self.data[self.index].1.as_ref()\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        if let Some(error_when) = self.error_when {\r\n            if self.index \u003e= error_when {\r\n                panic!(\"invalid access after next returns an error!\");\r\n            }\r\n        }\r\n        self.index \u003c self.data.len()\r\n    }\r\n}\r\n\r\npub fn as_bytes(x: \u0026[u8]) -\u003e Bytes {\r\n    Bytes::copy_from_slice(x)\r\n}\r\n\r\npub fn check_iter_result_by_key\u003cI\u003e(iter: \u0026mut I, expected: Vec\u003c(Bytes, Bytes)\u003e)\r\nwhere\r\n    I: for\u003c'a\u003e StorageIterator\u003cKeyType\u003c'a\u003e = KeySlice\u003c'a\u003e\u003e,\r\n{\r\n    for (k, v) in expected {\r\n        assert!(iter.is_valid());\r\n        assert_eq!(\r\n            k,\r\n            iter.key().for_testing_key_ref(),\r\n            \"expected key: {:?}, actual key: {:?}\",\r\n            k,\r\n            as_bytes(iter.key().for_testing_key_ref()),\r\n        );\r\n        assert_eq!(\r\n            v,\r\n            iter.value(),\r\n            \"expected value: {:?}, actual value: {:?}\",\r\n            v,\r\n            as_bytes(iter.value()),\r\n        );\r\n        iter._next().unwrap();\r\n    }\r\n    assert!(!iter.is_valid());\r\n}\r\n\r\n#[allow(dead_code)]\r\npub fn check_iter_result_by_key_and_ts\u003cI\u003e(iter: \u0026mut I, expected: Vec\u003c((Bytes, u64), Bytes)\u003e)\r\nwhere\r\n    I: for\u003c'a\u003e StorageIterator\u003cKeyType\u003c'a\u003e = KeySlice\u003c'a\u003e\u003e,\r\n{\r\n    for ((k, ts), v) in expected {\r\n        assert!(iter.is_valid());\r\n        assert_eq!(\r\n            (\u0026k[..], ts),\r\n            (\r\n                iter.key().for_testing_key_ref(),\r\n                iter.key().for_testing_ts()\r\n            ),\r\n            \"expected key: {:?}@{}, actual key: {:?}@{}\",\r\n            k,\r\n            ts,\r\n            as_bytes(iter.key().for_testing_key_ref()),\r\n            iter.key().for_testing_ts(),\r\n        );\r\n        assert_eq!(\r\n            v,\r\n            iter.value(),\r\n            \"expected value: {:?}, actual value: {:?}\",\r\n            v,\r\n            as_bytes(iter.value()),\r\n        );\r\n        iter._next().unwrap();\r\n    }\r\n    assert!(!iter.is_valid());\r\n}\r\n\r\npub fn check_lsm_iter_result_by_key\u003cI\u003e(iter: \u0026mut I, expected: Vec\u003c(Bytes, Bytes)\u003e)\r\nwhere\r\n    I: for\u003c'a\u003e StorageIterator\u003cKeyType\u003c'a\u003e = \u0026'a [u8]\u003e,\r\n{\r\n    for (k, v) in expected {\r\n        assert!(iter.is_valid());\r\n        assert_eq!(\r\n            k,\r\n            iter.key(),\r\n            \"expected key: {:?}, actual key: {:?}\",\r\n            k,\r\n            as_bytes(iter.key()),\r\n        );\r\n        assert_eq!(\r\n            v,\r\n            iter.value(),\r\n            \"expected value: {:?}, actual value: {:?}\",\r\n            v,\r\n            as_bytes(iter.value()),\r\n        );\r\n        iter._next().unwrap();\r\n    }\r\n    assert!(!iter.is_valid());\r\n}\r\n\r\npub fn expect_iter_error(mut iter: impl StorageIterator) {\r\n    loop {\r\n        match iter._next() {\r\n            Ok(_) if iter.is_valid() =\u003e continue,\r\n            Ok(_) =\u003e panic!(\"expect an error\"),\r\n            Err(_) =\u003e break,\r\n        }\r\n    }\r\n}\r\n\r\npub fn generate_sst(\r\n    id: usize,\r\n    path: impl AsRef\u003cPath\u003e,\r\n    data: Vec\u003c(Bytes, Bytes)\u003e,\r\n    block_cache: Option\u003cArc\u003cBlockCache\u003e\u003e,\r\n) -\u003e SsTable {\r\n    let mut builder = SsTableBuilder::new(128);\r\n    for (key, value) in data {\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(\u0026key[..]), \u0026value[..]);\r\n    }\r\n    builder.build(id, block_cache,0.01, path.as_ref()).unwrap()\r\n}\r\n\r\n#[allow(dead_code)]\r\npub fn generate_sst_with_ts(\r\n    id: usize,\r\n    path: impl AsRef\u003cPath\u003e,\r\n    data: Vec\u003c((Bytes, u64), Bytes)\u003e,\r\n    block_cache: Option\u003cArc\u003cBlockCache\u003e\u003e,\r\n) -\u003e SsTable {\r\n    let mut builder = SsTableBuilder::new(128);\r\n    for ((key, ts), value) in data {\r\n        builder.add(\r\n            KeySlice::for_testing_from_slice_with_ts(\u0026key[..], ts),\r\n            \u0026value[..],\r\n        );\r\n    }\r\n    builder.build(id, block_cache,0.01, path.as_ref()).unwrap()\r\n}\r\n\r\npub fn sync(storage: \u0026LsmStorageInner) {\r\n    storage\r\n        .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n        .unwrap();\r\n    storage.force_flush_next_imm_memtable().unwrap();\r\n}\r\n\r\npub fn compaction_bench(storage: Arc\u003cPiggyKV\u003e) {\r\n    let mut key_map = BTreeMap::\u003cusize, usize\u003e::new();\r\n    let gen_key = |i| format!(\"{:010}\", i); // 10B\r\n    let gen_value = |i| format!(\"{:0110}\", i); // 110B\r\n    let mut max_key = 0;\r\n    let overlaps = if TS_ENABLED { 10000 } else { 20000 };\r\n    for iter in 0..10 {\r\n        let range_begin = iter * 5000;\r\n        for i in range_begin..(range_begin + overlaps) {\r\n            // 120B per key, 4MB data populated\r\n            let key: String = gen_key(i);\r\n            let version = key_map.get(\u0026i).copied().unwrap_or_default() + 1;\r\n            let value = gen_value(version);\r\n            key_map.insert(i, version);\r\n            storage.put(key.as_bytes(), value.as_bytes()).unwrap();\r\n            max_key = max_key.max(i);\r\n        }\r\n    }\r\n\r\n    std::thread::sleep(Duration::from_secs(1)); // wait until all memtables flush\r\n    while {\r\n        let snapshot = storage.inner.state.read();\r\n        !snapshot.imm_memtables.is_empty()\r\n    } {\r\n        storage.inner.force_flush_next_imm_memtable().unwrap();\r\n    }\r\n\r\n    let mut prev_snapshot = storage.inner.state.read().clone();\r\n    while {\r\n        std::thread::sleep(Duration::from_secs(1));\r\n        let snapshot = storage.inner.state.read().clone();\r\n        let to_cont = prev_snapshot.levels != snapshot.levels\r\n            || prev_snapshot.l0_sstables != snapshot.l0_sstables;\r\n        prev_snapshot = snapshot;\r\n        to_cont\r\n    } {\r\n        println!(\"waiting for compaction to converge\");\r\n    }\r\n\r\n    let mut expected_key_value_pairs = Vec::new();\r\n    for i in 0..(max_key + 40000) {\r\n        let key = gen_key(i);\r\n        let value = storage.get(key.as_bytes()).unwrap();\r\n        if let Some(val) = key_map.get(\u0026i) {\r\n            let expected_value = gen_value(*val);\r\n            assert_eq!(value, Some(Bytes::from(expected_value.clone())));\r\n            expected_key_value_pairs.push((Bytes::from(key), Bytes::from(expected_value)));\r\n        } else {\r\n            assert!(value.is_none());\r\n        }\r\n    }\r\n\r\n    check_lsm_iter_result_by_key(\r\n        \u0026mut storage.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n        expected_key_value_pairs,\r\n    );\r\n\r\n    storage.dump_structure();\r\n\r\n    println!(\"This test case does not guarantee your compaction algorithm produces a LSM state as expected. It only does minimal checks on the size of the levels. Please use the compaction simulator to check if the compaction is correctly going on.\");\r\n}\r\n\r\npub fn check_compaction_ratio(storage: Arc\u003cPiggyKV\u003e) {\r\n    let state = storage.inner.state.read().clone();\r\n    let compaction_options = storage.inner.options.compaction_options.clone();\r\n    let mut level_size = Vec::new();\r\n    let l0_sst_num = state.l0_sstables.len();\r\n    for (_, files) in \u0026state.levels {\r\n        let size = match \u0026compaction_options {\r\n            CompactionOptions::Leveled(_) =\u003e files\r\n                .iter()\r\n                .map(|x| state.sstables.get(x).as_ref().unwrap().table_size())\r\n                .sum::\u003cu64\u003e(),\r\n            _ =\u003e unreachable!(),\r\n        };\r\n        level_size.push(size);\r\n    }\r\n    let extra_iterators = if TS_ENABLED {\r\n        1 /* txn local iterator for OCC */\r\n    } else {\r\n        0\r\n    };\r\n    let num_iters = storage\r\n        .scan(Bound::Unbounded, Bound::Unbounded)\r\n        .unwrap()\r\n        .num_active_iterators();\r\n    let num_memtables = storage.inner.state.read().imm_memtables.len() + 1;\r\n    match compaction_options {\r\n        CompactionOptions::NoCompaction =\u003e unreachable!(),\r\n        CompactionOptions::Leveled(LeveledCompactionOptions {\r\n            level_size_multiplier,\r\n            level0_file_num_compaction_trigger,\r\n            max_levels,\r\n            ..\r\n        }) =\u003e {\r\n            assert!(l0_sst_num \u003c level0_file_num_compaction_trigger);\r\n            assert!(level_size.len() \u003c= max_levels);\r\n            let last_level_size = *level_size.last().unwrap();\r\n            let mut multiplier = 1.0;\r\n            for idx in (1..level_size.len()).rev() {\r\n                multiplier *= level_size_multiplier as f64;\r\n                let this_size = level_size[idx - 1];\r\n                assert!(\r\n                    // do not add hard requirement on level size multiplier considering bloom filters...\r\n                    this_size as f64 / last_level_size as f64 \u003c= 1.0 / multiplier + 0.5,\r\n                    \"L{}/L_max, {}/{}\u003e\u003e1.0/{}\",\r\n                    state.levels[idx - 1].0,\r\n                    this_size,\r\n                    last_level_size,\r\n                    multiplier\r\n                );\r\n            }\r\n            assert!(\r\n                num_iters \u003c= l0_sst_num + num_memtables + max_levels + extra_iterators,\r\n                \"we found {num_iters} iterators in your implementation, (l0_sst_num={l0_sst_num}, num_memtables={num_memtables}, max_levels={max_levels}) did you use concat iterators?\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\npub fn dump_files_in_dir(path: impl AsRef\u003cPath\u003e) {\r\n    println!(\"--- DIR DUMP ---\");\r\n    for f in path.as_ref().read_dir().unwrap() {\r\n        let f = f.unwrap();\r\n        print!(\"{}\", f.path().display());\r\n        println!(\r\n            \", size={:.3}KB\",\r\n            f.metadata().unwrap().file_size() as f64 / 1024.0\r\n        );\r\n    }\r\n}\r\n\r\npub fn construct_merge_iterator_over_storage(\r\n    state: \u0026LsmStorageState,\r\n) -\u003e MergeIterator\u003cSsTableIterator\u003e {\r\n    let mut iters = Vec::new();\r\n    for t in \u0026state.l0_sstables {\r\n        iters.push(Box::new(\r\n            SsTableIterator::create_and_seek_to_first(state.sstables.get(t).cloned().unwrap())\r\n                .unwrap(),\r\n        ));\r\n    }\r\n    for (_, files) in \u0026state.levels {\r\n        for f in files {\r\n            iters.push(Box::new(\r\n                SsTableIterator::create_and_seek_to_first(state.sstables.get(f).cloned().unwrap())\r\n                    .unwrap(),\r\n            ));\r\n        }\r\n    }\r\n    MergeIterator::create(iters)\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":6269010681299730432},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":12538021362599460864},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6269010681299730432},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6413125869375586304},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":8718968878589280255},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":8358680908399640578},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":17942340915444056064},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":18158513697557839872},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":17942340915444056064},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":14483576401623515136},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":7638104968020361001},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":2377900603251621673},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2377900603251621673},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":2377900603251621673},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":2377900603251621673},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":2377900603251621673},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2377900603251621673},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":18446744073709551401},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":18446744073709551401},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":2377900603251621888},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":2882303761517117655},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":13258597302978740224},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":8718968878589281017},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":144115188075856262},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":144115188075856262},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":72057594037928326},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":17221764975064776333},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":15564440312192434332},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":4539628424389460339},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":72057594037928092},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":72057594037928092},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":72057594037928092},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":72057594037928092},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":72057594037928092},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":648518346341351580},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":936748722493063773},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":2377900603251621888},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null}],"covered":154,"coverable":184},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","iterators","concat_iterator.rs"],"content":"use std::sync::Arc;\r\nuse crate::errors::Result;\r\n\r\n\r\nuse crate::storage::engine::piggykv::{key::KeySlice, table::{SsTable, SsTableIterator}};\r\n\r\nuse super::StorageIterator;\r\n\r\n/// Concat multiple iterators ordered in key order and their key ranges do not overlap. We do not want to create the\r\n/// iterators when initializing this iterator to reduce the overhead of seeking.\r\npub struct SstConcatIterator {\r\n    current: Option\u003cSsTableIterator\u003e,\r\n    next_sst_idx: usize,\r\n    sstables: Vec\u003cArc\u003cSsTable\u003e\u003e,\r\n}\r\n\r\nimpl SstConcatIterator {\r\n    fn check_sst_valid(sstables: \u0026[Arc\u003cSsTable\u003e]) {\r\n        for sst in sstables {\r\n            assert!(sst.first_key() \u003c= sst.last_key());\r\n        }\r\n        if !sstables.is_empty() {\r\n            for i in 0..(sstables.len() - 1) {\r\n                assert!(sstables[i].last_key() \u003c sstables[i + 1].first_key());\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn create_and_seek_to_first(sstables: Vec\u003cArc\u003cSsTable\u003e\u003e) -\u003e Result\u003cSelf\u003e {\r\n        Self::check_sst_valid(\u0026sstables);\r\n        if sstables.is_empty() {\r\n            return Ok(Self {\r\n                current: None,\r\n                next_sst_idx: 0,\r\n                sstables,\r\n            });\r\n        }\r\n        let mut iter = Self {\r\n            current: Some(SsTableIterator::create_and_seek_to_first(\r\n                sstables[0].clone(),\r\n            )?),\r\n            next_sst_idx: 1,\r\n            sstables,\r\n        };\r\n        iter.move_until_valid()?;\r\n        Ok(iter)\r\n    }\r\n\r\n    pub fn create_and_seek_to_key(sstables: Vec\u003cArc\u003cSsTable\u003e\u003e, key: KeySlice) -\u003e Result\u003cSelf\u003e {\r\n        Self::check_sst_valid(\u0026sstables);\r\n        let idx: usize = sstables\r\n            .partition_point(|table| table.first_key().as_key_slice() \u003c= key)\r\n            .saturating_sub(1);\r\n        if idx \u003e= sstables.len() {\r\n            return Ok(Self {\r\n                current: None,\r\n                next_sst_idx: sstables.len(),\r\n                sstables,\r\n            });\r\n        }\r\n        let mut iter = Self {\r\n            current: Some(SsTableIterator::create_and_seek_to_key(\r\n                sstables[idx].clone(),\r\n                key,\r\n            )?),\r\n            next_sst_idx: idx + 1,\r\n            sstables,\r\n        };\r\n        iter.move_until_valid()?;\r\n        Ok(iter)\r\n    }\r\n\r\n    fn move_until_valid(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        while let Some(iter) = self.current.as_mut() {\r\n            if iter.is_valid() {\r\n                break;\r\n            }\r\n            if self.next_sst_idx \u003e= self.sstables.len() {\r\n                self.current = None;\r\n            } else {\r\n                self.current = Some(SsTableIterator::create_and_seek_to_first(\r\n                    self.sstables[self.next_sst_idx].clone(),\r\n                )?);\r\n                self.next_sst_idx += 1;\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl StorageIterator for SstConcatIterator {\r\n    type KeyType\u003c'a\u003e = KeySlice\u003c'a\u003e;\r\n\r\n    fn key(\u0026self) -\u003e KeySlice {\r\n        self.current.as_ref().unwrap().key()\r\n    }\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        self.current.as_ref().unwrap().value()\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        if let Some(current) = \u0026self.current {\r\n            assert!(current.is_valid());\r\n            true\r\n        } else {\r\n            false\r\n        }\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        self.current.as_mut().unwrap()._next()?;\r\n        self.move_until_valid()?;\r\n        Ok(())\r\n    }\r\n\r\n    fn num_active_iterators(\u0026self) -\u003e usize {\r\n        1\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":12465963768561535704},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1513209474796486856},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":5476377146882522043},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":6917529027641082051},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":6052837899185946624},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6052837899185946624},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":6052837899185946624},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":3819052484010180608},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3819052484010180608},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3819052484010180608},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3819052484010180608},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":13907115649320091648},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":13907115649320091648},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":13907115649320091648},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":9367487224930631680},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":13907115649320091648},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":17582052945254417871},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":17582052945254417871},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":17582052945254417871},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":17582052945254417871},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":14771806777775226880},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":2305843009213694147},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":9295429630892706318},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":18086456103519911936},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6341068275337660747},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2666130979403334724},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2017612633061982403},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1008806316530991299},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":10232178353385766912},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":10232178353385766912},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":10808639105689197697},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":10808639105689197697},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3746994889972254369},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":14051230837395941712},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":10304235947423698645},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":11889503016258118642},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":3746994889972258076},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":3746994889972258972},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":3746994889972257180},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":3746994889972252672},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":864691128455136128},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":864691128455136128},"fn_name":null}],"covered":46,"coverable":48},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","iterators","merge_iterator.rs"],"content":"use std::cmp::{self};\r\nuse std::collections::binary_heap::PeekMut;\r\nuse std::collections::BinaryHeap;\r\n\r\nuse crate::errors::Result;\r\nuse crate::storage::engine::piggykv::key::KeySlice;\r\n\r\n\r\nuse super::StorageIterator;\r\n\r\nstruct HeapWrapper\u003cI: StorageIterator\u003e(pub usize, pub Box\u003cI\u003e);\r\n\r\nimpl\u003cI: StorageIterator\u003e PartialEq for HeapWrapper\u003cI\u003e {\r\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n        self.partial_cmp(other).unwrap() == cmp::Ordering::Equal\r\n    }\r\n}\r\n\r\nimpl\u003cI: StorageIterator\u003e Eq for HeapWrapper\u003cI\u003e {}\r\n\r\nimpl\u003cI: StorageIterator\u003e PartialOrd for HeapWrapper\u003cI\u003e {\r\n    #[allow(clippy::non_canonical_partial_ord_impl)]\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003ccmp::Ordering\u003e {\r\n        match self.1.key().cmp(\u0026other.1.key()) {\r\n            cmp::Ordering::Greater =\u003e Some(cmp::Ordering::Greater),\r\n            cmp::Ordering::Less =\u003e Some(cmp::Ordering::Less),\r\n            cmp::Ordering::Equal =\u003e self.0.partial_cmp(\u0026other.0),\r\n        }\r\n        .map(|x| x.reverse())\r\n    }\r\n}\r\n\r\nimpl\u003cI: StorageIterator\u003e Ord for HeapWrapper\u003cI\u003e {\r\n    fn cmp(\u0026self, other: \u0026Self) -\u003e cmp::Ordering {\r\n        self.partial_cmp(other).unwrap()\r\n    }\r\n}\r\n\r\n/// Merge multiple iterators of the same type. If the same key occurs multiple times in some\r\n/// iterators, perfer the one with smaller index.\r\npub struct MergeIterator\u003cI: StorageIterator\u003e {\r\n    iters: BinaryHeap\u003cHeapWrapper\u003cI\u003e\u003e,\r\n    current: Option\u003cHeapWrapper\u003cI\u003e\u003e,\r\n}\r\n\r\nimpl\u003cI: StorageIterator\u003e MergeIterator\u003cI\u003e {\r\n    pub fn create(iters: Vec\u003cBox\u003cI\u003e\u003e) -\u003e Self {\r\n        if iters.is_empty() {\r\n            return Self {\r\n                iters: BinaryHeap::new(),\r\n                current: None,\r\n            };\r\n        }\r\n\r\n        let mut heap = BinaryHeap::new();\r\n\r\n        if iters.iter().all(|x| !x.is_valid()) {\r\n            // All invalid, select the last one as the current.\r\n            let mut iters = iters;\r\n            return Self {\r\n                iters: heap,\r\n                current: Some(HeapWrapper(0, iters.pop().unwrap())),\r\n            };\r\n        }\r\n\r\n        for (idx, iter) in iters.into_iter().enumerate() {\r\n            if iter.is_valid() {\r\n                heap.push(HeapWrapper(idx, iter));\r\n            }\r\n        }\r\n\r\n        let current = heap.pop().unwrap();\r\n        Self {\r\n            iters: heap,\r\n            current: Some(current),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cI: 'static + for\u003c'a\u003e StorageIterator\u003cKeyType\u003c'a\u003e = KeySlice\u003c'a\u003e\u003e\u003e StorageIterator\r\n    for MergeIterator\u003cI\u003e\r\n{\r\n    type KeyType\u003c'a\u003e = KeySlice\u003c'a\u003e;\r\n\r\n    fn key(\u0026self) -\u003e KeySlice {\r\n        self.current.as_ref().unwrap().1.key()\r\n    }\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        self.current.as_ref().unwrap().1.value()\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        self.current\r\n            .as_ref()\r\n            .map(|x| x.1.is_valid())\r\n            .unwrap_or(false)\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        let current = self.current.as_mut().unwrap();\r\n        // Pop the item out of the heap if they have the same value.\r\n        while let Some(mut inner_iter) = self.iters.peek_mut() {\r\n            debug_assert!(\r\n                inner_iter.1.key() \u003e= current.1.key(),\r\n                \"heap invariant violated\"\r\n            );\r\n            if inner_iter.1.key() == current.1.key() {\r\n                // Case 1: an error occurred when calling `next`.\r\n                if let e @ Err(_) = inner_iter.1._next() {\r\n                    PeekMut::pop(inner_iter);\r\n                    return e;\r\n                }\r\n\r\n                // Case 2: iter is no longer valid.\r\n                if !inner_iter.1.is_valid() {\r\n                    PeekMut::pop(inner_iter);\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        current.1._next()?;\r\n\r\n        // If the current iterator is invalid, pop it out of the heap and select the next one.\r\n        if !current.1.is_valid() {\r\n            if let Some(iter) = self.iters.pop() {\r\n                *current = iter;\r\n            }\r\n            return Ok(());\r\n        }\r\n\r\n        // Otherwise, compare with heap top and swap if necessary.\r\n        if let Some(mut inner_iter) = self.iters.peek_mut() {\r\n            if *current \u003c *inner_iter {\r\n                std::mem::swap(\u0026mut *inner_iter, current);\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn num_active_iterators(\u0026self) -\u003e usize {\r\n        self.iters\r\n            .iter()\r\n            .map(|x| x.1.num_active_iterators())\r\n            .sum::\u003cusize\u003e()\r\n            + self\r\n                .current\r\n                .as_ref()\r\n                .map(|x| x.1.num_active_iterators())\r\n                .unwrap_or(0)\r\n    }\r\n}\r\n\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use std::{ops::Bound, sync::Arc, time::Duration};\r\n\r\n    use bytes::Bytes;\r\n\r\n    use crate::storage::engine::piggykv::{debug::{check_iter_result_by_key, check_lsm_iter_result_by_key, generate_sst, sync, MockIterator}, iterators::{two_merge_iterator::TwoMergeIterator, StorageIterator}, key::{KeySlice, KeyVec}, lsm_storage::{LsmStorageInner, LsmStorageOptions}, PiggyKV};\r\n    use tempfile::{tempdir, TempDir};\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_task1_merge_1() {\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n        ]);\r\n        let i2 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.2\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n        ]);\r\n        let mut iter = TwoMergeIterator::create(i1, i2).unwrap();\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n                (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n            ],\r\n        )\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task1_merge_2() {\r\n        let i2 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n        ]);\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.2\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n        ]);\r\n        let mut iter = TwoMergeIterator::create(i1, i2).unwrap();\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.2\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n                (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n            ],\r\n        )\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task1_merge_3() {\r\n        let i2 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n        ]);\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n        ]);\r\n        let mut iter = TwoMergeIterator::create(i1, i2).unwrap();\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n                (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n            ],\r\n        )\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task1_merge_4() {\r\n        let i2 = MockIterator::new(vec![]);\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n        ]);\r\n        let mut iter = TwoMergeIterator::create(i1, i2).unwrap();\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n                (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n            ],\r\n        );\r\n        let i1 = MockIterator::new(vec![]);\r\n        let i2 = MockIterator::new(vec![\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n        ]);\r\n        let mut iter = TwoMergeIterator::create(i1, i2).unwrap();\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n                (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n            ],\r\n        );\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task1_merge_5() {\r\n        let i2 = MockIterator::new(vec![]);\r\n        let i1 = MockIterator::new(vec![]);\r\n        let mut iter = TwoMergeIterator::create(i1, i2).unwrap();\r\n        check_iter_result_by_key(\u0026mut iter, vec![])\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task2_storage_scan() {\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(\u0026dir, LsmStorageOptions::default()).unwrap());\r\n        storage.put(b\"1\", b\"233\").unwrap();\r\n        storage.put(b\"2\", b\"2333\").unwrap();\r\n        storage.put(b\"00\", b\"2333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        storage.put(b\"3\", b\"23333\").unwrap();\r\n        storage.delete(b\"1\").unwrap();\r\n        let sst1 = generate_sst(\r\n            10,\r\n            dir.path().join(\"10.sst\"),\r\n            vec![\r\n                (Bytes::from_static(b\"0\"), Bytes::from_static(b\"2333333\")),\r\n                (Bytes::from_static(b\"00\"), Bytes::from_static(b\"2333333\")),\r\n                (Bytes::from_static(b\"4\"), Bytes::from_static(b\"23\")),\r\n            ],\r\n            Some(storage.block_cache.clone()),\r\n        );\r\n        let sst2 = generate_sst(\r\n            11,\r\n            dir.path().join(\"11.sst\"),\r\n            vec![(Bytes::from_static(b\"4\"), Bytes::from_static(b\"\"))],\r\n            Some(storage.block_cache.clone()),\r\n        );\r\n        {\r\n            let mut state = storage.state.write();\r\n            let mut snapshot = state.as_ref().clone();\r\n            snapshot.l0_sstables.push(sst2.sst_id()); // this is the latest SST\r\n            snapshot.l0_sstables.push(sst1.sst_id());\r\n            snapshot.sstables.insert(sst2.sst_id(), sst2.into());\r\n            snapshot.sstables.insert(sst1.sst_id(), sst1.into());\r\n            *state = snapshot.into();\r\n        }\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut storage.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"0\"), Bytes::from(\"2333333\")),\r\n                (Bytes::from(\"00\"), Bytes::from(\"2333\")),\r\n                (Bytes::from(\"2\"), Bytes::from(\"2333\")),\r\n                (Bytes::from(\"3\"), Bytes::from(\"23333\")),\r\n            ],\r\n        );\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut storage\r\n                .scan(Bound::Included(b\"1\"), Bound::Included(b\"2\"))\r\n                .unwrap(),\r\n            vec![(Bytes::from(\"2\"), Bytes::from(\"2333\"))],\r\n        );\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut storage\r\n                .scan(Bound::Excluded(b\"1\"), Bound::Excluded(b\"3\"))\r\n                .unwrap(),\r\n            vec![(Bytes::from(\"2\"), Bytes::from(\"2333\"))],\r\n        );\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut storage\r\n                .scan(Bound::Included(b\"0\"), Bound::Included(b\"1\"))\r\n                .unwrap(),\r\n            vec![\r\n                (Bytes::from_static(b\"0\"), Bytes::from_static(b\"2333333\")),\r\n                (Bytes::from(\"00\"), Bytes::from(\"2333\")),\r\n            ],\r\n        );\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut storage\r\n                .scan(Bound::Excluded(b\"0\"), Bound::Included(b\"1\"))\r\n                .unwrap(),\r\n            vec![(Bytes::from(\"00\"), Bytes::from(\"2333\"))],\r\n        );\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task3_storage_get() {\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(\u0026dir, LsmStorageOptions::default()).unwrap());\r\n        storage.put(b\"1\", b\"233\").unwrap();\r\n        storage.put(b\"2\", b\"2333\").unwrap();\r\n        storage.put(b\"00\", b\"2333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        storage.put(b\"3\", b\"23333\").unwrap();\r\n        storage.delete(b\"1\").unwrap();\r\n        let sst1 = generate_sst(\r\n            10,\r\n            dir.path().join(\"10.sst\"),\r\n            vec![\r\n                (Bytes::from_static(b\"0\"), Bytes::from_static(b\"2333333\")),\r\n                (Bytes::from_static(b\"00\"), Bytes::from_static(b\"2333333\")),\r\n                (Bytes::from_static(b\"4\"), Bytes::from_static(b\"23\")),\r\n            ],\r\n            Some(storage.block_cache.clone()),\r\n        );\r\n        let sst2 = generate_sst(\r\n            11,\r\n            dir.path().join(\"11.sst\"),\r\n            vec![(Bytes::from_static(b\"4\"), Bytes::from_static(b\"\"))],\r\n            Some(storage.block_cache.clone()),\r\n        );\r\n        {\r\n            let mut state = storage.state.write();\r\n            let mut snapshot = state.as_ref().clone();\r\n            snapshot.l0_sstables.push(sst2.sst_id()); // this is the latest SST\r\n            snapshot.l0_sstables.push(sst1.sst_id());\r\n            snapshot.sstables.insert(sst2.sst_id(), sst2.into());\r\n            snapshot.sstables.insert(sst1.sst_id(), sst1.into());\r\n            *state = snapshot.into();\r\n        }\r\n        assert_eq!(\r\n            storage.get(b\"0\").unwrap(),\r\n            Some(Bytes::from_static(b\"2333333\"))\r\n        );\r\n        assert_eq!(\r\n            storage.get(b\"00\").unwrap(),\r\n            Some(Bytes::from_static(b\"2333\"))\r\n        );\r\n        assert_eq!(\r\n            storage.get(b\"2\").unwrap(),\r\n            Some(Bytes::from_static(b\"2333\"))\r\n        );\r\n        assert_eq!(\r\n            storage.get(b\"3\").unwrap(),\r\n            Some(Bytes::from_static(b\"23333\"))\r\n        );\r\n        assert_eq!(storage.get(b\"4\").unwrap(), None);\r\n        assert_eq!(storage.get(b\"--\").unwrap(), None);\r\n        assert_eq!(storage.get(b\"555\").unwrap(), None);\r\n    }\r\n    #[test]\r\nfn test_task1_storage_scan() {\r\n    let dir = tempdir().unwrap();\r\n    let storage =\r\n        Arc::new(LsmStorageInner::open(\u0026dir, LsmStorageOptions::default()).unwrap());\r\n    storage.put(b\"0\", b\"2333333\").unwrap();\r\n    storage.put(b\"00\", b\"2333333\").unwrap();\r\n    storage.put(b\"4\", b\"23\").unwrap();\r\n    sync(\u0026storage);\r\n\r\n    storage.delete(b\"4\").unwrap();\r\n    sync(\u0026storage);\r\n\r\n    storage.put(b\"1\", b\"233\").unwrap();\r\n    storage.put(b\"2\", b\"2333\").unwrap();\r\n    storage\r\n        .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n        .unwrap();\r\n    storage.put(b\"00\", b\"2333\").unwrap();\r\n    storage\r\n        .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n        .unwrap();\r\n    storage.put(b\"3\", b\"23333\").unwrap();\r\n    storage.delete(b\"1\").unwrap();\r\n\r\n    {\r\n        let state = storage.state.read();\r\n        assert_eq!(state.l0_sstables.len(), 2);\r\n        assert_eq!(state.imm_memtables.len(), 2);\r\n    }\r\n\r\n    check_lsm_iter_result_by_key(\r\n        \u0026mut storage.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n        vec![\r\n            (Bytes::from(\"0\"), Bytes::from(\"2333333\")),\r\n            (Bytes::from(\"00\"), Bytes::from(\"2333\")),\r\n            (Bytes::from(\"2\"), Bytes::from(\"2333\")),\r\n            (Bytes::from(\"3\"), Bytes::from(\"23333\")),\r\n        ],\r\n    );\r\n    check_lsm_iter_result_by_key(\r\n        \u0026mut storage\r\n            .scan(Bound::Included(b\"1\"), Bound::Included(b\"2\"))\r\n            .unwrap(),\r\n        vec![(Bytes::from(\"2\"), Bytes::from(\"2333\"))],\r\n    );\r\n    check_lsm_iter_result_by_key(\r\n        \u0026mut storage\r\n            .scan(Bound::Excluded(b\"1\"), Bound::Excluded(b\"3\"))\r\n            .unwrap(),\r\n        vec![(Bytes::from(\"2\"), Bytes::from(\"2333\"))],\r\n    );\r\n}\r\n\r\n#[test]\r\nfn test_task1_storage_get() {\r\n    let dir = tempdir().unwrap();\r\n    let storage =\r\n        Arc::new(LsmStorageInner::open(\u0026dir, LsmStorageOptions::default()).unwrap());\r\n    storage.put(b\"0\", b\"2333333\").unwrap();\r\n    storage.put(b\"00\", b\"2333333\").unwrap();\r\n    storage.put(b\"4\", b\"23\").unwrap();\r\n    sync(\u0026storage);\r\n\r\n    storage.delete(b\"4\").unwrap();\r\n    sync(\u0026storage);\r\n\r\n    storage.put(b\"1\", b\"233\").unwrap();\r\n    storage.put(b\"2\", b\"2333\").unwrap();\r\n    storage\r\n        .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n        .unwrap();\r\n    storage.put(b\"00\", b\"2333\").unwrap();\r\n    storage\r\n        .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n        .unwrap();\r\n    storage.put(b\"3\", b\"23333\").unwrap();\r\n    storage.delete(b\"1\").unwrap();\r\n\r\n    {\r\n        let state = storage.state.read();\r\n        assert_eq!(state.l0_sstables.len(), 2);\r\n        assert_eq!(state.imm_memtables.len(), 2);\r\n    }\r\n\r\n    assert_eq!(\r\n        storage.get(b\"0\").unwrap(),\r\n        Some(Bytes::from_static(b\"2333333\"))\r\n    );\r\n    assert_eq!(\r\n        storage.get(b\"00\").unwrap(),\r\n        Some(Bytes::from_static(b\"2333\"))\r\n    );\r\n    assert_eq!(\r\n        storage.get(b\"2\").unwrap(),\r\n        Some(Bytes::from_static(b\"2333\"))\r\n    );\r\n    assert_eq!(\r\n        storage.get(b\"3\").unwrap(),\r\n        Some(Bytes::from_static(b\"23333\"))\r\n    );\r\n    assert_eq!(storage.get(b\"4\").unwrap(), None);\r\n    assert_eq!(storage.get(b\"--\").unwrap(), None);\r\n    assert_eq!(storage.get(b\"555\").unwrap(), None);\r\n}\r\n\r\n#[test]\r\nfn test_task2_auto_flush() {\r\n    let dir = tempdir().unwrap();\r\n    let storage = PiggyKV::open(\u0026dir, LsmStorageOptions::default()).unwrap();\r\n\r\n    let value = \"1\".repeat(1024); // 1KB\r\n\r\n    // approximately 6MB\r\n    for i in 0..6000 {\r\n        storage\r\n            .put(format!(\"{i}\").as_bytes(), value.as_bytes())\r\n            .unwrap();\r\n    }\r\n\r\n    std::thread::sleep(Duration::from_millis(500));\r\n\r\n    assert!(!storage.inner.state.read().l0_sstables.is_empty());\r\n}\r\n\r\n#[test]\r\nfn test_task3_sst_filter() {\r\n    let dir = tempdir().unwrap();\r\n    let storage =\r\n        Arc::new(LsmStorageInner::open(\u0026dir, LsmStorageOptions::default()).unwrap());\r\n\r\n    for i in 1..=10000 {\r\n        if i % 1000 == 0 {\r\n            sync(\u0026storage);\r\n        }\r\n        storage\r\n            .put(format!(\"{:05}\", i).as_bytes(), b\"2333333\")\r\n            .unwrap();\r\n    }\r\n\r\n    let iter = storage.scan(Bound::Unbounded, Bound::Unbounded).unwrap();\r\n    assert!(\r\n        iter.num_active_iterators() \u003e= 10,\r\n        \"did you implement num_active_iterators? current active iterators = {}\",\r\n        iter.num_active_iterators()\r\n    );\r\n    let max_num = iter.num_active_iterators();\r\n    let iter = storage\r\n        .scan(\r\n            Bound::Excluded(format!(\"{:05}\", 10000).as_bytes()),\r\n            Bound::Unbounded,\r\n        )\r\n        .unwrap();\r\n    assert!(iter.num_active_iterators() \u003c max_num);\r\n    let min_num = iter.num_active_iterators();\r\n    let iter = storage\r\n        .scan(\r\n            Bound::Unbounded,\r\n            Bound::Excluded(format!(\"{:05}\", 1).as_bytes()),\r\n        )\r\n        .unwrap();\r\n    assert_eq!(iter.num_active_iterators(), min_num);\r\n    let iter = storage\r\n        .scan(\r\n            Bound::Unbounded,\r\n            Bound::Included(format!(\"{:05}\", 0).as_bytes()),\r\n        )\r\n        .unwrap();\r\n    assert_eq!(iter.num_active_iterators(), min_num);\r\n    let iter = storage\r\n        .scan(\r\n            Bound::Included(format!(\"{:05}\", 10001).as_bytes()),\r\n            Bound::Unbounded,\r\n        )\r\n        .unwrap();\r\n    assert_eq!(iter.num_active_iterators(), min_num);\r\n    let iter = storage\r\n        .scan(\r\n            Bound::Included(format!(\"{:05}\", 5000).as_bytes()),\r\n            Bound::Excluded(format!(\"{:05}\", 6000).as_bytes()),\r\n        )\r\n        .unwrap();\r\n    assert!(min_num \u003c= iter.num_active_iterators() \u0026\u0026 iter.num_active_iterators() \u003c max_num);\r\n}\r\n\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1297036692682703422},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2089670227099911260},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2089670227099911260},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2089670227099911260},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":17293822569102703751},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":15348267530078650906},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":15492382718154506781},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":15492382718154506781},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":18446744073709551613},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1224979098644777024},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1369094286720632896},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":554},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":5476377146882522581},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":13690942867206307840},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":13690942867206308027},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":13690942867206308027},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":5764607523034234894},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":6124895493223874574},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null}],"covered":59,"coverable":64},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","iterators","two_merge_iterator.rs"],"content":"use crate::errors::Result;\r\n\r\nuse super::StorageIterator;\r\n\r\n/// Merges two iterators of different types into one. If the two iterators have the same key, only\r\n/// produce the key once and prefer the entry from A.\r\npub struct TwoMergeIterator\u003cA: StorageIterator, B: StorageIterator\u003e {\r\n    a: A,\r\n    b: B,\r\n    choose_a: bool,\r\n}\r\n\r\nimpl\u003c\r\n        A: 'static + StorageIterator,\r\n        B: 'static + for\u003c'a\u003e StorageIterator\u003cKeyType\u003c'a\u003e = A::KeyType\u003c'a\u003e\u003e,\r\n    \u003e TwoMergeIterator\u003cA, B\u003e\r\n{\r\n    fn choose_a(a: \u0026A, b: \u0026B) -\u003e bool {\r\n        if !a.is_valid() {\r\n            return false;\r\n        }\r\n        if !b.is_valid() {\r\n            return true;\r\n        }\r\n        a.key() \u003c b.key()\r\n    }\r\n\r\n    fn skip_b(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        if self.a.is_valid() \u0026\u0026 self.b.is_valid() \u0026\u0026 self.b.key() == self.a.key() {\r\n            self.b._next()?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub fn create(a: A, b: B) -\u003e Result\u003cSelf\u003e {\r\n        let mut iter = Self {\r\n            choose_a: false,\r\n            a,\r\n            b,\r\n        };\r\n        iter.skip_b()?;\r\n        iter.choose_a = Self::choose_a(\u0026iter.a, \u0026iter.b);\r\n        Ok(iter)\r\n    }\r\n}\r\n\r\nimpl\u003c\r\n        A: 'static + StorageIterator,\r\n        B: 'static + for\u003c'a\u003e StorageIterator\u003cKeyType\u003c'a\u003e = A::KeyType\u003c'a\u003e\u003e,\r\n    \u003e StorageIterator for TwoMergeIterator\u003cA, B\u003e\r\n{\r\n    type KeyType\u003c'a\u003e = A::KeyType\u003c'a\u003e;\r\n\r\n    fn key(\u0026self) -\u003e A::KeyType\u003c'_\u003e {\r\n        if self.choose_a {\r\n            self.a.key()\r\n        } else {\r\n            self.b.key()\r\n        }\r\n    }\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        if self.choose_a {\r\n            self.a.value()\r\n        } else {\r\n            self.b.value()\r\n        }\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        if self.choose_a {\r\n            self.a.is_valid()\r\n        } else {\r\n            self.b.is_valid()\r\n        }\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        if self.choose_a {\r\n            self.a._next()?;\r\n        } else {\r\n            self.b._next()?;\r\n        }\r\n        self.skip_b()?;\r\n        self.choose_a = Self::choose_a(\u0026self.a, \u0026self.b);\r\n        Ok(())\r\n    }\r\n\r\n    fn num_active_iterators(\u0026self) -\u003e usize {\r\n        self.a.num_active_iterators() + self.b.num_active_iterators()\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":18446744073709551613},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":743},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":813},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2161727821137838295},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2161727821137838295},"fn_name":null}],"covered":35,"coverable":35},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","iterators.rs"],"content":"pub mod concat_iterator;\r\npub mod merge_iterator;\r\npub mod two_merge_iterator;\r\nuse crate::errors::Result;\r\n\r\npub trait StorageIterator {\r\n    type KeyType\u003c'a\u003e: PartialEq + Eq + PartialOrd + Ord\r\n    where\r\n        Self: 'a;\r\n\r\n    /// Get the current value.\r\n    fn value(\u0026self) -\u003e \u0026[u8];\r\n\r\n    /// Get the current key.\r\n    fn key(\u0026self) -\u003e Self::KeyType\u003c'_\u003e;\r\n\r\n    /// Check if the current iterator is valid.\r\n    fn is_valid(\u0026self) -\u003e bool;\r\n\r\n    /// Move to the next position.\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e;\r\n\r\n    /// Number of underlying active iterators for this iterator.\r\n    fn num_active_iterators(\u0026self) -\u003e usize {\r\n        1\r\n    }\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":3098476543630901248},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3098476543630901248},"fn_name":null}],"covered":2,"coverable":2},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","key.rs"],"content":"use std::{cmp::Reverse, fmt::Debug};\r\n\r\nuse bytes::Bytes;\r\n\r\npub struct Key\u003cT: AsRef\u003c[u8]\u003e\u003e(T, u64);\r\n\r\npub type KeySlice\u003c'a\u003e = Key\u003c\u0026'a [u8]\u003e;\r\npub type KeyVec = Key\u003cVec\u003cu8\u003e\u003e;\r\npub type KeyBytes = Key\u003cBytes\u003e;\r\n\r\n/// For testing purpose, should not use anywhere in your implementation.\r\npub const TS_ENABLED: bool = true;\r\n\r\n/// Temporary, should remove after implementing full week 3 day 1 + 2.\r\npub const TS_DEFAULT: u64 = 0;\r\n\r\npub const TS_MAX: u64 = std::u64::MAX;\r\npub const TS_MIN: u64 = std::u64::MIN;\r\npub const TS_RANGE_BEGIN: u64 = std::u64::MAX;\r\npub const TS_RANGE_END: u64 = std::u64::MIN;\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e\u003e Key\u003cT\u003e {\r\n    pub fn into_inner(self) -\u003e T {\r\n        self.0\r\n    }\r\n\r\n    pub fn key_len(\u0026self) -\u003e usize {\r\n        self.0.as_ref().len()\r\n    }\r\n\r\n    pub fn raw_len(\u0026self) -\u003e usize {\r\n        self.0.as_ref().len() + std::mem::size_of::\u003cu64\u003e()\r\n    }\r\n\r\n    pub fn is_empty(\u0026self) -\u003e bool {\r\n        self.0.as_ref().is_empty()\r\n    }\r\n    pub fn for_testing_ts(self) -\u003e u64 {\r\n        self.1\r\n    }\r\n\r\n}\r\n\r\nimpl Key\u003cVec\u003cu8\u003e\u003e {\r\n    pub fn new() -\u003e Self {\r\n        Self(Vec::new(), TS_DEFAULT)\r\n    }\r\n\r\n    /// Create a `KeyVec` from a `Vec\u003cu8\u003e` and a ts. Will be removed in week 3.\r\n    pub fn from_vec_with_ts(key: Vec\u003cu8\u003e, ts: u64) -\u003e Self {\r\n        Self(key, ts)\r\n    }\r\n\r\n    /// Clears the key and set ts to 0.\r\n    pub fn clear(\u0026mut self) {\r\n        self.0.clear()\r\n    }\r\n\r\n    /// Append a slice to the end of the key\r\n    pub fn append(\u0026mut self, data: \u0026[u8]) {\r\n        self.0.extend(data)\r\n    }\r\n\r\n    pub fn set_ts(\u0026mut self, ts: u64) {\r\n        self.1 = ts;\r\n    }\r\n\r\n    /// Set the key from a slice without re-allocating.\r\n    pub fn set_from_slice(\u0026mut self, key_slice: KeySlice) {\r\n        self.0.clear();\r\n        self.0.extend(key_slice.0);\r\n        self.1 = key_slice.1;\r\n    }\r\n\r\n    pub fn as_key_slice(\u0026self) -\u003e KeySlice {\r\n        Key(self.0.as_slice(), self.1)\r\n    }\r\n\r\n    pub fn into_key_bytes(self) -\u003e KeyBytes {\r\n        Key(self.0.into(), self.1)\r\n    }\r\n\r\n    pub fn key_ref(\u0026self) -\u003e \u0026[u8] {\r\n        self.0.as_ref()\r\n    }\r\n\r\n    pub fn ts(\u0026self) -\u003e u64 {\r\n        self.1\r\n    }\r\n\r\n    pub fn for_testing_key_ref(\u0026self) -\u003e \u0026[u8] {\r\n        self.0.as_ref()\r\n    }\r\n\r\n    pub fn for_testing_from_vec_no_ts(key: Vec\u003cu8\u003e) -\u003e Self {\r\n        Self(key, TS_DEFAULT)\r\n    }\r\n}\r\n\r\nimpl Key\u003cBytes\u003e {\r\n    pub fn new() -\u003e Self {\r\n        Self(Bytes::new(), TS_DEFAULT)\r\n    }\r\n\r\n    pub fn as_key_slice(\u0026self) -\u003e KeySlice {\r\n        Key(\u0026self.0, self.1)\r\n    }\r\n\r\n    /// Create a `KeyBytes` from a `Bytes` and a ts.\r\n    pub fn from_bytes_with_ts(bytes: Bytes, ts: u64) -\u003e KeyBytes {\r\n        Key(bytes, ts)\r\n    }\r\n\r\n    pub fn key_ref(\u0026self) -\u003e \u0026[u8] {\r\n        self.0.as_ref()\r\n    }\r\n\r\n    pub fn ts(\u0026self) -\u003e u64 {\r\n        self.1\r\n    }\r\n\r\n    pub fn for_testing_from_bytes_no_ts(bytes: Bytes) -\u003e KeyBytes {\r\n        Key(bytes, TS_DEFAULT)\r\n    }\r\n\r\n    pub fn for_testing_key_ref(\u0026self) -\u003e \u0026[u8] {\r\n        self.0.as_ref()\r\n    }\r\n    \r\n}\r\n\r\nimpl\u003c'a\u003e Key\u003c\u0026'a [u8]\u003e {\r\n    pub fn to_key_vec(self) -\u003e KeyVec {\r\n        Key(self.0.to_vec(), self.1)\r\n    }\r\n\r\n    /// Create a key slice from a slice. Will be removed in week 3.\r\n    pub fn from_slice(slice: \u0026'a [u8], ts: u64) -\u003e Self {\r\n        Self(slice, ts)\r\n    }\r\n\r\n    pub fn key_ref(self) -\u003e \u0026'a [u8] {\r\n        self.0\r\n    }\r\n\r\n    pub fn ts(\u0026self) -\u003e u64 {\r\n        self.1\r\n    }\r\n\r\n    pub fn for_testing_key_ref(self) -\u003e \u0026'a [u8] {\r\n        self.0\r\n    }\r\n\r\n    pub fn for_testing_from_slice_no_ts(slice: \u0026'a [u8]) -\u003e Self {\r\n        Self(slice, TS_DEFAULT)\r\n    }\r\n    pub fn for_testing_from_slice_with_ts(slice: \u0026'a [u8], ts: u64) -\u003e Self {\r\n        Self(slice, ts)\r\n    }\r\n\r\n\r\n}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + Debug\u003e Debug for Key\u003cT\u003e {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        self.0.fmt(f)\r\n    }\r\n}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + Default\u003e Default for Key\u003cT\u003e {\r\n    fn default() -\u003e Self {\r\n        Self(T::default(), TS_DEFAULT)\r\n    }\r\n}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + PartialEq\u003e PartialEq for Key\u003cT\u003e {\r\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n        (self.0.as_ref(), self.1).eq(\u0026(other.0.as_ref(), other.1))\r\n    }\r\n}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + Eq\u003e Eq for Key\u003cT\u003e {}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + Clone\u003e Clone for Key\u003cT\u003e {\r\n    fn clone(\u0026self) -\u003e Self {\r\n        Self(self.0.clone(), self.1)\r\n    }\r\n}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + Copy\u003e Copy for Key\u003cT\u003e {}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + PartialOrd\u003e PartialOrd for Key\u003cT\u003e {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cstd::cmp::Ordering\u003e {\r\n        (self.0.as_ref(), Reverse(self.1)).partial_cmp(\u0026(other.0.as_ref(), Reverse(other.1)))\r\n    }\r\n}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + Ord\u003e Ord for Key\u003cT\u003e {\r\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\r\n        (self.0.as_ref(), Reverse(self.1)).cmp(\u0026(other.0.as_ref(), Reverse(other.1)))\r\n    }\r\n}\r\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":7205759403792794977},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":7205759403792794977},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":11240984669916758016},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":11240984669916758016},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1297036692682703174},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":1297036692682703174},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":9007199254740992280},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":9007199254740992280},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":13402712491054598818},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":13402712491054598818},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6701356245527303392},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":6701356245527303392},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":15780613094306220656},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":15780613094306220656},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":15780613094306220656},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":15780613094306220656},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":7277816997830722911},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":7277816997830722911},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":11529215046068483631},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":11529215046068483631},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":6701356245527298601},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":6701356245527298601},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":15132094747964869232},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":15132094747964869232},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":6341068275337658375},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":6341068275337658375},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":4899916394579099659},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":4899916394579099659},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":8935141660703064802},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":8935141660703064802},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":10232178353385779935},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":10232178353385779935},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":9223372036854776553},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":9223372036854776553},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":9223372036854775898},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":9223372036854775898},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855962},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":144115188075855962},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":9007199254740992508},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":9007199254740992508},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":18374686479671626407},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":18374686479671626407},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":9295429630892743226},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":9295429630892743226},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":2594073385365410981},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2594073385365410981},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2233785415175766025},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":2233785415175766025},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":7782220156096217095},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":7782220156096217095},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":9223372036854775808},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":9223372036854775808},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":13907115649320091865},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":13907115649320091865},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":1441151880758559863},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":1441151880758559863},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null}],"covered":68,"coverable":76},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","lsm_iterator.rs"],"content":"use std::ops::Bound;\r\n\r\nuse crate::errors::{DatabaseError, Result};\r\nuse bytes::Bytes;\r\n\r\n\r\nuse super::iterators::concat_iterator::SstConcatIterator;\r\nuse super::iterators::merge_iterator::MergeIterator;\r\nuse super::iterators::two_merge_iterator::TwoMergeIterator;\r\nuse super::iterators::StorageIterator;\r\nuse super::mem_table::MemTableIterator;\r\nuse super::table::SsTableIterator;\r\n\r\n/// Represents the internal type for an LSM iterator. This type will be changed across the tutorial for multiple times.\r\ntype LsmIteratorInner = TwoMergeIterator\u003c\r\n    TwoMergeIterator\u003cMergeIterator\u003cMemTableIterator\u003e, MergeIterator\u003cSsTableIterator\u003e\u003e,\r\n    MergeIterator\u003cSstConcatIterator\u003e,\r\n\u003e;\r\n\r\npub struct LsmIterator {\r\n    inner: LsmIteratorInner,\r\n    end_bound: Bound\u003cBytes\u003e,\r\n    is_valid: bool,\r\n    read_ts: u64,\r\n    prev_key: Vec\u003cu8\u003e,\r\n}\r\n\r\nimpl LsmIterator {\r\n    pub(crate) fn new(\r\n        iter: LsmIteratorInner,\r\n        end_bound: Bound\u003cBytes\u003e,\r\n        read_ts: u64,\r\n    ) -\u003e Result\u003cSelf\u003e {\r\n        let mut iter = Self {\r\n            is_valid: iter.is_valid(),\r\n            inner: iter,\r\n            end_bound,\r\n            read_ts,\r\n            prev_key: Vec::new(),\r\n        };\r\n        iter.move_to_key()?;\r\n        Ok(iter)\r\n    }\r\n\r\n    fn next_inner(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        self.inner._next()?;\r\n        if !self.inner.is_valid() {\r\n            self.is_valid = false;\r\n            return Ok(());\r\n        }\r\n\r\n        match self.end_bound.as_ref() {\r\n            Bound::Unbounded =\u003e {}\r\n            Bound::Included(key) =\u003e self.is_valid = self.inner.key().key_ref() \u003c= key.as_ref(),\r\n            Bound::Excluded(key) =\u003e self.is_valid = self.inner.key().key_ref() \u003c key.as_ref(),\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn move_to_key(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        loop {\r\n            while self.inner.is_valid() \u0026\u0026 self.inner.key().key_ref() == self.prev_key {\r\n                self.next_inner()?;\r\n            }\r\n            if !self.inner.is_valid() {\r\n                break;\r\n            }\r\n            self.prev_key.clear();\r\n            self.prev_key.extend(self.inner.key().key_ref());\r\n            while self.inner.is_valid()\r\n                \u0026\u0026 self.inner.key().key_ref() == self.prev_key\r\n                \u0026\u0026 self.inner.key().ts() \u003e self.read_ts\r\n            {\r\n                self.next_inner()?;\r\n            }\r\n            if !self.inner.is_valid() {\r\n                break;\r\n            }\r\n            if self.inner.key().key_ref() != self.prev_key {\r\n                continue;\r\n            }\r\n            if !self.inner.value().is_empty() {\r\n                break;\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl StorageIterator for LsmIterator {\r\n    type KeyType\u003c'a\u003e = \u0026'a [u8];\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        self.is_valid\r\n    }\r\n\r\n    fn key(\u0026self) -\u003e \u0026[u8] {\r\n        self.inner.key().key_ref()\r\n    }\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        self.inner.value()\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        self.next_inner()?;\r\n        self.move_to_key()?;\r\n        Ok(())\r\n    }\r\n\r\n    fn num_active_iterators(\u0026self) -\u003e usize {\r\n        self.inner.num_active_iterators()\r\n    }\r\n}\r\n\r\n/// A wrapper around existing iterator, will prevent users from calling `next` when the iterator is\r\n/// invalid. If an iterator is already invalid, `next` does not do anything. If `next` returns an error,\r\n/// `is_valid` should return false, and `next` should always return an error.\r\npub struct FusedIterator\u003cI: StorageIterator\u003e {\r\n    iter: I,\r\n    has_errored: bool,\r\n}\r\n\r\nimpl\u003cI: StorageIterator\u003e FusedIterator\u003cI\u003e {\r\n    pub fn new(iter: I) -\u003e Self {\r\n        Self {\r\n            iter,\r\n            has_errored: false,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cI: StorageIterator\u003e StorageIterator for FusedIterator\u003cI\u003e {\r\n    type KeyType\u003c'a\u003e = I::KeyType\u003c'a\u003e where Self: 'a;\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        !self.has_errored \u0026\u0026 self.iter.is_valid()\r\n    }\r\n\r\n    fn key(\u0026self) -\u003e Self::KeyType\u003c'_\u003e {\r\n        if !self.is_valid() {\r\n            panic!(\"invalid access to the underlying iterator\");\r\n        }\r\n        self.iter.key()\r\n    }\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        if !self.is_valid() {\r\n            panic!(\"invalid access to the underlying iterator\");\r\n        }\r\n        self.iter.value()\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        // only move when the iterator is valid and not errored\r\n        if self.has_errored {\r\n            return Err(DatabaseError::InternalError(\"the iterator is tainted\".to_string()));\r\n        }\r\n        if self.iter.is_valid() {\r\n            if let Err(e) = self.iter._next() {\r\n                self.has_errored = true;\r\n                return Err(e);\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn num_active_iterators(\u0026self) -\u003e usize {\r\n        self.iter.num_active_iterators()\r\n    }\r\n}\r\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":5692549928996306949},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":5692549928996306949},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":5692549928996306949},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":5692549928996307321},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":5692549928996306577},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":7782220156096217480},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":7782220156096216696},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1585267068834414200},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":9223372036854775808},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":720575940379279751},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1585267068834414983},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":17582052945254416384},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":13835058055282164710},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":5404319552844595455},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1441151880758559052},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":18302628885633696175},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1585267068834414493},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1585267068834414493},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":10520408729537478557},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":9295429630892703645},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":9223372036854775709},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":8935141660703063965},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1224979098644775342},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":360287970189639250},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":72057594037928523},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":288230376151710727},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":16501189034685497500},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":17582052945254417401},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":8430738502437568943},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":8430738502437568943},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":10952754293765048370},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":10952754293765048370},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":12321848580485677702},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":12321848580485677702},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":11889503016258110301},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":11889503016258110516},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":11889503016258110086},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":11889503016258109440},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":720575940379279575},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":720575940379279575},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":15708555500268290048},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":12898309332789099034},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":7277816997830721536},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":7277816997830721536},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":18446744073709551185},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":7277816997830721967},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":5404319552844595631},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":5404319552844595631},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":5404319552844595631},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":12754194144713245103},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":12754194144713245103},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":144115188075856087},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":12610078956637389016},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":12033618204333965313},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":12538021362599461079},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null}],"covered":65,"coverable":66},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","lsm_storage.rs"],"content":"use std::collections::{BTreeSet, HashMap};\r\n\r\nuse std::ops::Bound;\r\nuse std::path::{Path, PathBuf};\r\nuse std::sync::atomic::AtomicUsize;\r\nuse std::sync::Arc;\r\n\r\nuse crate::errors::Result;\r\nuse bytes::Bytes;\r\nuse derive_with::With;\r\nuse parking_lot::{Mutex, MutexGuard, RwLock};\r\nuse tracing::debug;\r\n\r\nuse super::block::Block;\r\nuse super::compact::{\r\n    CompactionController, CompactionOptions, LeveledCompactionController, LeveledCompactionOptions,\r\n};\r\nuse super::iterators::concat_iterator::SstConcatIterator;\r\nuse super::iterators::merge_iterator::MergeIterator;\r\nuse super::iterators::two_merge_iterator::TwoMergeIterator;\r\nuse super::iterators::StorageIterator;\r\nuse super::key::{self, KeySlice};\r\nuse super::lsm_iterator::{FusedIterator, LsmIterator};\r\nuse super::manifest::{Manifest, ManifestRecord};\r\nuse super::mem_table::{map_bound, map_key_bound_plus_ts, MemTable};\r\nuse super::mvcc::txn::{Transaction, TxnIterator};\r\nuse super::mvcc::LsmMvccInner;\r\nuse super::table::{FileObject, SsTable, SsTableBuilder, SsTableIterator};\r\n\r\npub type BlockCache = moka::sync::Cache\u003c(usize, usize), Arc\u003cBlock\u003e\u003e;\r\n/// Represents the state of the storage engine.\r\n#[derive(Clone)]\r\npub struct LsmStorageState {\r\n    /// The current memtable.\r\n    pub memtable: Arc\u003cMemTable\u003e,\r\n    /// Immutable memtables, from latest to earliest.\r\n    pub imm_memtables: Vec\u003cArc\u003cMemTable\u003e\u003e,\r\n    /// L0 SSTs, from latest to earliest.\r\n    /// l0 is unsorted,each l0 sst created by imm_memtables,but imm_memtables is not sorted by key  \r\n    pub l0_sstables: Vec\u003cusize\u003e,\r\n    /// SsTables sorted by key range; L1 - L_max for leveled compaction, or tiers for tiered\r\n    /// compaction.  \r\n    /// each element is (level, a vec of sst_id of current level)  \r\n    pub levels: Vec\u003c(usize, Vec\u003cusize\u003e)\u003e,\r\n    /// SST objects.\r\n    pub sstables: HashMap\u003cusize, Arc\u003cSsTable\u003e\u003e,\r\n}\r\n\r\npub enum WriteBatchRecord\u003cT: AsRef\u003c[u8]\u003e\u003e {\r\n    Put(T, T),\r\n    Del(T),\r\n}\r\n\r\nimpl LsmStorageState {\r\n    fn create(options: \u0026LsmStorageOptions) -\u003e Self {\r\n        let levels = match \u0026options.compaction_options {\r\n            CompactionOptions::Leveled(LeveledCompactionOptions { max_levels, .. }) =\u003e (1\r\n                ..=*max_levels)\r\n                .map(|level| (level, Vec::new()))\r\n                .collect::\u003cVec\u003c_\u003e\u003e(),\r\n            CompactionOptions::NoCompaction =\u003e vec![(1, Vec::new())],\r\n        };\r\n        Self {\r\n            memtable: Arc::new(MemTable::create(0)),\r\n            imm_memtables: Vec::new(),\r\n            l0_sstables: Vec::new(),\r\n            levels,\r\n            sstables: Default::default(),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, With)]\r\npub struct LsmStorageOptions {\r\n    // Block size in bytes\r\n    pub block_size: usize,\r\n    // SST size in bytes, also the approximate memtable capacity limit\r\n    pub target_sst_size: usize,\r\n    // Maximum number of memtables in memory, flush to L0 when exceeding this limit\r\n    pub num_memtable_limit: usize,\r\n    pub compaction_options: CompactionOptions,\r\n    pub enable_wal: bool,\r\n    pub bloom_false_positive_rate: f64,\r\n    pub serializable: bool,\r\n}\r\nimpl Default for LsmStorageOptions {\r\n    fn default() -\u003e Self {\r\n        Self {\r\n            block_size: 4096,\r\n            target_sst_size: 2 \u003c\u003c 20, // 2MB\r\n            num_memtable_limit: 2,\r\n            compaction_options: CompactionOptions::NoCompaction,\r\n            enable_wal: true,\r\n            bloom_false_positive_rate: 0.01,\r\n            serializable: true,\r\n        }\r\n    }\r\n}\r\nimpl LsmStorageOptions {\r\n    pub fn default_for_mvcc_test(compaction_options: CompactionOptions) -\u003e Self {\r\n        Self {\r\n            block_size: 4096,\r\n            target_sst_size: 1 \u003c\u003c 20, // 1MB\r\n            compaction_options,\r\n            enable_wal: false,\r\n            num_memtable_limit: 2,\r\n            serializable: false,\r\n            bloom_false_positive_rate: 0.01,\r\n        }\r\n    }\r\n\r\n    pub fn compaction_test(compaction_options: CompactionOptions) -\u003e Self {\r\n        Self {\r\n            block_size: 4096,\r\n            target_sst_size: 1 \u003c\u003c 20, // 1MB\r\n            compaction_options,\r\n            enable_wal: false,\r\n            num_memtable_limit: 2,\r\n            serializable: false,\r\n            bloom_false_positive_rate: 0.01,\r\n        }\r\n    }\r\n\r\n\r\n    pub fn no_compaction() -\u003e Self {\r\n        Self {\r\n            block_size: 4096,\r\n            target_sst_size: 2 \u003c\u003c 20, // 2MB\r\n            num_memtable_limit: 3,\r\n            compaction_options: CompactionOptions::NoCompaction,\r\n            enable_wal: true,\r\n            bloom_false_positive_rate: 0.01,\r\n            serializable: false,\r\n        }\r\n    }\r\n    pub fn leveled_compaction() -\u003e Self {\r\n        Self {\r\n            block_size: 4096,\r\n            target_sst_size: 2 \u003c\u003c 20, // 2MB\r\n            num_memtable_limit: 3,\r\n            compaction_options: CompactionOptions::Leveled(LeveledCompactionOptions {\r\n                level0_file_num_compaction_trigger: 2,\r\n                max_levels: 4,\r\n                base_level_size_mb: 128,\r\n                level_size_multiplier: 2,\r\n            }),\r\n            enable_wal: true,\r\n            bloom_false_positive_rate: 0.01,\r\n            serializable: true,\r\n        }\r\n    }\r\n}\r\nfn range_overlap(\r\n    user_begin: Bound\u003c\u0026[u8]\u003e,\r\n    user_end: Bound\u003c\u0026[u8]\u003e,\r\n    table_begin: KeySlice,\r\n    table_end: KeySlice,\r\n) -\u003e bool {\r\n    match user_end {\r\n        Bound::Excluded(key) if key \u003c= table_begin.key_ref() =\u003e {\r\n            return false;\r\n        }\r\n        Bound::Included(key) if key \u003c table_begin.key_ref() =\u003e {\r\n            return false;\r\n        }\r\n        _ =\u003e {}\r\n    }\r\n    match user_begin {\r\n        Bound::Excluded(key) if key \u003e= table_end.key_ref() =\u003e {\r\n            return false;\r\n        }\r\n        Bound::Included(key) if key \u003e table_end.key_ref() =\u003e {\r\n            return false;\r\n        }\r\n        _ =\u003e {}\r\n    }\r\n    true\r\n}\r\n\r\nfn key_within(user_key: \u0026[u8], table_begin: KeySlice, table_end: KeySlice) -\u003e bool {\r\n    table_begin.key_ref() \u003c= user_key \u0026\u0026 user_key \u003c= table_end.key_ref()\r\n}\r\n\r\n/// The storage interface of the LSM tree.\r\npub(crate) struct LsmStorageInner {\r\n    pub(crate) state: Arc\u003cRwLock\u003cArc\u003cLsmStorageState\u003e\u003e\u003e,\r\n    pub(crate) state_lock: Mutex\u003c()\u003e,\r\n    path: PathBuf,\r\n    pub(crate) block_cache: Arc\u003cBlockCache\u003e,\r\n    next_sst_id: AtomicUsize,\r\n    pub(crate) options: Arc\u003cLsmStorageOptions\u003e,\r\n    pub(crate) compaction_controller: CompactionController,\r\n    pub(crate) manifest: Option\u003cManifest\u003e,\r\n    pub(crate) mvcc: Option\u003cLsmMvccInner\u003e,\r\n}\r\n\r\nimpl LsmStorageInner {\r\n    pub(crate) fn mvcc(\u0026self) -\u003e \u0026LsmMvccInner {\r\n        self.mvcc.as_ref().unwrap()\r\n    }\r\n\r\n    pub(crate) fn manifest(\u0026self) -\u003e \u0026Manifest {\r\n        self.manifest.as_ref().unwrap()\r\n    }\r\n    pub(crate) fn next_sst_id(\u0026self) -\u003e usize {\r\n        self.next_sst_id\r\n            .fetch_add(1, std::sync::atomic::Ordering::SeqCst)\r\n    }\r\n\r\n    /// Start the storage engine by either loading an existing directory or creating a new one if the directory does\r\n    /// not exist.\r\n    pub(crate) fn open(path: impl AsRef\u003cPath\u003e, options: LsmStorageOptions) -\u003e Result\u003cSelf\u003e {\r\n        let mut state = LsmStorageState::create(\u0026options);\r\n        let path = path.as_ref();\r\n        let mut next_sst_id = 1;\r\n        let block_cache = Arc::new(BlockCache::new(1 \u003c\u003c 20)); // 4GB block cache,\r\n        let manifest;\r\n\r\n        let compaction_controller = match \u0026options.compaction_options {\r\n            CompactionOptions::Leveled(options) =\u003e {\r\n                CompactionController::Leveled(LeveledCompactionController::new(options.clone()))\r\n            }\r\n            CompactionOptions::NoCompaction =\u003e CompactionController::NoCompaction,\r\n        };\r\n\r\n        if !path.exists() {\r\n            std::fs::create_dir_all(path).expect(\"failed to create DB dir\");\r\n        }\r\n        let mut last_commit_ts = 0;\r\n        let manifest_path = path.join(\"MANIFEST\");\r\n        if !manifest_path.exists() {\r\n            if options.enable_wal {\r\n                state.memtable = Arc::new(MemTable::create_with_wal(\r\n                    state.memtable.id(),\r\n                    Self::path_of_wal_static(path, state.memtable.id()),\r\n                )?);\r\n            }\r\n            manifest = Manifest::create(\u0026manifest_path).expect(\"failed to create manifest\");\r\n            manifest.add_record_when_init(ManifestRecord::NewMemtable(state.memtable.id()))?;\r\n        } else {\r\n            let (m, records) = Manifest::recover(\u0026manifest_path)?;\r\n            let mut memtables = BTreeSet::new();\r\n            for record in records {\r\n                match record {\r\n                    ManifestRecord::Flush(sst_id) =\u003e {\r\n                        let res = memtables.remove(\u0026sst_id);\r\n                        assert!(res, \"memtable not exist?\");\r\n                        if compaction_controller.flush_to_l0() {\r\n                            state.l0_sstables.insert(0, sst_id);\r\n                        } else {\r\n                            state.levels.insert(0, (sst_id, vec![sst_id]));\r\n                        }\r\n                        next_sst_id = next_sst_id.max(sst_id);\r\n                    }\r\n                    ManifestRecord::NewMemtable(x) =\u003e {\r\n                        next_sst_id = next_sst_id.max(x);\r\n                        memtables.insert(x);\r\n                    }\r\n                    ManifestRecord::Compaction(task, output) =\u003e {\r\n                        let (new_state, _) = compaction_controller\r\n                            .apply_compaction_result(\u0026state, \u0026task, \u0026output, true);\r\n                        // TODO: apply remove again\r\n                        state = new_state;\r\n                        next_sst_id =\r\n                            next_sst_id.max(output.iter().max().copied().unwrap_or_default());\r\n                    }\r\n                }\r\n            }\r\n\r\n            let mut sst_cnt = 0;\r\n            // recover SSTs\r\n            for table_id in state\r\n                .l0_sstables\r\n                .iter()\r\n                .chain(state.levels.iter().flat_map(|(_, files)| files))\r\n            {\r\n                let table_id = *table_id;\r\n                let sst = SsTable::open(\r\n                    table_id,\r\n                    Some(block_cache.clone()),\r\n                    FileObject::open(\u0026Self::path_of_sst_static(path, table_id))?,\r\n                )?;\r\n                last_commit_ts = last_commit_ts.max(sst.max_ts());\r\n\r\n                state.sstables.insert(table_id, Arc::new(sst));\r\n                sst_cnt += 1;\r\n            }\r\n            println!(\"{} SSTs opened\", sst_cnt);\r\n\r\n            next_sst_id += 1;\r\n\r\n            // recover memtables\r\n            if options.enable_wal {\r\n                let mut wal_cnt = 0;\r\n                for id in memtables.iter() {\r\n                    let memtable =\r\n                        MemTable::recover_from_wal(*id, Self::path_of_wal_static(path, *id))?;\r\n                    let max_ts = memtable\r\n                        .map\r\n                        .iter()\r\n                        .map(|x| x.key().ts())\r\n                        .max()\r\n                        .unwrap_or_default();\r\n                    last_commit_ts = last_commit_ts.max(max_ts);\r\n\r\n                    if !memtable.is_empty() {\r\n                        state.imm_memtables.insert(0, Arc::new(memtable));\r\n                        wal_cnt += 1;\r\n                    }\r\n                }\r\n                println!(\"{} WALs recovered\", wal_cnt);\r\n                state.memtable = Arc::new(MemTable::create_with_wal(\r\n                    next_sst_id,\r\n                    Self::path_of_wal_static(path, next_sst_id),\r\n                )?);\r\n            } else {\r\n                state.memtable = Arc::new(MemTable::create(next_sst_id));\r\n            }\r\n            m.add_record_when_init(ManifestRecord::NewMemtable(state.memtable.id()))?;\r\n            next_sst_id += 1;\r\n            manifest = m;\r\n            for (_id, ssts) in \u0026mut state.levels {\r\n                ssts.sort_by(|x, y| {\r\n                    state\r\n                        .sstables\r\n                        .get(x)\r\n                        .unwrap()\r\n                        .first_key()\r\n                        .cmp(state.sstables.get(y).unwrap().first_key())\r\n                })\r\n            }\r\n        };\r\n\r\n        let storage = Self {\r\n            state: Arc::new(RwLock::new(Arc::new(state))),\r\n            state_lock: Mutex::new(()),\r\n            path: path.to_path_buf(),\r\n            block_cache,\r\n            next_sst_id: AtomicUsize::new(next_sst_id),\r\n            compaction_controller,\r\n            manifest: Some(manifest),\r\n            options: options.into(),\r\n            mvcc: Some(LsmMvccInner::new(last_commit_ts)),\r\n        };\r\n        storage.sync_dir()?;\r\n        Ok(storage)\r\n    }\r\n\r\n    pub fn sync(\u0026self) -\u003e Result\u003c()\u003e {\r\n        self.state.read().memtable.sync_wal()\r\n    }\r\n\r\n    /// Get a key from the storage. In day 7, this can be further optimized by using a bloom filter.\r\n    pub fn get(self: \u0026Arc\u003cSelf\u003e, key: \u0026[u8]) -\u003e Result\u003cOption\u003cBytes\u003e\u003e {\r\n        let txn = self.mvcc().new_txn(self.clone(), self.options.serializable);\r\n        txn.get(key)\r\n    }\r\n    pub(crate) fn get_with_ts(\u0026self, key: \u0026[u8], read_ts: u64) -\u003e Result\u003cOption\u003cBytes\u003e\u003e {\r\n        let snapshot = {\r\n            let guard = self.state.read();\r\n            Arc::clone(\u0026guard)\r\n        }; // drop global lock here\r\n\r\n        let mut memtable_iters = Vec::with_capacity(snapshot.imm_memtables.len() + 1);\r\n        memtable_iters.push(Box::new(snapshot.memtable.scan(\r\n            Bound::Included(KeySlice::from_slice(key, key::TS_RANGE_BEGIN)),\r\n            Bound::Included(KeySlice::from_slice(key, key::TS_RANGE_END)),\r\n        )));\r\n        for memtable in snapshot.imm_memtables.iter() {\r\n            memtable_iters.push(Box::new(memtable.scan(\r\n                Bound::Included(KeySlice::from_slice(key, key::TS_RANGE_BEGIN)),\r\n                Bound::Included(KeySlice::from_slice(key, key::TS_RANGE_END)),\r\n            )));\r\n        }\r\n        let memtable_iter = MergeIterator::create(memtable_iters);\r\n\r\n        let mut l0_iters = Vec::with_capacity(snapshot.l0_sstables.len());\r\n\r\n        let keep_table = |key: \u0026[u8], table: \u0026SsTable| {\r\n            if key_within(\r\n                key,\r\n                table.first_key().as_key_slice(),\r\n                table.last_key().as_key_slice(),\r\n            ) {\r\n                if let Some(bloom) = \u0026table.bloom {\r\n                    if bloom.may_contain(farmhash::fingerprint32(key)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    return true;\r\n                }\r\n            }\r\n            false\r\n        };\r\n\r\n        for table in snapshot.l0_sstables.iter() {\r\n            let table = snapshot.sstables[table].clone();\r\n            if keep_table(key, \u0026table) {\r\n                l0_iters.push(Box::new(SsTableIterator::create_and_seek_to_key(\r\n                    table,\r\n                    KeySlice::from_slice(key, key::TS_RANGE_BEGIN),\r\n                )?));\r\n            }\r\n        }\r\n        let l0_iter = MergeIterator::create(l0_iters);\r\n        let mut level_iters = Vec::with_capacity(snapshot.levels.len());\r\n        for (_, level_sst_ids) in \u0026snapshot.levels {\r\n            let mut level_ssts = Vec::with_capacity(level_sst_ids.len());\r\n            for table in level_sst_ids {\r\n                let table = snapshot.sstables[table].clone();\r\n                if keep_table(key, \u0026table) {\r\n                    level_ssts.push(table);\r\n                }\r\n            }\r\n            let level_iter = SstConcatIterator::create_and_seek_to_key(\r\n                level_ssts,\r\n                KeySlice::from_slice(key, key::TS_RANGE_BEGIN),\r\n            )?;\r\n            level_iters.push(Box::new(level_iter));\r\n        }\r\n\r\n        let iter = LsmIterator::new(\r\n            TwoMergeIterator::create(\r\n                TwoMergeIterator::create(memtable_iter, l0_iter)?,\r\n                MergeIterator::create(level_iters),\r\n            )?,\r\n            Bound::Unbounded,\r\n            read_ts,\r\n        )?;\r\n\r\n        if iter.is_valid() \u0026\u0026 iter.key() == key \u0026\u0026 !iter.value().is_empty() {\r\n            return Ok(Some(Bytes::copy_from_slice(iter.value())));\r\n        }\r\n        Ok(None)\r\n    }\r\n\r\n    pub fn write_batch_inner\u003cT: AsRef\u003c[u8]\u003e\u003e(\u0026self, batch: \u0026[WriteBatchRecord\u003cT\u003e]) -\u003e Result\u003cu64\u003e {\r\n        let _lck = self.mvcc().write_lock.lock();\r\n        let ts = self.mvcc().latest_commit_ts() + 1;\r\n        for record in batch {\r\n            match record {\r\n                WriteBatchRecord::Del(key) =\u003e {\r\n                    let key = key.as_ref();\r\n                    assert!(!key.is_empty(), \"key cannot be empty\");\r\n                    let size;\r\n                    {\r\n                        let guard = self.state.read();\r\n                        guard.memtable.put(KeySlice::from_slice(key, ts), b\"\")?;\r\n                        size = guard.memtable.approximate_size();\r\n                    }\r\n                    self.try_freeze(size)?;\r\n                }\r\n                WriteBatchRecord::Put(key, value) =\u003e {\r\n                    let key = key.as_ref();\r\n                    let value = value.as_ref();\r\n                    assert!(!key.is_empty(), \"key cannot be empty\");\r\n                    assert!(!value.is_empty(), \"value cannot be empty\");\r\n                    let size;\r\n                    {\r\n                        let guard = self.state.read();\r\n                        guard.memtable.put(KeySlice::from_slice(key, ts), value)?;\r\n                        size = guard.memtable.approximate_size();\r\n                    }\r\n                    self.try_freeze(size)?;\r\n                }\r\n            }\r\n        }\r\n        self.mvcc().update_commit_ts(ts);\r\n        Ok(ts)\r\n    }\r\n\r\n    pub fn write_batch\u003cT: AsRef\u003c[u8]\u003e\u003e(\r\n        self: \u0026Arc\u003cSelf\u003e,\r\n        batch: \u0026[WriteBatchRecord\u003cT\u003e],\r\n    ) -\u003e Result\u003c()\u003e {\r\n        if !self.options.serializable {\r\n            self.write_batch_inner(batch)?;\r\n        } else {\r\n            let txn = self.mvcc().new_txn(self.clone(), self.options.serializable);\r\n            for record in batch {\r\n                match record {\r\n                    WriteBatchRecord::Del(key) =\u003e {\r\n                        txn.delete(key.as_ref());\r\n                    }\r\n                    WriteBatchRecord::Put(key, value) =\u003e {\r\n                        txn.put(key.as_ref(), value.as_ref());\r\n                    }\r\n                }\r\n            }\r\n            txn.commit()?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    /// Put a key-value pair into the storage by writing into the current memtable.\r\n    pub fn put(self: \u0026Arc\u003cSelf\u003e, key: \u0026[u8], value: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        if !self.options.serializable {\r\n            self.write_batch_inner(\u0026[WriteBatchRecord::Put(key, value)])?;\r\n        } else {\r\n            let txn = self.mvcc().new_txn(self.clone(), self.options.serializable);\r\n            txn.put(key, value);\r\n            txn.commit()?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    /// Remove a key from the storage by writing an empty value.\r\n    pub fn delete(self: \u0026Arc\u003cSelf\u003e, key: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        if !self.options.serializable {\r\n            self.write_batch_inner(\u0026[WriteBatchRecord::Del(key)])?;\r\n        } else {\r\n            let txn = self.mvcc().new_txn(self.clone(), self.options.serializable);\r\n            txn.delete(key);\r\n            txn.commit()?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn try_freeze(\u0026self, estimated_size: usize) -\u003e Result\u003c()\u003e {\r\n        if estimated_size \u003e= self.options.target_sst_size {\r\n            let state_lock = self.state_lock.lock();\r\n            let guard = self.state.read();\r\n            // the memtable could have already been frozen, check again to ensure we really need to freeze\r\n            if guard.memtable.approximate_size() \u003e= self.options.target_sst_size {\r\n                drop(guard);\r\n                self.force_freeze_memtable(\u0026state_lock)?;\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub(crate) fn path_of_sst_static(path: impl AsRef\u003cPath\u003e, id: usize) -\u003e PathBuf {\r\n        path.as_ref().join(format!(\"{:05}.sst\", id))\r\n    }\r\n\r\n    pub(crate) fn path_of_sst(\u0026self, id: usize) -\u003e PathBuf {\r\n        Self::path_of_sst_static(\u0026self.path, id)\r\n    }\r\n\r\n    pub(crate) fn path_of_wal_static(path: impl AsRef\u003cPath\u003e, id: usize) -\u003e PathBuf {\r\n        path.as_ref().join(format!(\"{:05}.wal\", id))\r\n    }\r\n\r\n    pub(crate) fn path_of_wal(\u0026self, id: usize) -\u003e PathBuf {\r\n        Self::path_of_wal_static(\u0026self.path, id)\r\n    }\r\n\r\n    pub(super) fn sync_dir(\u0026self) -\u003e Result\u003c()\u003e {\r\n        if let Some(manifest) = \u0026self.manifest {\r\n            manifest.sync()?;\r\n        }\r\n        self.state\r\n            .write()\r\n            .sstables\r\n            .values()\r\n            .for_each(|sstable| sstable.sync().ok().unwrap());\r\n        Ok(())\r\n    }\r\n\r\n    pub(super) fn freeze_memtable_with_memtable(\u0026self, memtable: Arc\u003cMemTable\u003e) -\u003e Result\u003c()\u003e {\r\n        let mut guard = self.state.write();\r\n        // Swap the current memtable with a new one.\r\n        let mut snapshot = guard.as_ref().clone();\r\n        let old_memtable = std::mem::replace(\u0026mut snapshot.memtable, memtable);\r\n        // Add the memtable to the immutable memtables.\r\n        snapshot.imm_memtables.insert(0, old_memtable.clone());\r\n        // Update the snapshot.\r\n        *guard = Arc::new(snapshot);\r\n\r\n        drop(guard);\r\n        old_memtable.sync_wal()?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// Force freeze the current memtable to an immutable memtable\r\n    pub fn force_freeze_memtable(\u0026self, state_lock_observer: \u0026MutexGuard\u003c'_, ()\u003e) -\u003e Result\u003c()\u003e {\r\n        let memtable_id = self.next_sst_id();\r\n        let memtable = if self.options.enable_wal {\r\n            Arc::new(MemTable::create_with_wal(\r\n                memtable_id,\r\n                self.path_of_wal(memtable_id),\r\n            )?)\r\n        } else {\r\n            Arc::new(MemTable::create(memtable_id))\r\n        };\r\n\r\n        self.freeze_memtable_with_memtable(memtable)?;\r\n\r\n        self.manifest.as_ref().unwrap().add_record(\r\n            state_lock_observer,\r\n            ManifestRecord::NewMemtable(memtable_id),\r\n        )?;\r\n        self.sync_dir()?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// Force flush the earliest-created immutable memtable to disk\r\n    pub fn force_flush_next_imm_memtable(\u0026self) -\u003e Result\u003c()\u003e {\r\n        let state_lock = self.state_lock.lock();\r\n\r\n        let flush_memtable;\r\n\r\n        {\r\n            let guard = self.state.read();\r\n            flush_memtable = guard\r\n                .imm_memtables\r\n                .last()\r\n                .expect(\"no imm memtables!\")\r\n                .clone();\r\n        }\r\n\r\n        let mut builder = SsTableBuilder::new(self.options.block_size);\r\n        flush_memtable.flush(\u0026mut builder)?;\r\n        let sst_id = flush_memtable.id();\r\n        let sst = Arc::new(builder.build(\r\n            sst_id,\r\n            Some(self.block_cache.clone()),\r\n            self.options.bloom_false_positive_rate,\r\n            self.path_of_sst(sst_id),\r\n        )?);\r\n\r\n        // Add the flushed L0 table to the list.\r\n        {\r\n            let mut guard = self.state.write();\r\n            let mut snapshot = guard.as_ref().clone();\r\n            // Remove the memtable from the immutable memtables.\r\n            let mem = snapshot.imm_memtables.pop().unwrap();\r\n            assert_eq!(mem.id(), sst_id);\r\n            // Add L0 table\r\n            if self.compaction_controller.flush_to_l0() {\r\n                // In leveled compaction or no compaction, simply flush to L0\r\n                snapshot.l0_sstables.insert(0, sst_id);\r\n            } else {\r\n                // In tiered compaction, create a new tier\r\n                snapshot.levels.insert(0, (sst_id, vec![sst_id]));\r\n            }\r\n            debug!(\"flushed {}.sst with size={}\", sst_id, sst.table_size());\r\n            snapshot.sstables.insert(sst_id, sst);\r\n            // Update the snapshot.\r\n            *guard = Arc::new(snapshot);\r\n        }\r\n\r\n        if self.options.enable_wal {\r\n            std::fs::remove_file(self.path_of_wal(sst_id))?;\r\n        }\r\n\r\n        self.manifest()\r\n            .add_record(\u0026state_lock, ManifestRecord::Flush(sst_id))?;\r\n\r\n        self.sync_dir()?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub fn new_txn(self: \u0026Arc\u003cSelf\u003e) -\u003e Result\u003cArc\u003cTransaction\u003e\u003e {\r\n        Ok(self.mvcc().new_txn(self.clone(), self.options.serializable))\r\n    }\r\n\r\n    pub fn scan\u003c'a\u003e(\r\n        self: \u0026'a Arc\u003cSelf\u003e,\r\n        lower: Bound\u003c\u0026[u8]\u003e,\r\n        upper: Bound\u003c\u0026[u8]\u003e,\r\n    ) -\u003e Result\u003cTxnIterator\u003e {\r\n        let txn = self.mvcc().new_txn(self.clone(), self.options.serializable);\r\n        txn.scan(lower, upper)\r\n    }\r\n\r\n    /// Create an iterator over a range of keys.\r\n    pub(crate) fn scan_with_ts(\r\n        \u0026self,\r\n        lower: Bound\u003c\u0026[u8]\u003e,\r\n        upper: Bound\u003c\u0026[u8]\u003e,\r\n        read_ts: u64,\r\n    ) -\u003e Result\u003cFusedIterator\u003cLsmIterator\u003e\u003e {\r\n        // println!(\r\n        //     \"scan_with_ts: {:?}\",\r\n        //     (\r\n        //         map_key_bound(map_key_bound_plus_ts(lower, key::TS_RANGE_BEGIN)),\r\n        //         map_key_bound(map_key_bound_plus_ts(upper, key::TS_RANGE_END)),\r\n        //         read_ts\r\n        //     )\r\n        // );\r\n        let snapshot = {\r\n            let guard = self.state.read();\r\n            Arc::clone(\u0026guard)\r\n        }; // drop global lock here\r\n\r\n        let mut memtable_iters = Vec::with_capacity(snapshot.imm_memtables.len() + 1);\r\n        memtable_iters.push(Box::new(snapshot.memtable.scan(\r\n            map_key_bound_plus_ts(lower, key::TS_RANGE_BEGIN),\r\n            map_key_bound_plus_ts(upper, key::TS_RANGE_END),\r\n        )));\r\n        for memtable in snapshot.imm_memtables.iter() {\r\n            memtable_iters.push(Box::new(memtable.scan(\r\n                map_key_bound_plus_ts(lower, key::TS_RANGE_BEGIN),\r\n                map_key_bound_plus_ts(upper, key::TS_RANGE_END),\r\n            )));\r\n        }\r\n        let memtable_iter = MergeIterator::create(memtable_iters);\r\n        let mut table_iters = Vec::with_capacity(snapshot.l0_sstables.len());\r\n        for table_id in snapshot.l0_sstables.iter() {\r\n            let table = snapshot.sstables[table_id].clone();\r\n            if range_overlap(\r\n                lower,\r\n                upper,\r\n                table.first_key().as_key_slice(),\r\n                table.last_key().as_key_slice(),\r\n            ) {\r\n                // println!(\"hit sst:{}\", table_id);\r\n                let iter = match lower {\r\n                    Bound::Included(key) =\u003e SsTableIterator::create_and_seek_to_key(\r\n                        table,\r\n                        KeySlice::from_slice(key, key::TS_RANGE_BEGIN),\r\n                    )?,\r\n                    Bound::Excluded(key) =\u003e {\r\n                        let mut iter = SsTableIterator::create_and_seek_to_key(\r\n                            table,\r\n                            KeySlice::from_slice(key, key::TS_RANGE_BEGIN),\r\n                        )?;\r\n                        while iter.is_valid() \u0026\u0026 iter.key().key_ref() == key {\r\n                            iter._next()?;\r\n                        }\r\n                        iter\r\n                    }\r\n\r\n                    Bound::Unbounded =\u003e SsTableIterator::create_and_seek_to_first(table)?,\r\n                };\r\n                table_iters.push(Box::new(iter));\r\n            }\r\n        }\r\n\r\n        let l0_iter = MergeIterator::create(table_iters);\r\n        let mut level_iters = Vec::with_capacity(snapshot.levels.len());\r\n        for (_, level_sst_ids) in \u0026snapshot.levels {\r\n            let mut level_ssts = Vec::with_capacity(level_sst_ids.len());\r\n            for table in level_sst_ids {\r\n                let table = snapshot.sstables[table].clone();\r\n                if range_overlap(\r\n                    lower,\r\n                    upper,\r\n                    table.first_key().as_key_slice(),\r\n                    table.last_key().as_key_slice(),\r\n                ) {\r\n                    level_ssts.push(table);\r\n                }\r\n            }\r\n\r\n            let level_iter = match lower {\r\n                Bound::Included(key) =\u003e SstConcatIterator::create_and_seek_to_key(\r\n                    level_ssts,\r\n                    KeySlice::from_slice(key, key::TS_RANGE_BEGIN),\r\n                )?,\r\n                Bound::Excluded(key) =\u003e {\r\n                    let mut iter = SstConcatIterator::create_and_seek_to_key(\r\n                        level_ssts,\r\n                        KeySlice::from_slice(key, key::TS_RANGE_BEGIN),\r\n                    )?;\r\n                    while iter.is_valid() \u0026\u0026 iter.key().key_ref() == key {\r\n                        iter._next()?;\r\n                    }\r\n                    iter\r\n                }\r\n                Bound::Unbounded =\u003e SstConcatIterator::create_and_seek_to_first(level_ssts)?,\r\n            };\r\n            level_iters.push(Box::new(level_iter));\r\n        }\r\n\r\n        let iter = TwoMergeIterator::create(memtable_iter, l0_iter)?;\r\n\r\n        let iter = TwoMergeIterator::create(iter, MergeIterator::create(level_iters))?;\r\n\r\n        let lsm_iter = LsmIterator::new(iter, map_bound(upper), read_ts)?;\r\n        Ok(FusedIterator::new(lsm_iter))\r\n    }\r\n}\r\n","traces":[{"line":55,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":9799832789158199296},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":16212958658533785821},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":8935141660703064064},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":4179340454199820288},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":6773413839565225984},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":10520408729537478656},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":18086456103519917131},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":15636497906230365901},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":15636497906230365901},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":4107282860161894906},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":4107282860161894906},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":8430738502437568512},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":8430738502437568512},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":8430738502437568512},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":9799832789158199296},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":9151314442816847872},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":4251398048237748224},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":4251398048237748224},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":4539628424389459968},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":4539628424389459968},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":4539628424389459968},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":5908722711110091865},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":3386706919782613363},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":3386706919782613363},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":3386706919782613363},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":17582052945254416384},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":17582052945254416384},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":9655717601082343424},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":10520408729537478656},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":10520408729537478656},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":10520408729537478656},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":3026418949592983702},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":10448351135499550720},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":72057594037922968},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":6052837899185946995},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":6917529027641082227},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":6917529027641082227},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":3819052484010180979},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":3819052484010180979},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":3819052484010180979},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":9871890383196127635},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":10736581511651262496},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":17942340915444051890},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":6629298651489370112},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":6629298651489370112},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":10736581511651267092},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":10736581511651267092},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":17582052945254418241},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":17582052945254417499},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":17582052945254417499},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":17582052945254417499},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":7133701809754865664},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":3458764513820540713},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":14123288431433876786},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":13474770085092524259},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":13474770085092524259},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":13474770085092524259},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":14915921965851083443},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":1513209474796487117},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":18374686479671623914},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":18374686479671623914},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":18374686479671623914},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":18374686479671623918},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":18374686479671623910},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":18374686479671623910},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":18374686479671623910},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":18374686479671623910},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":18374686479671623910},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":13474770085092524490},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":13474770085092524490},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":11601272640106397305},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":13402712491054596553},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":13402712491054596553},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":13402712491054596553},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":6557241057451441653},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":18230571291595767874},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":18230571291595767874},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":18230571291595767811},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":18230571291595767811},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":18230571291595767811},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":18230571291595767868},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":1441151880758558723},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":1441151880758558723},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":2522015791327478223},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":2522015791327478223},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":2522015791327478223},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":2522015791327478223},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":2522015791327478223},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":1441151880758558260},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":9367487224930631680},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":9367487224930631680},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":9367487224930631680},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":9367487224930631680},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":10520408729537478656},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":10520408729537478656},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":6269010681299730432},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":6269010681299730432},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":4179340454199820288},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":8358680908399640575},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":4179340454199820289},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":4179340454199820289},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":4179340454199820289},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":5260204364768739329},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":10664523917613334528},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":4395513236313604096},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":4395513236313604096},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":4395513236313604096},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":5620492334958379008},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":9583660007044415488},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":13546827679130451968},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":6052837899185946624},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":4179340454199820288},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":16068843470457929728},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":746,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":13690942867206307840},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":12321848580485677056},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":12321848580485677056},"fn_name":null},{"line":755,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":3098476543630901248},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":772,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null}],"covered":278,"coverable":352},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","manifest.rs"],"content":"use std::fs::{File, OpenOptions};\r\nuse std::io::{Read, Write};\r\nuse std::path::Path;\r\nuse std::sync::Arc;\r\n\r\nuse bytes::{Buf, BufMut};\r\nuse parking_lot::{Mutex, MutexGuard};\r\nuse serde::{Deserialize, Serialize};\r\nuse tracing::{error};\r\nuse crate::errors::Result;\r\n\r\nuse super::compact::CompactionTask;\r\n\r\n\r\npub struct Manifest {\r\n    file: Arc\u003cMutex\u003cFile\u003e\u003e,\r\n}\r\n\r\n#[derive(Serialize, Deserialize)]\r\npub enum ManifestRecord {\r\n    Flush(usize),\r\n    NewMemtable(usize),\r\n    Compaction(CompactionTask, Vec\u003cusize\u003e),\r\n}\r\n\r\nimpl Manifest {\r\n    pub fn create(path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cSelf\u003e {\r\n        Ok(Self {\r\n            file: Arc::new(Mutex::new(\r\n                OpenOptions::new()\r\n                    .read(true)\r\n                    .create_new(true)\r\n                    .write(true)\r\n                    .open(path)\r\n                    .expect(\"failed to create manifest\"),\r\n            )),\r\n        })\r\n    }\r\n    pub fn sync(\u0026self) -\u003e Result\u003c()\u003e {\r\n        self.file.lock().sync_all()?;\r\n        Ok(())\r\n    }\r\n    pub fn recover(path: impl AsRef\u003cPath\u003e) -\u003e Result\u003c(Self, Vec\u003cManifestRecord\u003e)\u003e {\r\n        let mut file = OpenOptions::new()\r\n            .read(true)\r\n            .append(true)\r\n            .open(path)\r\n            .expect(\"failed to recover manifest\");\r\n        let mut buf = Vec::new();\r\n        file.read_to_end(\u0026mut buf)?;\r\n        let mut buf_ptr = buf.as_slice();\r\n        let mut records = Vec::new();\r\n        while buf_ptr.has_remaining() {\r\n            let len = buf_ptr.get_u64();\r\n            let slice = \u0026buf_ptr[..len as usize];\r\n            let json = serde_json::from_slice::\u003cManifestRecord\u003e(slice).unwrap();\r\n            buf_ptr.advance(len as usize);\r\n            let checksum = buf_ptr.get_u32();\r\n            if checksum != crc32fast::hash(slice) {\r\n                error!(\"checksum mismatched!\");\r\n                panic!(\"checksum mismatched!\");\r\n            }\r\n            records.push(json);\r\n        }\r\n        Ok((\r\n            Self {\r\n                file: Arc::new(Mutex::new(file)),\r\n            },\r\n            records,\r\n        ))\r\n    }\r\n\r\n    pub fn add_record(\r\n        \u0026self,\r\n        _state_lock_observer: \u0026MutexGuard\u003c()\u003e,\r\n        record: ManifestRecord,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        self.add_record_when_init(record)\r\n    }\r\n\r\n    pub fn add_record_when_init(\u0026self, record: ManifestRecord) -\u003e Result\u003c()\u003e {\r\n        let mut file = self.file.lock();\r\n        let mut buf = serde_json::to_vec(\u0026record).unwrap();\r\n        let hash = crc32fast::hash(\u0026buf);\r\n        file.write_all(\u0026(buf.len() as u64).to_be_bytes())?;\r\n        buf.put_u32(hash);\r\n        file.write_all(\u0026buf)?;\r\n        file.sync_all()?;\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":4179340454199820288},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":4179340454199820289},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":4179340454199820287},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":14987979559889010688},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":14987979559889010688},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":14987979559889010688},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":14987979559889010688},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":14987979559889010688},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":14987979559889010688},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":14987979559889010688},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":14987979559889010688},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":14987979559889010688},"fn_name":null}],"covered":23,"coverable":44},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","mem_table.rs"],"content":"use std::ops::Bound;\r\nuse std::path::Path;\r\nuse std::sync::atomic::AtomicUsize;\r\nuse std::sync::Arc;\r\n\r\nuse crate::errors::Result;\r\nuse bytes::Bytes;\r\nuse crossbeam_skiplist::map::Entry;\r\nuse crossbeam_skiplist::SkipMap;\r\nuse ouroboros::self_referencing;\r\n\r\nuse super::iterators::StorageIterator;\r\nuse super::key::{KeyBytes, KeySlice, TS_DEFAULT};\r\nuse super::table::SsTableBuilder;\r\nuse super::wal::Wal;\r\n\r\n/// A basic mem-table based on crossbeam-skiplist.\r\n///\r\n/// An initial implementation of memtable is part of week 1, day 1. It will be incrementally implemented in other\r\n/// chapters of week 1 and week 2.\r\npub struct MemTable {\r\n    pub(super) map: Arc\u003cSkipMap\u003cKeyBytes, Bytes\u003e\u003e,\r\n    wal: Option\u003cWal\u003e,\r\n    id: usize,\r\n    approximate_size: Arc\u003cAtomicUsize\u003e,\r\n}\r\n\r\n/// Create a bound of `Bytes` from a bound of `\u0026[u8]`.\r\npub(crate) fn map_bound(bound: Bound\u003c\u0026[u8]\u003e) -\u003e Bound\u003cBytes\u003e {\r\n    match bound {\r\n        Bound::Included(x) =\u003e Bound::Included(Bytes::copy_from_slice(x)),\r\n        Bound::Excluded(x) =\u003e Bound::Excluded(Bytes::copy_from_slice(x)),\r\n        Bound::Unbounded =\u003e Bound::Unbounded,\r\n    }\r\n}\r\n\r\n/// Create a bound of `Bytes` from a bound of `KeySlice`.\r\npub(crate) fn map_key_bound(bound: Bound\u003cKeySlice\u003e) -\u003e Bound\u003cKeyBytes\u003e {\r\n    match bound {\r\n        Bound::Included(x) =\u003e Bound::Included(KeyBytes::from_bytes_with_ts(\r\n            Bytes::copy_from_slice(x.key_ref()),\r\n            x.ts(),\r\n        )),\r\n        Bound::Excluded(x) =\u003e Bound::Excluded(KeyBytes::from_bytes_with_ts(\r\n            Bytes::copy_from_slice(x.key_ref()),\r\n            x.ts(),\r\n        )),\r\n        Bound::Unbounded =\u003e Bound::Unbounded,\r\n    }\r\n}\r\n\r\n/// Create a bound of `Bytes` from a bound of `KeySlice`.\r\npub(crate) fn map_key_bound_plus_ts(bound: Bound\u003c\u0026[u8]\u003e, ts: u64) -\u003e Bound\u003cKeySlice\u003e {\r\n    match bound {\r\n        Bound::Included(x) =\u003e Bound::Included(KeySlice::from_slice(x, ts)),\r\n        Bound::Excluded(x) =\u003e Bound::Excluded(KeySlice::from_slice(x, ts)),\r\n        Bound::Unbounded =\u003e Bound::Unbounded,\r\n    }\r\n}\r\n\r\nimpl MemTable {\r\n    /// Create a new mem-table.\r\n    pub fn create(id: usize) -\u003e Self {\r\n        Self {\r\n            id,\r\n            map: Arc::new(SkipMap::new()),\r\n            wal: None,\r\n            approximate_size: Arc::new(AtomicUsize::new(0)),\r\n        }\r\n    }\r\n\r\n    /// Create a new mem-table with WAL\r\n    pub fn create_with_wal(id: usize, path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cSelf\u003e {\r\n        Ok(Self {\r\n            id,\r\n            map: Arc::new(SkipMap::new()),\r\n            wal: Some(Wal::create(path.as_ref())?),\r\n            approximate_size: Arc::new(AtomicUsize::new(0)),\r\n        })\r\n    }\r\n\r\n    /// Create a memtable from WAL\r\n    pub fn recover_from_wal(id: usize, path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cSelf\u003e {\r\n        let map = Arc::new(SkipMap::new());\r\n        Ok(Self {\r\n            id,\r\n            wal: Some(Wal::recover(path.as_ref(), \u0026map)?),\r\n            map,\r\n            approximate_size: Arc::new(AtomicUsize::new(0)),\r\n        })\r\n    }\r\n\r\n    /// Get a value by key.\r\n    pub fn get(\u0026self, key: KeySlice) -\u003e Option\u003cBytes\u003e {\r\n        let key_bytes = KeyBytes::from_bytes_with_ts(\r\n            Bytes::from_static(unsafe { std::mem::transmute(key.key_ref()) }),\r\n            key.ts(),\r\n        );\r\n\r\n        self.map.get(\u0026key_bytes).map(|e| e.value().clone())\r\n    }\r\n\r\n    /// Put a key-value pair into the mem-table.\r\n    pub fn put(\u0026self, key: KeySlice, value: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        let estimated_size = key.raw_len() + value.len();\r\n        self.map.insert(\r\n            key.to_key_vec().into_key_bytes(),\r\n            Bytes::copy_from_slice(value),\r\n        );\r\n        self.approximate_size\r\n            .fetch_add(estimated_size, std::sync::atomic::Ordering::Relaxed);\r\n        if let Some(ref wal) = self.wal {\r\n            wal.put(key, value)?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub fn sync_wal(\u0026self) -\u003e Result\u003c()\u003e {\r\n        if let Some(ref wal) = self.wal {\r\n            wal.sync()?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    /// Get an iterator over a range of keys.\r\n    pub fn scan(\u0026self, lower: Bound\u003cKeySlice\u003e, upper: Bound\u003cKeySlice\u003e) -\u003e MemTableIterator {\r\n        let (lower, upper) = (map_key_bound(lower), map_key_bound(upper));\r\n        let mut iter = MemTableIteratorBuilder {\r\n            map: self.map.clone(),\r\n            iter_builder: |map| map.range((lower, upper)),\r\n            item: (KeyBytes::new(), Bytes::new()),\r\n        }\r\n        .build();\r\n        let entry = iter.with_iter_mut(|iter| MemTableIterator::entry_to_item(iter.next()));\r\n        iter.with_mut(|x| *x.item = entry);\r\n        iter\r\n    }\r\n\r\n    /// Flush the mem-table to SSTable. Implement in week 1 day 6.\r\n    pub fn flush(\u0026self, builder: \u0026mut SsTableBuilder) -\u003e Result\u003c()\u003e {\r\n        for entry in self.map.iter() {\r\n            builder.add(entry.key().as_key_slice(), \u0026entry.value()[..]);\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub fn id(\u0026self) -\u003e usize {\r\n        self.id\r\n    }\r\n\r\n    pub fn approximate_size(\u0026self) -\u003e usize {\r\n        self.approximate_size\r\n            .load(std::sync::atomic::Ordering::Relaxed)\r\n    }\r\n\r\n    /// Only use this function when closing the database\r\n    pub fn is_empty(\u0026self) -\u003e bool {\r\n        self.map.is_empty()\r\n    }\r\n    pub fn for_testing_put_slice(\u0026self, key: \u0026[u8], value: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        self.put(KeySlice::from_slice(key, TS_DEFAULT), value)\r\n    }\r\n\r\n    pub fn for_testing_get_slice(\u0026self, key: \u0026[u8]) -\u003e Option\u003cBytes\u003e {\r\n        self.get(KeySlice::from_slice(key, TS_DEFAULT))\r\n    }\r\n\r\n    pub fn for_testing_scan_slice(\r\n        \u0026self,\r\n        lower: Bound\u003c\u0026[u8]\u003e,\r\n        upper: Bound\u003c\u0026[u8]\u003e,\r\n    ) -\u003e MemTableIterator {\r\n        self.scan(\r\n            map_key_bound_plus_ts(lower, TS_DEFAULT),\r\n            map_key_bound_plus_ts(upper, TS_DEFAULT),\r\n        )\r\n    }\r\n}\r\n\r\ntype SkipMapRangeIter\u003c'a\u003e = crossbeam_skiplist::map::Range\u003c\r\n    'a,\r\n    KeyBytes,\r\n    (Bound\u003cKeyBytes\u003e, Bound\u003cKeyBytes\u003e),\r\n    KeyBytes,\r\n    Bytes,\r\n\u003e;\r\n\r\n/// An iterator over a range of `SkipMap`. This is a self-referential structure and please refer to week 1, day 2\r\n/// chapter for more information.\r\n///\r\n/// This is part of week 1, day 2.\r\n#[self_referencing]\r\npub struct MemTableIterator {\r\n    /// Stores a reference to the skipmap.\r\n    map: Arc\u003cSkipMap\u003cKeyBytes, Bytes\u003e\u003e,\r\n    /// Stores a skipmap iterator that refers to the lifetime of `MemTableIterator` itself.\r\n    #[borrows(map)]\r\n    #[not_covariant]\r\n    iter: SkipMapRangeIter\u003c'this\u003e,\r\n    /// Stores the current key-value pair.\r\n    item: (KeyBytes, Bytes),\r\n}\r\n\r\nimpl MemTableIterator {\r\n    fn entry_to_item(entry: Option\u003cEntry\u003c'_, KeyBytes, Bytes\u003e\u003e) -\u003e (KeyBytes, Bytes) {\r\n        entry\r\n            .map(|x| (x.key().clone(), x.value().clone()))\r\n            .unwrap_or_else(|| (KeyBytes::new(), Bytes::new()))\r\n    }\r\n}\r\n\r\nimpl StorageIterator for MemTableIterator {\r\n    type KeyType\u003c'a\u003e = KeySlice\u003c'a\u003e;\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        \u0026self.borrow_item().1[..]\r\n    }\r\n\r\n    fn key(\u0026self) -\u003e KeySlice {\r\n        self.borrow_item().0.as_key_slice()\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        !self.borrow_item().0.is_empty()\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        let entry = self.with_iter_mut(|iter| MemTableIterator::entry_to_item(iter.next()));\r\n        self.with_mut(|x| *x.item = entry);\r\n        Ok(())\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod test {\r\n    use std::{ops::Bound, sync::Arc};\r\n    use bytes::Bytes;\r\n    use tempfile::tempdir;\r\n\r\n    use crate::storage::engine::piggykv::{\r\n        debug::{check_iter_result_by_key, check_lsm_iter_result_by_key, expect_iter_error, MockIterator}, iterators::{merge_iterator::MergeIterator, StorageIterator}, lsm_iterator::FusedIterator, lsm_storage::{LsmStorageInner, LsmStorageOptions}, mem_table::MemTable\r\n    };\r\n\r\n    #[test]\r\n    fn test_task1_memtable_get() {\r\n        let memtable = MemTable::create(0);\r\n        memtable.for_testing_put_slice(b\"key1\", b\"value1\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key2\", b\"value2\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key3\", b\"value3\").unwrap();\r\n        assert_eq!(\r\n            \u0026memtable.for_testing_get_slice(b\"key1\").unwrap()[..],\r\n            b\"value1\"\r\n        );\r\n        assert_eq!(\r\n            \u0026memtable.for_testing_get_slice(b\"key2\").unwrap()[..],\r\n            b\"value2\"\r\n        );\r\n        assert_eq!(\r\n            \u0026memtable.for_testing_get_slice(b\"key3\").unwrap()[..],\r\n            b\"value3\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task1_memtable_overwrite() {\r\n        let memtable = MemTable::create(0);\r\n        memtable.for_testing_put_slice(b\"key1\", b\"value1\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key2\", b\"value2\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key3\", b\"value3\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key1\", b\"value11\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key2\", b\"value22\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key3\", b\"value33\").unwrap();\r\n        assert_eq!(\r\n            \u0026memtable.for_testing_get_slice(b\"key1\").unwrap()[..],\r\n            b\"value11\"\r\n        );\r\n        assert_eq!(\r\n            \u0026memtable.for_testing_get_slice(b\"key2\").unwrap()[..],\r\n            b\"value22\"\r\n        );\r\n        assert_eq!(\r\n            \u0026memtable.for_testing_get_slice(b\"key3\").unwrap()[..],\r\n            b\"value33\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_storage_integration() {\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(dir.path(), LsmStorageOptions::default()).unwrap());\r\n        assert_eq!(\u0026storage.get(b\"0\").unwrap(), \u0026None);\r\n        storage.put(b\"1\", b\"233\").unwrap();\r\n        storage.put(b\"2\", b\"2333\").unwrap();\r\n        storage.put(b\"3\", b\"23333\").unwrap();\r\n        assert_eq!(\u0026storage.get(b\"1\").unwrap().unwrap()[..], b\"233\");\r\n        assert_eq!(\u0026storage.get(b\"2\").unwrap().unwrap()[..], b\"2333\");\r\n        assert_eq!(\u0026storage.get(b\"3\").unwrap().unwrap()[..], b\"23333\");\r\n        storage.delete(b\"2\").unwrap();\r\n        assert!(storage.get(b\"2\").unwrap().is_none());\r\n        storage.delete(b\"0\").unwrap(); // should NOT report any error\r\n    }\r\n\r\n    #[test]\r\n    fn test_task3_storage_integration() {\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(dir.path(), LsmStorageOptions::default()).unwrap());\r\n        storage.put(b\"1\", b\"233\").unwrap();\r\n        storage.put(b\"2\", b\"2333\").unwrap();\r\n        storage.put(b\"3\", b\"23333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        assert_eq!(storage.state.read().imm_memtables.len(), 1);\r\n        let previous_approximate_size = storage.state.read().imm_memtables[0].approximate_size();\r\n        assert!(previous_approximate_size \u003e= 15);\r\n        storage.put(b\"1\", b\"2333\").unwrap();\r\n        storage.put(b\"2\", b\"23333\").unwrap();\r\n        storage.put(b\"3\", b\"233333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        assert_eq!(storage.state.read().imm_memtables.len(), 2);\r\n        assert!(\r\n            storage.state.read().imm_memtables[1].approximate_size() == previous_approximate_size,\r\n            \"wrong order of memtables?\"\r\n        );\r\n        assert!(\r\n            storage.state.read().imm_memtables[0].approximate_size() \u003e previous_approximate_size\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task3_freeze_on_capacity() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default();\r\n        options.target_sst_size = 1024;\r\n        options.num_memtable_limit = 1000;\r\n        let storage = Arc::new(LsmStorageInner::open(dir.path(), options).unwrap());\r\n        for _ in 0..1000 {\r\n            storage.put(b\"1\", b\"2333\").unwrap();\r\n        }\r\n        let num_imm_memtables = storage.state.read().imm_memtables.len();\r\n        assert!(num_imm_memtables \u003e= 1, \"no memtable frozen?\");\r\n        for _ in 0..1000 {\r\n            storage.delete(b\"1\").unwrap();\r\n        }\r\n        assert!(\r\n            storage.state.read().imm_memtables.len() \u003e num_imm_memtables,\r\n            \"no more memtable frozen?\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task4_storage_integration() {\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(dir.path(), LsmStorageOptions::default()).unwrap());\r\n        assert_eq!(\u0026storage.get(b\"0\").unwrap(), \u0026None);\r\n        storage.put(b\"1\", b\"233\").unwrap();\r\n        storage.put(b\"2\", b\"2333\").unwrap();\r\n        storage.put(b\"3\", b\"23333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        storage.delete(b\"1\").unwrap();\r\n        storage.delete(b\"2\").unwrap();\r\n        storage.put(b\"3\", b\"2333\").unwrap();\r\n        storage.put(b\"4\", b\"23333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        storage.put(b\"1\", b\"233333\").unwrap();\r\n        storage.put(b\"3\", b\"233333\").unwrap();\r\n        assert_eq!(storage.state.read().imm_memtables.len(), 2);\r\n        assert_eq!(\u0026storage.get(b\"1\").unwrap().unwrap()[..], b\"233333\");\r\n        assert_eq!(\u0026storage.get(b\"2\").unwrap(), \u0026None);\r\n        assert_eq!(\u0026storage.get(b\"3\").unwrap().unwrap()[..], b\"233333\");\r\n        assert_eq!(\u0026storage.get(b\"4\").unwrap().unwrap()[..], b\"23333\");\r\n    }\r\n    #[test]\r\n    fn test_task1_memtable_iter() {\r\n        use std::ops::Bound;\r\n        let memtable = MemTable::create(0);\r\n        memtable.for_testing_put_slice(b\"key1\", b\"value1\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key2\", b\"value2\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key3\", b\"value3\").unwrap();\r\n\r\n        {\r\n            let mut iter = memtable.for_testing_scan_slice(Bound::Unbounded, Bound::Unbounded);\r\n            assert_eq!(iter.key().for_testing_key_ref(), b\"key1\");\r\n            assert_eq!(iter.value(), b\"value1\");\r\n            assert!(iter.is_valid());\r\n            iter._next().unwrap();\r\n            assert_eq!(iter.key().for_testing_key_ref(), b\"key2\");\r\n            assert_eq!(iter.value(), b\"value2\");\r\n            assert!(iter.is_valid());\r\n            iter._next().unwrap();\r\n            assert_eq!(iter.key().for_testing_key_ref(), b\"key3\");\r\n            assert_eq!(iter.value(), b\"value3\");\r\n            assert!(iter.is_valid());\r\n            iter._next().unwrap();\r\n            assert!(!iter.is_valid());\r\n        }\r\n\r\n        {\r\n            let mut iter =\r\n                memtable.for_testing_scan_slice(Bound::Included(b\"key1\"), Bound::Included(b\"key2\"));\r\n            assert_eq!(iter.key().for_testing_key_ref(), b\"key1\");\r\n            assert_eq!(iter.value(), b\"value1\");\r\n            assert!(iter.is_valid());\r\n            iter._next().unwrap();\r\n            assert_eq!(iter.key().for_testing_key_ref(), b\"key2\");\r\n            assert_eq!(iter.value(), b\"value2\");\r\n            assert!(iter.is_valid());\r\n            iter._next().unwrap();\r\n            assert!(!iter.is_valid());\r\n        }\r\n\r\n        {\r\n            let mut iter =\r\n                memtable.for_testing_scan_slice(Bound::Excluded(b\"key1\"), Bound::Excluded(b\"key3\"));\r\n            assert_eq!(iter.key().for_testing_key_ref(), b\"key2\");\r\n            assert_eq!(iter.value(), b\"value2\");\r\n            assert!(iter.is_valid());\r\n            iter._next().unwrap();\r\n            assert!(!iter.is_valid());\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_task1_empty_memtable_iter() {\r\n        use std::ops::Bound;\r\n        let memtable = MemTable::create(0);\r\n        {\r\n            let iter =\r\n                memtable.for_testing_scan_slice(Bound::Excluded(b\"key1\"), Bound::Excluded(b\"key3\"));\r\n            assert!(!iter.is_valid());\r\n        }\r\n        {\r\n            let iter =\r\n                memtable.for_testing_scan_slice(Bound::Included(b\"key1\"), Bound::Included(b\"key2\"));\r\n            assert!(!iter.is_valid());\r\n        }\r\n        {\r\n            let iter = memtable.for_testing_scan_slice(Bound::Unbounded, Bound::Unbounded);\r\n            assert!(!iter.is_valid());\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_merge_1() {\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n            (Bytes::from(\"e\"), Bytes::new()),\r\n        ]);\r\n        let i2 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.2\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n        ]);\r\n        let i3 = MockIterator::new(vec![\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.3\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.3\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"4.3\")),\r\n        ]);\r\n\r\n        let mut iter = MergeIterator::create(vec![\r\n            Box::new(i1.clone()),\r\n            Box::new(i2.clone()),\r\n            Box::new(i3.clone()),\r\n        ]);\r\n\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n                (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n                (Bytes::from(\"e\"), Bytes::new()),\r\n            ],\r\n        );\r\n\r\n        let mut iter = MergeIterator::create(vec![Box::new(i3), Box::new(i1), Box::new(i2)]);\r\n\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.3\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.3\")),\r\n                (Bytes::from(\"d\"), Bytes::from(\"4.3\")),\r\n                (Bytes::from(\"e\"), Bytes::new()),\r\n            ],\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_merge_2() {\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n        ]);\r\n        let i2 = MockIterator::new(vec![\r\n            (Bytes::from(\"d\"), Bytes::from(\"1.2\")),\r\n            (Bytes::from(\"e\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"f\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"g\"), Bytes::from(\"4.2\")),\r\n        ]);\r\n        let i3 = MockIterator::new(vec![\r\n            (Bytes::from(\"h\"), Bytes::from(\"1.3\")),\r\n            (Bytes::from(\"i\"), Bytes::from(\"2.3\")),\r\n            (Bytes::from(\"j\"), Bytes::from(\"3.3\")),\r\n            (Bytes::from(\"k\"), Bytes::from(\"4.3\")),\r\n        ]);\r\n        let i4 = MockIterator::new(vec![]);\r\n        let result = vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"1.2\")),\r\n            (Bytes::from(\"e\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"f\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"g\"), Bytes::from(\"4.2\")),\r\n            (Bytes::from(\"h\"), Bytes::from(\"1.3\")),\r\n            (Bytes::from(\"i\"), Bytes::from(\"2.3\")),\r\n            (Bytes::from(\"j\"), Bytes::from(\"3.3\")),\r\n            (Bytes::from(\"k\"), Bytes::from(\"4.3\")),\r\n        ];\r\n\r\n        let mut iter = MergeIterator::create(vec![\r\n            Box::new(i1.clone()),\r\n            Box::new(i2.clone()),\r\n            Box::new(i3.clone()),\r\n            Box::new(i4.clone()),\r\n        ]);\r\n        check_iter_result_by_key(\u0026mut iter, result.clone());\r\n\r\n        let mut iter = MergeIterator::create(vec![\r\n            Box::new(i2.clone()),\r\n            Box::new(i4.clone()),\r\n            Box::new(i3.clone()),\r\n            Box::new(i1.clone()),\r\n        ]);\r\n        check_iter_result_by_key(\u0026mut iter, result.clone());\r\n\r\n        let mut iter =\r\n            MergeIterator::create(vec![Box::new(i4), Box::new(i3), Box::new(i2), Box::new(i1)]);\r\n        check_iter_result_by_key(\u0026mut iter, result);\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_merge_empty() {\r\n        let mut iter = MergeIterator::\u003cMockIterator\u003e::create(vec![]);\r\n        check_iter_result_by_key(\u0026mut iter, vec![]);\r\n\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n        ]);\r\n        let i2 = MockIterator::new(vec![]);\r\n        let mut iter = MergeIterator::\u003cMockIterator\u003e::create(vec![Box::new(i1), Box::new(i2)]);\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n            ],\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_merge_error() {\r\n        let mut iter = MergeIterator::\u003cMockIterator\u003e::create(vec![]);\r\n        check_iter_result_by_key(\u0026mut iter, vec![]);\r\n\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n        ]);\r\n        let i2 = MockIterator::new_with_error(\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n            ],\r\n            1,\r\n        );\r\n        let iter = MergeIterator::\u003cMockIterator\u003e::create(vec![\r\n            Box::new(i1.clone()),\r\n            Box::new(i1),\r\n            Box::new(i2),\r\n        ]);\r\n        // your implementation should correctly throw an error instead of panic\r\n        expect_iter_error(iter);\r\n    }\r\n\r\n    #[test]\r\n    fn test_task3_fused_iterator() {\r\n        let iter = MockIterator::new(vec![]);\r\n        let mut fused_iter = FusedIterator::new(iter);\r\n        assert!(!fused_iter.is_valid());\r\n        fused_iter._next().unwrap();\r\n        fused_iter._next().unwrap();\r\n        fused_iter._next().unwrap();\r\n        assert!(!fused_iter.is_valid());\r\n\r\n        let iter = MockIterator::new_with_error(\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            ],\r\n            1,\r\n        );\r\n        let mut fused_iter = FusedIterator::new(iter);\r\n        assert!(fused_iter.is_valid());\r\n        assert!(fused_iter._next().is_err());\r\n        assert!(!fused_iter.is_valid());\r\n        assert!(fused_iter._next().is_err());\r\n        assert!(fused_iter._next().is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_task4_integration() {\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(dir.path(), LsmStorageOptions::default()).unwrap());\r\n        storage.put(b\"1\", b\"233\").unwrap();\r\n        storage.put(b\"2\", b\"2333\").unwrap();\r\n        storage.put(b\"3\", b\"23333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        storage.delete(b\"1\").unwrap();\r\n        storage.delete(b\"2\").unwrap();\r\n        storage.put(b\"3\", b\"2333\").unwrap();\r\n        storage.put(b\"4\", b\"23333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        storage.put(b\"1\", b\"233333\").unwrap();\r\n        storage.put(b\"3\", b\"233333\").unwrap();\r\n        {\r\n            let mut iter = storage.scan(Bound::Unbounded, Bound::Unbounded).unwrap();\r\n            check_lsm_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"233333\")),\r\n                    (Bytes::from_static(b\"3\"), Bytes::from_static(b\"233333\")),\r\n                    (Bytes::from_static(b\"4\"), Bytes::from_static(b\"23333\")),\r\n                ],\r\n            );\r\n            assert!(!iter.is_valid());\r\n            iter._next().unwrap();\r\n            iter._next().unwrap();\r\n            iter._next().unwrap();\r\n            assert!(!iter.is_valid());\r\n        }\r\n        {\r\n            let mut iter = storage\r\n                .scan(Bound::Included(b\"2\"), Bound::Included(b\"3\"))\r\n                .unwrap();\r\n            check_lsm_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![(Bytes::from_static(b\"3\"), Bytes::from_static(b\"233333\"))],\r\n            );\r\n            assert!(!iter.is_valid());\r\n            iter._next().unwrap();\r\n            iter._next().unwrap();\r\n            iter._next().unwrap();\r\n            assert!(!iter.is_valid());\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":10520408729537478655},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1152921504606846977},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3602879701896396800},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3602879701896396800},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":13258597302978739479},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":13258597302978739479},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":13258597302978739479},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1585267068834415337},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1585267068834415337},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1585267068834415337},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":17005592192950992896},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":17005592192950992896},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":8791026472627207729},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2305843009213694805},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":16068843470457929728},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":11024811887802974208},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":11024811887802974208},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":11024811887802974208},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":14627691589699371008},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":11024811887802974208},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":14627691589699371380},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":14627691589699371380},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":11024811887802974208},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2810246167479189876},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":8142508126285857140},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":2666130979403333632},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":2810246167479189935},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":4179340454199820289},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":4179340454199820289},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":4179340454199820289},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":216172782113784271},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":216172782113784271},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":14267403619509731700},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":11601272640106397710},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":12105675798371893628},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":12105675798371893628},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":6917529027641081898},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":6917529027641081898},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1080863910568919201},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":1080863910568919201},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":16285016252571714851},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":11961560610296040371},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":11961560610296040013},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":16285016252571714851},"fn_name":null}],"covered":86,"coverable":94},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","mod.rs"],"content":"pub mod block;\r\npub mod compact;\r\nmod debug;\r\npub mod iterators;\r\npub mod key;\r\npub mod lsm_iterator;\r\npub mod lsm_storage;\r\npub mod manifest;\r\npub mod mem_table;\r\npub mod mvcc;\r\npub mod table;\r\npub mod wal;\r\n\r\nuse std::{ops::Bound, path::Path, sync::Arc};\r\n\r\nuse bytes::Bytes;\r\nuse parking_lot::Mutex;\r\n\r\nuse self::{\r\n    lsm_storage::{LsmStorageInner, LsmStorageOptions, WriteBatchRecord},\r\n    mem_table::MemTable,\r\n    mvcc::txn::{Transaction, TxnIterator},\r\n};\r\n\r\nuse crate::errors::Result;\r\n\r\n/// A thin wrapper for `LsmStorageInner` and the user interface .\r\npub struct PiggyKV {\r\n    pub(crate) inner: Arc\u003cLsmStorageInner\u003e,\r\n    /// Notifies the L0 flush thread to stop working. (In week 1 day 6)\r\n    flush_notifier: crossbeam_channel::Sender\u003c()\u003e,\r\n    /// The handle for the compaction thread. (In week 1 day 6)\r\n    flush_thread: Mutex\u003cOption\u003cstd::thread::JoinHandle\u003c()\u003e\u003e\u003e,\r\n    /// Notifies the compaction thread to stop working. (In week 2)\r\n    compaction_notifier: crossbeam_channel::Sender\u003c()\u003e,\r\n    /// The handle for the compaction thread. (In week 2)\r\n    compaction_thread: Mutex\u003cOption\u003cstd::thread::JoinHandle\u003c()\u003e\u003e\u003e,\r\n}\r\n\r\nimpl Drop for PiggyKV {\r\n    fn drop(\u0026mut self) {\r\n        // println!(\"drop\");\r\n        self.compaction_notifier.send(()).ok();\r\n        self.flush_notifier.send(()).ok();\r\n    }\r\n}\r\n\r\nimpl PiggyKV {\r\n    pub fn close(\u0026self) -\u003e Result\u003c()\u003e {\r\n        self.inner.sync_dir()?;\r\n        self.compaction_notifier.send(()).ok();\r\n        self.flush_notifier.send(()).ok();\r\n\r\n        let mut compaction_thread = self.compaction_thread.lock();\r\n        if let Some(compaction_thread) = compaction_thread.take() {\r\n            compaction_thread.join().unwrap();\r\n        }\r\n        let mut flush_thread = self.flush_thread.lock();\r\n        if let Some(flush_thread) = flush_thread.take() {\r\n            flush_thread.join().unwrap();\r\n        }\r\n        if self.inner.options.enable_wal {\r\n            self.inner.sync()?;\r\n            self.inner.sync_dir()?;\r\n            return Ok(());\r\n        }\r\n\r\n        // create memtable and skip updating manifest\r\n        if !self.inner.state.read().memtable.is_empty() {\r\n            self.inner\r\n                .freeze_memtable_with_memtable(Arc::new(MemTable::create(\r\n                    self.inner.next_sst_id(),\r\n                )))?;\r\n        }\r\n\r\n        while {\r\n            let snapshot = self.inner.state.read();\r\n            !snapshot.imm_memtables.is_empty()\r\n        } {\r\n            self.inner.force_flush_next_imm_memtable()?;\r\n        }\r\n        self.inner.sync_dir()?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// Start the storage engine by either loading an existing directory or creating a new one if the directory does\r\n    /// not exist.\r\n    pub fn open(path: impl AsRef\u003cPath\u003e, options: LsmStorageOptions) -\u003e Result\u003cArc\u003cSelf\u003e\u003e {\r\n        let inner = Arc::new(LsmStorageInner::open(path, options)?);\r\n        let (tx1, rx) = crossbeam_channel::unbounded();\r\n        let compaction_thread = inner.spawn_compaction_thread(rx)?;\r\n        let (tx2, rx) = crossbeam_channel::unbounded();\r\n        let flush_thread = inner.spawn_flush_thread(rx)?;\r\n        Ok(Arc::new(Self {\r\n            inner,\r\n            flush_notifier: tx2,\r\n            flush_thread: Mutex::new(flush_thread),\r\n            compaction_notifier: tx1,\r\n            compaction_thread: Mutex::new(compaction_thread),\r\n        }))\r\n    }\r\n\r\n    pub fn get(\u0026self, key: \u0026[u8]) -\u003e Result\u003cOption\u003cBytes\u003e\u003e {\r\n        self.inner.get(key)\r\n    }\r\n\r\n    pub fn write_batch\u003cT: AsRef\u003c[u8]\u003e\u003e(\u0026self, batch: \u0026[WriteBatchRecord\u003cT\u003e]) -\u003e Result\u003c()\u003e {\r\n        self.inner.write_batch(batch)\r\n    }\r\n\r\n    pub fn put(self: \u0026Arc\u003cSelf\u003e, key: \u0026[u8], value: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        self.inner.put(key, value)\r\n    }\r\n    pub fn delete(self: \u0026Arc\u003cSelf\u003e, key: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        self.inner.delete(key)\r\n    }\r\n    pub fn sync(\u0026self) -\u003e Result\u003c()\u003e {\r\n        self.inner.sync()\r\n    }\r\n\r\n    pub fn new_txn(self: \u0026Arc\u003cSelf\u003e) -\u003e Result\u003cArc\u003cTransaction\u003e\u003e {\r\n        self.inner.new_txn()\r\n    }\r\n\r\n    pub fn scan(\u0026self, lower: Bound\u003c\u0026[u8]\u003e, upper: Bound\u003c\u0026[u8]\u003e) -\u003e Result\u003cTxnIterator\u003e {\r\n        self.inner.scan(lower, upper)\r\n    }\r\n\r\n    /// Only call this in test cases due to race conditions\r\n    pub fn force_flush(\u0026self) -\u003e Result\u003c()\u003e {\r\n        if !self.inner.state.read().memtable.is_empty() {\r\n            self.inner\r\n                .force_freeze_memtable(\u0026self.inner.state_lock.lock())?;\r\n        }\r\n        if !self.inner.state.read().imm_memtables.is_empty() {\r\n            self.inner.force_flush_next_imm_memtable()?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub fn force_full_compaction(\u0026self) -\u003e Result\u003c()\u003e {\r\n        self.inner.force_full_compaction()\r\n    }\r\n}\r\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":4035225266123964858},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4035225266123964858},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4035225266123964858},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2954361355555045747},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2954361355555045747},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":288230376151712158},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":288230376151712158},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":11457157452030541824},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":11457157452030541824},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null}],"covered":46,"coverable":57},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","mvcc","txn.rs"],"content":"#![allow(unused_variables)] // TODO(you): remove this lint after implementing this mod\r\n#![allow(dead_code)] // TODO(you): remove this lint after implementing this mod\r\n\r\nuse std::{\r\n    collections::HashSet,\r\n    ops::Bound,\r\n    sync::{\r\n        atomic::{AtomicBool, Ordering},\r\n        Arc,\r\n    },\r\n};\r\n\r\nuse bytes::Bytes;\r\nuse crossbeam_skiplist::{map::Entry, SkipMap};\r\nuse itertools::Itertools;\r\nuse ouroboros::self_referencing;\r\nuse parking_lot::Mutex;\r\nuse tracing::error;\r\n\r\nuse super::CommittedTxnData;\r\nuse crate::errors::{DatabaseError, Result};\r\nuse crate::storage::engine::piggykv::{\r\n    iterators::{two_merge_iterator::TwoMergeIterator, StorageIterator},\r\n    lsm_iterator::{FusedIterator, LsmIterator},\r\n    lsm_storage::{LsmStorageInner, WriteBatchRecord},\r\n    mem_table::map_bound,\r\n};\r\n\r\npub struct Transaction {\r\n    pub(crate) read_ts: u64,\r\n    pub(crate) inner: Arc\u003cLsmStorageInner\u003e,\r\n    pub(crate) local_storage: Arc\u003cSkipMap\u003cBytes, Bytes\u003e\u003e,\r\n    pub(crate) committed: Arc\u003cAtomicBool\u003e,\r\n    /// Write set and read set\r\n    pub(crate) key_hashes: Option\u003cMutex\u003c(HashSet\u003cu32\u003e, HashSet\u003cu32\u003e)\u003e\u003e,\r\n}\r\n\r\nimpl Transaction {\r\n    pub fn get(\u0026self, key: \u0026[u8]) -\u003e Result\u003cOption\u003cBytes\u003e\u003e {\r\n        if self.committed.load(Ordering::SeqCst) {\r\n            error!(\"cannot operate on committed txn!\");\r\n            return Err(DatabaseError::InternalError(\r\n                \"cannot operate on committed txn!\".to_string(),\r\n            ));\r\n        }\r\n        if let Some(guard) = \u0026self.key_hashes {\r\n            let mut guard = guard.lock();\r\n            let (_, read_set) = \u0026mut *guard;\r\n            read_set.insert(farmhash::hash32(key));\r\n        }\r\n        if let Some(entry) = self.local_storage.get(key) {\r\n            if entry.value().is_empty() {\r\n                return Ok(None);\r\n            } else {\r\n                return Ok(Some(entry.value().clone()));\r\n            }\r\n        }\r\n        self.inner.get_with_ts(key, self.read_ts)\r\n    }\r\n\r\n    pub fn scan(self: \u0026Arc\u003cSelf\u003e, lower: Bound\u003c\u0026[u8]\u003e, upper: Bound\u003c\u0026[u8]\u003e) -\u003e Result\u003cTxnIterator\u003e {\r\n        if self.committed.load(Ordering::SeqCst) {\r\n            panic!(\"cannot operate on committed txn!\");\r\n        }\r\n        let mut local_iter = TxnLocalIteratorBuilder {\r\n            map: self.local_storage.clone(),\r\n            iter_builder: |map| map.range((map_bound(lower), map_bound(upper))),\r\n            item: (Bytes::new(), Bytes::new()),\r\n        }\r\n        .build();\r\n        let entry = local_iter.with_iter_mut(|iter| TxnLocalIterator::entry_to_item(iter.next()));\r\n        local_iter.with_mut(|x| *x.item = entry);\r\n        let inner_scan = self.inner.scan_with_ts(lower, upper, self.read_ts)?;\r\n\r\n        let iter = TwoMergeIterator::create(local_iter, inner_scan)?;\r\n        TxnIterator::create(self.clone(), iter)\r\n    }\r\n\r\n    pub fn put(\u0026self, key: \u0026[u8], value: \u0026[u8]) {\r\n        if self.committed.load(Ordering::SeqCst) {\r\n            panic!(\"cannot operate on committed txn!\");\r\n        }\r\n        self.local_storage\r\n            .insert(Bytes::copy_from_slice(key), Bytes::copy_from_slice(value));\r\n        if let Some(key_hashes) = \u0026self.key_hashes {\r\n            let mut key_hashes = key_hashes.lock();\r\n            let (write_hashes, _) = \u0026mut *key_hashes;\r\n            write_hashes.insert(farmhash::hash32(key));\r\n        }\r\n    }\r\n\r\n    pub fn delete(\u0026self, key: \u0026[u8]) {\r\n        if self.committed.load(Ordering::SeqCst) {\r\n            panic!(\"cannot operate on committed txn!\");\r\n        }\r\n        self.local_storage\r\n            .insert(Bytes::copy_from_slice(key), Bytes::new());\r\n        if let Some(key_hashes) = \u0026self.key_hashes {\r\n            let mut key_hashes = key_hashes.lock();\r\n            let (write_hashes, _) = \u0026mut *key_hashes;\r\n            write_hashes.insert(farmhash::hash32(key));\r\n        }\r\n    }\r\n\r\n    pub fn commit(\u0026self) -\u003e Result\u003c()\u003e {\r\n        self.committed\r\n            .compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)\r\n            .expect(\"cannot operate on committed txn!\");\r\n        let _commit_lock = self.inner.mvcc().commit_lock.lock();\r\n        let serializability_check;\r\n        if let Some(guard) = \u0026self.key_hashes {\r\n            let guard = guard.lock();\r\n            let (write_set, read_set) = \u0026*guard;\r\n            // println!(\r\n            //     \"commit txn {}: write_set: {:?}, read_set: {:?}\",\r\n            //     self.read_ts,write_set, read_set\r\n            // );\r\n            if !write_set.is_empty() {\r\n                let committed_txns = self.inner.mvcc().committed_txns.lock();\r\n                for (_, txn_data) in committed_txns.range((self.read_ts + 1)..) {\r\n\r\n                    for key_hash in read_set {\r\n                        if txn_data.key_hashes.contains(key_hash) {\r\n                            return Err(DatabaseError::Serialization);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            serializability_check = true;\r\n        } else {\r\n            serializability_check = false;\r\n        }\r\n        let batch = self\r\n            .local_storage\r\n            .iter()\r\n            .map(|entry| {\r\n                if entry.value().is_empty() {\r\n                    WriteBatchRecord::Del(entry.key().clone())\r\n                } else {\r\n                    WriteBatchRecord::Put(entry.key().clone(), entry.value().clone())\r\n                }\r\n            })\r\n            .collect::\u003cVec\u003c_\u003e\u003e();\r\n        let ts = self.inner.write_batch_inner(\u0026batch)?;\r\n        if serializability_check {\r\n            let mut committed_txns = self.inner.mvcc().committed_txns.lock();\r\n            let mut key_hashes = self.key_hashes.as_ref().unwrap().lock();\r\n            let (write_set, _) = \u0026mut *key_hashes;\r\n\r\n            let old_data = committed_txns.insert(\r\n                ts,\r\n                CommittedTxnData {\r\n                    key_hashes: std::mem::take(write_set),\r\n                    read_ts: self.read_ts,\r\n                    commit_ts: ts,\r\n                },\r\n            );\r\n            assert!(old_data.is_none());\r\n\r\n            // remove unneeded txn data\r\n            let watermark = self.inner.mvcc().watermark();\r\n            while let Some(entry) = committed_txns.first_entry() {\r\n                if *entry.key() \u003c watermark {\r\n                    entry.remove();\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n    pub fn debug(\u0026self) {\r\n        let snapshot = {\r\n            let guard = self.inner.state.write();\r\n            guard\r\n        };\r\n        for sst in snapshot.l0_sstables.iter() {\r\n            println!(\r\n                \"l0 sst: {:?},first_key:{:?},last_key:{:?}\",\r\n                sst,\r\n                snapshot.sstables[sst].first_key(),\r\n                snapshot.sstables[sst].last_key()\r\n            );\r\n        }\r\n        for level in snapshot.levels.iter() {\r\n            for sst in level.1.iter() {\r\n                println!(\r\n                    \"l{} sst: {:?},first_key:{:?},last_key:{:?}\",\r\n                    level.0,\r\n                    sst,\r\n                    snapshot.sstables[sst].first_key(),\r\n                    snapshot.sstables[sst].last_key()\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl Drop for Transaction {\r\n    fn drop(\u0026mut self) {\r\n        self.inner.mvcc().ts.lock().1.remove_reader(self.read_ts)\r\n    }\r\n}\r\n\r\ntype SkipMapRangeIter\u003c'a\u003e =\r\n    crossbeam_skiplist::map::Range\u003c'a, Bytes, (Bound\u003cBytes\u003e, Bound\u003cBytes\u003e), Bytes, Bytes\u003e;\r\n\r\nimpl TxnLocalIterator {\r\n    fn entry_to_item(entry: Option\u003cEntry\u003c'_, Bytes, Bytes\u003e\u003e) -\u003e (Bytes, Bytes) {\r\n        entry\r\n            .map(|x| (x.key().clone(), x.value().clone()))\r\n            .unwrap_or_else(|| (Bytes::new(), Bytes::new()))\r\n    }\r\n}\r\n#[self_referencing]\r\npub struct TxnLocalIterator {\r\n    /// Stores a reference to the skipmap.\r\n    map: Arc\u003cSkipMap\u003cBytes, Bytes\u003e\u003e,\r\n    /// Stores a skipmap iterator that refers to the lifetime of `MemTableIterator` itself.\r\n    #[borrows(map)]\r\n    #[not_covariant]\r\n    iter: SkipMapRangeIter\u003c'this\u003e,\r\n    /// Stores the current key-value pair.\r\n    item: (Bytes, Bytes),\r\n}\r\n\r\nimpl StorageIterator for TxnLocalIterator {\r\n    type KeyType\u003c'a\u003e = \u0026'a [u8];\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        \u0026self.borrow_item().1[..]\r\n    }\r\n\r\n    fn key(\u0026self) -\u003e \u0026[u8] {\r\n        \u0026self.borrow_item().0[..]\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        !self.borrow_item().0.is_empty()\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        let entry = self.with_iter_mut(|iter| TxnLocalIterator::entry_to_item(iter.next()));\r\n        self.with_mut(|x| *x.item = entry);\r\n        Ok(())\r\n    }\r\n}\r\n\r\npub struct TxnIterator {\r\n    txn: Arc\u003cTransaction\u003e,\r\n    iter: TwoMergeIterator\u003cTxnLocalIterator, FusedIterator\u003cLsmIterator\u003e\u003e,\r\n}\r\n\r\nimpl TxnIterator {\r\n    pub fn create(\r\n        txn: Arc\u003cTransaction\u003e,\r\n        iter: TwoMergeIterator\u003cTxnLocalIterator, FusedIterator\u003cLsmIterator\u003e\u003e,\r\n    ) -\u003e Result\u003cSelf\u003e {\r\n        let mut iter = Self { txn, iter };\r\n\r\n        iter.skip_deletes()?;\r\n        if iter.is_valid() {\r\n            iter.add_to_read_set(iter.key());\r\n        }\r\n        Ok(iter)\r\n    }\r\n\r\n    fn skip_deletes(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        while self.iter.is_valid() \u0026\u0026 self.iter.value().is_empty() {\r\n            println!(\"skip key={}\", String::from_utf8(self.iter.key().to_vec())?);\r\n            if !self.iter.value().is_empty() {\r\n                println!(\"val={}\", String::from_utf8(self.iter.value().to_vec())?);\r\n            }\r\n            self.iter._next()?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn add_to_read_set(\u0026self, key: \u0026[u8]) {\r\n        if let Some(guard) = \u0026self.txn.key_hashes {\r\n            let mut guard = guard.lock();\r\n            let (_, read_set) = \u0026mut *guard;\r\n            read_set.insert(farmhash::hash32(key));\r\n        }\r\n    }\r\n}\r\n\r\nimpl StorageIterator for TxnIterator {\r\n    type KeyType\u003c'a\u003e = \u0026'a [u8] where Self: 'a;\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        self.iter.value()\r\n    }\r\n\r\n    fn key(\u0026self) -\u003e Self::KeyType\u003c'_\u003e {\r\n        self.iter.key()\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        self.iter.is_valid()\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        self.iter._next()?;\r\n        self.skip_deletes()?;\r\n        if self.is_valid() {\r\n            self.add_to_read_set(self.key());\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn num_active_iterators(\u0026self) -\u003e usize {\r\n        self.iter.num_active_iterators()\r\n    }\r\n}\r\n\r\nimpl Iterator for TxnIterator {\r\n    type Item = (Bytes, Bytes);\r\n\r\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\r\n        if self.is_valid() {\r\n            let key = Bytes::copy_from_slice(self.key());\r\n            let val = Bytes::copy_from_slice(self.value());\r\n            self._next().ok();\r\n            Some((key, val))\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use std::ops::Bound;\r\n\r\n    use bytes::Bytes;\r\n    use tempfile::tempdir;\r\n\r\n    use crate::storage::engine::piggykv::{\r\n        compact::CompactionOptions, debug::check_lsm_iter_result_by_key,\r\n        iterators::StorageIterator, lsm_storage::LsmStorageOptions, PiggyKV,\r\n    };\r\n\r\n    #[test]\r\n    fn test_txn_integration() {\r\n        let dir = tempdir().unwrap();\r\n        let options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        let txn1 = storage.new_txn().unwrap();\r\n        let txn2 = storage.new_txn().unwrap();\r\n        txn1.put(b\"test1\", b\"233\");\r\n        txn2.put(b\"test2\", b\"233\");\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut txn1.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![(Bytes::from(\"test1\"), Bytes::from(\"233\"))],\r\n        );\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut txn2.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![(Bytes::from(\"test2\"), Bytes::from(\"233\"))],\r\n        );\r\n        let txn3 = storage.new_txn().unwrap();\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut txn3.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![],\r\n        );\r\n        txn1.commit().unwrap();\r\n        txn2.commit().unwrap();\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut txn3.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![],\r\n        );\r\n        drop(txn3);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut storage.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"test1\"), Bytes::from(\"233\")),\r\n                (Bytes::from(\"test2\"), Bytes::from(\"233\")),\r\n            ],\r\n        );\r\n        let txn4 = storage.new_txn().unwrap();\r\n        assert_eq!(txn4.get(b\"test1\").unwrap(), Some(Bytes::from(\"233\")));\r\n        assert_eq!(txn4.get(b\"test2\").unwrap(), Some(Bytes::from(\"233\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut txn4.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"test1\"), Bytes::from(\"233\")),\r\n                (Bytes::from(\"test2\"), Bytes::from(\"233\")),\r\n            ],\r\n        );\r\n        txn4.put(b\"test2\", b\"2333\");\r\n        assert_eq!(txn4.get(b\"test1\").unwrap(), Some(Bytes::from(\"233\")));\r\n        assert_eq!(txn4.get(b\"test2\").unwrap(), Some(Bytes::from(\"2333\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut txn4.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"test1\"), Bytes::from(\"233\")),\r\n                (Bytes::from(\"test2\"), Bytes::from(\"2333\")),\r\n            ],\r\n        );\r\n        txn4.delete(b\"test2\");\r\n        assert_eq!(txn4.get(b\"test1\").unwrap(), Some(Bytes::from(\"233\")));\r\n        assert_eq!(txn4.get(b\"test2\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut txn4.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![(Bytes::from(\"test1\"), Bytes::from(\"233\"))],\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_serializable_1() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        options.serializable = true;\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        storage.put(b\"key1\", b\"1\").unwrap();\r\n        storage.put(b\"key2\", b\"2\").unwrap();\r\n        let txn1 = storage.new_txn().unwrap();\r\n        let txn2 = storage.new_txn().unwrap();\r\n        txn1.put(b\"key1\", \u0026txn1.get(b\"key2\").unwrap().unwrap());\r\n        txn2.put(b\"key2\", \u0026txn2.get(b\"key1\").unwrap().unwrap());\r\n        txn1.commit().unwrap();\r\n        assert!(txn2.commit().is_err());\r\n        drop(txn2);\r\n        assert_eq!(storage.get(b\"key1\").unwrap(), Some(Bytes::from(\"2\")));\r\n        assert_eq!(storage.get(b\"key2\").unwrap(), Some(Bytes::from(\"2\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_serializable_2() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        options.serializable = true;\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        let txn1 = storage.new_txn().unwrap();\r\n        let txn2 = storage.new_txn().unwrap();\r\n        txn1.put(b\"key1\", b\"1\");\r\n        txn2.put(b\"key1\", b\"2\");\r\n        txn1.commit().unwrap();\r\n        txn2.commit().unwrap();\r\n        assert_eq!(storage.get(b\"key1\").unwrap(), Some(Bytes::from(\"2\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_serializable_3_ts_range() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        options.serializable = true;\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        storage.put(b\"key1\", b\"1\").unwrap();\r\n        storage.put(b\"key2\", b\"2\").unwrap();\r\n        let txn1 = storage.new_txn().unwrap();\r\n        txn1.put(b\"key1\", \u0026txn1.get(b\"key2\").unwrap().unwrap());\r\n        txn1.commit().unwrap();\r\n        let txn2 = storage.new_txn().unwrap();\r\n        txn2.put(b\"key2\", \u0026txn2.get(b\"key1\").unwrap().unwrap());\r\n        txn2.commit().unwrap();\r\n        drop(txn2);\r\n        assert_eq!(storage.get(b\"key1\").unwrap(), Some(Bytes::from(\"2\")));\r\n        assert_eq!(storage.get(b\"key2\").unwrap(), Some(Bytes::from(\"2\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_serializable_4_scan() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        options.serializable = true;\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        storage.put(b\"key1\", b\"1\").unwrap();\r\n        storage.put(b\"key2\", b\"2\").unwrap();\r\n        let txn1 = storage.new_txn().unwrap();\r\n        let txn2 = storage.new_txn().unwrap();\r\n        txn1.put(b\"key1\", \u0026txn1.get(b\"key2\").unwrap().unwrap());\r\n        txn1.commit().unwrap();\r\n        let iter = txn2.scan(Bound::Unbounded, Bound::Unbounded).unwrap();\r\n        let consume = iter.count();\r\n\r\n        assert_eq!(consume, 2);\r\n        txn2.put(b\"key2\", b\"1\");\r\n        assert!(txn2.commit().is_err());\r\n        drop(txn2);\r\n        assert_eq!(storage.get(b\"key1\").unwrap(), Some(Bytes::from(\"2\")));\r\n        assert_eq!(storage.get(b\"key2\").unwrap(), Some(Bytes::from(\"2\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_serializable_5_read_only() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        options.serializable = true;\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        storage.put(b\"key1\", b\"1\").unwrap();\r\n        storage.put(b\"key2\", b\"2\").unwrap();\r\n        let txn1 = storage.new_txn().unwrap();\r\n        txn1.put(b\"key1\", \u0026txn1.get(b\"key2\").unwrap().unwrap());\r\n        txn1.commit().unwrap();\r\n        let txn2 = storage.new_txn().unwrap();\r\n        txn2.get(b\"key1\").unwrap().unwrap();\r\n        let iter = txn2.scan(Bound::Unbounded, Bound::Unbounded).unwrap();\r\n        let _ = iter.count();\r\n        txn2.commit().unwrap();\r\n        assert_eq!(storage.get(b\"key1\").unwrap(), Some(Bytes::from(\"2\")));\r\n        assert_eq!(storage.get(b\"key2\").unwrap(), Some(Bytes::from(\"2\")));\r\n    }\r\n}\r\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":17726168133330272256},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":17726168133330272256},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":742},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":371},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":371},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":15636497906230361741},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":17870283321406127386},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":17582052945254416384},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":6989586621679009724},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":6989586621679009724},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6773413839565225916},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1441151880758558716},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1441151880758558716},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1369094286720630780},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":3314649325744684985},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":17582052945254416313},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":144115188075855943},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1585267068834414663},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1585267068834414663},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":9295429630892703815},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1369094286720630856},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":6341068275337658296},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1585267068834414663},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":8502796096475496590},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":12033618204333965383},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":12033618204333965383},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1585267068834414663},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":12249790986447749120},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":12249790986447749120},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":14411518807585587204},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":432345564227568048},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1297036692682703712},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":1297036692682703712},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":432345564227568048},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":6557241057451442246},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":6557241057451442246},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":6557241057451442246},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":12682136550675316806},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":13258597302978740656},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":144115188075856304},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":12465963768561532928},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":8646911284551352105},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":12105675798371893462},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":12105675798371893462},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":7566047373982433495},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":7566047373982433495},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":2017612633061982639},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":2017612633061982639},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":12538021362599461296},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":12538021362599461511},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":12538021362599461081},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":432345564227567833},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":6341068275337658368},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":12538021362599461079},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":12538021362599460864},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":12538021362599460864},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":9727775195120271360},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":9727775195120271360},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":9727775195120271360},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":9727775195120271360},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null}],"covered":117,"coverable":134},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","mvcc","watermark.rs"],"content":"#![allow(unused_variables)] // TODO(you): remove this lint after implementing this mod\r\n#![allow(dead_code)] // TODO(you): remove this lint after implementing this mod\r\n\r\nuse std::collections::BTreeMap;\r\n\r\npub struct Watermark {\r\n    readers: BTreeMap\u003cu64, usize\u003e,\r\n}\r\n\r\nimpl Watermark {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            readers: BTreeMap::new(),\r\n        }\r\n    }\r\n\r\n    pub fn add_reader(\u0026mut self, ts: u64) {\r\n        *self.readers.entry(ts).or_default() += 1;\r\n    }\r\n\r\n    pub fn remove_reader(\u0026mut self, ts: u64) {\r\n        let cnt = self.readers.get_mut(\u0026ts).unwrap();\r\n        *cnt -= 1;\r\n        if *cnt == 0 {\r\n            self.readers.remove(\u0026ts);\r\n        }\r\n    }\r\n    pub fn num_retained_snapshots(\u0026self) -\u003e usize {\r\n        self.readers.len()\r\n    }\r\n\r\n    pub fn watermark(\u0026self) -\u003e Option\u003cu64\u003e {\r\n        self.readers.first_key_value().map(|(ts, _)| *ts)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::storage::engine::piggykv::{compact::CompactionOptions, debug::{check_iter_result_by_key, construct_merge_iterator_over_storage}, lsm_storage::{LsmStorageOptions, WriteBatchRecord}, mvcc::watermark::Watermark, PiggyKV};\r\n    use bytes::Bytes;\r\n    use tempfile::tempdir;\r\n\r\n    #[test]\r\n    fn test_task1_watermark() {\r\n        let mut watermark = Watermark::new();\r\n        watermark.add_reader(0);\r\n        for i in 1..=1000 {\r\n            watermark.add_reader(i);\r\n            assert_eq!(watermark.watermark(), Some(0));\r\n            assert_eq!(watermark.num_retained_snapshots(), i as usize + 1);\r\n        }\r\n        let mut cnt = 1001;\r\n        for i in 0..500 {\r\n            watermark.remove_reader(i);\r\n            assert_eq!(watermark.watermark(), Some(i + 1));\r\n            cnt -= 1;\r\n            assert_eq!(watermark.num_retained_snapshots(), cnt);\r\n        }\r\n        for i in (501..=1000).rev() {\r\n            watermark.remove_reader(i);\r\n            assert_eq!(watermark.watermark(), Some(500));\r\n            cnt -= 1;\r\n            assert_eq!(watermark.num_retained_snapshots(), cnt);\r\n        }\r\n        watermark.remove_reader(500);\r\n        assert_eq!(watermark.watermark(), None);\r\n        assert_eq!(watermark.num_retained_snapshots(), 0);\r\n        watermark.add_reader(2000);\r\n        watermark.add_reader(2000);\r\n        watermark.add_reader(2001);\r\n        assert_eq!(watermark.num_retained_snapshots(), 2);\r\n        assert_eq!(watermark.watermark(), Some(2000));\r\n        watermark.remove_reader(2000);\r\n        assert_eq!(watermark.num_retained_snapshots(), 2);\r\n        assert_eq!(watermark.watermark(), Some(2000));\r\n        watermark.remove_reader(2000);\r\n        assert_eq!(watermark.num_retained_snapshots(), 1);\r\n        assert_eq!(watermark.watermark(), Some(2001));\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_snapshot_watermark() {\r\n        let dir = tempdir().unwrap();\r\n        let options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        let txn1 = storage.new_txn().unwrap();\r\n        let txn2 = storage.new_txn().unwrap();\r\n        storage.put(b\"233\", b\"23333\").unwrap();\r\n        let txn3 = storage.new_txn().unwrap();\r\n        assert_eq!(storage.inner.mvcc().watermark(), txn1.read_ts);\r\n        drop(txn1);\r\n        assert_eq!(storage.inner.mvcc().watermark(), txn2.read_ts);\r\n        drop(txn2);\r\n        assert_eq!(storage.inner.mvcc().watermark(), txn3.read_ts);\r\n        drop(txn3);\r\n        assert_eq!(\r\n            storage.inner.mvcc().watermark(),\r\n            storage.inner.mvcc().latest_commit_ts()\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task3_mvcc_compaction() {\r\n        let dir = tempdir().unwrap();\r\n        let options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        let snapshot0 = storage.new_txn().unwrap();\r\n        storage\r\n            .write_batch(\u0026[\r\n                WriteBatchRecord::Put(b\"a\", b\"1\"),\r\n                WriteBatchRecord::Put(b\"b\", b\"1\"),\r\n            ])\r\n            .unwrap();\r\n        let snapshot1 = storage.new_txn().unwrap();\r\n        storage\r\n            .write_batch(\u0026[\r\n                WriteBatchRecord::Put(b\"a\", b\"2\"),\r\n                WriteBatchRecord::Put(b\"d\", b\"2\"),\r\n            ])\r\n            .unwrap();\r\n        let snapshot2 = storage.new_txn().unwrap();\r\n        storage\r\n            .write_batch(\u0026[\r\n                WriteBatchRecord::Put(b\"a\", b\"3\"),\r\n                WriteBatchRecord::Del(b\"d\"),\r\n            ])\r\n            .unwrap();\r\n        let snapshot3 = storage.new_txn().unwrap();\r\n        storage\r\n            .write_batch(\u0026[\r\n                WriteBatchRecord::Put(b\"c\", b\"4\"),\r\n                WriteBatchRecord::Del(b\"a\"),\r\n            ])\r\n            .unwrap();\r\n\r\n        storage.force_flush().unwrap();\r\n        storage.force_full_compaction().unwrap();\r\n\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.inner.state.read());\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::new()),\r\n                (Bytes::from(\"a\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"a\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"4\")),\r\n                (Bytes::from(\"d\"), Bytes::new()),\r\n                (Bytes::from(\"d\"), Bytes::from(\"2\")),\r\n            ],\r\n        );\r\n\r\n        drop(snapshot0);\r\n        storage.force_full_compaction().unwrap();\r\n\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.inner.state.read());\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::new()),\r\n                (Bytes::from(\"a\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"a\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"4\")),\r\n                (Bytes::from(\"d\"), Bytes::new()),\r\n                (Bytes::from(\"d\"), Bytes::from(\"2\")),\r\n            ],\r\n        );\r\n\r\n        drop(snapshot1);\r\n        storage.force_full_compaction().unwrap();\r\n\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.inner.state.read());\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::new()),\r\n                (Bytes::from(\"a\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"4\")),\r\n                (Bytes::from(\"d\"), Bytes::new()),\r\n                (Bytes::from(\"d\"), Bytes::from(\"2\")),\r\n            ],\r\n        );\r\n\r\n        drop(snapshot2);\r\n        storage.force_full_compaction().unwrap();\r\n\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.inner.state.read());\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::new()),\r\n                (Bytes::from(\"a\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"4\")),\r\n            ],\r\n        );\r\n\r\n        drop(snapshot3);\r\n        storage.force_full_compaction().unwrap();\r\n\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.inner.state.read());\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"4\")),\r\n            ],\r\n        );\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":10808639105689190400},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":10808639105689190400},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":10736581511651262910},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":10736581511651262910},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":10736581511651262910},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1369094286720631676},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":9079256848778920382},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":15276209936040722878},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":15276209936040722878},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":504403158265495559},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":18302628885633695758},"fn_name":null}],"covered":13,"coverable":13},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","mvcc.rs"],"content":"pub mod txn;\r\nmod watermark;\r\n\r\nuse std::{\r\n    collections::{BTreeMap, HashSet},\r\n    sync::{atomic::AtomicBool, Arc},\r\n};\r\n\r\nuse crossbeam_skiplist::SkipMap;\r\nuse parking_lot::Mutex;\r\n\r\nuse self::{txn::Transaction, watermark::Watermark};\r\n\r\nuse super::lsm_storage::LsmStorageInner;\r\n\r\npub(crate) struct CommittedTxnData {\r\n    pub(crate) key_hashes: HashSet\u003cu32\u003e,\r\n    #[allow(dead_code)]\r\n    pub(crate) read_ts: u64,\r\n    #[allow(dead_code)]\r\n    pub(crate) commit_ts: u64,\r\n}\r\n\r\npub(crate) struct LsmMvccInner {\r\n    pub(crate) write_lock: Mutex\u003c()\u003e,\r\n    pub(crate) commit_lock: Mutex\u003c()\u003e,\r\n\r\n    pub(crate) ts: Arc\u003cMutex\u003c(u64, Watermark)\u003e\u003e,\r\n    pub(crate) committed_txns: Arc\u003cMutex\u003cBTreeMap\u003cu64, CommittedTxnData\u003e\u003e\u003e,\r\n}\r\n\r\nimpl LsmMvccInner {\r\n    pub fn new(initial_ts: u64) -\u003e Self {\r\n        Self {\r\n            write_lock: Mutex::new(()),\r\n            commit_lock: Mutex::new(()),\r\n\r\n            ts: Arc::new(Mutex::new((initial_ts, Watermark::new()))),\r\n            committed_txns: Arc::new(Mutex::new(BTreeMap::new())),\r\n        }\r\n    }\r\n\r\n    pub fn latest_commit_ts(\u0026self) -\u003e u64 {\r\n        self.ts.lock().0\r\n    }\r\n\r\n    pub fn update_commit_ts(\u0026self, ts: u64) {\r\n        self.ts.lock().0 = ts;\r\n    }\r\n\r\n    /// All ts (strictly) below this ts can be garbage collected.\r\n    pub fn watermark(\u0026self) -\u003e u64 {\r\n        let ts = self.ts.lock();\r\n        ts.1.watermark().unwrap_or(ts.0)\r\n    }\r\n\r\n    pub fn new_txn(\u0026self, inner: Arc\u003cLsmStorageInner\u003e, serializable: bool) -\u003e Arc\u003cTransaction\u003e {\r\n        let mut ts = self.ts.lock();\r\n        let read_ts = ts.0;\r\n        ts.1.add_reader(read_ts);\r\n\r\n        Arc::new(Transaction {\r\n            inner,\r\n            read_ts,\r\n            local_storage: Arc::new(SkipMap::new()),\r\n            committed: Arc::new(AtomicBool::new(false)),\r\n            key_hashes: if serializable {\r\n                Some(Mutex::new((HashSet::new(), HashSet::new())))\r\n            } else {\r\n                None\r\n            },\r\n        })\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n\r\n    use std::{ops::Bound, sync::Arc, time::Duration};\r\n\r\n    use bytes::Bytes;\r\n    use tempfile::tempdir;\r\n\r\n    use crate::storage::engine::piggykv::{\r\n        compact::CompactionOptions,\r\n        debug::{\r\n            check_iter_result_by_key_and_ts, check_lsm_iter_result_by_key, dump_files_in_dir,\r\n            generate_sst_with_ts,\r\n        },\r\n        key::KeySlice,\r\n        lsm_storage::LsmStorageOptions,\r\n        table::{FileObject, SsTable, SsTableBuilder, SsTableIterator},\r\n        PiggyKV,\r\n    };\r\n\r\n    #[test]\r\n    fn test_sst_build_multi_version_simple() {\r\n        let mut builder = SsTableBuilder::new(16);\r\n        builder.add(\r\n            KeySlice::for_testing_from_slice_with_ts(b\"233\", 233),\r\n            b\"233333\",\r\n        );\r\n        builder.add(\r\n            KeySlice::for_testing_from_slice_with_ts(b\"233\", 0),\r\n            b\"2333333\",\r\n        );\r\n        let dir = tempdir().unwrap();\r\n        builder.build_for_test(dir.path().join(\"1.sst\")).unwrap();\r\n    }\r\n\r\n    fn generate_test_data() -\u003e Vec\u003c((Bytes, u64), Bytes)\u003e {\r\n        (0..100)\r\n            .map(|id| {\r\n                (\r\n                    (Bytes::from(format!(\"key{:05}\", id / 5)), 5 - (id % 5)),\r\n                    Bytes::from(format!(\"value{:05}\", id)),\r\n                )\r\n            })\r\n            .collect()\r\n    }\r\n\r\n    #[test]\r\n    fn test_sst_build_multi_version_hard() {\r\n        let dir = tempdir().unwrap();\r\n        let data = generate_test_data();\r\n        generate_sst_with_ts(1, dir.path().join(\"1.sst\"), data.clone(), None);\r\n        let sst = Arc::new(\r\n            SsTable::open(\r\n                1,\r\n                None,\r\n                FileObject::open(\u0026dir.path().join(\"1.sst\")).unwrap(),\r\n            )\r\n            .unwrap(),\r\n        );\r\n        check_iter_result_by_key_and_ts(\r\n            \u0026mut SsTableIterator::create_and_seek_to_first(sst).unwrap(),\r\n            data,\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_memtable_mvcc() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default();\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        storage.put(b\"a\", b\"1\").unwrap();\r\n        storage.put(b\"b\", b\"1\").unwrap();\r\n        let snapshot1 = storage.new_txn().unwrap();\r\n        storage.put(b\"a\", b\"2\").unwrap();\r\n        let snapshot2 = storage.new_txn().unwrap();\r\n        storage.delete(b\"b\").unwrap();\r\n        storage.put(b\"c\", b\"1\").unwrap();\r\n        let snapshot3 = storage.new_txn().unwrap();\r\n        assert_eq!(snapshot1.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot1.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot2.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot2.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot2.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot2.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot3.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot3.get(b\"b\").unwrap(), None);\r\n        assert_eq!(snapshot3.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot3.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        storage\r\n            .inner\r\n            .force_freeze_memtable(\u0026storage.inner.state_lock.lock())\r\n            .unwrap();\r\n        storage.put(b\"a\", b\"3\").unwrap();\r\n        storage.put(b\"b\", b\"3\").unwrap();\r\n        let snapshot4 = storage.new_txn().unwrap();\r\n        storage.put(b\"a\", b\"4\").unwrap();\r\n        let snapshot5 = storage.new_txn().unwrap();\r\n        storage.delete(b\"b\").unwrap();\r\n        storage.put(b\"c\", b\"5\").unwrap();\r\n        let snapshot6 = storage.new_txn().unwrap();\r\n        assert_eq!(snapshot1.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot1.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot2.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot2.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot2.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot2.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot3.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot3.get(b\"b\").unwrap(), None);\r\n        assert_eq!(snapshot3.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot3.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot4.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"3\")));\r\n        assert_eq!(snapshot4.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"3\")));\r\n        assert_eq!(snapshot4.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot4.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot5.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"4\")));\r\n        assert_eq!(snapshot5.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"3\")));\r\n        assert_eq!(snapshot5.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot5.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"4\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot6.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"4\")));\r\n        assert_eq!(snapshot6.get(b\"b\").unwrap(), None);\r\n        assert_eq!(snapshot6.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"5\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot6.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"4\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"5\")),\r\n            ],\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_lsm_iterator_mvcc() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default();\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        storage.put(b\"a\", b\"1\").unwrap();\r\n        storage.put(b\"b\", b\"1\").unwrap();\r\n        let snapshot1 = storage.new_txn().unwrap();\r\n        storage.put(b\"a\", b\"2\").unwrap();\r\n        let snapshot2 = storage.new_txn().unwrap();\r\n        storage.delete(b\"b\").unwrap();\r\n        storage.put(b\"c\", b\"1\").unwrap();\r\n        let snapshot3 = storage.new_txn().unwrap();\r\n        storage.force_flush().unwrap();\r\n        assert_eq!(snapshot1.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot1.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot2.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot2.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot2.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot2.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot3.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot3.get(b\"b\").unwrap(), None);\r\n        assert_eq!(snapshot3.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot3.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        storage.put(b\"a\", b\"3\").unwrap();\r\n        storage.put(b\"b\", b\"3\").unwrap();\r\n        let snapshot4 = storage.new_txn().unwrap();\r\n        storage.put(b\"a\", b\"4\").unwrap();\r\n        let snapshot5 = storage.new_txn().unwrap();\r\n        storage.delete(b\"b\").unwrap();\r\n        storage.put(b\"c\", b\"5\").unwrap();\r\n        let snapshot6 = storage.new_txn().unwrap();\r\n        storage.force_flush().unwrap();\r\n        assert_eq!(snapshot1.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot1.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot2.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot2.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot2.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot2.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot3.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot3.get(b\"b\").unwrap(), None);\r\n        assert_eq!(snapshot3.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot3.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot4.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"3\")));\r\n        assert_eq!(snapshot4.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"3\")));\r\n        assert_eq!(snapshot4.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot4.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot5.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"4\")));\r\n        assert_eq!(snapshot5.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"3\")));\r\n        assert_eq!(snapshot5.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot5.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"4\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot6.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"4\")));\r\n        assert_eq!(snapshot6.get(b\"b\").unwrap(), None);\r\n        assert_eq!(snapshot6.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"5\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot6.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"4\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"5\")),\r\n            ],\r\n        );\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot6\r\n                .scan(Bound::Included(b\"a\"), Bound::Included(b\"a\"))\r\n                .unwrap(),\r\n            vec![(Bytes::from(\"a\"), Bytes::from(\"4\"))],\r\n        );\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot6\r\n                .scan(Bound::Excluded(b\"a\"), Bound::Excluded(b\"c\"))\r\n                .unwrap(),\r\n            vec![],\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task3_sst_ts() {\r\n        let mut builder = SsTableBuilder::new(16);\r\n        builder.add(KeySlice::for_testing_from_slice_with_ts(b\"11\", 1), b\"11\");\r\n        builder.add(KeySlice::for_testing_from_slice_with_ts(b\"22\", 2), b\"22\");\r\n        builder.add(KeySlice::for_testing_from_slice_with_ts(b\"33\", 3), b\"11\");\r\n        builder.add(KeySlice::for_testing_from_slice_with_ts(b\"44\", 4), b\"22\");\r\n        builder.add(KeySlice::for_testing_from_slice_with_ts(b\"55\", 5), b\"11\");\r\n        builder.add(KeySlice::for_testing_from_slice_with_ts(b\"66\", 6), b\"22\");\r\n        let dir = tempdir().unwrap();\r\n        let sst = builder.build_for_test(dir.path().join(\"1.sst\")).unwrap();\r\n        assert_eq!(sst.max_ts(), 6);\r\n    }\r\n\r\n\r\n\r\n\r\n}\r\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":13546827679130451968},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":13546827679130451968},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":13474770085092524493},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":13474770085092524493},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3674937295934325197},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3674937295934325197},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3674937295934325197},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":9583660007044415930},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2666130979403333261},"fn_name":null}],"covered":24,"coverable":24},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","table","bloom.rs"],"content":"// Copyright 2021 TiKV Project Authors. Licensed under Apache-2.0.\r\nuse crate::errors::Result;\r\n\r\nuse bytes::{Buf, BufMut, Bytes, BytesMut};\r\n\r\n/// Implements a bloom filter\r\npub struct Bloom {\r\n    /// data of filter in bits\r\n    pub(crate) filter: Bytes,\r\n    /// number of hash functions\r\n    pub(crate) k: u8,\r\n}\r\n\r\npub trait BitSlice {\r\n    fn get_bit(\u0026self, idx: usize) -\u003e bool;\r\n    fn bit_len(\u0026self) -\u003e usize;\r\n}\r\n\r\npub trait BitSliceMut {\r\n    fn set_bit(\u0026mut self, idx: usize, val: bool);\r\n}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e\u003e BitSlice for T {\r\n    fn get_bit(\u0026self, idx: usize) -\u003e bool {\r\n        let pos = idx / 8;\r\n        let offset = idx % 8;\r\n        (self.as_ref()[pos] \u0026 (1 \u003c\u003c offset)) != 0\r\n    }\r\n\r\n    fn bit_len(\u0026self) -\u003e usize {\r\n        self.as_ref().len() * 8\r\n    }\r\n}\r\n\r\nimpl\u003cT: AsMut\u003c[u8]\u003e\u003e BitSliceMut for T {\r\n    fn set_bit(\u0026mut self, idx: usize, val: bool) {\r\n        let pos = idx / 8;\r\n        let offset = idx % 8;\r\n        if val {\r\n            self.as_mut()[pos] |= 1 \u003c\u003c offset;\r\n        } else {\r\n            self.as_mut()[pos] \u0026= !(1 \u003c\u003c offset);\r\n        }\r\n    }\r\n}\r\n\r\nimpl Bloom {\r\n    /// Decode a bloom filter\r\n    pub fn decode(buf: \u0026[u8]) -\u003e Result\u003cSelf\u003e {\r\n        let checksum = (\u0026buf[buf.len() - 4..buf.len()]).get_u32();\r\n        if checksum != crc32fast::hash(\u0026buf[..buf.len() - 4]) {\r\n            panic!(\"checksum mismatched for bloom filters\");\r\n        }\r\n        let filter = \u0026buf[..buf.len() - 5];\r\n        let k = buf[buf.len() - 5];\r\n        Ok(Self {\r\n            filter: filter.to_vec().into(),\r\n            k,\r\n        })\r\n    }\r\n\r\n    /// Encode a bloom filter\r\n    pub fn encode(\u0026self, buf: \u0026mut Vec\u003cu8\u003e) {\r\n        let offset = buf.len();\r\n        buf.extend(\u0026self.filter);\r\n        buf.put_u8(self.k);\r\n        let checksum = crc32fast::hash(\u0026buf[offset..]);\r\n        buf.put_u32(checksum);\r\n    }\r\n\r\n    /// Get bloom filter bits per key from entries count and FPR\r\n    pub fn bloom_bits_per_key(entries: usize, false_positive_rate: f64) -\u003e usize {\r\n        let size =\r\n            -1.0 * (entries as f64) * false_positive_rate.ln() / std::f64::consts::LN_2.powi(2);\r\n        let locs = (size / (entries as f64)).ceil();\r\n        locs as usize\r\n    }\r\n\r\n    /// Build bloom filter from key hashes\r\n    pub fn build_from_key_hashes(keys: \u0026[u32], bits_per_key: usize) -\u003e Self {\r\n        let k = (bits_per_key as f64 * 0.69) as u32;\r\n        let k = k.min(30).max(1);\r\n        let nbits = (keys.len() * bits_per_key).max(64);\r\n        let nbytes = (nbits + 7) / 8;\r\n        let nbits = nbytes * 8;\r\n        let mut filter = BytesMut::with_capacity(nbytes);\r\n        filter.resize(nbytes, 0);\r\n        for h in keys {\r\n            let mut h = *h;\r\n            let delta = (h \u003e\u003e 17) | (h \u003c\u003c 15);\r\n            for _ in 0..k {\r\n                let bit_pos = (h as usize) % nbits;\r\n                filter.set_bit(bit_pos, true);\r\n                h = h.wrapping_add(delta);\r\n            }\r\n        }\r\n        Self {\r\n            filter: filter.freeze(),\r\n            k: k as u8,\r\n        }\r\n    }\r\n\r\n    /// Check if a bloom filter may contain some data\r\n    pub fn may_contain(\u0026self, mut h: u32) -\u003e bool {\r\n        if self.k \u003e 30 {\r\n            // potential new encoding for short bloom filters\r\n            true\r\n        } else {\r\n            let nbits = self.filter.bit_len();\r\n            let delta = (h \u003e\u003e 17) | (h \u003c\u003c 15);\r\n            for _ in 0..self.k {\r\n                let bit_pos = h % (nbits as u32);\r\n                if !self.filter.get_bit(bit_pos as usize) {\r\n                    return false;\r\n                }\r\n                h = h.wrapping_add(delta);\r\n            }\r\n            true\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use tempfile::tempdir;\r\n    use crate::storage::engine::piggykv::{key::{KeySlice, TS_ENABLED}, table::{bloom::Bloom, FileObject, SsTable, SsTableBuilder}};\r\n    fn key_of(idx: usize) -\u003e Vec\u003cu8\u003e {\r\n        format!(\"key_{:010}\", idx * 5).into_bytes()\r\n    }\r\n\r\n    fn value_of(idx: usize) -\u003e Vec\u003cu8\u003e {\r\n        format!(\"value_{:010}\", idx).into_bytes()\r\n    }\r\n\r\n    fn num_of_keys() -\u003e usize {\r\n        100\r\n    }\r\n    #[test]\r\n    fn test_task1_bloom_filter() {\r\n        let mut key_hashes = Vec::new();\r\n        for idx in 0..num_of_keys() {\r\n            let key = key_of(idx);\r\n            key_hashes.push(farmhash::fingerprint32(\u0026key));\r\n        }\r\n        let bits_per_key = Bloom::bloom_bits_per_key(key_hashes.len(), 0.01);\r\n        println!(\"bits per key: {}\", bits_per_key);\r\n        let bloom = Bloom::build_from_key_hashes(\u0026key_hashes, bits_per_key);\r\n        println!(\"bloom size: {}, k={}\", bloom.filter.len(), bloom.k);\r\n        assert!(bloom.k \u003c 30);\r\n        for idx in 0..num_of_keys() {\r\n            let key = key_of(idx);\r\n            assert!(bloom.may_contain(farmhash::fingerprint32(\u0026key)));\r\n        }\r\n        let mut x = 0;\r\n        let mut cnt = 0;\r\n        for idx in num_of_keys()..(num_of_keys() * 10) {\r\n            let key = key_of(idx);\r\n            if bloom.may_contain(farmhash::fingerprint32(\u0026key)) {\r\n                x += 1;\r\n            }\r\n            cnt += 1;\r\n        }\r\n        assert_ne!(x, cnt, \"bloom filter not taking effect?\");\r\n        assert_ne!(x, 0, \"bloom filter not taking effect?\");\r\n    }\r\n    #[test]\r\n    fn test_task2_sst_decode() {\r\n        let mut builder = SsTableBuilder::new(128);\r\n        for idx in 0..num_of_keys() {\r\n            let key = key_of(idx);\r\n            let value = value_of(idx);\r\n            builder.add(KeySlice::for_testing_from_slice_no_ts(\u0026key[..]), \u0026value[..]);\r\n        }\r\n        let dir = tempdir().unwrap();\r\n        let path = dir.path().join(\"1.sst\");\r\n        let sst = builder.build_for_test(\u0026path).unwrap();\r\n        let sst2 = SsTable::open(0, None, FileObject::open(\u0026path).unwrap()).unwrap();\r\n        let bloom_1 = sst.bloom.as_ref().unwrap();\r\n        let bloom_2 = sst2.bloom.as_ref().unwrap();\r\n        assert_eq!(bloom_1.k, bloom_2.k);\r\n        assert_eq!(bloom_1.filter, bloom_2.filter);\r\n    }\r\n    #[test]\r\nfn test_task3_block_key_compression() {\r\n    let mut builder = SsTableBuilder::new(128);\r\n    for idx in 0..num_of_keys() {\r\n        let key = key_of(idx);\r\n        let value = value_of(idx);\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(\u0026key[..]), \u0026value[..]);\r\n    }\r\n    let dir = tempdir().unwrap();\r\n    let path = dir.path().join(\"1.sst\");\r\n    let sst = builder.build_for_test(path).unwrap();\r\n    if TS_ENABLED {\r\n        assert!(\r\n            sst.block_meta.len() \u003c= 34,\r\n            \"you have {} blocks, expect 34\",\r\n            sst.block_meta.len()\r\n        );\r\n    } else {\r\n        assert!(\r\n            sst.block_meta.len() \u003c= 25,\r\n            \"you have {} blocks, expect 25\",\r\n            sst.block_meta.len()\r\n        );\r\n    }\r\n}\r\n\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":9007199254740993374},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":9007199254740993374},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":18014398509481984000},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":18014398509481984000},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":18014398509481984000},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":17582052945254424369},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":18014398509481991985},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":18446744073709543631},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":7638104968020359886},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":18014398509481984000},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":18014398509481984000},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":18014398509481984000},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":18014398509481984000},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":7782220156096218418},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":7782220156096218418},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":9007199254740999985},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":9007199254740999985},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":231},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":9007199254740999754},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":9007199254740999754},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":9007199254740999754},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":1008806316530991107},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":1008806316530991107},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":8574853690513424612},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":10880696699727118111},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null}],"covered":57,"coverable":58},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","table","builder.rs"],"content":"use std::path::Path;\r\nuse std::sync::Arc;\r\n\r\nuse crate::errors::Result;\r\nuse crate::storage::engine::piggykv::block::BlockBuilder;\r\nuse crate::storage::engine::piggykv::key::{KeySlice, KeyVec};\r\nuse crate::storage::engine::piggykv::lsm_storage::BlockCache;\r\n\r\nuse bytes::BufMut;\r\n\r\nuse super::bloom::Bloom;\r\nuse super::{BlockMeta, FileObject, SsTable};\r\n\r\n/// Builds an SSTable from key-value pairs.\r\npub struct SsTableBuilder {\r\n    builder: BlockBuilder,\r\n    first_key: KeyVec,\r\n    last_key: KeyVec,\r\n    data: Vec\u003cu8\u003e,\r\n    pub(crate) meta: Vec\u003cBlockMeta\u003e,\r\n    block_size: usize,\r\n    key_hashes: Vec\u003cu32\u003e,\r\n    max_ts: u64,\r\n}\r\n\r\nimpl SsTableBuilder {\r\n    /// Create a builder based on target block size.\r\n    pub fn new(block_size: usize) -\u003e Self {\r\n        Self {\r\n            data: Vec::new(),\r\n            meta: Vec::new(),\r\n            first_key: KeyVec::new(),\r\n            last_key: KeyVec::new(),\r\n            block_size,\r\n            builder: BlockBuilder::new(block_size),\r\n            key_hashes: Vec::new(),\r\n            max_ts: 0,\r\n        }\r\n    }\r\n\r\n    /// Adds a key-value pair to SSTable\r\n    pub fn add(\u0026mut self, key: KeySlice, value: \u0026[u8]) {\r\n        if self.first_key.is_empty() {\r\n            self.first_key.set_from_slice(key);\r\n        }\r\n        if key.ts() \u003e self.max_ts {\r\n            self.max_ts = key.ts();\r\n        }\r\n\r\n        self.key_hashes.push(farmhash::fingerprint32(key.key_ref()));\r\n\r\n        if self.builder.add(key, value) {\r\n            self.last_key.set_from_slice(key);\r\n            return;\r\n        }\r\n        assert!(!self.builder.is_empty());\r\n        // create a new block builder and append block data\r\n        self.finish_block();\r\n\r\n        // add the key-value pair to the next block\r\n        assert!(self.builder.add(key, value));\r\n        self.first_key.set_from_slice(key);\r\n        self.last_key.set_from_slice(key);\r\n    }\r\n\r\n    /// Get the estimated size of the SSTable.\r\n    pub fn estimated_size(\u0026self) -\u003e usize {\r\n        self.data.len()\r\n    }\r\n\r\n    fn finish_block(\u0026mut self) {\r\n        let builder = std::mem::replace(\u0026mut self.builder, BlockBuilder::new(self.block_size));\r\n        let encoded_block = builder.build().encode();\r\n        self.meta.push(BlockMeta {\r\n            offset: self.data.len(),\r\n            first_key: std::mem::take(\u0026mut self.first_key).into_key_bytes(),\r\n            last_key: std::mem::take(\u0026mut self.last_key).into_key_bytes(),\r\n        });\r\n        let checksum = crc32fast::hash(\u0026encoded_block);\r\n        self.data.extend(encoded_block);\r\n        self.data.put_u32(checksum);\r\n    }\r\n\r\n    /// Builds the SSTable and writes it to the given path. Use the `FileObject` structure to manipulate the disk objects.\r\n    pub fn build(\r\n        mut self,\r\n        id: usize,\r\n        block_cache: Option\u003cArc\u003cBlockCache\u003e\u003e,\r\n        bloom_false_positive_rate: f64,\r\n        path: impl AsRef\u003cPath\u003e,\r\n    ) -\u003e Result\u003cSsTable\u003e {\r\n        self.finish_block();\r\n        let mut buf = self.data;\r\n        let meta_offset = buf.len();\r\n        BlockMeta::encode_block_meta(\u0026self.meta, self.max_ts, \u0026mut buf);\r\n        buf.put_u32(meta_offset as u32);\r\n        let bloom = Bloom::build_from_key_hashes(\r\n            \u0026self.key_hashes,\r\n            Bloom::bloom_bits_per_key(self.key_hashes.len(), bloom_false_positive_rate),\r\n        );\r\n        let bloom_offset = buf.len();\r\n        bloom.encode(\u0026mut buf);\r\n        buf.put_u32(bloom_offset as u32);\r\n        let file = FileObject::create(path.as_ref(), buf)?;\r\n        Ok(SsTable {\r\n            id,\r\n            file,\r\n            first_key: self.meta.first().unwrap().first_key.clone(),\r\n            last_key: self.meta.last().unwrap().last_key.clone(),\r\n            block_meta: self.meta,\r\n            block_meta_offset: meta_offset,\r\n            block_cache,\r\n            bloom: Some(bloom),\r\n            max_ts: self.max_ts,\r\n        })\r\n    }\r\n    #[cfg(test)]\r\n    pub(crate) fn build_for_test(self, path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cSsTable\u003e {\r\n        self.build(0, None,0.01, path)\r\n    }\r\n\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":11168927075878830080},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":432345564227568946},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":7710162562058290482},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":11168927075878830080},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":11168927075878830080},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":11168927075878830080},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":14267403619509732083},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":14267403619509732083},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":15348267530078649613},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":15348267530078649569},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":15348267530078649569},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":15348267530078651653},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":15348267530078651653},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":4539628424389459968},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":4539628424389459968},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":4611686018427388800},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":4611686018427388800},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":4611686018427388800},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":4611686018427388800},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":4611686018427388800},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":4611686018427388800},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":4611686018427388800},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":4611686018427388800},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4611686018427388800},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":4611686018427388800},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":15420325124116578304},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null}],"covered":46,"coverable":47},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","table","iterator.rs"],"content":"use std::sync::Arc;\r\n\r\nuse crate::errors::Result;\r\nuse crate::storage::engine::piggykv::block::BlockIterator;\r\nuse crate::storage::engine::piggykv::iterators::StorageIterator;\r\nuse crate::storage::engine::piggykv::key::KeySlice;\r\n\r\nuse super::SsTable;\r\n\r\n/// An iterator over the contents of an SSTable.\r\npub struct SsTableIterator {\r\n    table: Arc\u003cSsTable\u003e,\r\n    blk_iter: BlockIterator,\r\n    blk_idx: usize,\r\n}\r\n\r\nimpl SsTableIterator {\r\n    fn seek_to_first_inner(table: \u0026Arc\u003cSsTable\u003e) -\u003e Result\u003c(usize, BlockIterator)\u003e {\r\n        Ok((\r\n            0,\r\n            BlockIterator::create_and_seek_to_first(table.read_block_cached(0)?),\r\n        ))\r\n    }\r\n\r\n    /// Create a new iterator and seek to the first key-value pair.\r\n    pub fn create_and_seek_to_first(table: Arc\u003cSsTable\u003e) -\u003e Result\u003cSelf\u003e {\r\n        let (blk_idx, blk_iter) = Self::seek_to_first_inner(\u0026table)?;\r\n        let iter = Self {\r\n            blk_iter,\r\n            table,\r\n            blk_idx,\r\n        };\r\n        Ok(iter)\r\n    }\r\n\r\n    /// Seek to the first key-value pair.\r\n    pub fn seek_to_first(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        let (blk_idx, blk_iter) = Self::seek_to_first_inner(\u0026self.table)?;\r\n        self.blk_idx = blk_idx;\r\n        self.blk_iter = blk_iter;\r\n        Ok(())\r\n    }\r\n\r\n    fn seek_to_key_inner(table: \u0026Arc\u003cSsTable\u003e, key: KeySlice) -\u003e Result\u003c(usize, BlockIterator)\u003e {\r\n        let mut blk_idx = table.find_block_idx(key);\r\n        let mut blk_iter =\r\n            BlockIterator::create_and_seek_to_key(table.read_block_cached(blk_idx)?, key);\r\n        if !blk_iter.is_valid() {\r\n            blk_idx += 1;\r\n            if blk_idx \u003c table.num_of_blocks() {\r\n                blk_iter =\r\n                    BlockIterator::create_and_seek_to_first(table.read_block_cached(blk_idx)?);\r\n            }\r\n        }\r\n        Ok((blk_idx, blk_iter))\r\n    }\r\n\r\n    /// Create a new iterator and seek to the first key-value pair which \u003e= `key`.\r\n    pub fn create_and_seek_to_key(table: Arc\u003cSsTable\u003e, key: KeySlice) -\u003e Result\u003cSelf\u003e {\r\n        let (blk_idx, blk_iter) = Self::seek_to_key_inner(\u0026table, key)?;\r\n        let iter = Self {\r\n            blk_iter,\r\n            table,\r\n            blk_idx,\r\n        };\r\n        Ok(iter)\r\n    }\r\n\r\n    /// Seek to the first key-value pair which \u003e= `key`.\r\n    pub fn seek_to_key(\u0026mut self, key: KeySlice) -\u003e Result\u003c()\u003e {\r\n        let (blk_idx, blk_iter) = Self::seek_to_key_inner(\u0026self.table, key)?;\r\n        self.blk_iter = blk_iter;\r\n        self.blk_idx = blk_idx;\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl StorageIterator for SsTableIterator {\r\n    type KeyType\u003c'a\u003e = KeySlice\u003c'a\u003e;\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        self.blk_iter.value()\r\n    }\r\n\r\n    fn key(\u0026self) -\u003e KeySlice {\r\n        self.blk_iter.key()\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        self.blk_iter.is_valid()\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        self.blk_iter.next();\r\n        if !self.blk_iter.is_valid() {\r\n            self.blk_idx += 1;\r\n            if self.blk_idx \u003c self.table.num_of_blocks() {\r\n                self.blk_iter = BlockIterator::create_and_seek_to_first(\r\n                    self.table.read_block_cached(self.blk_idx)?,\r\n                );\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":8430738502437568519},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":8430738502437568519},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":8430738502437568519},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":8430738502437568519},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":16140901064495857664},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":504403158265495322},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":504403158265495782},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":16357073846609641242},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":13186539708940812280},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":15276209936040722654},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":15276209936040722195},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":504403158265495781},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":17942340915444056064},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":17437937757178560512},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":3602879701896399091},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3602879701896399091},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":8718968878589291631},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":8718968878589291631},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":8286623314361722069},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":8286623314361722069},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":8286623314361722069},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":3674937295934332882},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":17509995351216497835},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":13835058055282164953},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":13835058055282171817},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":8286623314361715205},"fn_name":null}],"covered":35,"coverable":35},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","table.rs"],"content":"pub(crate) mod bloom;\r\nmod builder;\r\nmod iterator;\r\nuse crate::errors::Result;\r\n\r\nuse std::fs::File;\r\nuse std::io::Write;\r\nuse std::path::Path;\r\nuse std::sync::Arc;\r\n\r\npub use builder::SsTableBuilder;\r\nuse bytes::{Buf, BufMut};\r\npub use iterator::SsTableIterator;\r\nuse tracing::error;\r\n\r\nuse self::bloom::Bloom;\r\n\r\nuse super::{\r\n    block::Block,\r\n    key::{KeyBytes, KeySlice},\r\n    lsm_storage::BlockCache,\r\n};\r\n\r\n#[derive(Clone, Debug, PartialEq, Eq)]\r\npub struct BlockMeta {\r\n    /// Offset of this data block.\r\n    pub offset: usize,\r\n    /// The first key of the data block.\r\n    pub first_key: KeyBytes,\r\n    /// The last key of the data block.\r\n    pub last_key: KeyBytes,\r\n}\r\n\r\nimpl BlockMeta {\r\n    /// Encode block meta to a buffer.\r\n    pub fn encode_block_meta(block_meta: \u0026[BlockMeta], max_ts: u64, buf: \u0026mut Vec\u003cu8\u003e) {\r\n        let mut estimated_size = std::mem::size_of::\u003cu32\u003e(); // number of blocks\r\n        for meta in block_meta {\r\n            // The size of offset\r\n            estimated_size += std::mem::size_of::\u003cu32\u003e();\r\n            // The size of key length\r\n            estimated_size += std::mem::size_of::\u003cu16\u003e();\r\n            // The size of actual key\r\n            estimated_size += meta.first_key.raw_len();\r\n            // The size of key length\r\n            estimated_size += std::mem::size_of::\u003cu16\u003e();\r\n            // The size of actual key\r\n            estimated_size += meta.last_key.raw_len();\r\n        }\r\n        estimated_size += std::mem::size_of::\u003cu64\u003e(); // max timestamp\r\n        estimated_size += std::mem::size_of::\u003cu32\u003e(); // checksum\r\n\r\n        // Reserve the space to improve performance, especially when the size of incoming data is\r\n        // large\r\n        buf.reserve(estimated_size);\r\n        let original_len = buf.len();\r\n        buf.put_u32(block_meta.len() as u32);\r\n        for meta in block_meta {\r\n            buf.put_u32(meta.offset as u32);\r\n            buf.put_u16(meta.first_key.key_len() as u16);\r\n            buf.put_slice(meta.first_key.key_ref());\r\n            buf.put_u64(meta.first_key.ts());\r\n            buf.put_u16(meta.last_key.key_len() as u16);\r\n            buf.put_slice(meta.last_key.key_ref());\r\n            buf.put_u64(meta.last_key.ts());\r\n        }\r\n        buf.put_u64(max_ts);\r\n\r\n        buf.put_u32(crc32fast::hash(\u0026buf[original_len + 4..]));\r\n        assert_eq!(estimated_size, buf.len() - original_len);\r\n    }\r\n\r\n    /// Decode block meta from a buffer.\r\n    pub fn decode_block_meta(mut buf: \u0026[u8]) -\u003e Result\u003c(Vec\u003cBlockMeta\u003e, u64)\u003e {\r\n        let mut block_meta = Vec::new();\r\n        let num = buf.get_u32() as usize;\r\n        let checksum = crc32fast::hash(\u0026buf[..buf.remaining() - 4]);\r\n        for _ in 0..num {\r\n            let offset = buf.get_u32() as usize;\r\n            let first_key_len = buf.get_u16() as usize;\r\n            let first_key =\r\n                KeyBytes::from_bytes_with_ts(buf.copy_to_bytes(first_key_len), buf.get_u64());\r\n            let last_key_len: usize = buf.get_u16() as usize;\r\n            let last_key =\r\n                KeyBytes::from_bytes_with_ts(buf.copy_to_bytes(last_key_len), buf.get_u64());\r\n            block_meta.push(BlockMeta {\r\n                offset,\r\n                first_key,\r\n                last_key,\r\n            });\r\n        }\r\n        let max_ts = buf.get_u64();\r\n\r\n        if buf.get_u32() != checksum {\r\n            error!(\"checksum mismatched!\");\r\n            panic!(\"meta checksum mismatched\");\r\n        }\r\n\r\n        Ok((block_meta, max_ts))\r\n    }\r\n}\r\n\r\n/// A file object.\r\npub struct FileObject(Option\u003cFile\u003e, u64);\r\n\r\nimpl FileObject {\r\n    pub fn read(\u0026self, offset: u64, len: u64) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\r\n        let mut data = vec![0; len as usize];\r\n\r\n        #[cfg(windows)]\r\n        {\r\n            use std::os::windows::fs::FileExt;\r\n            self.0.as_ref().unwrap().seek_read(\u0026mut data[..], offset)?;\r\n        }\r\n        #[cfg(unix)]\r\n        {\r\n            use std::os::unix::fs::FileExt;\r\n            self.0\r\n                .as_ref()\r\n                .unwrap()\r\n                .read_exact_at(\u0026mut data[..], offset)?;\r\n        }\r\n        Ok(data)\r\n    }\r\n\r\n    pub fn size(\u0026self) -\u003e u64 {\r\n        self.1\r\n    }\r\n\r\n    /// Create a new file object (day 2) and write the file to the disk (day 4).\r\n    pub fn create(path: \u0026Path, data: Vec\u003cu8\u003e) -\u003e Result\u003cSelf\u003e {\r\n        // std::fs::write(path, \u0026data)?;\r\n        // println!(\"reach\");\r\n        let mut file = File::options()\r\n            .read(true)\r\n            .write(true)\r\n            .create(true)\r\n            .truncate(false)\r\n            .open(path)\r\n            .unwrap();\r\n        file.write_all(\u0026data)?;\r\n        file.sync_all().unwrap();\r\n        Ok(FileObject(Some(file), data.len() as u64))\r\n    }\r\n\r\n    pub fn open(path: \u0026Path) -\u003e Result\u003cSelf\u003e {\r\n        let file = File::options().read(true).write(true).open(path)?;\r\n        let size = file.metadata()?.len();\r\n        Ok(FileObject(Some(file), size))\r\n    }\r\n}\r\n\r\n/// An SSTable.\r\npub struct SsTable {\r\n    /// The actual storage unit of SsTable, the format is as above.\r\n    pub(crate) file: FileObject,\r\n    /// The meta blocks that hold info for data blocks.\r\n    pub(crate) block_meta: Vec\u003cBlockMeta\u003e,\r\n    /// The offset that indicates the start point of meta blocks in `file`.\r\n    pub(crate) block_meta_offset: usize,\r\n    id: usize,\r\n    block_cache: Option\u003cArc\u003cBlockCache\u003e\u003e,\r\n    first_key: KeyBytes,\r\n    last_key: KeyBytes,\r\n    pub(crate) bloom: Option\u003cBloom\u003e,\r\n    max_ts: u64,\r\n\r\n}\r\nimpl SsTable {\r\n    pub fn sync(\u0026self) -\u003e Result\u003c()\u003e {\r\n        self.file.0.as_ref().unwrap().sync_all()?;\r\n        Ok(())\r\n    }\r\n    /// Open SSTable from a file.\r\n    pub fn open(id: usize, block_cache: Option\u003cArc\u003cBlockCache\u003e\u003e, file: FileObject) -\u003e Result\u003cSelf\u003e {\r\n        let len = file.size();\r\n        let raw_bloom_offset = file.read(len - 4, 4)?;\r\n        let bloom_offset = (\u0026raw_bloom_offset[..]).get_u32() as u64;\r\n        let raw_bloom = file.read(bloom_offset, len - 4 - bloom_offset)?;\r\n        let bloom_filter = Bloom::decode(\u0026raw_bloom)?;\r\n        let raw_meta_offset = file.read(bloom_offset - 4, 4)?;\r\n        let block_meta_offset = (\u0026raw_meta_offset[..]).get_u32() as u64;\r\n        let raw_meta = file.read(block_meta_offset, bloom_offset - 4 - block_meta_offset)?;\r\n        let (block_meta, max_ts) = BlockMeta::decode_block_meta(\u0026raw_meta[..])?;\r\n        Ok(Self {\r\n            file,\r\n            first_key: block_meta.first().unwrap().first_key.clone(),\r\n            last_key: block_meta.last().unwrap().last_key.clone(),\r\n            block_meta,\r\n            block_meta_offset: block_meta_offset as usize,\r\n            id,\r\n            block_cache,\r\n            bloom: Some(bloom_filter),\r\n            max_ts,\r\n        })\r\n    }\r\n\r\n    /// Create a mock SST with only first key + last key metadata\r\n    pub fn create_meta_only(\r\n        id: usize,\r\n        file_size: u64,\r\n        first_key: KeyBytes,\r\n        last_key: KeyBytes,\r\n    ) -\u003e Self {\r\n        Self {\r\n            file: FileObject(None, file_size),\r\n            block_meta: vec![],\r\n            block_meta_offset: 0,\r\n            id,\r\n            block_cache: None,\r\n            first_key,\r\n            last_key,\r\n            bloom: None,\r\n            max_ts:0,\r\n        }\r\n    }\r\n\r\n    /// Read a block from the disk.\r\n    pub fn read_block(\u0026self, block_idx: usize) -\u003e Result\u003cArc\u003cBlock\u003e\u003e {\r\n        let offset = self.block_meta[block_idx].offset;\r\n        let offset_end = self\r\n            .block_meta\r\n            .get(block_idx + 1)\r\n            .map_or(self.block_meta_offset, |x| x.offset);\r\n        let block_len = offset_end - offset - 4;\r\n        let block_data_with_chksum: Vec\u003cu8\u003e = self\r\n            .file\r\n            .read(offset as u64, (offset_end - offset) as u64)?;\r\n        let block_data = \u0026block_data_with_chksum[..block_len];\r\n        let checksum = (\u0026block_data_with_chksum[block_len..]).get_u32();\r\n        if checksum != crc32fast::hash(block_data) {\r\n            error!(\"block checksum mismatched!\");\r\n            panic!(\"block checksum mismatched\");\r\n        }\r\n        Ok(Arc::new(Block::decode(block_data)))\r\n    }\r\n\r\n    /// Read a block from disk, with block cache.\r\n    pub fn read_block_cached(\u0026self, block_idx: usize) -\u003e Result\u003cArc\u003cBlock\u003e\u003e {\r\n        if let Some(ref block_cache) = self.block_cache {\r\n            let blk = block_cache\r\n                .try_get_with((self.id, block_idx), || self.read_block(block_idx))\r\n                .unwrap();\r\n            Ok(blk)\r\n        } else {\r\n            self.read_block(block_idx)\r\n        }\r\n    }\r\n\r\n    /// Find the block that may contain `key`.\r\n    pub fn find_block_idx(\u0026self, key: KeySlice) -\u003e usize {\r\n        self.block_meta\r\n            .partition_point(|meta| meta.first_key.as_key_slice() \u003c= key)\r\n            .saturating_sub(1)\r\n    }\r\n\r\n    /// Get number of data blocks.\r\n    pub fn num_of_blocks(\u0026self) -\u003e usize {\r\n        self.block_meta.len()\r\n    }\r\n\r\n    pub fn first_key(\u0026self) -\u003e \u0026KeyBytes {\r\n        \u0026self.first_key\r\n    }\r\n\r\n    pub fn last_key(\u0026self) -\u003e \u0026KeyBytes {\r\n        \u0026self.last_key\r\n    }\r\n\r\n    pub fn table_size(\u0026self) -\u003e u64 {\r\n        self.file.1\r\n    }\r\n\r\n    pub fn sst_id(\u0026self) -\u003e usize {\r\n        self.id\r\n    }\r\n    \r\n    pub fn max_ts(\u0026self) -\u003e u64 {\r\n        self.max_ts\r\n    }\r\n    #[cfg(test)]\r\n    pub(crate) fn open_for_test(file: FileObject) -\u003e Result\u003cSelf\u003e {\r\n        Self::open(0, None, file)\r\n    }\r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use std::sync::Arc;\r\n\r\n    use bytes::Bytes;\r\n\r\n    use crate::storage::engine::piggykv::{iterators::StorageIterator, key::{KeySlice, KeyVec}};\r\n    use tempfile::{tempdir, TempDir};\r\n    use super::{SsTable, SsTableBuilder, SsTableIterator};\r\n\r\n\r\n    #[test]\r\n    fn test_sst_build_single_key() {\r\n        let mut builder = SsTableBuilder::new(16);\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(b\"233\"), b\"233333\");\r\n        let dir = tempdir().unwrap();\r\n        builder.build_for_test(dir.path().join(\"1.sst\")).unwrap();\r\n    }\r\n    \r\n    #[test]\r\n    fn test_sst_build_two_blocks() {\r\n        let mut builder = SsTableBuilder::new(16);\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(b\"11\"), b\"11\");\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(b\"22\"), b\"22\");\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(b\"33\"), b\"11\");\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(b\"44\"), b\"22\");\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(b\"55\"), b\"11\");\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(b\"66\"), b\"22\");\r\n        assert!(builder.meta.len() \u003e= 2);\r\n        let dir = tempdir().unwrap();\r\n        builder.build_for_test(dir.path().join(\"1.sst\")).unwrap();\r\n    }\r\n    \r\n    fn key_of(idx: usize) -\u003e KeyVec {\r\n        KeyVec::for_testing_from_vec_no_ts(format!(\"key_{:03}\", idx * 5).into_bytes())\r\n    }\r\n    \r\n    fn value_of(idx: usize) -\u003e Vec\u003cu8\u003e {\r\n        format!(\"value_{:010}\", idx).into_bytes()\r\n    }\r\n    \r\n    fn num_of_keys() -\u003e usize {\r\n        100\r\n    }\r\n    \r\n    fn generate_sst() -\u003e (TempDir, SsTable) {\r\n        let mut builder = SsTableBuilder::new(128);\r\n        for idx in 0..num_of_keys() {\r\n            let key = key_of(idx);\r\n            let value = value_of(idx);\r\n            builder.add(key.as_key_slice(), \u0026value[..]);\r\n        }\r\n        let dir = tempdir().unwrap();\r\n        let path = dir.path().join(\"1.sst\");\r\n        (dir, builder.build_for_test(path).unwrap())\r\n    }\r\n    \r\n    #[test]\r\n    fn test_sst_build_all() {\r\n        generate_sst();\r\n    }\r\n    \r\n    #[test]\r\n    fn test_sst_decode() {\r\n        let (_dir, sst) = generate_sst();\r\n        let meta = sst.block_meta.clone();\r\n        let new_sst = SsTable::open_for_test(sst.file).unwrap();\r\n        assert_eq!(new_sst.block_meta, meta);\r\n        assert_eq!(\r\n            new_sst.first_key().for_testing_key_ref(),\r\n            key_of(0).for_testing_key_ref()\r\n        );\r\n        assert_eq!(\r\n            new_sst.last_key().for_testing_key_ref(),\r\n            key_of(num_of_keys() - 1).for_testing_key_ref()\r\n        );\r\n    }\r\n    \r\n    fn as_bytes(x: \u0026[u8]) -\u003e Bytes {\r\n        Bytes::copy_from_slice(x)\r\n    }\r\n    \r\n    #[test]\r\n    fn test_sst_iterator() {\r\n        let (_dir, sst) = generate_sst();\r\n        let sst = Arc::new(sst);\r\n        let mut iter = SsTableIterator::create_and_seek_to_first(sst).unwrap();\r\n        for _ in 0..5 {\r\n            for i in 0..num_of_keys() {\r\n                let key = iter.key();\r\n                let value = iter.value();\r\n                assert_eq!(\r\n                    key.for_testing_key_ref(),\r\n                    key_of(i).for_testing_key_ref(),\r\n                    \"expected key: {:?}, actual key: {:?}\",\r\n                    as_bytes(key_of(i).for_testing_key_ref()),\r\n                    as_bytes(key.for_testing_key_ref())\r\n                );\r\n                assert_eq!(\r\n                    value,\r\n                    value_of(i),\r\n                    \"expected value: {:?}, actual value: {:?}\",\r\n                    as_bytes(\u0026value_of(i)),\r\n                    as_bytes(value)\r\n                );\r\n                iter._next().unwrap();\r\n            }\r\n            iter.seek_to_first().unwrap();\r\n        }\r\n    }\r\n    \r\n    #[test]\r\n    fn test_sst_seek_key() {\r\n        let (_dir, sst) = generate_sst();\r\n        let sst = Arc::new(sst);\r\n        let mut iter = SsTableIterator::create_and_seek_to_key(sst, key_of(0).as_key_slice()).unwrap();\r\n        for offset in 1..=5 {\r\n            for i in 0..num_of_keys() {\r\n                let key = iter.key();\r\n                let value = iter.value();\r\n                assert_eq!(\r\n                    key.for_testing_key_ref(),\r\n                    key_of(i).for_testing_key_ref(),\r\n                    \"expected key: {:?}, actual key: {:?}\",\r\n                    as_bytes(key_of(i).for_testing_key_ref()),\r\n                    as_bytes(key.for_testing_key_ref())\r\n                );\r\n                assert_eq!(\r\n                    value,\r\n                    value_of(i),\r\n                    \"expected value: {:?}, actual value: {:?}\",\r\n                    as_bytes(\u0026value_of(i)),\r\n                    as_bytes(value)\r\n                );\r\n                iter.seek_to_key(KeySlice::for_testing_from_slice_no_ts(\r\n                    \u0026format!(\"key_{:03}\", i * 5 + offset).into_bytes(),\r\n                ))\r\n                .unwrap();\r\n            }\r\n            iter.seek_to_key(KeySlice::for_testing_from_slice_no_ts(b\"k\"))\r\n                .unwrap();\r\n        }\r\n    }\r\n    \r\n}\r\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3098476543630901248},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3098476543630901383},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":4611686018427387949},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4611686018427387949},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4611686018427387949},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4611686018427387949},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4611686018427387949},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":4611686018427387949},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":4611686018427387949},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6917529027641081856},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2233785415175766061},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":2233785415175765971},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1080863910568919043},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1080863910568919037},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":11673330234144325632},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":2738188573441261523},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":1369094286720630829},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":18446744073709551571},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":7277816997830721256},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":6341068275337658412},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":13474770085092524312},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":504403158265495555},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":504403158265495555},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":16789419410837209135},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":1585267068834414822},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1585267068834414822},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":12177733392409821234},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":12177733392409821234},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":1513209474796492254},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":1513209474796492254},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":3746994889972258073},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":3746994889972258073},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":11529215046068469766},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":11529215046068469766},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":113,"coverable":119},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","wal.rs"],"content":"use crate::errors::Result;\r\nuse std::fs::{File, OpenOptions};\r\nuse std::hash::Hasher;\r\nuse std::io::{BufWriter, Read, Write};\r\nuse std::path::Path;\r\nuse std::sync::Arc;\r\n\r\nuse bytes::{Buf, BufMut, Bytes};\r\nuse crossbeam_skiplist::SkipMap;\r\nuse parking_lot::Mutex;\r\n\r\nuse super::key::{KeyBytes, KeySlice};\r\n\r\npub struct Wal {\r\n    file: Arc\u003cMutex\u003cBufWriter\u003cFile\u003e\u003e\u003e,\r\n}\r\n\r\nimpl Wal {\r\n    pub fn create(path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cSelf\u003e {\r\n        Ok(Self {\r\n            file: Arc::new(Mutex::new(BufWriter::new(\r\n                OpenOptions::new()\r\n                    .read(true)\r\n                    .create_new(true)\r\n                    .write(true)\r\n                    .open(path)\r\n                    .expect(\"failed to create WAL\"),\r\n            ))),\r\n        })\r\n    }\r\n\r\n    pub fn recover(path: impl AsRef\u003cPath\u003e, skiplist: \u0026SkipMap\u003cKeyBytes, Bytes\u003e) -\u003e Result\u003cSelf\u003e {\r\n        let path = path.as_ref();\r\n        let mut file = OpenOptions::new()\r\n            .read(true)\r\n            .append(true)\r\n            .open(path)\r\n            .expect(\"failed to recover from WAL\");\r\n        let mut buf = Vec::new();\r\n        file.read_to_end(\u0026mut buf)?;\r\n        let mut rbuf: \u0026[u8] = buf.as_slice();\r\n        while rbuf.has_remaining() {\r\n            let mut hasher = crc32fast::Hasher::new();\r\n            let key_len = rbuf.get_u16() as usize;\r\n            hasher.write_u16(key_len as u16);\r\n            let key = Bytes::copy_from_slice(\u0026rbuf[..key_len]);\r\n            hasher.write(\u0026key);\r\n            rbuf.advance(key_len);\r\n            let ts = rbuf.get_u64();\r\n            hasher.write_u64(ts);\r\n\r\n            let value_len = rbuf.get_u16() as usize;\r\n            hasher.write_u16(value_len as u16);\r\n            let value = Bytes::copy_from_slice(\u0026rbuf[..value_len]);\r\n            hasher.write(\u0026value);\r\n            rbuf.advance(value_len);\r\n            let checksum = rbuf.get_u32();\r\n            if hasher.finalize() != checksum {\r\n                panic!(\"checksum mismatch\");\r\n            }\r\n            skiplist.insert(KeyBytes::from_bytes_with_ts(key, ts), value);\r\n        }\r\n        Ok(Self {\r\n            file: Arc::new(Mutex::new(BufWriter::new(file))),\r\n        })\r\n    }\r\n\r\n    pub fn put(\u0026self, key: KeySlice, value: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        let mut file = self.file.lock();\r\n        let mut buf: Vec\u003cu8\u003e =\r\n            Vec::with_capacity(key.raw_len() + value.len() + std::mem::size_of::\u003cu16\u003e());\r\n        let mut hasher = crc32fast::Hasher::new();\r\n        hasher.write_u16(key.key_len() as u16);\r\n        buf.put_u16(key.key_len() as u16);\r\n        hasher.write(key.key_ref());\r\n        buf.put_slice(key.key_ref());\r\n        hasher.write_u64(key.ts());\r\n        buf.put_u64(key.ts());\r\n        hasher.write_u16(value.len() as u16);\r\n        buf.put_u16(value.len() as u16);\r\n        buf.put_slice(value);\r\n        hasher.write(value);\r\n        buf.put_u32(hasher.finalize());\r\n        file.write_all(\u0026buf)?;\r\n        Ok(())\r\n    }\r\n\r\n    pub fn sync(\u0026self) -\u003e Result\u003c()\u003e {\r\n        let mut file = self.file.lock();\r\n        file.flush()?;\r\n        file.get_mut().sync_all()?;\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":6485183463413514437},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":6485183463413514509},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6485183463413514365},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null}],"covered":32,"coverable":59},{"path":["E:","\\","sql-layer","src","storage","mod.rs"],"content":"pub mod engine;\r\npub mod piggy_stroage;\r\nmod table_codec;\r\n\r\nuse crate::catalog::{ColumnCatalog, ColumnRef, IndexName, TableCatalog, TableName};\r\n\r\nuse crate::expression::simplify::ConstantBinary;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::types::index::{Index, IndexMetaRef};\r\nuse crate::types::tuple::{Tuple, TupleId};\r\nuse crate::types::ColumnId;\r\nuse crate::{errors::*};\r\n\r\npub trait Storage: Sync + Send {\r\n    type TransactionType: Transaction;\r\n    #[allow(async_fn_in_trait)]\r\n    async fn transaction(\u0026self) -\u003e Result\u003cSelf::TransactionType\u003e;\r\n}\r\n\r\n/// Optional bounds of the reader, of the form (offset, limit).\r\npub(crate) type Bounds = (Option\u003cusize\u003e, Option\u003cusize\u003e);\r\ntype Projections = Vec\u003cScalarExpression\u003e;\r\n\r\npub trait Transaction: Sync + Send + 'static {\r\n    type IterType\u003c'a\u003e: Iter;\r\n    type IndexIterType\u003c'a\u003e: Iter;\r\n\r\n    /// The bounds is applied to the whole data batches, not per batch.\r\n    ///\r\n    /// The projections is column indices.\r\n    fn read(\r\n        \u0026self,\r\n        table_name: TableName,\r\n        bound: Bounds,\r\n        projection: Projections,\r\n    ) -\u003e Result\u003cSelf::IterType\u003c'_\u003e\u003e;\r\n\r\n    fn read_by_index(\r\n        \u0026self,\r\n        table_name: TableName,\r\n        projection: Projections,\r\n        index_meta: IndexMetaRef,\r\n        binaries: Vec\u003cConstantBinary\u003e,\r\n    ) -\u003e Result\u003cSelf::IndexIterType\u003c'_\u003e\u003e;\r\n\r\n    fn add_index(\r\n        \u0026mut self,\r\n        table_name: \u0026str,\r\n        index: Index,\r\n        tuple_ids: Vec\u003cTupleId\u003e,\r\n        is_unique: bool,\r\n    ) -\u003e Result\u003c()\u003e;\r\n\r\n    fn del_index(\u0026mut self, table_name: \u0026str, index: \u0026Index) -\u003e Result\u003c()\u003e;\r\n\r\n    fn append(\u0026mut self, table_name: \u0026str, tuple: Tuple, is_overwrite: bool) -\u003e Result\u003c()\u003e;\r\n\r\n    fn delete(\u0026mut self, table_name: \u0026str, tuple_id: TupleId) -\u003e Result\u003c()\u003e;\r\n\r\n    fn add_column(\r\n        \u0026mut self,\r\n        table_name: \u0026TableName,\r\n        column: \u0026ColumnCatalog,\r\n        if_not_exists: bool,\r\n    ) -\u003e Result\u003cColumnId\u003e;\r\n\r\n    fn drop_column(\u0026mut self, table_name: \u0026TableName, column: \u0026str, if_exists: bool) -\u003e Result\u003c()\u003e;\r\n\r\n    fn create_table(\r\n        \u0026mut self,\r\n        table_name: TableName,\r\n        columns: Vec\u003cColumnCatalog\u003e,\r\n        if_not_exists: bool,\r\n    ) -\u003e Result\u003cTableName\u003e;\r\n\r\n    fn drop_table(\u0026mut self, table_name: \u0026str, if_exists: bool) -\u003e Result\u003c()\u003e;\r\n    fn drop_data(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e;\r\n    fn table(\u0026self, table_name: TableName) -\u003e Option\u003cTableCatalog\u003e;\r\n\r\n    fn show_tables(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e;\r\n\r\n    #[allow(async_fn_in_trait)]\r\n    async fn commit(self) -\u003e Result\u003c()\u003e;\r\n    #[allow(async_fn_in_trait)]\r\n    async fn rollback(self) -\u003e Result\u003c()\u003e;\r\n\r\n    fn set_isolation(\u0026mut self, serializable: bool) -\u003e Result\u003c()\u003e;\r\n    fn create_index(\r\n        \u0026mut self,\r\n        table_name: TableName,\r\n        index_name: IndexName,\r\n        column_name: \u0026str,\r\n    ) -\u003e Result\u003c()\u003e;\r\n    fn drop_index(\r\n        \u0026mut self,\r\n        table_name: TableName,\r\n        index_name: IndexName,\r\n        if_not_exists: bool,\r\n    ) -\u003e Result\u003c()\u003e;\r\n}\r\n#[allow(dead_code)]\r\nenum IndexValue {\r\n    PrimaryKey(Tuple),\r\n    Normal(TupleId),\r\n}\r\n\r\npub trait Iter: Sync + Send {\r\n    fn fetch_tuple(\u0026mut self) -\u003e Result\u003cOption\u003cVec\u003cTuple\u003e\u003e\u003e;\r\n}\r\n\r\npub(crate) fn tuple_projection(\r\n    projections: \u0026Projections,\r\n    schema: \u0026[ColumnRef],\r\n    tuple: Tuple,\r\n) -\u003e Result\u003cTuple\u003e {\r\n    let projection_len = projections.len();\r\n    let mut values = Vec::with_capacity(projection_len);\r\n    for expr in projections.iter() {\r\n        values.push(expr.eval(\u0026tuple, schema)?);\r\n    }\r\n    Ok(Tuple {\r\n        id: tuple.id,\r\n        values,\r\n    })\r\n}\r\n\r\n","traces":[{"line":111,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":12898309332789100544},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null}],"covered":8,"coverable":8},{"path":["E:","\\","sql-layer","src","storage","piggy_stroage.rs"],"content":"use std::mem;\r\nuse std::ops::Bound;\r\nuse std::{collections::VecDeque, path::PathBuf, sync::Arc};\r\n\r\nuse itertools::Itertools;\r\nuse moka::sync::Cache;\r\nuse tracing::debug;\r\n\r\nuse crate::catalog::{ColumnCatalog, ColumnRef, IndexName};\r\nuse crate::catalog::{TableCatalog, TableName};\r\nuse crate::expression::simplify::ConstantBinary;\r\n\r\nuse crate::errors::*;\r\nuse crate::storage::table_codec::TableCodec;\r\nuse crate::types::index::{Index, IndexMeta, IndexMetaRef};\r\nuse crate::types::tuple::{Tuple, TupleId};\r\nuse crate::types::value::ValueRef;\r\nuse crate::types::ColumnId;\r\n\r\nuse super::engine::piggykv::iterators::StorageIterator;\r\nuse super::engine::piggykv::mvcc::txn::{Transaction as StorageTransaction, TxnIterator};\r\nuse super::engine::piggykv::PiggyKV;\r\nuse super::{engine::piggykv::lsm_storage::LsmStorageOptions, Projections, Storage};\r\nuse super::{tuple_projection, Bounds, Iter, Transaction};\r\npub struct PiggyKVStroage {\r\n    db: Arc\u003cPiggyKV\u003e,\r\n    cache: Arc\u003cCache\u003cTableName, TableCatalog\u003e\u003e,\r\n}\r\nimpl PiggyKVStroage {\r\n    pub fn new(path: PathBuf, option: Option\u003cLsmStorageOptions\u003e) -\u003e Self {\r\n        let option = match option {\r\n            Some(op) =\u003e op,\r\n            None =\u003e LsmStorageOptions::leveled_compaction(),\r\n        };\r\n        let db = PiggyKV::open(path, option).unwrap();\r\n        let cache = Arc::new(Cache::new(40));\r\n        Self { db, cache }\r\n    }\r\n}\r\nimpl Drop for PiggyKVStroage {\r\n    fn drop(\u0026mut self) {\r\n        self.db.close().unwrap();\r\n    }\r\n}\r\npub struct TransactionWarpper {\r\n    txn: Arc\u003cStorageTransaction\u003e,\r\n    cache: Arc\u003cCache\u003cTableName, TableCatalog\u003e\u003e,\r\n}\r\n\r\nimpl Storage for PiggyKVStroage {\r\n    type TransactionType = TransactionWarpper;\r\n\r\n    async fn transaction(\u0026self) -\u003e Result\u003cSelf::TransactionType\u003e {\r\n        Ok(TransactionWarpper {\r\n            txn: self.db.new_txn().unwrap(),\r\n            cache: self.cache.clone(),\r\n        })\r\n    }\r\n}\r\npub struct IndexIteratorWarpper {\r\n    projection: Projections,\r\n\r\n    index_meta: IndexMetaRef,\r\n    table: TableCatalog,\r\n    txn: Arc\u003cStorageTransaction\u003e,\r\n    binaries: VecDeque\u003cConstantBinary\u003e,\r\n}\r\n\r\nimpl IndexIteratorWarpper {\r\n    fn val_to_key(\u0026self, val: ValueRef) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\r\n        if self.index_meta.is_unique {\r\n            let index = Index::new(self.index_meta.id, vec![val]);\r\n\r\n            TableCodec::encode_index_key(\u0026self.table.name, \u0026index)\r\n        } else {\r\n            TableCodec::encode_tuple_key(\u0026self.table.name, \u0026val)\r\n        }\r\n    }\r\n    fn get_tuple_by_id(\u0026self, tuple_id: \u0026TupleId) -\u003e Result\u003cOption\u003cTuple\u003e\u003e {\r\n        let key = TableCodec::encode_tuple_key(\u0026self.table.name, tuple_id)?;\r\n        let schema = self.table.all_columns();\r\n        self.txn\r\n            .get(\u0026key)\r\n            .unwrap()\r\n            .map(|bytes| {\r\n                let tuple = TableCodec::decode_tuple(\u0026schema, \u0026bytes);\r\n\r\n                tuple_projection(\u0026self.projection, \u0026schema, tuple)\r\n            })\r\n            .transpose()\r\n    }\r\n}\r\nimpl Iter for IndexIteratorWarpper {\r\n    fn fetch_tuple(\u0026mut self) -\u003e Result\u003cOption\u003cVec\u003cTuple\u003e\u003e\u003e {\r\n        let mut tuples: Vec\u003cTuple\u003e = Vec::new();\r\n        let schema = self.table.all_columns();\r\n        for binary in self.binaries.iter().cloned() {\r\n            match binary {\r\n                ConstantBinary::Scope { min, max } =\u003e {\r\n                    let table_name = \u0026self.table.name;\r\n                    let index_meta = \u0026self.index_meta;\r\n\r\n                    let bound_encode = |bound: Bound\u003cValueRef\u003e| -\u003e Result\u003c_\u003e {\r\n                        match bound {\r\n                            Bound::Included(val) =\u003e Ok(Bound::Included(self.val_to_key(val)?)),\r\n                            Bound::Excluded(val) =\u003e Ok(Bound::Excluded(self.val_to_key(val)?)),\r\n                            Bound::Unbounded =\u003e Ok(Bound::Unbounded),\r\n                        }\r\n                    };\r\n                    let check_bound = |value: \u0026mut Bound\u003cVec\u003cu8\u003e\u003e, bound: Vec\u003cu8\u003e| {\r\n                        if matches!(value, Bound::Unbounded) {\r\n                            let _ = mem::replace(value, Bound::Included(bound));\r\n                        }\r\n                    };\r\n                    let (bound_min, bound_max) = if index_meta.is_unique {\r\n                        TableCodec::index_bound(table_name, \u0026index_meta.id)\r\n                    } else {\r\n                        TableCodec::tuple_bound(table_name)\r\n                    };\r\n\r\n                    let mut encode_min = bound_encode(min)?;\r\n                    check_bound(\u0026mut encode_min, bound_min);\r\n\r\n                    let mut encode_max = bound_encode(max)?;\r\n                    check_bound(\u0026mut encode_max, bound_max);\r\n                    let encode_min = match encode_min {\r\n                        Bound::Included(ref lo) =\u003e Bound::Included(lo.as_slice()),\r\n                        Bound::Excluded(ref lo) =\u003e Bound::Excluded(lo.as_slice()),\r\n                        Bound::Unbounded =\u003e Bound::Unbounded,\r\n                    };\r\n                    let encode_max = match encode_max {\r\n                        Bound::Included(ref lo) =\u003e Bound::Included(lo.as_slice()),\r\n                        Bound::Excluded(ref lo) =\u003e Bound::Excluded(lo.as_slice()),\r\n                        Bound::Unbounded =\u003e Bound::Unbounded,\r\n                    };\r\n                    let collect_iter = self.txn.scan(encode_min, encode_max)?;\r\n                    if self.index_meta.is_primary {\r\n                        //\r\n                        let collect = collect_iter\r\n                            .map(|(_, v)| -\u003e Tuple { TableCodec::decode_tuple(\u0026schema, \u0026v) })\r\n                            .collect_vec();\r\n                        tuples.extend(collect);\r\n                    } else {\r\n                        let index_values = collect_iter\r\n                            .map(|(_, v)| TableCodec::decode_index(\u0026v).expect(\"decode index error\"))\r\n                            .collect_vec();\r\n                        for tuple_ids in index_values {\r\n                            for tuple_id in tuple_ids {\r\n                                if let Some(tuple) = self.get_tuple_by_id(\u0026tuple_id)? {\r\n                                    tuples.push(tuple);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                ConstantBinary::Eq(val) =\u003e {\r\n                    let key = self.val_to_key(val)?;\r\n                    if let Some(Ok(bytes)) = self.txn.get(\u0026key).transpose() {\r\n                        let mut index_values = Vec::new();\r\n\r\n                        if self.index_meta.is_unique {\r\n                            for tuple_id in TableCodec::decode_index(\u0026bytes)? {\r\n                                index_values.push(tuple_id);\r\n                            }\r\n                            for tuple_id in index_values {\r\n                                if let Some(tuple) = self.get_tuple_by_id(\u0026tuple_id)? {\r\n                                    tuples.push(tuple);\r\n                                }\r\n                            }\r\n                        } else if self.index_meta.is_primary {\r\n                            let tuple = TableCodec::decode_tuple(\u0026schema, \u0026bytes);\r\n                            tuples.push(tuple);\r\n                        } else {\r\n                            todo!()\r\n                        }\r\n                    }\r\n                }\r\n                _ =\u003e (),\r\n            }\r\n        }\r\n\r\n        Ok(Some(tuples))\r\n    }\r\n}\r\n\r\npub struct IteratorWarpper {\r\n    projection: Projections,\r\n    all_columns: Vec\u003cColumnRef\u003e,\r\n    bound: Bounds,\r\n    iter: TxnIterator,\r\n}\r\nimpl Iter for IteratorWarpper {\r\n    fn fetch_tuple(\u0026mut self) -\u003e Result\u003cOption\u003cVec\u003cTuple\u003e\u003e\u003e {\r\n        let limit = match self.bound.1 {\r\n            Some(limit) =\u003e limit,\r\n            None =\u003e usize::MAX,\r\n        };\r\n        let offset = self.bound.0.unwrap_or(0);\r\n        // let mut tuples = vec![];\r\n        let tuples = self\r\n            .iter\r\n            .by_ref()\r\n            .skip(offset)\r\n            .filter_map(|(_, val)| {\r\n                tuple_projection(\r\n                    \u0026self.projection,\r\n                    \u0026self.all_columns,\r\n                    TableCodec::decode_tuple(\u0026self.all_columns, \u0026val),\r\n                )\r\n                .ok()\r\n            })\r\n            .take(limit)\r\n            .collect_vec();\r\n\r\n        Ok(Some(tuples))\r\n    }\r\n}\r\n\r\nimpl Transaction for TransactionWarpper {\r\n    type IterType\u003c'a\u003e = IteratorWarpper;\r\n\r\n    type IndexIterType\u003c'a\u003e = IndexIteratorWarpper;\r\n\r\n    fn read(\r\n        \u0026self,\r\n        table_name: TableName,\r\n        bound: Bounds,\r\n        projection: Projections,\r\n    ) -\u003e Result\u003cSelf::IterType\u003c'_\u003e\u003e {\r\n        let all_columns = self\r\n            .table(table_name.clone())\r\n            .ok_or(DatabaseError::TableNotFound)?\r\n            .all_columns();\r\n        let (min, max) = TableCodec::tuple_bound(\u0026table_name);\r\n\r\n        Ok(IteratorWarpper {\r\n            projection,\r\n            all_columns,\r\n            bound,\r\n            iter: self\r\n                .txn\r\n                .scan(Bound::Included(\u0026min), Bound::Included(\u0026max))\r\n                .unwrap(),\r\n        })\r\n    }\r\n\r\n    fn read_by_index(\r\n        \u0026self,\r\n        table_name: TableName,\r\n        projection: Projections,\r\n        index_meta: IndexMetaRef,\r\n        binaries: Vec\u003cConstantBinary\u003e,\r\n    ) -\u003e Result\u003cSelf::IndexIterType\u003c'_\u003e\u003e {\r\n        let table = self\r\n            .table(table_name.clone())\r\n            .ok_or(DatabaseError::TableNotFound)?;\r\n        Ok(IndexIteratorWarpper {\r\n            projection,\r\n            index_meta,\r\n            table,\r\n            binaries: VecDeque::from(binaries),\r\n            txn: self.txn.clone(),\r\n        })\r\n    }\r\n\r\n    fn add_index(\r\n        \u0026mut self,\r\n        table_name: \u0026str,\r\n        index: Index,\r\n        tuple_ids: Vec\u003cTupleId\u003e,\r\n        is_unique: bool,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let (key, value) = TableCodec::encode_index(table_name, \u0026index, \u0026tuple_ids)?;\r\n\r\n        if let Some(bytes) = self.txn.get(\u0026key).unwrap() {\r\n            if is_unique {\r\n                let old_tuple_ids = TableCodec::decode_index(\u0026bytes)?;\r\n\r\n                if old_tuple_ids[0] != tuple_ids[0] {\r\n                    return Err(DatabaseError::DuplicateUniqueValue);\r\n                } else {\r\n                    return Ok(());\r\n                }\r\n            } else {\r\n                todo!(\"\")\r\n            }\r\n        }\r\n\r\n        self.txn.put(\u0026key, \u0026value);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn del_index(\u0026mut self, table_name: \u0026str, index: \u0026Index) -\u003e Result\u003c()\u003e {\r\n        let key = TableCodec::encode_index_key(table_name, index)?;\r\n\r\n        self.txn.delete(\u0026key);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn append(\u0026mut self, table_name: \u0026str, tuple: Tuple, is_overwrite: bool) -\u003e Result\u003c()\u003e {\r\n        let (key, value) = TableCodec::encode_tuple(table_name, \u0026tuple)?;\r\n\r\n        if !is_overwrite \u0026\u0026 self.txn.get(\u0026key).unwrap().is_some() \u0026\u0026 tuple.id.is_some() {\r\n            return Err(DatabaseError::DuplicatePrimaryKey);\r\n        }\r\n        self.txn.put(\u0026key, \u0026value);\r\n        Ok(())\r\n    }\r\n\r\n    fn delete(\u0026mut self, table_name: \u0026str, tuple_id: TupleId) -\u003e Result\u003c()\u003e {\r\n        let key = TableCodec::encode_tuple_key(table_name, \u0026tuple_id)?;\r\n        self.txn.delete(\u0026key);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn add_column(\r\n        \u0026mut self,\r\n        table_name: \u0026TableName,\r\n        column: \u0026ColumnCatalog,\r\n        if_not_exists: bool,\r\n    ) -\u003e Result\u003cColumnId\u003e {\r\n        // if self.concurrency_transaction.load(Ordering::SeqCst) \u003e 1 {\r\n        //     return Err(DatabaseError::DDLSerialError(\r\n        //         self.concurrency_transaction.load(Ordering::SeqCst),\r\n        //     ));\r\n        // }\r\n\r\n        if let Some(mut catalog) = self.table(table_name.clone()) {\r\n            if !column.nullable \u0026\u0026 column.default_value().is_none() {\r\n                return Err(DatabaseError::NeedNullAbleOrDefault);\r\n            }\r\n\r\n            for col in catalog.all_columns() {\r\n                if col.name() == column.name() {\r\n                    if if_not_exists {\r\n                        return Ok(col.id().unwrap());\r\n                    } else {\r\n                        return Err(DatabaseError::DuplicateColumn);\r\n                    }\r\n                }\r\n            }\r\n\r\n            let col_id = catalog.add_column(column.clone())?;\r\n\r\n            if column.desc.is_unique {\r\n                let meta_ref = catalog.add_index_meta(\r\n                    format!(\"uk_{}\", column.name()),\r\n                    vec![col_id],\r\n                    true,\r\n                    false,\r\n                );\r\n                let (key, value) = TableCodec::encode_index_meta(table_name, meta_ref)?;\r\n                self.txn.put(\u0026key, \u0026value);\r\n            }\r\n\r\n            let column = catalog.get_column_by_id(\u0026col_id).unwrap();\r\n            let (key, value) = TableCodec::encode_column(table_name, column)?;\r\n            self.txn.put(\u0026key, \u0026value);\r\n            self.cache.remove(table_name);\r\n            Ok(col_id)\r\n        } else {\r\n            Err(DatabaseError::TableNotFound)\r\n        }\r\n    }\r\n\r\n    fn drop_column(\u0026mut self, table_name: \u0026TableName, column: \u0026str, if_exists: bool) -\u003e Result\u003c()\u003e {\r\n        if let Some(catalog) = self.table(table_name.clone()) {\r\n            let column = match catalog.get_column_by_name(column) {\r\n                Some(col) =\u003e col,\r\n                None =\u003e {\r\n                    if if_exists {\r\n                        return Ok(());\r\n                    } else {\r\n                        return Err(DatabaseError::NotFound(\r\n                            \"Coloum\",\r\n                            format!(\"{} not found\", column),\r\n                        ));\r\n                    }\r\n                }\r\n            };\r\n\r\n            if let Some(index_meta) = catalog.get_unique_index(\u0026column.id().unwrap()) {\r\n                let (index_meta_key, _) = TableCodec::encode_index_meta(table_name, index_meta)?;\r\n                self.txn.delete(\u0026index_meta_key);\r\n\r\n                let (index_min, index_max) = TableCodec::index_bound(table_name, \u0026index_meta.id);\r\n                self._drop_data(\u0026index_min, \u0026index_max)?;\r\n            }\r\n            let (key, _) = TableCodec::encode_column(table_name, column)?;\r\n            self.txn.delete(\u0026key);\r\n            self.cache.remove(table_name);\r\n            Ok(())\r\n        } else {\r\n            Err(DatabaseError::TableNotFound)\r\n        }\r\n    }\r\n\r\n    fn create_table(\r\n        \u0026mut self,\r\n        table_name: TableName,\r\n        columns: Vec\u003cColumnCatalog\u003e,\r\n        if_not_exists: bool,\r\n    ) -\u003e Result\u003cTableName\u003e {\r\n        let (table_key, value) = TableCodec::encode_root_table(\u0026table_name)?;\r\n        if self.txn.get(\u0026table_key).transpose().is_some() {\r\n            if if_not_exists {\r\n                return Ok(table_name);\r\n            }\r\n            return Err(DatabaseError::TableExists);\r\n        }\r\n        self.txn.put(\u0026table_key, \u0026value);\r\n\r\n        let mut table_catalog = TableCatalog::new(table_name.clone(), columns)?;\r\n\r\n        self.create_primary_key(\u0026mut table_catalog)?;\r\n        self._create_index(\u0026mut table_catalog, None)?;\r\n        // println!(\"create_table:table_catalog: {:#?}\", table_catalog);\r\n        for column in table_catalog.columns.values() {\r\n            let (key, value) = TableCodec::encode_column(\u0026table_name, column)?;\r\n            self.txn.put(\u0026key, \u0026value);\r\n        }\r\n        // info!(\"create_table:table_catalog: {:#?}\", table_catalog);\r\n        self.cache.insert(table_name.clone(), table_catalog);\r\n\r\n        Ok(table_name)\r\n    }\r\n\r\n    fn drop_table(\u0026mut self, table_name: \u0026str, if_exists: bool) -\u003e Result\u003c()\u003e {\r\n        if self.table(Arc::new(table_name.to_string())).is_none() {\r\n            if if_exists {\r\n                return Ok(());\r\n            } else {\r\n                return Err(DatabaseError::TableNotFound);\r\n            }\r\n        }\r\n        self.drop_data(table_name)?;\r\n\r\n        let (column_min, column_max) = TableCodec::columns_bound(table_name);\r\n        self._drop_data(\u0026column_min, \u0026column_max)?;\r\n\r\n        let (index_meta_min, index_meta_max) = TableCodec::index_meta_bound(table_name);\r\n        self._drop_data(\u0026index_meta_min, \u0026index_meta_max)?;\r\n\r\n        self.txn\r\n            .delete(\u0026TableCodec::encode_root_table_key(table_name));\r\n        self.cache.remove(\u0026Arc::new(table_name.to_string()));\r\n        Ok(())\r\n    }\r\n\r\n    fn drop_data(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\r\n        //\r\n        let (tuple_min, tuple_max) = TableCodec::tuple_bound(table_name);\r\n        self._drop_data(\u0026tuple_min, \u0026tuple_max)?;\r\n        //\r\n        let (index_min, index_max) = TableCodec::all_index_bound(table_name);\r\n        self._drop_data(\u0026index_min, \u0026index_max)?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn table(\u0026self, table_name: TableName) -\u003e Option\u003cTableCatalog\u003e {\r\n        match self.cache.get(\u0026table_name) {\r\n            Some(table) =\u003e Some(table),\r\n            None =\u003e {\r\n                // debug!(\"cache:{:?}\",self.cache);\r\n                let columns = match self.column_collect(table_name.clone()) {\r\n                    Ok(cols) =\u003e cols,\r\n                    Err(e) =\u003e {\r\n                        debug!(\"cannot fetch table {},because:{}\", table_name, e);\r\n                        return None;\r\n                    }\r\n                };\r\n\r\n                let indexes = self\r\n                    .index_meta_collect(\u0026table_name)?\r\n                    .into_iter()\r\n                    .map(Arc::new)\r\n                    .collect_vec();\r\n                //todo\r\n                match TableCatalog::new_with_indexes(table_name.clone(), columns, indexes) {\r\n                    Ok(table) =\u003e {\r\n                        self.cache.insert(table_name, table.clone());\r\n                        Some(table)\r\n                    }\r\n                    Err(e) =\u003e {\r\n                        debug!(\"cannot fetch table {},because:{}\", table_name, e);\r\n                        None\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fn show_tables(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\r\n        let (min, max) = TableCodec::root_table_bound();\r\n        let scan = self\r\n            .txn\r\n            .scan(Bound::Included(\u0026min), Bound::Included(\u0026max))\r\n            .unwrap();\r\n        let metas = scan\r\n            .filter_map(|(_, val)| TableCodec::decode_root_table(\u0026val).ok())\r\n            .collect_vec();\r\n\r\n        // self.txn.debug();\r\n        Ok(metas)\r\n    }\r\n\r\n    async fn commit(self) -\u003e Result\u003c()\u003e {\r\n        self.txn.commit()?;\r\n        Ok(())\r\n    }\r\n\r\n    async fn rollback(self) -\u003e Result\u003c()\u003e {\r\n        Ok(())\r\n    }\r\n\r\n    fn set_isolation(\u0026mut self, _serializable: bool) -\u003e Result\u003c()\u003e {\r\n        todo!()\r\n    }\r\n\r\n    fn create_index(\r\n        \u0026mut self,\r\n        table_name: TableName,\r\n        index_name: IndexName,\r\n        column_name: \u0026str,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let indexs = self.index_meta_collect(\u0026table_name).unwrap_or_default();\r\n        let indexs = indexs.into_iter().map(Arc::new).collect_vec();\r\n        let mut cols = self.column_collect(table_name.clone())?;\r\n        let col = cols.iter_mut().find(|col| col.name() == column_name);\r\n        if let Some(col) = col {\r\n            col.desc.is_unique = true;\r\n            let mut table = TableCatalog::new_with_indexes(table_name.clone(), cols, indexs)?;\r\n            self._create_index(\u0026mut table, Some(index_name.to_string()))?;\r\n            self.cache.remove(\u0026table_name);\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn drop_index(\r\n        \u0026mut self,\r\n        table_name: TableName,\r\n        index_name: IndexName,\r\n        _if_not_exists: bool,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        //check index exists\r\n        //operator in copy temp data\r\n        let mut indexs = self.index_meta_collect(\u0026table_name).unwrap();\r\n        let (i, _) = indexs\r\n            .iter()\r\n            .find_position(|meta| meta.name == format!(\"{}_{}\", \"uk\", index_name))\r\n            .unwrap();\r\n        let item = indexs.remove(i);\r\n        let mut cols = self.column_collect(table_name.clone()).unwrap();\r\n        let indexs = indexs.into_iter().map(Arc::new).collect_vec();\r\n        cols.get_mut(item.column_ids[0] as usize).and_then(|col| {\r\n            col.desc.is_unique = false;\r\n            Some(())\r\n        });\r\n        //\r\n        //todo\r\n        //tablecodec,,\r\n        //IO\r\n        let (index_meta_min, index_meta_max) = TableCodec::index_meta_bound(\u0026table_name);\r\n        self._drop_data(\u0026index_meta_min, \u0026index_meta_max)?;\r\n        for meta in indexs.iter() {\r\n            let (key, value) = TableCodec::encode_index_meta(\u0026table_name, meta)?;\r\n            self.txn.put(\u0026key, \u0026value);\r\n        }\r\n        //\r\n        let (index_min, index_max) = TableCodec::index_bound(\u0026table_name, \u0026item.id);\r\n        self._drop_data(\u0026index_min, \u0026index_max)?;\r\n\r\n        let table = TableCatalog::new_with_indexes(table_name.clone(), cols, indexs)?;\r\n        self.update_table_meta(\u0026table)?;\r\n        self.cache.remove(\u0026table_name);\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl TransactionWarpper {\r\n    fn _drop_data(\u0026self, min: \u0026[u8], max: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        let mut scan = self\r\n            .txn\r\n            .scan(Bound::Included(min), Bound::Included(max))\r\n            .unwrap();\r\n        // let mut iter = scan.iter();\r\n        while scan.is_valid() {\r\n            let key = scan.key();\r\n            self.txn.delete(key);\r\n            scan.next().unwrap();\r\n        }\r\n\r\n        // for key in data_keys {\r\n        //     self.txn.delete(key);\r\n        // }\r\n\r\n        Ok(())\r\n    }\r\n    fn update_table_meta(\u0026self, table: \u0026TableCatalog) -\u003e Result\u003c()\u003e {\r\n        for column in table.columns.values() {\r\n            let (key, value) = TableCodec::encode_column(\u0026table.name, column)?;\r\n            self.txn.put(\u0026key, \u0026value);\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    ///\r\n    fn index_meta_collect(\u0026self, name: \u0026str) -\u003e Option\u003cVec\u003cIndexMeta\u003e\u003e {\r\n        let (index_min, index_max) = TableCodec::index_meta_bound(name);\r\n        let mut index_metas = vec![];\r\n        let mut scan = self\r\n            .txn\r\n            .scan(Bound::Included(\u0026index_min), Bound::Included(\u0026index_max))\r\n            .expect(\"scan index meta error\");\r\n        // let mut index_iter = index_scan.iter();\r\n        while scan.is_valid() {\r\n            if let Ok(index_meta) = TableCodec::decode_index_meta(scan.value()) {\r\n                index_metas.push(index_meta);\r\n            }\r\n            scan.next().unwrap();\r\n        }\r\n        Some(index_metas)\r\n    }\r\n    ///\r\n    fn column_collect(\u0026self, table_name: TableName) -\u003e Result\u003cVec\u003cColumnCatalog\u003e\u003e {\r\n        let (column_min, column_max) = TableCodec::columns_bound(\u0026table_name);\r\n        let mut scan = self\r\n            .txn\r\n            .scan(Bound::Included(\u0026column_min), Bound::Included(\u0026column_max))\r\n            .unwrap();\r\n        let mut columns = vec![];\r\n        while scan.is_valid() {\r\n            let col = TableCodec::decode_column(scan.value())?;\r\n            columns.push(col);\r\n            scan.next().unwrap();\r\n        }\r\n\r\n        Ok(columns)\r\n    }\r\n    fn create_primary_key(\u0026self, table: \u0026mut TableCatalog) -\u003e Result\u003c()\u003e {\r\n        let table_name = table.name.clone();\r\n\r\n        let index_column = table\r\n            .all_columns()\r\n            .into_iter()\r\n            .filter(|col| col.desc.is_primary)\r\n            .collect_vec();\r\n\r\n        for col in index_column {\r\n            // FIXME: composite indexes may exist on future\r\n            let prefix = \"pk\";\r\n            if let Some(col_id) = col.id() {\r\n                let meta_ref = table.add_index_meta(\r\n                    format!(\"{}_{}\", prefix, col.name()),\r\n                    vec![col_id],\r\n                    col.desc.is_unique,\r\n                    col.desc.is_primary,\r\n                );\r\n                // println!(\"{:#?}\", meta_ref);\r\n\r\n                let (key, value) = TableCodec::encode_index_meta(\u0026table_name, meta_ref)?;\r\n\r\n                self.txn.put(\u0026key, \u0026value);\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn _create_index(\u0026self, table: \u0026mut TableCatalog, index_name: Option\u003cString\u003e) -\u003e Result\u003c()\u003e {\r\n        let table_name = table.name.clone();\r\n\r\n        for col in table\r\n            .all_columns()\r\n            .into_iter()\r\n            .filter(|col| col.desc.is_unique)\r\n        {\r\n            let mut name = col.name().to_string();\r\n            if let Some(index_name) = \u0026index_name {\r\n                name = index_name.clone();\r\n            }\r\n            // FIXME: composite indexes may exist on future\r\n            let prefix = \"uk\";\r\n            if let Some(col_id) = col.id() {\r\n                let meta_ref = table.add_index_meta(\r\n                    format!(\"{}_{}\", prefix, name),\r\n                    vec![col_id],\r\n                    col.desc.is_unique,\r\n                    col.desc.is_primary,\r\n                );\r\n                // println!(\"meta_ref:{:#?}\", meta_ref);\r\n\r\n                let (key, value) = TableCodec::encode_index_meta(\u0026table_name, meta_ref)?;\r\n\r\n                self.txn.put(\u0026key, \u0026value);\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod test {\r\n\r\n    use crate::{\r\n        catalog::ColumnDesc,\r\n        expression::ScalarExpression,\r\n        types::{value::DataValue, LogicalType},\r\n    };\r\n\r\n    use super::*;\r\n    #[tokio::test]\r\n    async fn test_in_storage() -\u003e Result\u003c()\u003e {\r\n        let path = tempdir::TempDir::new(\"piggydb\")\r\n            .unwrap()\r\n            .path()\r\n            .join(\"piggydb\");\r\n\r\n        let storage = PiggyKVStroage::new(path, None);\r\n        let mut transaction = storage.transaction().await?;\r\n        let columns = vec![\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c1\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Integer, true, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c2\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Boolean, false, false, None),\r\n                // None,\r\n            )),\r\n        ];\r\n        let source_columns = columns\r\n            .iter()\r\n            .map(|col_ref| ColumnCatalog::clone(\u0026col_ref))\r\n            .collect_vec();\r\n        let _ = transaction.create_table(Arc::new(\"test\".to_string()), source_columns, false)?;\r\n        let table_catalog = transaction.table(Arc::new(\"test\".to_string()));\r\n        assert!(table_catalog.is_some());\r\n        let cols = table_catalog.unwrap().all_columns();\r\n\r\n        transaction.append(\r\n            \u0026\"test\".to_string(),\r\n            Tuple {\r\n                id: Some(Arc::new(DataValue::Int32(Some(1)))),\r\n                values: vec![\r\n                    Arc::new(DataValue::Int32(Some(1))),\r\n                    Arc::new(DataValue::Boolean(Some(true))),\r\n                ],\r\n            },\r\n            false,\r\n        )?;\r\n        transaction.append(\r\n            \u0026\"test\".to_string(),\r\n            Tuple {\r\n                id: Some(Arc::new(DataValue::Int32(Some(2)))),\r\n                values: vec![\r\n                    Arc::new(DataValue::Int32(Some(2))),\r\n                    Arc::new(DataValue::Boolean(Some(false))),\r\n                ],\r\n            },\r\n            false,\r\n        )?;\r\n        let mut iter = transaction.read(\r\n            Arc::new(\"test\".to_string()),\r\n            (None, None),\r\n            vec![ScalarExpression::ColumnRef(cols[0].clone())],\r\n        )?;\r\n\r\n        let tuples = iter.fetch_tuple()?;\r\n        println!(\"{:#?}\", tuples);\r\n\r\n        if let Some(tuples) = tuples {\r\n            assert_eq!(tuples[0].id, Some(Arc::new(DataValue::Int32(Some(1)))));\r\n            assert_eq!(tuples[0].values, vec![Arc::new(DataValue::Int32(Some(1))),],);\r\n            assert_eq!(tuples[1].id, Some(Arc::new(DataValue::Int32(Some(2)))));\r\n            assert_eq!(tuples[1].values, vec![Arc::new(DataValue::Int32(Some(2))),],);\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":6341068275337658368},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":18158513697557839872},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":9079256848778919936},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":9079256848778919936},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":9079256848778919936},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":5188146770730811392},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":5188146770730811392},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":12249790986447749120},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":12610078956637388800},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":432345564227567617},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":12249790986447749120},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":6269010681299730432},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":18374686479671623680},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":674,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":675,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":9151314442816847872},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":6269010681299730432},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null}],"covered":166,"coverable":296},{"path":["E:","\\","sql-layer","src","storage","table_codec.rs"],"content":"use crate::catalog::{ColumnCatalog, ColumnRef};\r\nuse crate::errors::Result;\r\n\r\nuse crate::types::index::{Index, IndexId, IndexMeta};\r\nuse crate::types::tuple::{Tuple, TupleId};\r\nuse crate::types::value::DataValue;\r\nuse crate::types::LogicalType;\r\nuse bytes::Bytes;\r\nuse lazy_static::lazy_static;\r\nconst BOUND_MIN_TAG: u8 = 0;\r\nconst BOUND_MAX_TAG: u8 = 1;\r\nlazy_static! {\r\n    static ref ROOT_BYTES: Vec\u003cu8\u003e = b\"Root\".to_vec();\r\n}\r\n\r\n#[derive(Clone)]\r\npub struct TableCodec {}\r\n\r\n#[derive(Copy, Clone)]\r\nenum CodecType {\r\n    Column,\r\n    IndexMeta,\r\n    Index,\r\n    Tuple,\r\n    Root,\r\n}\r\n\r\nimpl TableCodec {\r\n    /// TableName + Type\r\n    ///\r\n    /// Tips: Root full key = key_prefix\r\n    fn key_prefix(ty: CodecType, table_name: \u0026str) -\u003e Vec\u003cu8\u003e {\r\n        let mut table_bytes = table_name.to_string().into_bytes();\r\n\r\n        match ty {\r\n            CodecType::Column =\u003e {\r\n                table_bytes.push(b'0');\r\n            }\r\n            CodecType::IndexMeta =\u003e {\r\n                table_bytes.push(b'1');\r\n            }\r\n            CodecType::Index =\u003e {\r\n                table_bytes.push(b'2');\r\n            }\r\n            CodecType::Tuple =\u003e {\r\n                table_bytes.push(b'3');\r\n            }\r\n            CodecType::Root =\u003e {\r\n                let mut bytes = ROOT_BYTES.clone();\r\n                bytes.push(BOUND_MIN_TAG);\r\n                bytes.append(\u0026mut table_bytes);\r\n\r\n                table_bytes = bytes\r\n            }\r\n        }\r\n\r\n        table_bytes\r\n    }\r\n\r\n    pub fn tuple_bound(table_name: \u0026str) -\u003e (Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\r\n        let op = |bound_id| {\r\n            let mut key_prefix = Self::key_prefix(CodecType::Tuple, table_name);\r\n\r\n            key_prefix.push(bound_id);\r\n            key_prefix\r\n        };\r\n\r\n        (op(BOUND_MIN_TAG), op(BOUND_MAX_TAG))\r\n    }\r\n    ///\r\n    pub fn index_meta_bound(table_name: \u0026str) -\u003e (Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\r\n        let op = |bound_id| {\r\n            let mut key_prefix = Self::key_prefix(CodecType::IndexMeta, table_name);\r\n\r\n            key_prefix.push(bound_id);\r\n            key_prefix\r\n        };\r\n\r\n        (op(BOUND_MIN_TAG), op(BOUND_MAX_TAG))\r\n    }\r\n    ///\r\n    pub fn index_bound(table_name: \u0026str, index_id: \u0026IndexId) -\u003e (Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\r\n        let op = |bound_id| {\r\n            let mut key_prefix = Self::key_prefix(CodecType::Index, table_name);\r\n\r\n            key_prefix.push(BOUND_MIN_TAG);\r\n            key_prefix.append(\u0026mut index_id.to_be_bytes().to_vec());\r\n            key_prefix.push(bound_id);\r\n            key_prefix\r\n        };\r\n\r\n        (op(BOUND_MIN_TAG), op(BOUND_MAX_TAG))\r\n    }\r\n\r\n    pub fn all_index_bound(table_name: \u0026str) -\u003e (Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\r\n        let op = |bound_id| {\r\n            let mut key_prefix = Self::key_prefix(CodecType::Index, table_name);\r\n\r\n            key_prefix.push(bound_id);\r\n            key_prefix\r\n        };\r\n\r\n        (op(BOUND_MIN_TAG), op(BOUND_MAX_TAG))\r\n    }\r\n\r\n    pub fn root_table_bound() -\u003e (Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\r\n        let op = |bound_id| {\r\n            let mut key_prefix = ROOT_BYTES.clone();\r\n\r\n            key_prefix.push(bound_id);\r\n            key_prefix\r\n        };\r\n\r\n        (op(BOUND_MIN_TAG), op(BOUND_MAX_TAG))\r\n    }\r\n\r\n    pub fn columns_bound(table_name: \u0026str) -\u003e (Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\r\n        let op = |bound_id| {\r\n            let mut key_prefix = Self::key_prefix(CodecType::Column, table_name);\r\n\r\n            key_prefix.push(bound_id);\r\n            key_prefix\r\n        };\r\n\r\n        (op(BOUND_MIN_TAG), op(BOUND_MAX_TAG))\r\n    }\r\n\r\n    /// Key: {TableName}{TUPLE_TAG}{BOUND_MIN_TAG}{RowID}(Sorted)\r\n    /// Value: Tuple\r\n    pub fn encode_tuple(table_name: \u0026str, tuple: \u0026Tuple) -\u003e Result\u003c(Bytes, Bytes)\u003e {\r\n        // let tuple_id = tuple.id.clone().ok_or(DatabaseError::PrimaryKeyNotFound)?;\r\n        let tuple_id = tuple.id.clone();\r\n        let key = match tuple_id {\r\n            Some(tuple_id) =\u003e Self::encode_tuple_key(table_name, \u0026tuple_id)?,\r\n            None =\u003e Self::encode_tuple_key_without_primary_key(table_name)?,\r\n        };\r\n\r\n        Ok((Bytes::from(key), Bytes::from(tuple.serialize_to())))\r\n    }\r\n    pub fn encode_tuple_key_without_primary_key(table_name: \u0026str) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\r\n        let mut key_prefix = Self::key_prefix(CodecType::Tuple, table_name);\r\n        key_prefix.push(BOUND_MIN_TAG);\r\n        let id = DataValue::init(\u0026LogicalType::UUID);\r\n        id.to_primary_key(\u0026mut key_prefix)?;\r\n        Ok(key_prefix)\r\n    }\r\n\r\n    pub fn encode_tuple_key(table_name: \u0026str, tuple_id: \u0026TupleId) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\r\n        let mut key_prefix = Self::key_prefix(CodecType::Tuple, table_name);\r\n        key_prefix.push(BOUND_MIN_TAG);\r\n\r\n        tuple_id.to_primary_key(\u0026mut key_prefix)?;\r\n\r\n        Ok(key_prefix)\r\n    }\r\n\r\n    pub fn decode_tuple(columns: \u0026[ColumnRef], bytes: \u0026[u8]) -\u003e Tuple {\r\n        Tuple::deserialize_from(columns, bytes)\r\n    }\r\n\r\n    /// Key: {TableName}{INDEX_META_TAG}{BOUND_MIN_TAG}{IndexID}\r\n    /// Value: IndexMeta\r\n    pub fn encode_index_meta(table_name: \u0026str, index_meta: \u0026IndexMeta) -\u003e Result\u003c(Bytes, Bytes)\u003e {\r\n        let mut key_prefix = Self::key_prefix(CodecType::IndexMeta, table_name);\r\n        key_prefix.push(BOUND_MIN_TAG);\r\n        key_prefix.append(\u0026mut index_meta.id.to_be_bytes().to_vec());\r\n\r\n        Ok((\r\n            Bytes::from(key_prefix),\r\n            Bytes::from(bincode::serialize(\u0026index_meta)?),\r\n        ))\r\n    }\r\n\r\n    pub fn decode_index_meta(bytes: \u0026[u8]) -\u003e Result\u003cIndexMeta\u003e {\r\n        Ok(bincode::deserialize(bytes)?)\r\n    }\r\n\r\n    /// NonUnique Index:\r\n    /// Key: {TableName}{INDEX_TAG}{BOUND_MIN_TAG}{IndexID}{BOUND_MIN_TAG}{DataValue1}{DataValue2} ..\r\n    /// Value: TupleIDs\r\n    ///\r\n    /// Unique Index:\r\n    /// Key: {TableName}{INDEX_TAG}{BOUND_MIN_TAG}{IndexID}{BOUND_MIN_TAG}{DataValue}\r\n    /// Value: TupleIDs\r\n    ///\r\n    /// Tips: The unique index has only one ColumnID and one corresponding DataValue,\r\n    /// so it can be positioned directly.\r\n    pub fn encode_index(\r\n        name: \u0026str,\r\n        index: \u0026Index,\r\n        tuple_ids: \u0026[TupleId],\r\n    ) -\u003e Result\u003c(Bytes, Bytes)\u003e {\r\n        let key = TableCodec::encode_index_key(name, index)?;\r\n\r\n        Ok((\r\n            Bytes::from(key),\r\n            Bytes::from(bincode::serialize(tuple_ids)?),\r\n        ))\r\n    }\r\n\r\n    pub fn encode_index_key(name: \u0026str, index: \u0026Index) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\r\n        let mut key_prefix = Self::key_prefix(CodecType::Index, name);\r\n        key_prefix.push(BOUND_MIN_TAG);\r\n        key_prefix.append(\u0026mut index.id.to_be_bytes().to_vec());\r\n        key_prefix.push(BOUND_MIN_TAG);\r\n\r\n        for col_v in \u0026index.column_values {\r\n            col_v.to_index_key(\u0026mut key_prefix)?;\r\n        }\r\n\r\n        Ok(key_prefix)\r\n    }\r\n\r\n    pub fn decode_index(bytes: \u0026[u8]) -\u003e Result\u003cVec\u003cTupleId\u003e\u003e {\r\n        Ok(bincode::deserialize(bytes)?)\r\n    }\r\n\r\n    /// Key: {TableName}{COLUMN_TAG}{BOUND_MIN_TAG}{ColumnId}\r\n    /// Value: ColumnCatalog\r\n    ///\r\n    /// Tips: the `0` for bound range\r\n    pub fn encode_column(table_name: \u0026str, col: \u0026ColumnCatalog) -\u003e Result\u003c(Bytes, Bytes)\u003e {\r\n        let bytes = bincode::serialize(col)?;\r\n        let mut key_prefix = Self::key_prefix(CodecType::Column, table_name);\r\n\r\n        key_prefix.push(BOUND_MIN_TAG);\r\n        key_prefix.append(\u0026mut col.id().unwrap().to_be_bytes().to_vec());\r\n\r\n        Ok((Bytes::from(key_prefix), Bytes::from(bytes)))\r\n    }\r\n\r\n    pub fn decode_column(bytes: \u0026[u8]) -\u003e Result\u003cColumnCatalog\u003e {\r\n        Ok(bincode::deserialize::\u003cColumnCatalog\u003e(bytes)?)\r\n    }\r\n\r\n    /// Key: Root{BOUND_MIN_TAG}{TableName}\r\n    /// Value: TableName\r\n    pub fn encode_root_table(table_name: \u0026str) -\u003e Result\u003c(Bytes, Bytes)\u003e {\r\n        let key = Self::encode_root_table_key(table_name);\r\n\r\n        Ok((\r\n            Bytes::from(key),\r\n            Bytes::from(table_name.to_owned().into_bytes()),\r\n        ))\r\n    }\r\n\r\n    pub fn encode_root_table_key(table_name: \u0026str) -\u003e Vec\u003cu8\u003e {\r\n        Self::key_prefix(CodecType::Root, table_name)\r\n    }\r\n\r\n    pub fn decode_root_table(bytes: \u0026[u8]) -\u003e Result\u003cString\u003e {\r\n        Ok(String::from_utf8(bytes.to_vec())?)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::catalog::{ColumnCatalog, ColumnDesc, TableCatalog};\r\n    use crate::storage::table_codec::TableCodec;\r\n    use crate::types::index::{Index, IndexMeta};\r\n    use crate::types::tuple::Tuple;\r\n    use crate::types::value::DataValue;\r\n    use crate::types::LogicalType;\r\n    use bytes::Bytes;\r\n    use itertools::Itertools;\r\n    use std::collections::BTreeSet;\r\n    use std::ops::Bound;\r\n    use std::sync::Arc;\r\n\r\n    fn build_table_codec() -\u003e TableCatalog {\r\n        let columns = vec![ColumnCatalog::new(\r\n            \"c1\".into(),\r\n            false,\r\n            ColumnDesc::new(LogicalType::Integer, true, false, None),\r\n            // None,\r\n        )];\r\n        TableCatalog::new(Arc::new(\"t1\".to_string()), columns).unwrap()\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_tuple() -\u003e Result\u003c()\u003e {\r\n        let table_catalog = build_table_codec();\r\n\r\n        let tuple = Tuple {\r\n            id: Some(Arc::new(DataValue::Int32(Some(0)))),\r\n            values: vec![Arc::new(DataValue::Int32(Some(0)))],\r\n        };\r\n        let (_, bytes) = TableCodec::encode_tuple(\u0026table_catalog.name, \u0026tuple)?;\r\n\r\n        assert_eq!(\r\n            TableCodec::decode_tuple(\u0026table_catalog.all_columns(), \u0026bytes),\r\n            tuple\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_root_catalog() {\r\n        let table_catalog = build_table_codec();\r\n        let (_, bytes) = TableCodec::encode_root_table(\u0026table_catalog.name).unwrap();\r\n\r\n        let table_name = TableCodec::decode_root_table(\u0026bytes).unwrap();\r\n\r\n        assert_eq!(table_name, table_catalog.name.as_str());\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_index_meta() -\u003e Result\u003c()\u003e {\r\n        let index_meta = IndexMeta {\r\n            id: 0,\r\n            column_ids: vec![0],\r\n            name: \"index_1\".to_string(),\r\n            is_unique: false,\r\n            is_primary: false,\r\n        };\r\n        let (_, bytes) = TableCodec::encode_index_meta(\u0026\"T1\".to_string(), \u0026index_meta)?;\r\n\r\n        assert_eq!(TableCodec::decode_index_meta(\u0026bytes)?, index_meta);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_index() -\u003e Result\u003c()\u003e {\r\n        let table_catalog = build_table_codec();\r\n\r\n        let index = Index {\r\n            id: 0,\r\n            column_values: vec![Arc::new(DataValue::Int32(Some(0)))],\r\n        };\r\n        let tuple_ids = vec![Arc::new(DataValue::Int32(Some(0)))];\r\n        let (_, bytes) = TableCodec::encode_index(\u0026table_catalog.name, \u0026index, \u0026tuple_ids)?;\r\n\r\n        assert_eq!(TableCodec::decode_index(\u0026bytes)?, tuple_ids);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_column() {\r\n        let table_catalog = build_table_codec();\r\n        let col = table_catalog.all_columns()[0].clone();\r\n\r\n        let (_, bytes) = TableCodec::encode_column(\u0026table_catalog.name, \u0026col).unwrap();\r\n        let decode_col = TableCodec::decode_column(\u0026bytes).unwrap();\r\n\r\n        assert_eq!(\u0026decode_col, col.as_ref());\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_column_bound() {\r\n        let mut set = BTreeSet::new();\r\n        let op = |col_id: usize, table_name: \u0026str| {\r\n            let mut col = ColumnCatalog::new(\r\n                \"\".to_string(),\r\n                false,\r\n                ColumnDesc {\r\n                    column_datatype: LogicalType::Invalid,\r\n                    is_primary: false,\r\n                    is_unique: false,\r\n                    default: None,\r\n                },\r\n                // None,\r\n            );\r\n\r\n            col.summary.id = Some(col_id as u32);\r\n\r\n            let (key, _) = TableCodec::encode_column(\u0026table_name.to_string(), \u0026col).unwrap();\r\n            key\r\n        };\r\n\r\n        set.insert(op(0, \"T0\"));\r\n        set.insert(op(1, \"T0\"));\r\n        set.insert(op(2, \"T0\"));\r\n\r\n        set.insert(op(0, \"T1\"));\r\n        set.insert(op(1, \"T1\"));\r\n        set.insert(op(2, \"T1\"));\r\n\r\n        set.insert(op(0, \"T2\"));\r\n        set.insert(op(0, \"T2\"));\r\n        set.insert(op(0, \"T2\"));\r\n\r\n        let (min, max) = TableCodec::columns_bound(\u0026Arc::new(\"T1\".to_string()));\r\n\r\n        let vec = set\r\n            .range::\u003cBytes, (Bound\u003c\u0026Bytes\u003e, Bound\u003c\u0026Bytes\u003e)\u003e((\r\n                Bound::Included(\u0026Bytes::from(min)),\r\n                Bound::Included(\u0026Bytes::from(max)),\r\n            ))\r\n            .collect_vec();\r\n\r\n        assert_eq!(vec.len(), 3);\r\n\r\n        assert_eq!(vec[0], \u0026op(0, \"T1\"));\r\n        assert_eq!(vec[1], \u0026op(1, \"T1\"));\r\n        assert_eq!(vec[2], \u0026op(2, \"T1\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_index_meta_bound() {\r\n        let mut set = BTreeSet::new();\r\n        let op = |index_id: usize, table_name: \u0026str| {\r\n            let index_meta = IndexMeta {\r\n                id: index_id as u32,\r\n                column_ids: vec![],\r\n                name: \"\".to_string(),\r\n                is_unique: false,\r\n                is_primary: false,\r\n            };\r\n\r\n            let (key, _) =\r\n                TableCodec::encode_index_meta(\u0026table_name.to_string(), \u0026index_meta).unwrap();\r\n            key\r\n        };\r\n\r\n        set.insert(op(0, \"T0\"));\r\n        set.insert(op(1, \"T0\"));\r\n        set.insert(op(2, \"T0\"));\r\n\r\n        set.insert(op(0, \"T1\"));\r\n        set.insert(op(1, \"T1\"));\r\n        set.insert(op(2, \"T1\"));\r\n\r\n        set.insert(op(0, \"T2\"));\r\n        set.insert(op(1, \"T2\"));\r\n        set.insert(op(2, \"T2\"));\r\n\r\n        let (min, max) = TableCodec::index_meta_bound(\u0026\"T1\".to_string());\r\n\r\n        let vec = set\r\n            .range::\u003cBytes, (Bound\u003c\u0026Bytes\u003e, Bound\u003c\u0026Bytes\u003e)\u003e((\r\n                Bound::Included(\u0026Bytes::from(min)),\r\n                Bound::Included(\u0026Bytes::from(max)),\r\n            ))\r\n            .collect_vec();\r\n\r\n        assert_eq!(vec.len(), 3);\r\n\r\n        assert_eq!(vec[0], \u0026op(0, \"T1\"));\r\n        assert_eq!(vec[1], \u0026op(1, \"T1\"));\r\n        assert_eq!(vec[2], \u0026op(2, \"T1\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_index_bound() {\r\n        let mut set = BTreeSet::new();\r\n        let column = ColumnCatalog::new(\r\n            \"\".to_string(),\r\n            false,\r\n            ColumnDesc::new(LogicalType::Boolean, false, false, None),\r\n            // None,\r\n        );\r\n        let table_catalog = TableCatalog::new(Arc::new(\"T0\".to_string()), vec![column]).unwrap();\r\n\r\n        let op = |value: DataValue, index_id: usize, table_name: \u0026String| {\r\n            let index = Index {\r\n                id: index_id as u32,\r\n                column_values: vec![Arc::new(value)],\r\n            };\r\n\r\n            TableCodec::encode_index_key(table_name, \u0026index).unwrap()\r\n        };\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), 0, \u0026table_catalog.name));\r\n        set.insert(op(DataValue::Int32(Some(1)), 0, \u0026table_catalog.name));\r\n        set.insert(op(DataValue::Int32(Some(2)), 0, \u0026table_catalog.name));\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), 1, \u0026table_catalog.name));\r\n        set.insert(op(DataValue::Int32(Some(1)), 1, \u0026table_catalog.name));\r\n        set.insert(op(DataValue::Int32(Some(2)), 1, \u0026table_catalog.name));\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), 2, \u0026table_catalog.name));\r\n        set.insert(op(DataValue::Int32(Some(1)), 2, \u0026table_catalog.name));\r\n        set.insert(op(DataValue::Int32(Some(2)), 2, \u0026table_catalog.name));\r\n\r\n        println!(\"{:#?}\", set);\r\n\r\n        let (min, max) = TableCodec::index_bound(\u0026table_catalog.name, \u00261);\r\n\r\n        println!(\"{:?}\", min);\r\n        println!(\"{:?}\", max);\r\n\r\n        let vec = set\r\n            .range::\u003cVec\u003cu8\u003e, (Bound\u003c\u0026Vec\u003cu8\u003e\u003e, Bound\u003c\u0026Vec\u003cu8\u003e\u003e)\u003e((\r\n                Bound::Included(\u0026min),\r\n                Bound::Included(\u0026max),\r\n            ))\r\n            .collect_vec();\r\n\r\n        assert_eq!(vec.len(), 3);\r\n\r\n        assert_eq!(\r\n            vec[0],\r\n            \u0026op(DataValue::Int32(Some(0)), 1, \u0026table_catalog.name)\r\n        );\r\n        assert_eq!(\r\n            vec[1],\r\n            \u0026op(DataValue::Int32(Some(1)), 1, \u0026table_catalog.name)\r\n        );\r\n        assert_eq!(\r\n            vec[2],\r\n            \u0026op(DataValue::Int32(Some(2)), 1, \u0026table_catalog.name)\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_index_all_bound() {\r\n        let mut set = BTreeSet::new();\r\n        let op = |value: DataValue, index_id: usize, table_name: \u0026str| {\r\n            let index = Index {\r\n                id: index_id as u32,\r\n                column_values: vec![Arc::new(value)],\r\n            };\r\n\r\n            TableCodec::encode_index_key(\u0026table_name.to_string(), \u0026index).unwrap()\r\n        };\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), 0, \"T0\"));\r\n        set.insert(op(DataValue::Int32(Some(1)), 0, \"T0\"));\r\n        set.insert(op(DataValue::Int32(Some(2)), 0, \"T0\"));\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), 0, \"T1\"));\r\n        set.insert(op(DataValue::Int32(Some(1)), 0, \"T1\"));\r\n        set.insert(op(DataValue::Int32(Some(2)), 0, \"T1\"));\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), 0, \"T2\"));\r\n        set.insert(op(DataValue::Int32(Some(1)), 0, \"T2\"));\r\n        set.insert(op(DataValue::Int32(Some(2)), 0, \"T2\"));\r\n\r\n        let (min, max) = TableCodec::all_index_bound(\u0026\"T1\".to_string());\r\n\r\n        let vec = set\r\n            .range::\u003cVec\u003cu8\u003e, (Bound\u003c\u0026Vec\u003cu8\u003e\u003e, Bound\u003c\u0026Vec\u003cu8\u003e\u003e)\u003e((\r\n                Bound::Included(\u0026min),\r\n                Bound::Included(\u0026max),\r\n            ))\r\n            .collect_vec();\r\n\r\n        assert_eq!(vec.len(), 3);\r\n\r\n        assert_eq!(vec[0], \u0026op(DataValue::Int32(Some(0)), 0, \"T1\"));\r\n        assert_eq!(vec[1], \u0026op(DataValue::Int32(Some(1)), 0, \"T1\"));\r\n        assert_eq!(vec[2], \u0026op(DataValue::Int32(Some(2)), 0, \"T1\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_tuple_bound() {\r\n        let mut set = BTreeSet::new();\r\n        let op = |tuple_id: DataValue, table_name: \u0026str| {\r\n            TableCodec::encode_tuple_key(\u0026table_name.to_string(), \u0026Arc::new(tuple_id)).unwrap()\r\n        };\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), \"T0\"));\r\n        set.insert(op(DataValue::Int32(Some(1)), \"T0\"));\r\n        set.insert(op(DataValue::Int32(Some(2)), \"T0\"));\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), \"T1\"));\r\n        set.insert(op(DataValue::Int32(Some(1)), \"T1\"));\r\n        set.insert(op(DataValue::Int32(Some(2)), \"T1\"));\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), \"T2\"));\r\n        set.insert(op(DataValue::Int32(Some(1)), \"T2\"));\r\n        set.insert(op(DataValue::Int32(Some(2)), \"T2\"));\r\n\r\n        let (min, max) = TableCodec::tuple_bound(\u0026\"T1\".to_string());\r\n\r\n        let vec = set\r\n            .range::\u003cVec\u003cu8\u003e, (Bound\u003c\u0026Vec\u003cu8\u003e\u003e, Bound\u003c\u0026Vec\u003cu8\u003e\u003e)\u003e((\r\n                Bound::Included(\u0026min),\r\n                Bound::Included(\u0026max),\r\n            ))\r\n            .collect_vec();\r\n\r\n        assert_eq!(vec.len(), 3);\r\n\r\n        assert_eq!(vec[0], \u0026op(DataValue::Int32(Some(0)), \"T1\"));\r\n        assert_eq!(vec[1], \u0026op(DataValue::Int32(Some(1)), \"T1\"));\r\n        assert_eq!(vec[2], \u0026op(DataValue::Int32(Some(2)), \"T1\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_root_codec_name_bound() {\r\n        let mut set = BTreeSet::new();\r\n        let op = |table_name: \u0026str| TableCodec::encode_root_table_key(\u0026table_name.to_string());\r\n\r\n        set.insert(b\"A\".to_vec());\r\n\r\n        set.insert(op(\"T0\"));\r\n        set.insert(op(\"T1\"));\r\n        set.insert(op(\"T2\"));\r\n\r\n        set.insert(b\"Z\".to_vec());\r\n\r\n        let (min, max) = TableCodec::root_table_bound();\r\n\r\n        let vec = set\r\n            .range::\u003cVec\u003cu8\u003e, (Bound\u003c\u0026Vec\u003cu8\u003e\u003e, Bound\u003c\u0026Vec\u003cu8\u003e\u003e)\u003e((\r\n                Bound::Included(\u0026min),\r\n                Bound::Included(\u0026max),\r\n            ))\r\n            .collect_vec();\r\n\r\n        assert_eq!(vec[0], \u0026op(\"T0\"));\r\n        assert_eq!(vec[1], \u0026op(\"T1\"));\r\n        assert_eq!(vec[2], \u0026op(\"T2\"));\r\n    }\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":13690942867206307838},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":13690942867206307838},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":10376293541461622786},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":10376293541461622786},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":5476377146882523136},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":5476377146882523136},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":5476377146882523136},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":13402712491054596096},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null}],"covered":98,"coverable":107},{"path":["E:","\\","sql-layer","src","types","index.rs"],"content":"use crate::types::value::ValueRef;\r\nuse crate::types::ColumnId;\r\n\r\nuse serde::{Deserialize, Serialize};\r\nuse std::{\r\n    fmt::{self, Formatter},\r\n    sync::Arc,\r\n};\r\n\r\npub type IndexId = u32;\r\npub type IndexMetaRef = Arc\u003cIndexMeta\u003e;\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq)]\r\npub struct IndexMeta {\r\n    pub id: IndexId,\r\n    pub column_ids: Vec\u003cColumnId\u003e,\r\n    pub name: String,\r\n    pub is_unique: bool,\r\n    pub is_primary: bool,\r\n}\r\n\r\npub struct Index {\r\n    pub id: IndexId,\r\n    pub column_values: Vec\u003cValueRef\u003e,\r\n}\r\n\r\nimpl Index {\r\n    pub fn new(id: IndexId, column_values: Vec\u003cValueRef\u003e) -\u003e Self {\r\n        Index { id, column_values }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for IndexMeta {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"{}\", self.name)\r\n    }\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":3},{"path":["E:","\\","sql-layer","src","types","mod.rs"],"content":"pub mod index;\r\npub mod tuple;\r\npub mod tuple_builder;\r\npub mod value;\r\n\r\nuse chrono::{NaiveDate, NaiveDateTime};\r\nuse rust_decimal::Decimal;\r\nuse serde::{Deserialize, Serialize};\r\nuse sqlparser::ast::ExactNumberInfo;\r\nuse std::any::TypeId;\r\nuse strum_macros::AsRefStr;\r\n\r\nuse crate::errors::{DatabaseError, Result};\r\n\r\npub type ColumnId = u32;\r\n\r\n/// Sqlrs type conversion:\r\n/// sqlparser::ast::DataType -\u003e LogicalType -\u003e arrow::datatypes::DataType\r\n#[derive(\r\n    Debug, Clone, Copy, PartialEq, Eq, Hash, AsRefStr, PartialOrd, Ord, Serialize, Deserialize,\r\n)]\r\npub enum LogicalType {\r\n    Invalid,\r\n    SqlNull,\r\n    Boolean,\r\n    Tinyint,\r\n    UTinyint,\r\n    Smallint,\r\n    USmallint,\r\n    Integer,\r\n    UInteger,\r\n    Bigint,\r\n    UBigint,\r\n    Float,\r\n    Double,\r\n    Varchar(Option\u003cu32\u003e),\r\n    Date,\r\n    DateTime,\r\n    // decimal (precision, scale)\r\n    Decimal(Option\u003cu8\u003e, Option\u003cu8\u003e),\r\n    //uuid now only support to non-pk table,and use to identify a tuple\r\n    UUID,\r\n}\r\n\r\nimpl LogicalType {\r\n    pub fn type_trans\u003cT: 'static\u003e() -\u003e Option\u003cLogicalType\u003e {\r\n        let type_id = TypeId::of::\u003cT\u003e();\r\n\r\n        if type_id == TypeId::of::\u003ci8\u003e() {\r\n            Some(LogicalType::Tinyint)\r\n        } else if type_id == TypeId::of::\u003ci16\u003e() {\r\n            Some(LogicalType::Smallint)\r\n        } else if type_id == TypeId::of::\u003ci32\u003e() {\r\n            Some(LogicalType::Integer)\r\n        } else if type_id == TypeId::of::\u003ci64\u003e() {\r\n            Some(LogicalType::Bigint)\r\n        } else if type_id == TypeId::of::\u003cu8\u003e() {\r\n            Some(LogicalType::UTinyint)\r\n        } else if type_id == TypeId::of::\u003cu16\u003e() {\r\n            Some(LogicalType::USmallint)\r\n        } else if type_id == TypeId::of::\u003cu32\u003e() {\r\n            Some(LogicalType::UInteger)\r\n        } else if type_id == TypeId::of::\u003cu64\u003e() {\r\n            Some(LogicalType::UBigint)\r\n        } else if type_id == TypeId::of::\u003cf32\u003e() {\r\n            Some(LogicalType::Float)\r\n        } else if type_id == TypeId::of::\u003cf64\u003e() {\r\n            Some(LogicalType::Double)\r\n        } else if type_id == TypeId::of::\u003cNaiveDate\u003e() {\r\n            Some(LogicalType::Date)\r\n        } else if type_id == TypeId::of::\u003cNaiveDateTime\u003e() {\r\n            Some(LogicalType::DateTime)\r\n        } else if type_id == TypeId::of::\u003cDecimal\u003e() {\r\n            Some(LogicalType::Decimal(None, None))\r\n        } else if type_id == TypeId::of::\u003cString\u003e() {\r\n            Some(LogicalType::Varchar(None))\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    pub fn raw_len(\u0026self) -\u003e Option\u003cusize\u003e {\r\n        match self {\r\n            LogicalType::Invalid =\u003e Some(0),\r\n            LogicalType::SqlNull =\u003e Some(0),\r\n            LogicalType::Boolean =\u003e Some(1),\r\n            LogicalType::Tinyint =\u003e Some(1),\r\n            LogicalType::UTinyint =\u003e Some(1),\r\n            LogicalType::Smallint =\u003e Some(2),\r\n            LogicalType::USmallint =\u003e Some(2),\r\n            LogicalType::Integer =\u003e Some(4),\r\n            LogicalType::UInteger =\u003e Some(4),\r\n            LogicalType::Bigint =\u003e Some(8),\r\n            LogicalType::UBigint =\u003e Some(8),\r\n            LogicalType::Float =\u003e Some(4),\r\n            LogicalType::Double =\u003e Some(8),\r\n            // Note: The non-fixed length type's raw_len is None e.g. Varchar\r\n            LogicalType::Varchar(_) =\u003e None,\r\n            LogicalType::Date =\u003e Some(4),\r\n            LogicalType::DateTime =\u003e Some(8),\r\n            LogicalType::Decimal(_, _) =\u003e Some(16),\r\n            LogicalType::UUID =\u003e Some(16),\r\n        }\r\n    }\r\n\r\n    pub fn numeric() -\u003e Vec\u003cLogicalType\u003e {\r\n        vec![\r\n            LogicalType::Tinyint,\r\n            LogicalType::UTinyint,\r\n            LogicalType::Smallint,\r\n            LogicalType::USmallint,\r\n            LogicalType::Integer,\r\n            LogicalType::UInteger,\r\n            LogicalType::Bigint,\r\n            LogicalType::UBigint,\r\n            LogicalType::Float,\r\n            LogicalType::Double,\r\n        ]\r\n    }\r\n\r\n    pub fn is_numeric(\u0026self) -\u003e bool {\r\n        matches!(\r\n            self,\r\n            LogicalType::Tinyint\r\n                | LogicalType::UTinyint\r\n                | LogicalType::Smallint\r\n                | LogicalType::USmallint\r\n                | LogicalType::Integer\r\n                | LogicalType::UInteger\r\n                | LogicalType::Bigint\r\n                | LogicalType::UBigint\r\n                | LogicalType::Float\r\n                | LogicalType::Double\r\n        )\r\n    }\r\n\r\n    pub fn is_signed_numeric(\u0026self) -\u003e bool {\r\n        matches!(\r\n            self,\r\n            LogicalType::Tinyint\r\n                | LogicalType::Smallint\r\n                | LogicalType::Integer\r\n                | LogicalType::Bigint\r\n        )\r\n    }\r\n\r\n    pub fn is_unsigned_numeric(\u0026self) -\u003e bool {\r\n        matches!(\r\n            self,\r\n            LogicalType::UTinyint\r\n                | LogicalType::USmallint\r\n                | LogicalType::UInteger\r\n                | LogicalType::UBigint\r\n        )\r\n    }\r\n\r\n    pub fn is_floating_point_numeric(\u0026self) -\u003e bool {\r\n        matches!(self, LogicalType::Float | LogicalType::Double)\r\n    }\r\n\r\n    pub fn max_logical_type(left: \u0026LogicalType, right: \u0026LogicalType) -\u003e Result\u003cLogicalType\u003e {\r\n        if left == right {\r\n            return Ok(*left);\r\n        }\r\n        match (left, right) {\r\n            // SqlNull type can be cast to anything\r\n            (LogicalType::SqlNull, _) =\u003e return Ok(*right),\r\n            (_, LogicalType::SqlNull) =\u003e return Ok(*left),\r\n            _ =\u003e {}\r\n        }\r\n        if left.is_numeric() \u0026\u0026 right.is_numeric() {\r\n            return LogicalType::combine_numeric_types(left, right);\r\n        }\r\n        if matches!(\r\n            (left, right),\r\n            (LogicalType::Date, LogicalType::Varchar(_))\r\n                | (LogicalType::Varchar(_), LogicalType::Date)\r\n        ) {\r\n            return Ok(LogicalType::Date);\r\n        }\r\n        if matches!(\r\n            (left, right),\r\n            (LogicalType::Date, LogicalType::DateTime) | (LogicalType::DateTime, LogicalType::Date)\r\n        ) {\r\n            return Ok(LogicalType::DateTime);\r\n        }\r\n        if matches!(\r\n            (left, right),\r\n            (LogicalType::DateTime, LogicalType::Varchar(_))\r\n                | (LogicalType::Varchar(_), LogicalType::DateTime)\r\n        ) {\r\n            return Ok(LogicalType::DateTime);\r\n        }\r\n        Err(DatabaseError::Incomparable(*left, *right))\r\n    }\r\n\r\n    fn combine_numeric_types(left: \u0026LogicalType, right: \u0026LogicalType) -\u003e Result\u003cLogicalType\u003e {\r\n        if left == right {\r\n            return Ok(*left);\r\n        }\r\n        if left.is_signed_numeric() \u0026\u0026 right.is_unsigned_numeric() {\r\n            // this method is symmetric\r\n            // arrange it so the left type is smaller\r\n            // to limit the number of options we need to check\r\n            return LogicalType::combine_numeric_types(right, left);\r\n        }\r\n\r\n        if LogicalType::can_implicit_cast(left, right) {\r\n            return Ok(*right);\r\n        }\r\n        if LogicalType::can_implicit_cast(right, left) {\r\n            return Ok(*left);\r\n        }\r\n        // we can't cast implicitly either way and types are not equal\r\n        // this happens when left is signed and right is unsigned\r\n        // e.g. INTEGER and UINTEGER\r\n        // in this case we need to upcast to make sure the types fit\r\n        match (left, right) {\r\n            (LogicalType::Bigint, _) | (_, LogicalType::UBigint) =\u003e Ok(LogicalType::Double),\r\n            (LogicalType::Integer, _) | (_, LogicalType::UInteger) =\u003e Ok(LogicalType::Bigint),\r\n            (LogicalType::Smallint, _) | (_, LogicalType::USmallint) =\u003e Ok(LogicalType::Integer),\r\n            (LogicalType::Tinyint, _) | (_, LogicalType::UTinyint) =\u003e Ok(LogicalType::Smallint),\r\n            _ =\u003e Err(DatabaseError::Incomparable(*left, *right)),\r\n        }\r\n    }\r\n\r\n    pub fn can_implicit_cast(from: \u0026LogicalType, to: \u0026LogicalType) -\u003e bool {\r\n        if from == to {\r\n            return true;\r\n        }\r\n        match from {\r\n            LogicalType::Invalid =\u003e false,\r\n            LogicalType::SqlNull =\u003e true,\r\n            LogicalType::Boolean =\u003e false,\r\n            LogicalType::Tinyint =\u003e matches!(\r\n                to,\r\n                LogicalType::Smallint\r\n                    | LogicalType::Integer\r\n                    | LogicalType::Bigint\r\n                    | LogicalType::Float\r\n                    | LogicalType::Double\r\n            ),\r\n            LogicalType::UTinyint =\u003e matches!(\r\n                to,\r\n                LogicalType::USmallint\r\n                    | LogicalType::UInteger\r\n                    | LogicalType::UBigint\r\n                    | LogicalType::Smallint\r\n                    | LogicalType::Integer\r\n                    | LogicalType::Bigint\r\n                    | LogicalType::Float\r\n                    | LogicalType::Double\r\n            ),\r\n            LogicalType::Smallint =\u003e matches!(\r\n                to,\r\n                LogicalType::Integer\r\n                    | LogicalType::Bigint\r\n                    | LogicalType::Float\r\n                    | LogicalType::Double\r\n            ),\r\n            LogicalType::USmallint =\u003e matches!(\r\n                to,\r\n                LogicalType::UInteger\r\n                    | LogicalType::UBigint\r\n                    | LogicalType::Integer\r\n                    | LogicalType::Bigint\r\n                    | LogicalType::Float\r\n                    | LogicalType::Double\r\n            ),\r\n            LogicalType::Integer =\u003e matches!(\r\n                to,\r\n                LogicalType::Bigint | LogicalType::Float | LogicalType::Double\r\n            ),\r\n            LogicalType::UInteger =\u003e matches!(\r\n                to,\r\n                LogicalType::UBigint\r\n                    | LogicalType::Bigint\r\n                    | LogicalType::Float\r\n                    | LogicalType::Double\r\n            ),\r\n            LogicalType::Bigint =\u003e matches!(to, LogicalType::Float | LogicalType::Double),\r\n            LogicalType::UBigint =\u003e matches!(to, LogicalType::Float | LogicalType::Double),\r\n            LogicalType::Float =\u003e matches!(to, LogicalType::Double),\r\n            LogicalType::Double =\u003e false,\r\n            LogicalType::Varchar(_) =\u003e false,\r\n            LogicalType::Date =\u003e matches!(to, LogicalType::DateTime | LogicalType::Varchar(_)),\r\n            LogicalType::DateTime =\u003e matches!(to, LogicalType::Date | LogicalType::Varchar(_)),\r\n            LogicalType::Decimal(_, _) =\u003e false,\r\n            LogicalType::UUID =\u003e false,\r\n        }\r\n    }\r\n}\r\n\r\n/// sqlparser datatype to logical type\r\nimpl TryFrom\u003csqlparser::ast::DataType\u003e for LogicalType {\r\n    type Error = DatabaseError;\r\n\r\n    fn try_from(value: sqlparser::ast::DataType) -\u003e Result\u003cSelf\u003e {\r\n        match value {\r\n            sqlparser::ast::DataType::Char(len) | sqlparser::ast::DataType::Varchar(len) =\u003e {\r\n                Ok(LogicalType::Varchar(len.map(|len| len.length as u32)))\r\n            }\r\n            sqlparser::ast::DataType::Float(_) =\u003e Ok(LogicalType::Float),\r\n            sqlparser::ast::DataType::Double =\u003e Ok(LogicalType::Double),\r\n            sqlparser::ast::DataType::TinyInt(_) =\u003e Ok(LogicalType::Tinyint),\r\n            sqlparser::ast::DataType::UnsignedTinyInt(_) =\u003e Ok(LogicalType::UTinyint),\r\n            sqlparser::ast::DataType::SmallInt(_) =\u003e Ok(LogicalType::Smallint),\r\n            sqlparser::ast::DataType::UnsignedSmallInt(_) =\u003e Ok(LogicalType::USmallint),\r\n            sqlparser::ast::DataType::Int(_) | sqlparser::ast::DataType::Integer(_) =\u003e {\r\n                Ok(LogicalType::Integer)\r\n            }\r\n            sqlparser::ast::DataType::UnsignedInt(_)\r\n            | sqlparser::ast::DataType::UnsignedInteger(_) =\u003e Ok(LogicalType::UInteger),\r\n            sqlparser::ast::DataType::BigInt(_) =\u003e Ok(LogicalType::Bigint),\r\n            sqlparser::ast::DataType::UnsignedBigInt(_) =\u003e Ok(LogicalType::UBigint),\r\n            sqlparser::ast::DataType::Boolean =\u003e Ok(LogicalType::Boolean),\r\n            sqlparser::ast::DataType::Datetime(_) =\u003e Ok(LogicalType::DateTime),\r\n            sqlparser::ast::DataType::Date =\u003e Ok(LogicalType::Date),\r\n            sqlparser::ast::DataType::Decimal(info) | sqlparser::ast::DataType::Dec(info) =\u003e {\r\n                match info {\r\n                    ExactNumberInfo::None =\u003e Ok(Self::Decimal(None, None)),\r\n                    ExactNumberInfo::Precision(p) =\u003e Ok(Self::Decimal(Some(p as u8), None)),\r\n                    ExactNumberInfo::PrecisionAndScale(p, s) =\u003e {\r\n                        Ok(Self::Decimal(Some(p as u8), Some(s as u8)))\r\n                    }\r\n                }\r\n            }\r\n            other =\u003e Err(DatabaseError::NotImplementedSqlparserDataType(\r\n                other.to_string(),\r\n            )),\r\n        }\r\n    }\r\n}\r\n\r\nimpl std::fmt::Display for LogicalType {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        write!(f, \"{}\", self.as_ref().to_uppercase())\r\n    }\r\n}\r\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":10376293541461622784},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":10376293541461622784},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2522015791327477761},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":16212958658533785600},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":16212958658533785600},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":15636497906230362112},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":59,"coverable":162},{"path":["E:","\\","sql-layer","src","types","tuple.rs"],"content":"use crate::catalog::{ColumnRef, SchemaRef};\r\nuse crate::types::value::{DataValue, ValueRef};\r\nuse comfy_table::{Cell, Table};\r\nuse integer_encoding::FixedInt;\r\nuse itertools::Itertools;\r\nuse std::fmt::Display;\r\nuse std::sync::Arc;\r\n\r\nconst BITS_MAX_INDEX: usize = 8;\r\n\r\npub type TupleId = ValueRef;\r\n\r\n#[derive(Clone, Debug, PartialEq)]\r\npub struct Tuple {\r\n    pub id: Option\u003cTupleId\u003e,\r\n    pub values: Vec\u003cValueRef\u003e,\r\n}\r\n\r\nimpl Display for Tuple {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        let mut s = String::new();\r\n        s += \"[\";\r\n        let mut tuple = vec![];\r\n        for val in self.values.iter() {\r\n            tuple.push(format!(\"{}\", val));\r\n        }\r\n        s += \u0026tuple.iter().join(\",\");\r\n        s += \"]\";\r\n        write!(f, \"{:?}\", self.values)\r\n    }\r\n}\r\n\r\nimpl Tuple {\r\n    pub fn deserialize_from(columns: \u0026[ColumnRef], bytes: \u0026[u8]) -\u003e Self {\r\n        fn is_none(bits: u8, i: usize) -\u003e bool {\r\n            bits \u0026 (1 \u003c\u003c (7 - i)) \u003e 0\r\n        }\r\n\r\n        let values_len = columns.len();\r\n        let mut values = Vec::with_capacity(values_len);\r\n        let bits_len = (values_len + BITS_MAX_INDEX) / BITS_MAX_INDEX;\r\n        let mut id_option = None;\r\n\r\n        let mut pos = bits_len;\r\n\r\n        for (i, col) in columns.iter().enumerate() {\r\n            let logic_type = col.datatype();\r\n\r\n            if is_none(bytes[i / BITS_MAX_INDEX], i % BITS_MAX_INDEX) {\r\n                values.push(Arc::new(DataValue::none(logic_type)));\r\n            } else if let Some(len) = logic_type.raw_len() {\r\n                // fixed length (e.g.: int)\r\n                values.push(Arc::new(DataValue::from_raw(\r\n                    \u0026bytes[pos..pos + len],\r\n                    logic_type,\r\n                )));\r\n                pos += len;\r\n            } else {\r\n                // variable length (e.g.: varchar)\r\n                let len = u32::decode_fixed(\u0026bytes[pos..pos + 4]) as usize;\r\n                pos += 4;\r\n                values.push(Arc::new(DataValue::from_raw(\r\n                    \u0026bytes[pos..pos + len],\r\n                    logic_type,\r\n                )));\r\n                pos += len;\r\n            }\r\n\r\n            if col.desc.is_primary {\r\n                id_option = Some(values[i].clone());\r\n            }\r\n        }\r\n\r\n        Tuple {\r\n            id: id_option,\r\n            values,\r\n        }\r\n    }\r\n\r\n    /// e.g.: bits(u8)..|data_0(len for utf8_1)|utf8_0|data_1|\r\n    /// Tips: all len is u32\r\n    pub fn serialize_to(\u0026self) -\u003e Vec\u003cu8\u003e {\r\n        fn flip_bit(bits: u8, i: usize) -\u003e u8 {\r\n            bits | (1 \u003c\u003c (7 - i))\r\n        }\r\n\r\n        let values_len = self.values.len();\r\n        let bits_len = (values_len + BITS_MAX_INDEX) / BITS_MAX_INDEX;\r\n        let mut bytes = vec![0_u8; bits_len];\r\n\r\n        for (i, value) in self.values.iter().enumerate() {\r\n            if value.is_null() {\r\n                bytes[i / BITS_MAX_INDEX] = flip_bit(bytes[i / BITS_MAX_INDEX], i % BITS_MAX_INDEX);\r\n            } else {\r\n                let mut value_bytes = value.to_raw();\r\n\r\n                if value.is_variable() {\r\n                    bytes.append(\u0026mut (value_bytes.len() as u32).encode_fixed_vec());\r\n                }\r\n                bytes.append(\u0026mut value_bytes);\r\n            }\r\n        }\r\n\r\n        bytes\r\n    }\r\n}\r\n\r\npub fn create_table(tuples: \u0026(SchemaRef, Vec\u003cTuple\u003e)) -\u003e Table {\r\n    let schema = \u0026tuples.0;\r\n    let tuples = \u0026tuples.1;\r\n    let mut table = Table::new();\r\n\r\n    if tuples.is_empty() {\r\n        return table;\r\n    }\r\n\r\n    let mut header = Vec::new();\r\n    for col in schema.iter() {\r\n        header.push(Cell::new(col.name().to_string()));\r\n    }\r\n    table.set_header(header);\r\n\r\n    for tuple in tuples {\r\n        let cells = tuple\r\n            .values\r\n            .iter()\r\n            .map(|value| Cell::new(format!(\"{value}\")))\r\n            .collect_vec();\r\n\r\n        table.add_row(cells);\r\n    }\r\n\r\n    table\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::catalog::{ColumnCatalog, ColumnDesc};\r\n    use crate::types::tuple::Tuple;\r\n    use crate::types::value::DataValue;\r\n    use crate::types::LogicalType;\r\n    use std::sync::Arc;\r\n\r\n    #[test]\r\n    fn test_tuple_serialize_to_and_deserialize_from() {\r\n        let columns = vec![\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c1\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Integer, true, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c2\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::UInteger, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c3\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Varchar(Some(2)), false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c4\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Smallint, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c5\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::USmallint, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c6\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Float, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c7\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Double, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c8\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Tinyint, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c9\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::UTinyint, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c10\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Boolean, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c11\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::DateTime, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c12\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Date, false, false, None),\r\n                // None,\r\n            )),\r\n        ];\r\n\r\n        let tuples = vec![\r\n            Tuple {\r\n                id: Some(Arc::new(DataValue::Int32(Some(0)))),\r\n                values: vec![\r\n                    Arc::new(DataValue::Int32(Some(0))),\r\n                    Arc::new(DataValue::UInt32(Some(1))),\r\n                    Arc::new(DataValue::Utf8(Some(\"LOL\".to_string()))),\r\n                    Arc::new(DataValue::Int16(Some(1))),\r\n                    Arc::new(DataValue::UInt16(Some(1))),\r\n                    Arc::new(DataValue::Float32(Some(0.1))),\r\n                    Arc::new(DataValue::Float64(Some(0.1))),\r\n                    Arc::new(DataValue::Int8(Some(1))),\r\n                    Arc::new(DataValue::UInt8(Some(1))),\r\n                    Arc::new(DataValue::Boolean(Some(true))),\r\n                    Arc::new(DataValue::Date64(Some(0))),\r\n                    Arc::new(DataValue::Date32(Some(0))),\r\n                ],\r\n            },\r\n            Tuple {\r\n                id: Some(Arc::new(DataValue::Int32(Some(1)))),\r\n                values: vec![\r\n                    Arc::new(DataValue::Int32(Some(1))),\r\n                    Arc::new(DataValue::UInt32(None)),\r\n                    Arc::new(DataValue::Utf8(None)),\r\n                    Arc::new(DataValue::Int16(None)),\r\n                    Arc::new(DataValue::UInt16(None)),\r\n                    Arc::new(DataValue::Float32(None)),\r\n                    Arc::new(DataValue::Float64(None)),\r\n                    Arc::new(DataValue::Int8(None)),\r\n                    Arc::new(DataValue::UInt8(None)),\r\n                    Arc::new(DataValue::Boolean(None)),\r\n                    Arc::new(DataValue::Date64(None)),\r\n                    Arc::new(DataValue::Date32(None)),\r\n                ],\r\n            },\r\n        ];\r\n\r\n        let tuple_0 = Tuple::deserialize_from(\u0026columns, \u0026tuples[0].serialize_to());\r\n        let tuple_1 = Tuple::deserialize_from(\u0026columns, \u0026tuples[1].serialize_to());\r\n\r\n        assert_eq!(tuples[0], tuple_0);\r\n        assert_eq!(tuples[1], tuple_1);\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":11457157452030541824},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":12538021362599460865},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1080863910568919041},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":17221764975064776703},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1441151880758558721},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2377900603251621889},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2377900603251621889},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1441151880758558721},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1441151880758558721},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1441151880758558721},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":6845471433603153921},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":6341068275337658368},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":16140901064495857664},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":4683743612465315840},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":4683743612465315840},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":4683743612465315840},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null}],"covered":51,"coverable":60},{"path":["E:","\\","sql-layer","src","types","tuple_builder.rs"],"content":"use crate::catalog::ColumnRef;\r\nuse crate::errors::*;\r\nuse crate::types::value::{DataValue, ValueRef};\r\n\r\nuse std::sync::Arc;\r\n\r\nuse super::tuple::Tuple;\r\n\r\npub struct TupleBuilder {\r\n    columns: Vec\u003cColumnRef\u003e,\r\n}\r\n\r\nimpl TupleBuilder {\r\n    pub fn new( columns: Vec\u003cColumnRef\u003e) -\u003e Self {\r\n        TupleBuilder {\r\n            columns,\r\n        }\r\n    }\r\n\r\n    pub fn new_result() -\u003e Self {\r\n        TupleBuilder {\r\n            columns: Vec::new(),\r\n        }\r\n    }\r\n\r\n    pub fn push_result(self, _header: \u0026str, message: \u0026str) -\u003e Result\u003cTuple\u003e {\r\n        let values: Vec\u003cValueRef\u003e = vec![Arc::new(DataValue::Utf8(Some(String::from(message))))];\r\n        let t = Tuple { id: None, values };\r\n        Ok(t)\r\n    }\r\n\r\n    pub fn build_with_row\u003c'b\u003e(\u0026self, row: impl IntoIterator\u003cItem = \u0026'b str\u003e) -\u003e Result\u003cTuple\u003e {\r\n        let mut values = Vec::with_capacity(self.columns.len());\r\n        let mut primary_key = None;\r\n\r\n        for (i, value) in row.into_iter().enumerate() {\r\n            // debug!(\"{}: {}\", i, value);\r\n            let data_value = Arc::new(\r\n                DataValue::Utf8(Some(value.to_string())).cast(self.columns[i].datatype())?,\r\n            );\r\n\r\n            if primary_key.is_none() \u0026\u0026 self.columns[i].desc.is_primary {\r\n                primary_key = Some(data_value.clone());\r\n            }\r\n            values.push(data_value);\r\n        }\r\n        if values.len() != self.columns.len() {\r\n            return Err(DatabaseError::MisMatch(\r\n                \"types\".to_string(),\r\n                \"values\".to_string(),\r\n            ));\r\n        }\r\n\r\n        Ok(Tuple {\r\n            id: primary_key,\r\n            values,\r\n        })\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":10,"coverable":22},{"path":["E:","\\","sql-layer","src","types","value.rs"],"content":"use chrono::format::{DelayedFormat, StrftimeItems};\r\nuse chrono::{Datelike, NaiveDate, NaiveDateTime};\r\nuse integer_encoding::FixedInt;\r\nuse lazy_static::lazy_static;\r\nuse rust_decimal::prelude::FromPrimitive;\r\nuse rust_decimal::prelude::ToPrimitive;\r\nuse rust_decimal::Decimal;\r\nuse std::cmp::Ordering;\r\nuse std::fmt::Formatter;\r\nuse std::hash::Hash;\r\nuse std::str::FromStr;\r\nuse std::sync::Arc;\r\nuse std::{fmt, mem};\r\nuse uuid::Uuid;\r\n\r\nuse crate::errors::*;\r\nuse ordered_float::OrderedFloat;\r\nuse serde::{Deserialize, Serialize};\r\n\r\nuse super::LogicalType;\r\n\r\nlazy_static! {\r\n    pub static ref NULL_VALUE: ValueRef = Arc::new(DataValue::Null);\r\n    static ref UNIX_DATETIME: NaiveDateTime = NaiveDateTime::from_timestamp_opt(0, 0).unwrap();\r\n}\r\n\r\npub const DATE_FMT: \u0026str = \"%Y-%m-%d\";\r\npub const DATE_TIME_FMT: \u0026str = \"%Y-%m-%d %H:%M:%S\";\r\n\r\nconst ENCODE_GROUP_SIZE: usize = 8;\r\nconst ENCODE_MARKER: u8 = 0xFF;\r\n\r\npub type ValueRef = Arc\u003cDataValue\u003e;\r\n\r\n#[derive(Clone, Serialize, Deserialize)]\r\npub enum DataValue {\r\n    Null,\r\n    Boolean(Option\u003cbool\u003e),\r\n    Float32(Option\u003cf32\u003e),\r\n    Float64(Option\u003cf64\u003e),\r\n    Int8(Option\u003ci8\u003e),\r\n    Int16(Option\u003ci16\u003e),\r\n    Int32(Option\u003ci32\u003e),\r\n    Int64(Option\u003ci64\u003e),\r\n    UInt8(Option\u003cu8\u003e),\r\n    UInt16(Option\u003cu16\u003e),\r\n    UInt32(Option\u003cu32\u003e),\r\n    UInt64(Option\u003cu64\u003e),\r\n    Utf8(Option\u003cString\u003e),\r\n    /// Date stored as a signed 32bit int days since UNIX epoch 1970-01-01\r\n    Date32(Option\u003ci32\u003e),\r\n    /// Date stored as a signed 64bit int timestamp since UNIX epoch 1970-01-01\r\n    Date64(Option\u003ci64\u003e),\r\n    UUID(Option\u003cUuid\u003e),\r\n    Decimal(Option\u003cDecimal\u003e),\r\n}\r\n\r\nmacro_rules! generate_get_option {\r\n    ($data_value:ident, $($prefix:ident : $variant:ident($field:ty)),*) =\u003e {\r\n        impl $data_value {\r\n            $(\r\n                pub fn $prefix(\u0026self) -\u003e $field {\r\n                    if let $data_value::$variant(Some(val)) = self {\r\n                        Some(val.clone())\r\n                    } else {\r\n                        None\r\n                    }\r\n                }\r\n            )*\r\n        }\r\n    };\r\n}\r\n\r\ngenerate_get_option!(DataValue,\r\n    bool : Boolean(Option\u003cbool\u003e),\r\n    float : Float32(Option\u003cf32\u003e),\r\n    double : Float64(Option\u003cf64\u003e),\r\n    i8 : Int8(Option\u003ci8\u003e),\r\n    i16 : Int16(Option\u003ci16\u003e),\r\n    i32 : Int32(Option\u003ci32\u003e),\r\n    i64 : Int64(Option\u003ci64\u003e),\r\n    u8 : UInt8(Option\u003cu8\u003e),\r\n    u16 : UInt16(Option\u003cu16\u003e),\r\n    u32 : UInt32(Option\u003cu32\u003e),\r\n    u64 : UInt64(Option\u003cu64\u003e),\r\n    utf8 : Utf8(Option\u003cString\u003e),\r\n    // decimal : Decimal(Option\u003cDecimal\u003e),\r\n    uuid: UUID(Option\u003cUuid\u003e)\r\n\r\n);\r\n\r\nimpl PartialEq for DataValue {\r\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n        use DataValue::*;\r\n        match (self, other) {\r\n            (Boolean(v1), Boolean(v2)) =\u003e v1.eq(v2),\r\n            (Boolean(_), _) =\u003e false,\r\n            (Float32(v1), Float32(v2)) =\u003e {\r\n                let v1 = v1.map(OrderedFloat);\r\n                let v2 = v2.map(OrderedFloat);\r\n                v1.eq(\u0026v2)\r\n            }\r\n            (Float32(_), _) =\u003e false,\r\n            (Float64(v1), Float64(v2)) =\u003e {\r\n                let v1 = v1.map(OrderedFloat);\r\n                let v2 = v2.map(OrderedFloat);\r\n                v1.eq(\u0026v2)\r\n            }\r\n            (Float64(_), _) =\u003e false,\r\n            (Int8(v1), Int8(v2)) =\u003e v1.eq(v2),\r\n            (Int8(_), _) =\u003e false,\r\n            (Int16(v1), Int16(v2)) =\u003e v1.eq(v2),\r\n            (Int16(_), _) =\u003e false,\r\n            (Int32(v1), Int32(v2)) =\u003e v1.eq(v2),\r\n            (Int32(_), _) =\u003e false,\r\n            (Int64(v1), Int64(v2)) =\u003e v1.eq(v2),\r\n            (Int64(_), _) =\u003e false,\r\n            (UInt8(v1), UInt8(v2)) =\u003e v1.eq(v2),\r\n            (UInt8(_), _) =\u003e false,\r\n            (UInt16(v1), UInt16(v2)) =\u003e v1.eq(v2),\r\n            (UInt16(_), _) =\u003e false,\r\n            (UInt32(v1), UInt32(v2)) =\u003e v1.eq(v2),\r\n            (UInt32(_), _) =\u003e false,\r\n            (UInt64(v1), UInt64(v2)) =\u003e v1.eq(v2),\r\n            (UInt64(_), _) =\u003e false,\r\n            (Utf8(v1), Utf8(v2)) =\u003e v1.eq(v2),\r\n            (Utf8(_), _) =\u003e false,\r\n            (Null, Null) =\u003e true,\r\n            (Null, _) =\u003e false,\r\n            (Date32(v1), Date32(v2)) =\u003e v1.eq(v2),\r\n            (Date32(_), _) =\u003e false,\r\n            (Date64(v1), Date64(v2)) =\u003e v1.eq(v2),\r\n            (Date64(_), _) =\u003e false,\r\n            (Decimal(v1), Decimal(v2)) =\u003e v1.eq(v2),\r\n            (Decimal(_), _) =\u003e false,\r\n            (UUID(v1), UUID(v2)) =\u003e v1.eq(v2),\r\n            (UUID(_), _) =\u003e false,\r\n        }\r\n    }\r\n}\r\n\r\nimpl PartialOrd for DataValue {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\r\n        use DataValue::*;\r\n        match (self, other) {\r\n            (Boolean(v1), Boolean(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Boolean(_), _) =\u003e None,\r\n            (Float32(v1), Float32(v2)) =\u003e {\r\n                let v1 = v1.map(OrderedFloat);\r\n                let v2 = v2.map(OrderedFloat);\r\n                v1.partial_cmp(\u0026v2)\r\n            }\r\n            (Float32(_), _) =\u003e None,\r\n            (Float64(v1), Float64(v2)) =\u003e {\r\n                let v1 = v1.map(OrderedFloat);\r\n                let v2 = v2.map(OrderedFloat);\r\n                v1.partial_cmp(\u0026v2)\r\n            }\r\n            (Float64(_), _) =\u003e None,\r\n            (Int8(v1), Int8(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Int8(_), _) =\u003e None,\r\n            (Int16(v1), Int16(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Int16(_), _) =\u003e None,\r\n            (Int32(v1), Int32(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Int32(_), _) =\u003e None,\r\n            (Int64(v1), Int64(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Int64(_), _) =\u003e None,\r\n            (UInt8(v1), UInt8(v2)) =\u003e v1.partial_cmp(v2),\r\n            (UInt8(_), _) =\u003e None,\r\n            (UInt16(v1), UInt16(v2)) =\u003e v1.partial_cmp(v2),\r\n            (UInt16(_), _) =\u003e None,\r\n            (UInt32(v1), UInt32(v2)) =\u003e v1.partial_cmp(v2),\r\n            (UInt32(_), _) =\u003e None,\r\n            (UInt64(v1), UInt64(v2)) =\u003e v1.partial_cmp(v2),\r\n            (UInt64(_), _) =\u003e None,\r\n            (Utf8(v1), Utf8(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Utf8(_), _) =\u003e None,\r\n            (Null, Null) =\u003e Some(Ordering::Equal),\r\n            (Null, _) =\u003e None,\r\n            (Date32(v1), Date32(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Date32(_), _) =\u003e None,\r\n            (Date64(v1), Date64(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Date64(_), _) =\u003e None,\r\n            (Decimal(v1), Decimal(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Decimal(_), _) =\u003e None,\r\n            (UUID(v1), UUID(v2)) =\u003e v1.partial_cmp(v2),\r\n            (UUID(_), _) =\u003e None,\r\n        }\r\n    }\r\n}\r\n\r\nmacro_rules! encode_u {\r\n    ($b:ident, $u:expr) =\u003e {\r\n        $b.extend_from_slice(\u0026$u.to_be_bytes())\r\n    };\r\n}\r\n\r\nimpl Eq for DataValue {}\r\n\r\nimpl Hash for DataValue {\r\n    fn hash\u003cH: std::hash::Hasher\u003e(\u0026self, state: \u0026mut H) {\r\n        use DataValue::*;\r\n        match self {\r\n            Boolean(v) =\u003e v.hash(state),\r\n            Float32(v) =\u003e {\r\n                let v = v.map(OrderedFloat);\r\n                v.hash(state)\r\n            }\r\n            Float64(v) =\u003e {\r\n                let v = v.map(OrderedFloat);\r\n                v.hash(state)\r\n            }\r\n            Int8(v) =\u003e v.hash(state),\r\n            Int16(v) =\u003e v.hash(state),\r\n            Int32(v) =\u003e v.hash(state),\r\n            Int64(v) =\u003e v.hash(state),\r\n            UInt8(v) =\u003e v.hash(state),\r\n            UInt16(v) =\u003e v.hash(state),\r\n            UInt32(v) =\u003e v.hash(state),\r\n            UInt64(v) =\u003e v.hash(state),\r\n            Utf8(v) =\u003e v.hash(state),\r\n            Null =\u003e 1.hash(state),\r\n            Date32(v) =\u003e v.hash(state),\r\n            Date64(v) =\u003e v.hash(state),\r\n            Decimal(v) =\u003e v.hash(state),\r\n            UUID(v) =\u003e v.hash(state),\r\n        }\r\n    }\r\n}\r\nmacro_rules! varchar_cast {\r\n    ($value:expr, $len:expr) =\u003e {\r\n        $value\r\n            .map(|v| {\r\n                let string_value = format!(\"{}\", v);\r\n                if let Some(len) = $len {\r\n                    if string_value.len() \u003e *len as usize {\r\n                        return Err(DatabaseError::TooLong);\r\n                    }\r\n                }\r\n                Ok(DataValue::Utf8(Some(string_value)))\r\n            })\r\n            .unwrap_or(Ok(DataValue::Utf8(None)))\r\n    };\r\n}\r\n\r\nimpl DataValue {\r\n    pub fn date(\u0026self) -\u003e Option\u003cNaiveDate\u003e {\r\n        if let DataValue::Date32(Some(val)) = self {\r\n            NaiveDate::from_num_days_from_ce_opt(*val)\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    pub fn datetime(\u0026self) -\u003e Option\u003cNaiveDateTime\u003e {\r\n        if let DataValue::Date64(Some(val)) = self {\r\n            NaiveDateTime::from_timestamp_opt(*val, 0)\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n    pub fn decimal(\u0026self) -\u003e Option\u003cDecimal\u003e {\r\n        if let DataValue::Decimal(Some(val)) = self {\r\n            Some(*val)\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    pub(crate) fn check_len(\u0026self, logic_type: \u0026LogicalType) -\u003e Result\u003c()\u003e {\r\n        let is_over_len = match (logic_type, self) {\r\n            (LogicalType::Varchar(Some(len)), DataValue::Utf8(Some(val))) =\u003e {\r\n                val.len() \u003e *len as usize\r\n            }\r\n            (LogicalType::Decimal(full_len, scale_len), DataValue::Decimal(Some(val))) =\u003e {\r\n                if let Some(len) = full_len {\r\n                    if val.mantissa().ilog10() + 1 \u003e *len as u32 {\r\n                        return Err(DatabaseError::TooLong);\r\n                    }\r\n                }\r\n                if let Some(len) = scale_len {\r\n                    if val.scale() \u003e *len as u32 {\r\n                        return Err(DatabaseError::TooLong);\r\n                    }\r\n                }\r\n                false\r\n            }\r\n            _ =\u003e false,\r\n        };\r\n\r\n        if is_over_len {\r\n            return Err(DatabaseError::TooLong);\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn format_date(value: Option\u003ci32\u003e) -\u003e Option\u003cString\u003e {\r\n        value.and_then(|v| Self::date_format(v).map(|fmt| format!(\"{}\", fmt)))\r\n    }\r\n\r\n    fn format_datetime(value: Option\u003ci64\u003e) -\u003e Option\u003cString\u003e {\r\n        value.and_then(|v| Self::date_time_format(v).map(|fmt| format!(\"{}\", fmt)))\r\n    }\r\n\r\n    pub fn is_variable(\u0026self) -\u003e bool {\r\n        matches!(self, DataValue::Utf8(_))\r\n    }\r\n\r\n    pub fn is_null(\u0026self) -\u003e bool {\r\n        match self {\r\n            DataValue::Null =\u003e true,\r\n            DataValue::Boolean(value) =\u003e value.is_none(),\r\n            DataValue::Float32(value) =\u003e value.is_none(),\r\n            DataValue::Float64(value) =\u003e value.is_none(),\r\n            DataValue::Int8(value) =\u003e value.is_none(),\r\n            DataValue::Int16(value) =\u003e value.is_none(),\r\n            DataValue::Int32(value) =\u003e value.is_none(),\r\n            DataValue::Int64(value) =\u003e value.is_none(),\r\n            DataValue::UInt8(value) =\u003e value.is_none(),\r\n            DataValue::UInt16(value) =\u003e value.is_none(),\r\n            DataValue::UInt32(value) =\u003e value.is_none(),\r\n            DataValue::UInt64(value) =\u003e value.is_none(),\r\n            DataValue::Utf8(value) =\u003e value.is_none(),\r\n            DataValue::Date32(value) =\u003e value.is_none(),\r\n            DataValue::Date64(value) =\u003e value.is_none(),\r\n            DataValue::Decimal(value) =\u003e value.is_none(),\r\n            DataValue::UUID(value) =\u003e value.is_none(),\r\n        }\r\n    }\r\n\r\n    pub fn none(logic_type: \u0026LogicalType) -\u003e DataValue {\r\n        match logic_type {\r\n            LogicalType::Invalid =\u003e panic!(\"invalid logical type\"),\r\n            LogicalType::SqlNull =\u003e DataValue::Null,\r\n            LogicalType::Boolean =\u003e DataValue::Boolean(None),\r\n            LogicalType::Tinyint =\u003e DataValue::Int8(None),\r\n            LogicalType::UTinyint =\u003e DataValue::UInt8(None),\r\n            LogicalType::Smallint =\u003e DataValue::Int16(None),\r\n            LogicalType::USmallint =\u003e DataValue::UInt16(None),\r\n            LogicalType::Integer =\u003e DataValue::Int32(None),\r\n            LogicalType::UInteger =\u003e DataValue::UInt32(None),\r\n            LogicalType::Bigint =\u003e DataValue::Int64(None),\r\n            LogicalType::UBigint =\u003e DataValue::UInt64(None),\r\n            LogicalType::Float =\u003e DataValue::Float32(None),\r\n            LogicalType::Double =\u003e DataValue::Float64(None),\r\n            LogicalType::Varchar(_) =\u003e DataValue::Utf8(None),\r\n            LogicalType::Date =\u003e DataValue::Date32(None),\r\n            LogicalType::DateTime =\u003e DataValue::Date64(None),\r\n            LogicalType::Decimal(_, _) =\u003e DataValue::Decimal(None),\r\n            LogicalType::UUID =\u003e DataValue::UUID(None),\r\n        }\r\n    }\r\n\r\n    pub fn init(logic_type: \u0026LogicalType) -\u003e DataValue {\r\n        match logic_type {\r\n            LogicalType::Invalid =\u003e panic!(\"invalid logical type\"),\r\n            LogicalType::SqlNull =\u003e DataValue::Null,\r\n            LogicalType::Boolean =\u003e DataValue::Boolean(Some(false)),\r\n            LogicalType::Tinyint =\u003e DataValue::Int8(Some(0)),\r\n            LogicalType::UTinyint =\u003e DataValue::UInt8(Some(0)),\r\n            LogicalType::Smallint =\u003e DataValue::Int16(Some(0)),\r\n            LogicalType::USmallint =\u003e DataValue::UInt16(Some(0)),\r\n            LogicalType::Integer =\u003e DataValue::Int32(Some(0)),\r\n            LogicalType::UInteger =\u003e DataValue::UInt32(Some(0)),\r\n            LogicalType::Bigint =\u003e DataValue::Int64(Some(0)),\r\n            LogicalType::UBigint =\u003e DataValue::UInt64(Some(0)),\r\n            LogicalType::Float =\u003e DataValue::Float32(Some(0.0)),\r\n            LogicalType::Double =\u003e DataValue::Float64(Some(0.0)),\r\n            LogicalType::Varchar(_) =\u003e DataValue::Utf8(Some(\"\".to_string())),\r\n            LogicalType::Date =\u003e DataValue::Date32(Some(UNIX_DATETIME.num_days_from_ce())),\r\n            LogicalType::DateTime =\u003e DataValue::Date64(Some(UNIX_DATETIME.timestamp())),\r\n            LogicalType::Decimal(_, _) =\u003e DataValue::Decimal(Some(Decimal::new(0, 0))),\r\n            LogicalType::UUID =\u003e DataValue::UUID(Some(Uuid::new_v4())),\r\n        }\r\n    }\r\n\r\n    pub fn to_raw(\u0026self) -\u003e Vec\u003cu8\u003e {\r\n        match self {\r\n            DataValue::Null =\u003e None,\r\n            DataValue::Boolean(v) =\u003e v.map(|v| vec![v as u8]),\r\n            DataValue::Float32(v) =\u003e v.map(|v| v.to_ne_bytes().to_vec()),\r\n            DataValue::Float64(v) =\u003e v.map(|v| v.to_ne_bytes().to_vec()),\r\n            DataValue::Int8(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::Int16(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::Int32(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::Int64(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::UInt8(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::UInt16(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::UInt32(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::UInt64(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::Utf8(v) =\u003e v.clone().map(|v| v.into_bytes()),\r\n            DataValue::Date32(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::Date64(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::Decimal(v) =\u003e v.map(|v| v.serialize().to_vec()),\r\n            DataValue::UUID(v) =\u003e v.map(|v| v.as_bytes().to_vec()),\r\n        }\r\n        .unwrap_or(vec![])\r\n    }\r\n\r\n    pub fn from_raw(bytes: \u0026[u8], ty: \u0026LogicalType) -\u003e Self {\r\n        match ty {\r\n            LogicalType::Invalid =\u003e panic!(\"invalid logical type\"),\r\n            LogicalType::SqlNull =\u003e DataValue::Null,\r\n            LogicalType::Boolean =\u003e DataValue::Boolean(bytes.first().map(|v| *v != 0)),\r\n            LogicalType::Tinyint =\u003e {\r\n                DataValue::Int8((!bytes.is_empty()).then(|| i8::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::UTinyint =\u003e {\r\n                DataValue::UInt8((!bytes.is_empty()).then(|| u8::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::Smallint =\u003e {\r\n                DataValue::Int16((!bytes.is_empty()).then(|| i16::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::USmallint =\u003e {\r\n                DataValue::UInt16((!bytes.is_empty()).then(|| u16::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::Integer =\u003e {\r\n                DataValue::Int32((!bytes.is_empty()).then(|| i32::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::UInteger =\u003e {\r\n                DataValue::UInt32((!bytes.is_empty()).then(|| u32::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::Bigint =\u003e {\r\n                DataValue::Int64((!bytes.is_empty()).then(|| i64::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::UBigint =\u003e {\r\n                DataValue::UInt64((!bytes.is_empty()).then(|| u64::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::Float =\u003e DataValue::Float32((!bytes.is_empty()).then(|| {\r\n                let mut buf = [0; 4];\r\n                buf.copy_from_slice(bytes);\r\n                f32::from_ne_bytes(buf)\r\n            })),\r\n            LogicalType::Double =\u003e DataValue::Float64((!bytes.is_empty()).then(|| {\r\n                let mut buf = [0; 8];\r\n                buf.copy_from_slice(bytes);\r\n                f64::from_ne_bytes(buf)\r\n            })),\r\n            LogicalType::Varchar(_) =\u003e DataValue::Utf8(\r\n                (!bytes.is_empty()).then(|| String::from_utf8(bytes.to_owned()).unwrap()),\r\n            ),\r\n            LogicalType::Date =\u003e {\r\n                DataValue::Date32((!bytes.is_empty()).then(|| i32::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::DateTime =\u003e {\r\n                DataValue::Date64((!bytes.is_empty()).then(|| i64::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::Decimal(_, _) =\u003e DataValue::Decimal(\r\n                (!bytes.is_empty())\r\n                    .then(|| Decimal::deserialize(\u003c[u8; 16]\u003e::try_from(bytes).unwrap())),\r\n            ),\r\n            LogicalType::UUID =\u003e {\r\n                DataValue::UUID((!bytes.is_empty()).then(|| Uuid::from_slice(bytes).unwrap()))\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn logical_type(\u0026self) -\u003e LogicalType {\r\n        match self {\r\n            DataValue::Null =\u003e LogicalType::SqlNull,\r\n            DataValue::Boolean(_) =\u003e LogicalType::Boolean,\r\n            DataValue::Float32(_) =\u003e LogicalType::Float,\r\n            DataValue::Float64(_) =\u003e LogicalType::Double,\r\n            DataValue::Int8(_) =\u003e LogicalType::Tinyint,\r\n            DataValue::Int16(_) =\u003e LogicalType::Smallint,\r\n            DataValue::Int32(_) =\u003e LogicalType::Integer,\r\n            DataValue::Int64(_) =\u003e LogicalType::Bigint,\r\n            DataValue::UInt8(_) =\u003e LogicalType::UTinyint,\r\n            DataValue::UInt16(_) =\u003e LogicalType::USmallint,\r\n            DataValue::UInt32(_) =\u003e LogicalType::UInteger,\r\n            DataValue::UInt64(_) =\u003e LogicalType::UBigint,\r\n            DataValue::Utf8(_) =\u003e LogicalType::Varchar(None),\r\n            DataValue::Date32(_) =\u003e LogicalType::Date,\r\n            DataValue::Date64(_) =\u003e LogicalType::DateTime,\r\n            DataValue::Decimal(_) =\u003e LogicalType::Decimal(None, None),\r\n            DataValue::UUID(_) =\u003e LogicalType::UUID,\r\n        }\r\n    }\r\n\r\n    // EncodeBytes guarantees the encoded value is in ascending order for comparison,\r\n    // encoding with the following rule:\r\n    //\r\n    //\t[group1][marker1]...[groupN][markerN]\r\n    //\tgroup is 8 bytes slice which is padding with 0.\r\n    //\tmarker is `0xFF - padding 0 count`\r\n    //\r\n    // For example:\r\n    //\r\n    //\t[] -\u003e [0, 0, 0, 0, 0, 0, 0, 0, 247]\r\n    //\t[1, 2, 3] -\u003e [1, 2, 3, 0, 0, 0, 0, 0, 250]\r\n    //\t[1, 2, 3, 0] -\u003e [1, 2, 3, 0, 0, 0, 0, 0, 251]\r\n    //\t[1, 2, 3, 4, 5, 6, 7, 8] -\u003e [1, 2, 3, 4, 5, 6, 7, 8, 255, 0, 0, 0, 0, 0, 0, 0, 0, 247]\r\n    //\r\n    // Refer: https://github.com/facebook/mysql-5.6/wiki/MyRocks-record-format#memcomparable-format\r\n    fn encode_bytes(b: \u0026mut Vec\u003cu8\u003e, data: \u0026[u8]) {\r\n        let d_len = data.len();\r\n        let realloc_size = (d_len / ENCODE_GROUP_SIZE + 1) * (ENCODE_GROUP_SIZE + 1);\r\n        Self::realloc_bytes(b, realloc_size);\r\n\r\n        let mut idx = 0;\r\n        while idx \u003c= d_len {\r\n            let remain = d_len - idx;\r\n            let pad_count: usize;\r\n\r\n            if remain \u003e= ENCODE_GROUP_SIZE {\r\n                b.extend_from_slice(\u0026data[idx..idx + ENCODE_GROUP_SIZE]);\r\n                pad_count = 0;\r\n            } else {\r\n                pad_count = ENCODE_GROUP_SIZE - remain;\r\n                b.extend_from_slice(\u0026data[idx..]);\r\n                b.extend_from_slice(\u0026vec![0; pad_count]);\r\n            }\r\n\r\n            b.push(ENCODE_MARKER - pad_count as u8);\r\n            idx += ENCODE_GROUP_SIZE;\r\n        }\r\n    }\r\n\r\n    fn realloc_bytes(b: \u0026mut Vec\u003cu8\u003e, size: usize) {\r\n        let len = b.len();\r\n\r\n        if size \u003e len {\r\n            b.reserve(size - len);\r\n            b.resize(size, 0);\r\n        }\r\n    }\r\n\r\n    pub fn to_primary_key(\u0026self, b: \u0026mut Vec\u003cu8\u003e) -\u003e Result\u003c()\u003e {\r\n        match self {\r\n            DataValue::Int8(Some(v)) =\u003e encode_u!(b, *v as u8 ^ 0x80_u8),\r\n            DataValue::Int16(Some(v)) =\u003e encode_u!(b, *v as u16 ^ 0x8000_u16),\r\n            DataValue::Int32(Some(v)) =\u003e encode_u!(b, *v as u32 ^ 0x80000000_u32),\r\n            DataValue::Int64(Some(v)) =\u003e encode_u!(b, *v as u64 ^ 0x8000000000000000_u64),\r\n            DataValue::UInt8(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::UInt16(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::UInt32(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::UInt64(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::UUID(Some(v)) =\u003e Self::encode_bytes(b, v.as_bytes()),\r\n            DataValue::Utf8(Some(v)) =\u003e Self::encode_bytes(b, v.as_bytes()),\r\n            value =\u003e {\r\n                return if value.is_null() {\r\n                    Err(DatabaseError::PrimaryKeyNotFound)\r\n                } else {\r\n                    Err(DatabaseError::InvalidType)\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub fn to_index_key(\u0026self, b: \u0026mut Vec\u003cu8\u003e) -\u003e Result\u003c()\u003e {\r\n        match self {\r\n            DataValue::Int8(Some(v)) =\u003e encode_u!(b, *v as u8 ^ 0x80_u8),\r\n            DataValue::Int16(Some(v)) =\u003e encode_u!(b, *v as u16 ^ 0x8000_u16),\r\n            DataValue::Int32(Some(v)) | DataValue::Date32(Some(v)) =\u003e {\r\n                encode_u!(b, *v as u32 ^ 0x80000000_u32)\r\n            }\r\n            DataValue::Int64(Some(v)) | DataValue::Date64(Some(v)) =\u003e {\r\n                encode_u!(b, *v as u64 ^ 0x8000000000000000_u64)\r\n            }\r\n            DataValue::UInt8(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::UInt16(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::UInt32(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::UInt64(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::Utf8(Some(v)) =\u003e Self::encode_bytes(b, v.as_bytes()),\r\n            DataValue::Boolean(Some(v)) =\u003e b.push(if *v { b'1' } else { b'0' }),\r\n            DataValue::Float32(Some(f)) =\u003e {\r\n                let mut u = f.to_bits();\r\n\r\n                if *f \u003e= 0_f32 {\r\n                    u |= 0x80000000_u32;\r\n                } else {\r\n                    u = !u;\r\n                }\r\n\r\n                encode_u!(b, u);\r\n            }\r\n            DataValue::Float64(Some(f)) =\u003e {\r\n                let mut u = f.to_bits();\r\n\r\n                if *f \u003e= 0_f64 {\r\n                    u |= 0x8000000000000000_u64;\r\n                } else {\r\n                    u = !u;\r\n                }\r\n\r\n                encode_u!(b, u);\r\n            }\r\n            value =\u003e {\r\n                return if value.is_null() {\r\n                    todo!()\r\n                } else {\r\n                    Err(DatabaseError::InvalidType)\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n    #[allow(dead_code)]\r\n    fn decimal_round_i(option: \u0026Option\u003cu8\u003e, decimal: \u0026mut Decimal) {\r\n        if let Some(scale) = option {\r\n            let new_decimal = decimal.trunc_with_scale(*scale as u32);\r\n            let _ = mem::replace(decimal, new_decimal);\r\n        }\r\n    }\r\n\r\n    fn decimal_round_f(option: \u0026Option\u003cu8\u003e, decimal: \u0026mut Decimal) {\r\n        if let Some(scale) = option {\r\n            let new_decimal = decimal.round_dp_with_strategy(\r\n                *scale as u32,\r\n                rust_decimal::RoundingStrategy::MidpointAwayFromZero,\r\n            );\r\n            let _ = mem::replace(decimal, new_decimal);\r\n        }\r\n    }\r\n\r\n    pub fn cast(self, to: \u0026LogicalType) -\u003e Result\u003cDataValue\u003e {\r\n        match self {\r\n            DataValue::Null =\u003e match to {\r\n                LogicalType::Invalid =\u003e {\r\n                    Err(DatabaseError::CastFail(self.logical_type(), self, *to))\r\n                }\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Boolean =\u003e Ok(DataValue::Boolean(None)),\r\n                LogicalType::Tinyint =\u003e Ok(DataValue::Int8(None)),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(None)),\r\n                LogicalType::Smallint =\u003e Ok(DataValue::Int16(None)),\r\n                LogicalType::USmallint =\u003e Ok(DataValue::UInt16(None)),\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(None)),\r\n                LogicalType::UInteger =\u003e Ok(DataValue::UInt32(None)),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(None)),\r\n                LogicalType::UBigint =\u003e Ok(DataValue::UInt64(None)),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(None)),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(None)),\r\n                LogicalType::Varchar(_) =\u003e Ok(DataValue::Utf8(None)),\r\n                LogicalType::Date =\u003e Ok(DataValue::Date32(None)),\r\n                LogicalType::DateTime =\u003e Ok(DataValue::Date64(None)),\r\n                LogicalType::Decimal(_, _) =\u003e Ok(DataValue::Decimal(None)),\r\n                LogicalType::UUID =\u003e Ok(DataValue::UUID(None)),\r\n            },\r\n            DataValue::Boolean(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Boolean =\u003e Ok(DataValue::Boolean(value)),\r\n                LogicalType::Tinyint =\u003e Ok(DataValue::Int8(value.map(|v| v.into()))),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(value.map(|v| v.into()))),\r\n                LogicalType::Smallint =\u003e Ok(DataValue::Int16(value.map(|v| v.into()))),\r\n                LogicalType::USmallint =\u003e Ok(DataValue::UInt16(value.map(|v| v.into()))),\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(value.map(|v| v.into()))),\r\n                LogicalType::UInteger =\u003e Ok(DataValue::UInt32(value.map(|v| v.into()))),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value.map(|v| v.into()))),\r\n                LogicalType::UBigint =\u003e Ok(DataValue::UInt64(value.map(|v| v.into()))),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.map(|v| v.into()))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Float32(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value)),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                LogicalType::Decimal(_, option) =\u003e Ok(DataValue::Decimal(\r\n                    value\r\n                        .map(|v| {\r\n                            let mut decimal = Decimal::from_f32(v)\r\n                                .ok_or(DatabaseError::CastFail(self.logical_type(), self, *to))?;\r\n                            Self::decimal_round_f(option, \u0026mut decimal);\r\n\r\n                            Ok::\u003cDecimal, DatabaseError\u003e(decimal)\r\n                        })\r\n                        .transpose()?,\r\n                )),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Float64(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value)),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Int8(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Tinyint =\u003e Ok(DataValue::Int8(value)),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(value.map(u8::try_from).transpose()?)),\r\n                LogicalType::USmallint =\u003e {\r\n                    Ok(DataValue::UInt16(value.map(u16::try_from).transpose()?))\r\n                }\r\n                LogicalType::UInteger =\u003e {\r\n                    Ok(DataValue::UInt32(value.map(u32::try_from).transpose()?))\r\n                }\r\n                LogicalType::UBigint =\u003e {\r\n                    Ok(DataValue::UInt64(value.map(u64::try_from).transpose()?))\r\n                }\r\n                LogicalType::Smallint =\u003e Ok(DataValue::Int16(value.map(|v| v.into()))),\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(value.map(|v| v.into()))),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value.map(|v| v.into()))),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.map(|v| v.into()))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Int16(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(value.map(u8::try_from).transpose()?)),\r\n                LogicalType::USmallint =\u003e {\r\n                    Ok(DataValue::UInt16(value.map(u16::try_from).transpose()?))\r\n                }\r\n                LogicalType::UInteger =\u003e {\r\n                    Ok(DataValue::UInt32(value.map(u32::try_from).transpose()?))\r\n                }\r\n                LogicalType::UBigint =\u003e {\r\n                    Ok(DataValue::UInt64(value.map(u64::try_from).transpose()?))\r\n                }\r\n                LogicalType::Smallint =\u003e Ok(DataValue::Int16(value)),\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(value.map(|v| v.into()))),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value.map(|v| v.into()))),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.map(|v| v.into()))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Int32(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(value.map(u8::try_from).transpose()?)),\r\n                LogicalType::USmallint =\u003e {\r\n                    Ok(DataValue::UInt16(value.map(u16::try_from).transpose()?))\r\n                }\r\n                LogicalType::UInteger =\u003e {\r\n                    Ok(DataValue::UInt32(value.map(u32::try_from).transpose()?))\r\n                }\r\n                LogicalType::UBigint =\u003e {\r\n                    Ok(DataValue::UInt64(value.map(u64::try_from).transpose()?))\r\n                }\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(value)),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value.map(|v| v.into()))),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.map(|v| v as f32))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Int64(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(value.map(u8::try_from).transpose()?)),\r\n                LogicalType::USmallint =\u003e {\r\n                    Ok(DataValue::UInt16(value.map(u16::try_from).transpose()?))\r\n                }\r\n                LogicalType::UInteger =\u003e {\r\n                    Ok(DataValue::UInt32(value.map(u32::try_from).transpose()?))\r\n                }\r\n                LogicalType::UBigint =\u003e {\r\n                    Ok(DataValue::UInt64(value.map(u64::try_from).transpose()?))\r\n                }\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value)),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.map(|v| v as f32))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v as f64))),\r\n\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::UInt8(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(value)),\r\n                LogicalType::Smallint =\u003e Ok(DataValue::Int16(value.map(|v| v.into()))),\r\n                LogicalType::USmallint =\u003e Ok(DataValue::UInt16(value.map(|v| v.into()))),\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(value.map(|v| v.into()))),\r\n                LogicalType::UInteger =\u003e Ok(DataValue::UInt32(value.map(|v| v.into()))),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value.map(|v| v.into()))),\r\n                LogicalType::UBigint =\u003e Ok(DataValue::UInt64(value.map(|v| v.into()))),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.map(|v| v.into()))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::UInt16(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::USmallint =\u003e Ok(DataValue::UInt16(value)),\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(value.map(|v| v.into()))),\r\n                LogicalType::UInteger =\u003e Ok(DataValue::UInt32(value.map(|v| v.into()))),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value.map(|v| v.into()))),\r\n                LogicalType::UBigint =\u003e Ok(DataValue::UInt64(value.map(|v| v.into()))),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.map(|v| v.into()))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::UInt32(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::UInteger =\u003e Ok(DataValue::UInt32(value)),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value.map(|v| v.into()))),\r\n                LogicalType::UBigint =\u003e Ok(DataValue::UInt64(value.map(|v| v.into()))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::UInt64(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::UBigint =\u003e Ok(DataValue::UInt64(value)),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Utf8(value) =\u003e match to {\r\n                LogicalType::Decimal(_, _) =\u003e Ok(DataValue::Decimal(\r\n                    value.map(|v| Decimal::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::Invalid =\u003e Err(DatabaseError::CastFail(\r\n                    LogicalType::Invalid,\r\n                    DataValue::Utf8(value),\r\n                    *to,\r\n                )),\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Boolean =\u003e Ok(DataValue::Boolean(\r\n                    value.map(|v| bool::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::Tinyint =\u003e Ok(DataValue::Int8(\r\n                    value.map(|v| i8::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(\r\n                    value.map(|v| u8::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::Smallint =\u003e Ok(DataValue::Int16(\r\n                    value.map(|v| i16::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::USmallint =\u003e Ok(DataValue::UInt16(\r\n                    value.map(|v| u16::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(\r\n                    value.map(|v| i32::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::UInteger =\u003e Ok(DataValue::UInt32(\r\n                    value.map(|v| u32::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(\r\n                    value.map(|v| i64::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::UBigint =\u003e Ok(DataValue::UInt64(\r\n                    value.map(|v| u64::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(\r\n                    value.map(|v| f32::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(\r\n                    value.map(|v| f64::from_str(\u0026v)).transpose()?,\r\n                )),\r\n\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                LogicalType::Date =\u003e {\r\n                    let option = value\r\n                        .map(|v| {\r\n                            NaiveDate::parse_from_str(\u0026v, DATE_FMT)\r\n                                .map(|date| date.num_days_from_ce())\r\n                        })\r\n                        .transpose()?;\r\n\r\n                    Ok(DataValue::Date32(option))\r\n                }\r\n                LogicalType::DateTime =\u003e {\r\n                    let option = value\r\n                        .map(|v| {\r\n                            NaiveDateTime::parse_from_str(\u0026v, DATE_TIME_FMT)\r\n                                .or_else(|_| {\r\n                                    NaiveDate::parse_from_str(\u0026v, DATE_FMT)\r\n                                        .map(|date| date.and_hms_opt(0, 0, 0).unwrap())\r\n                                })\r\n                                .map(|date_time| date_time.timestamp())\r\n                        })\r\n                        .transpose()?;\r\n\r\n                    Ok(DataValue::Date64(option))\r\n                }\r\n                LogicalType::UUID =\u003e todo!(),\r\n            },\r\n            DataValue::Date32(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(Self::format_date(value), len),\r\n                LogicalType::Date =\u003e Ok(DataValue::Date32(value)),\r\n                LogicalType::DateTime =\u003e {\r\n                    let option = value.and_then(|v| {\r\n                        NaiveDate::from_num_days_from_ce_opt(v)\r\n                            .and_then(|date| date.and_hms_opt(0, 0, 0))\r\n                            .map(|date_time| date_time.timestamp())\r\n                    });\r\n\r\n                    Ok(DataValue::Date64(option))\r\n                }\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Date64(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(Self::format_datetime(value), len),\r\n                LogicalType::Date =\u003e {\r\n                    let option = value.and_then(|v| {\r\n                        NaiveDateTime::from_timestamp_opt(v, 0)\r\n                            .map(|date_time| date_time.date().num_days_from_ce())\r\n                    });\r\n\r\n                    Ok(DataValue::Date32(option))\r\n                }\r\n                LogicalType::DateTime =\u003e Ok(DataValue::Date64(value)),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Decimal(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.and_then(|v| v.to_f32()))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.and_then(|v| v.to_f64()))),\r\n                LogicalType::Decimal(_, _) =\u003e Ok(DataValue::Decimal(value)),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            //now not support uuid cast\r\n            DataValue::UUID(_) =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n        }\r\n    }\r\n\r\n    fn date_format\u003c'a\u003e(v: i32) -\u003e Option\u003cDelayedFormat\u003cStrftimeItems\u003c'a\u003e\u003e\u003e {\r\n        NaiveDate::from_num_days_from_ce_opt(v).map(|date| date.format(DATE_FMT))\r\n    }\r\n\r\n    fn date_time_format\u003c'a\u003e(v: i64) -\u003e Option\u003cDelayedFormat\u003cStrftimeItems\u003c'a\u003e\u003e\u003e {\r\n        NaiveDateTime::from_timestamp_opt(v, 0).map(|date_time| date_time.format(DATE_TIME_FMT))\r\n    }\r\n    fn decimal_format(v: \u0026Decimal) -\u003e String {\r\n        v.to_string()\r\n    }\r\n}\r\n\r\nmacro_rules! impl_scalar {\r\n    ($ty:ty, $scalar:tt) =\u003e {\r\n        impl From\u003c$ty\u003e for DataValue {\r\n            fn from(value: $ty) -\u003e Self {\r\n                DataValue::$scalar(Some(value))\r\n            }\r\n        }\r\n\r\n        impl From\u003cOption\u003c$ty\u003e\u003e for DataValue {\r\n            fn from(value: Option\u003c$ty\u003e) -\u003e Self {\r\n                DataValue::$scalar(value)\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nimpl_scalar!(f64, Float64);\r\nimpl_scalar!(f32, Float32);\r\nimpl_scalar!(i8, Int8);\r\nimpl_scalar!(i16, Int16);\r\nimpl_scalar!(i32, Int32);\r\nimpl_scalar!(i64, Int64);\r\nimpl_scalar!(bool, Boolean);\r\nimpl_scalar!(u8, UInt8);\r\nimpl_scalar!(u16, UInt16);\r\nimpl_scalar!(u32, UInt32);\r\nimpl_scalar!(u64, UInt64);\r\nimpl_scalar!(String, Utf8);\r\n\r\nimpl From\u003c\u0026sqlparser::ast::Value\u003e for DataValue {\r\n    fn from(v: \u0026sqlparser::ast::Value) -\u003e Self {\r\n        match v {\r\n            sqlparser::ast::Value::Number(n, _) =\u003e {\r\n                // use i32 to handle most cases\r\n                if let Ok(v) = n.parse::\u003ci32\u003e() {\r\n                    v.into()\r\n                } else if let Ok(v) = n.parse::\u003ci64\u003e() {\r\n                    v.into()\r\n                } else if let Ok(v) = n.parse::\u003cf32\u003e() {\r\n                    v.into()\r\n                } else if let Ok(v) = n.parse::\u003cf64\u003e() {\r\n                    v.into()\r\n                } else {\r\n                    panic!(\"unsupported number {:?}\", n)\r\n                }\r\n            }\r\n            sqlparser::ast::Value::SingleQuotedString(s) =\u003e s.clone().into(),\r\n            sqlparser::ast::Value::DoubleQuotedString(s) =\u003e s.clone().into(),\r\n            sqlparser::ast::Value::Boolean(b) =\u003e (*b).into(),\r\n            sqlparser::ast::Value::Null =\u003e Self::Null,\r\n            _ =\u003e todo!(\"unsupported parsed scalar value {:?}\", v),\r\n        }\r\n    }\r\n}\r\n\r\nmacro_rules! format_option {\r\n    ($F:expr, $EXPR:expr) =\u003e {{\r\n        match $EXPR {\r\n            Some(e) =\u003e write!($F, \"{}\", e),\r\n            None =\u003e write!($F, \"null\"),\r\n        }\r\n    }};\r\n}\r\n\r\nimpl fmt::Display for DataValue {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        match self {\r\n            DataValue::Boolean(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Float32(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Float64(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Int8(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Int16(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Int32(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Int64(e) =\u003e format_option!(f, e)?,\r\n            DataValue::UInt8(e) =\u003e format_option!(f, e)?,\r\n            DataValue::UInt16(e) =\u003e format_option!(f, e)?,\r\n            DataValue::UInt32(e) =\u003e format_option!(f, e)?,\r\n            DataValue::UInt64(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Utf8(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Null =\u003e write!(f, \"null\")?,\r\n            DataValue::Date32(e) =\u003e format_option!(f, e.and_then(DataValue::date_format))?,\r\n            DataValue::Date64(e) =\u003e format_option!(f, e.and_then(DataValue::date_time_format))?,\r\n            DataValue::Decimal(e) =\u003e format_option!(f, e.as_ref().map(DataValue::decimal_format))?,\r\n            DataValue::UUID(e) =\u003e format_option!(f, e)?,\r\n        };\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl fmt::Debug for DataValue {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        match self {\r\n            DataValue::Boolean(_) =\u003e write!(f, \"Boolean({})\", self),\r\n            DataValue::Float32(_) =\u003e write!(f, \"Float32({})\", self),\r\n            DataValue::Float64(_) =\u003e write!(f, \"Float64({})\", self),\r\n            DataValue::Int8(_) =\u003e write!(f, \"Int8({})\", self),\r\n            DataValue::Int16(_) =\u003e write!(f, \"Int16({})\", self),\r\n            DataValue::Int32(_) =\u003e write!(f, \"Int32({})\", self),\r\n            DataValue::Int64(_) =\u003e write!(f, \"Int64({})\", self),\r\n            DataValue::UInt8(_) =\u003e write!(f, \"UInt8({})\", self),\r\n            DataValue::UInt16(_) =\u003e write!(f, \"UInt16({})\", self),\r\n            DataValue::UInt32(_) =\u003e write!(f, \"UInt32({})\", self),\r\n            DataValue::UInt64(_) =\u003e write!(f, \"UInt64({})\", self),\r\n            DataValue::Utf8(None) =\u003e write!(f, \"Utf8({})\", self),\r\n            DataValue::Utf8(Some(_)) =\u003e write!(f, \"Utf8(\\\"{}\\\")\", self),\r\n            DataValue::Null =\u003e write!(f, \"null\"),\r\n            DataValue::Date32(_) =\u003e write!(f, \"Date32({})\", self),\r\n            DataValue::Date64(_) =\u003e write!(f, \"Date64({})\", self),\r\n            DataValue::Decimal(_) =\u003e write!(f, \"Decimal({})\", self),\r\n            DataValue::UUID(_) =\u003e write!(f, \"UUID({})\", self),\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n    use crate::types::value::DataValue;\r\n\r\n    #[test]\r\n    fn test_to_primary_key() -\u003e Result\u003c()\u003e {\r\n        let mut key_i8_1 = Vec::new();\r\n        let mut key_i8_2 = Vec::new();\r\n        let mut key_i8_3 = Vec::new();\r\n\r\n        DataValue::Int8(Some(i8::MIN)).to_primary_key(\u0026mut key_i8_1)?;\r\n        DataValue::Int8(Some(-1_i8)).to_primary_key(\u0026mut key_i8_2)?;\r\n        DataValue::Int8(Some(i8::MAX)).to_primary_key(\u0026mut key_i8_3)?;\r\n\r\n        println!(\"{:?} \u003c {:?}\", key_i8_1, key_i8_2);\r\n        println!(\"{:?} \u003c {:?}\", key_i8_2, key_i8_3);\r\n        assert!(key_i8_1 \u003c key_i8_2);\r\n        assert!(key_i8_2 \u003c key_i8_3);\r\n\r\n        let mut key_i16_1 = Vec::new();\r\n        let mut key_i16_2 = Vec::new();\r\n        let mut key_i16_3 = Vec::new();\r\n\r\n        DataValue::Int16(Some(i16::MIN)).to_primary_key(\u0026mut key_i16_1)?;\r\n        DataValue::Int16(Some(-1_i16)).to_primary_key(\u0026mut key_i16_2)?;\r\n        DataValue::Int16(Some(i16::MAX)).to_primary_key(\u0026mut key_i16_3)?;\r\n\r\n        println!(\"{:?} \u003c {:?}\", key_i16_1, key_i16_2);\r\n        println!(\"{:?} \u003c {:?}\", key_i16_2, key_i16_3);\r\n        assert!(key_i16_1 \u003c key_i16_2);\r\n        assert!(key_i16_2 \u003c key_i16_3);\r\n\r\n        let mut key_i32_1 = Vec::new();\r\n        let mut key_i32_2 = Vec::new();\r\n        let mut key_i32_3 = Vec::new();\r\n\r\n        DataValue::Int32(Some(i32::MIN)).to_primary_key(\u0026mut key_i32_1)?;\r\n        DataValue::Int32(Some(-1_i32)).to_primary_key(\u0026mut key_i32_2)?;\r\n        DataValue::Int32(Some(i32::MAX)).to_primary_key(\u0026mut key_i32_3)?;\r\n\r\n        println!(\"{:?} \u003c {:?}\", key_i32_1, key_i32_2);\r\n        println!(\"{:?} \u003c {:?}\", key_i32_2, key_i32_3);\r\n        assert!(key_i32_1 \u003c key_i32_2);\r\n        assert!(key_i32_2 \u003c key_i32_3);\r\n\r\n        let mut key_i64_1 = Vec::new();\r\n        let mut key_i64_2 = Vec::new();\r\n        let mut key_i64_3 = Vec::new();\r\n\r\n        DataValue::Int64(Some(i64::MIN)).to_primary_key(\u0026mut key_i64_1)?;\r\n        DataValue::Int64(Some(-1_i64)).to_primary_key(\u0026mut key_i64_2)?;\r\n        DataValue::Int64(Some(i64::MAX)).to_primary_key(\u0026mut key_i64_3)?;\r\n\r\n        println!(\"{:?} \u003c {:?}\", key_i64_1, key_i64_2);\r\n        println!(\"{:?} \u003c {:?}\", key_i64_2, key_i64_3);\r\n        assert!(key_i64_1 \u003c key_i64_2);\r\n        assert!(key_i64_2 \u003c key_i64_3);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_to_index_key_f() -\u003e Result\u003c()\u003e {\r\n        let mut key_f32_1 = Vec::new();\r\n        let mut key_f32_2 = Vec::new();\r\n        let mut key_f32_3 = Vec::new();\r\n\r\n        DataValue::Float32(Some(f32::MIN)).to_index_key(\u0026mut key_f32_1)?;\r\n        DataValue::Float32(Some(-1_f32)).to_index_key(\u0026mut key_f32_2)?;\r\n        DataValue::Float32(Some(f32::MAX)).to_index_key(\u0026mut key_f32_3)?;\r\n\r\n        println!(\"{:?} \u003c {:?}\", key_f32_1, key_f32_2);\r\n        println!(\"{:?} \u003c {:?}\", key_f32_2, key_f32_3);\r\n        assert!(key_f32_1 \u003c key_f32_2);\r\n        assert!(key_f32_2 \u003c key_f32_3);\r\n\r\n        let mut key_f64_1 = Vec::new();\r\n        let mut key_f64_2 = Vec::new();\r\n        let mut key_f64_3 = Vec::new();\r\n\r\n        DataValue::Float64(Some(f64::MIN)).to_index_key(\u0026mut key_f64_1)?;\r\n        DataValue::Float64(Some(-1_f64)).to_index_key(\u0026mut key_f64_2)?;\r\n        DataValue::Float64(Some(f64::MAX)).to_index_key(\u0026mut key_f64_3)?;\r\n\r\n        println!(\"{:?} \u003c {:?}\", key_f64_1, key_f64_2);\r\n        println!(\"{:?} \u003c {:?}\", key_f64_2, key_f64_3);\r\n        assert!(key_f64_1 \u003c key_f64_2);\r\n        assert!(key_f64_2 \u003c key_f64_3);\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":12970366926827028480},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":12970366926827028480},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":6052837899185946624},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6052837899185946624},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":6052837899185946624},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":4251398048237748224},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":10808639105689190400},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":10808639105689190400},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":4107282860161892352},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":4107282860161892352},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":10376293541461622784},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":10376293541461622784},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":7566047373982433283},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":13835058055282163712},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":7133701809754865664},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":7133701809754865664},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":18446744073709551611},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":2305843009213693955},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":4251398048237748224},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":4395513236313604098},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":10448351135499550720},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":14699749183737298944},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":14699749183737298944},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":2305843009213693953},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":662,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":4251398048237748224},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":4251398048237748224},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":14483576401623515136},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":14267403619509731328},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":746,"address":[],"length":0,"stats":{"Line":4395513236313604096},"fn_name":null},{"line":747,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":756,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":4395513236313604096},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":766,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":769,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":775,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":788,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":3891110078048108544},"fn_name":null},{"line":809,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":3602879701896396800},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":856,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":860,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":863,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":870,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":879,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":880,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":881,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":883,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":884,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":886,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":891,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":893,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":897,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":898,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":899,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":905,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":907,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":908,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":910,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":920,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":921,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":927,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":935,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":936,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":941,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":942,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":962,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":963,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":964,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":966,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":967,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":968,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":969,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":970,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":971,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":972,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":973,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":975,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":978,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":979,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":980,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":981,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":13546827679130451968},"fn_name":null},{"line":998,"address":[],"length":0,"stats":{"Line":13546827679130451968},"fn_name":null},{"line":999,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1000,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1001,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1003,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1004,"address":[],"length":0,"stats":{"Line":15852670688344145920},"fn_name":null},{"line":1005,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1006,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1007,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1008,"address":[],"length":0,"stats":{"Line":4323455642275676160},"fn_name":null},{"line":1009,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1010,"address":[],"length":0,"stats":{"Line":17005592192950992896},"fn_name":null},{"line":1011,"address":[],"length":0,"stats":{"Line":18446744073709551613},"fn_name":null},{"line":1012,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1013,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":1014,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1015,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1017,"address":[],"length":0,"stats":{"Line":13546827679130451966},"fn_name":null},{"line":1022,"address":[],"length":0,"stats":{"Line":3602879701896396800},"fn_name":null},{"line":1023,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":1024,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1025,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1026,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1027,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1028,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1029,"address":[],"length":0,"stats":{"Line":3386706919782612992},"fn_name":null},{"line":1030,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1032,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1033,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1034,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1035,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1036,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":1037,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":1038,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1039,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1040,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1041,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":221,"coverable":613},{"path":["E:","\\","sql-layer","tests","sqllogictest","src","lib.rs"],"content":"use std::time::Instant;\r\n\r\nuse piggysql::{\r\n    db::Database,\r\n    errors::DatabaseError,\r\n    storage::{piggy_stroage::PiggyKVStroage, Storage},\r\n};\r\nuse sqllogictest::{AsyncDB, DBOutput, DefaultColumnType};\r\n\r\npub struct Mock\u003cS: Storage\u003e {\r\n    pub db: Database\u003cS\u003e,\r\n}\r\n\r\n// impl Mock\u003cMVCCLayer\u003cMemory\u003e\u003e {\r\n//     pub fn new() -\u003e Self {\r\n//         Self {\r\n//             db: Database::new_memory().unwrap(),\r\n//         }\r\n//     }\r\n// }\r\nimpl Mock\u003cPiggyKVStroage\u003e {\r\n    pub fn new_lsm(path: std::path::PathBuf) -\u003e Self {\r\n        Self {\r\n            db: Database::new_lsm(path).unwrap(),\r\n        }\r\n    }\r\n}\r\n#[async_trait::async_trait]\r\nimpl AsyncDB for Mock\u003cPiggyKVStroage\u003e {\r\n    type Error = DatabaseError;\r\n\r\n    type ColumnType = DefaultColumnType;\r\n\r\n    async fn run(\r\n        \u0026mut self,\r\n        sql: \u0026str,\r\n    ) -\u003e Result\u003csqllogictest::DBOutput\u003cSelf::ColumnType\u003e, Self::Error\u003e {\r\n        let start = Instant::now();\r\n        let (schema, tuples) = self.db.run(sql).await?;\r\n        println!(\"| Input SQL:\");\r\n        println!(\" | {}\", sql);\r\n        println!(\" | Time consuming: {:?}\", start.elapsed());\r\n        if tuples.is_empty() {\r\n            return Ok(DBOutput::StatementComplete(0));\r\n        }\r\n        let types = vec![DefaultColumnType::Any; schema.len()];\r\n        let rows = tuples\r\n            .into_iter()\r\n            .map(|tuple| {\r\n                tuple\r\n                    .values\r\n                    .into_iter()\r\n                    .map(|value| format!(\"{}\", value))\r\n                    .collect()\r\n            })\r\n            .collect();\r\n        Ok(DBOutput::Rows { types, rows })\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","tests","sqllogictest","src","main.rs"],"content":"use std::path::Path;\r\n\r\nuse sqllogictest::Runner;\r\nuse sqllogictest_test::Mock;\r\nuse tempfile::{tempdir, TempDir};\r\n\r\n#[tokio::main]\r\nasync fn main() {\r\n    const SLT_PATTERN: \u0026str = \"tests/slt/**/*.slt\";\r\n    // const TEST: \u0026str = \"tests/slt/join.slt\";\r\n    let path = Path::new(env!(\"CARGO_MANIFEST_DIR\")).join(\"..\").join(\"..\");\r\n    std::env::set_current_dir(path).unwrap();\r\n\r\n    println!(\"PiggySQL Test Start!\\n\");\r\n\r\n    for slt_file in glob::glob(SLT_PATTERN).expect(\"failed to find slt files\") {\r\n        let temp_dir = TempDir::new().expect(\"unable to create temporary working directory\");\r\n        let filepath = slt_file\r\n            .expect(\"failed to read slt file\")\r\n            .to_str()\r\n            .unwrap()\r\n            .to_string();\r\n        println!(\"-\u003e Now the test file is: {}\", filepath);\r\n\r\n        let db = Mock::new_lsm(temp_dir.path().join(\"test\"));\r\n        let mut tester = Runner::new(db);\r\n\r\n        if let Err(err) = tester.run_file_async(filepath).await {\r\n            panic!(\"test error: {}\", err);\r\n        }\r\n        println!(\"-\u003e Pass!\\n\\n\")\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["E:","\\","sql-layer","benches","my_benchmark.rs"],"content":"use criterion::{criterion_group, criterion_main, Criterion};\r\nuse piggysql::{db::Database, errors::*, storage::piggy_stroage::PiggyKVStroage};\r\nconst QUERY_BENCH_SQLITE_PATH: \u0026'static str = \"./sqlite_bench\";\r\n\r\nasync fn data_source_lsm() -\u003e Result\u003cDatabase\u003cPiggyKVStroage\u003e\u003e {\r\n    let path = tempdir::TempDir::new(\"piggydb\").unwrap().path().join(\"lsm\");\r\n    let db = Database::new_lsm(path)?;\r\n    db.run(\r\n        \"CREATE TABLE benchtable(\r\n            id INT PRIMARY KEY,\r\n            val INT);\r\n            \",\r\n    )\r\n    .await?;\r\n    let mut batch = String::new();\r\n    for i in 0..500000 {\r\n        batch += format!(\"({},{})\", i, i).as_str();\r\n        batch += \",\"\r\n    }\r\n    batch += format!(\"({},{})\", 500001, 500001).as_str();\r\n\r\n    db.run(\u0026format!(\"INSERT INTO benchtable VALUES {}\", batch))\r\n        .await?;\r\n    Ok(db)\r\n}\r\nasync fn data_source_sqlite() -\u003e Result\u003c()\u003e {\r\n    let db = sqlite::open(QUERY_BENCH_SQLITE_PATH).unwrap();\r\n    db.execute(\r\n        \"DROP TABLE if EXISTS benchtable;\",\r\n    ).unwrap();\r\n    db.execute(\r\n        \"CREATE TABLE benchtable(\r\n            id INT PRIMARY KEY,\r\n            val INT);\r\n            \",\r\n    ).unwrap();\r\n    let mut batch = String::new();\r\n    for i in 0..500000 {\r\n        batch += format!(\"({},{})\", i, i).as_str();\r\n        batch += \",\"\r\n    }\r\n    batch += format!(\"({},{})\", 500001, 500001).as_str();\r\n\r\n    db.execute(\u0026format!(\"INSERT INTO benchtable VALUES {}\", batch)).unwrap();\r\n    Ok(())\r\n}\r\n\r\npub async fn lsm_benchmark_100000(engine: \u0026Database\u003cPiggyKVStroage\u003e) -\u003e Result\u003c()\u003e {\r\n    let _ = engine\r\n        .run(\"SELECT * FROM benchtable where id=490000\")\r\n        .await?;\r\n    Ok(())\r\n}\r\npub async fn lsm_without_primary_benchmark_100000(engine: \u0026Database\u003cPiggyKVStroage\u003e) -\u003e Result\u003c()\u003e {\r\n    let _ = engine\r\n        .run(\"SELECT * FROM benchtable where val=490000\")\r\n        .await?;\r\n    Ok(())\r\n}\r\n\r\nfn lsm_benchmark(c: \u0026mut Criterion) {\r\n    let rt = tokio::runtime::Builder::new_multi_thread()\r\n        .worker_threads(6)\r\n        .enable_all()\r\n        .build()\r\n        .unwrap();\r\n    let lsm = rt.block_on(async { data_source_lsm().await.unwrap() });\r\n    c.bench_function(\"lsm benchmark select rows with primary key\", |b| {\r\n        b.to_async(\u0026rt)\r\n            .iter(|| async { lsm_benchmark_100000(\u0026lsm).await.unwrap() })\r\n    });\r\n    c.bench_function(\"lsm benchmark select rows without primary key\", |b| {\r\n        b.to_async(\u0026rt)\r\n            .iter(|| async { lsm_without_primary_benchmark_100000(\u0026lsm).await.unwrap() })\r\n    });\r\n}\r\n\r\nfn data_insert(c: \u0026mut Criterion) {\r\n    let rt = tokio::runtime::Builder::new_multi_thread()\r\n        .worker_threads(6)\r\n        .enable_all()\r\n        .build()\r\n        .unwrap();\r\n    // let _=rt.block_on(data_source_sqlite()).unwrap();\r\n    c.bench_function(\"lsm insert benchmark select rows with primary key\", |b| {\r\n        b.to_async(\u0026rt)\r\n            .iter(|| async { data_source_lsm().await.unwrap() })\r\n    });\r\n    c.bench_function(\"sqlite insert benchmark select rows with primary key\", |b| {\r\n        b.to_async(\u0026rt)\r\n            .iter(|| async { data_source_sqlite().await.unwrap() })\r\n    });\r\n\r\n}\r\ncriterion_group!(\r\n    name = benches;\r\n    config = Criterion::default().sample_size(10);\r\n    targets = data_insert\r\n);\r\ncriterion_main!(benches);\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","client","src","lib.rs"],"content":"use anyhow::{bail, Context, Result};\r\nuse comfy_table::{Cell, Table};\r\nuse rand::Rng;\r\nuse tokio_postgres::{Client, NoTls,  SimpleQueryMessage};\r\n\r\npub struct SQLClient {\r\n    pub client: Client,\r\n}\r\n\r\nimpl SQLClient {\r\n    pub async fn connect() -\u003e Result\u003cSelf\u003e {\r\n        let (client, connection) =\r\n            tokio_postgres::connect(\"host=localhost user=postgres\", NoTls).await?;\r\n        tokio::spawn(async move {\r\n            if let Err(e) = connection.await {\r\n                eprintln!(\"connection error: {}\", e);\r\n            }\r\n        });\r\n        Ok(Self { client })\r\n    }\r\n    pub async fn query(\u0026self, sql: \u0026str) -\u003e Result\u003cVec\u003cSimpleQueryMessage\u003e\u003e {\r\n        for i in 0..16 {\r\n            if i \u003e 0 {\r\n                tokio::time::sleep(std::time::Duration::from_millis(\r\n                    2_u64.pow(i as u32 - 1) * rand::thread_rng().gen_range(25..=75),\r\n                ))\r\n                .await;\r\n            }\r\n            let result = self\r\n                .client\r\n                .simple_query(sql)\r\n                .await\r\n                .context(\"sql query error\");\r\n            return result;\r\n        }\r\n        bail!(\"Serialization verfication failed\")\r\n    }\r\n}\r\n\r\npub fn create_table(rows: Vec\u003cSimpleQueryMessage\u003e) -\u003e Table {\r\n    let mut table = Table::new();\r\n\r\n    if rows.is_empty() {\r\n        return table;\r\n    }\r\n\r\n    let mut show_schema = false;\r\n    for row in rows {\r\n        if let SimpleQueryMessage::Row(row) = row {\r\n            if !show_schema {\r\n                let mut header = Vec::new();\r\n                show_schema = true;\r\n                for col in row.columns() {\r\n                    header.push(Cell::new(col.name().to_string()));\r\n                }\r\n                table.set_header(header);\r\n            }\r\n\r\n            let mut cols = vec![];\r\n            for idx in 0..row.len() {\r\n                let val = row.get(idx);\r\n                cols.push(val);\r\n            }\r\n            let cells = cols\r\n                .iter()\r\n                .map(|value| match value {\r\n                    Some(value) =\u003e Cell::new(format!(\"{value}\")),\r\n                    None =\u003e Cell::new(format!(\"null\")),\r\n                })\r\n                .collect::\u003cVec\u003c_\u003e\u003e();\r\n            table.add_row(cells);\r\n        }\r\n    }\r\n\r\n    table\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","client","src","main.rs"],"content":"use anyhow::Result;\r\nuse client::{create_table, SQLClient};\r\nuse rustyline::error::ReadlineError;\r\nuse rustyline::DefaultEditor;\r\n\r\n#[tokio::main]\r\nasync fn main() -\u003e Result\u003c()\u003e {\r\n    // `()` can be used when no completer is required\r\n    let mut rl = DefaultEditor::new()?;\r\n    if rl.load_history(\"history.txt\").is_err() {\r\n        println!(\"No previous history.\");\r\n    }\r\n    let client = SQLClient::connect().await?;\r\n    loop {\r\n        let readline = rl.readline(\"SQL\u003e \");\r\n        match readline {\r\n            Ok(line) =\u003e {\r\n                rl.add_history_entry(line.as_str())?;\r\n                match client.query(line.as_str()).await {\r\n                    Ok(result) =\u003e println!(\"{}\", create_table(result)),\r\n                    Err(e) =\u003e {\r\n                        println!(\"Error: {:?}\", e);\r\n                    }\r\n                }\r\n                // let result = client.query(line.as_str()).await?;\r\n                // println!(\"{}\", create_table(result));\r\n            }\r\n            Err(ReadlineError::Interrupted) =\u003e {\r\n                println!(\"CTRL-C\");\r\n                break;\r\n            }\r\n            Err(ReadlineError::Eof) =\u003e {\r\n                println!(\"CTRL-D\");\r\n                break;\r\n            }\r\n            Err(err) =\u003e {\r\n                println!(\"Error: {:?}\", err);\r\n            }\r\n        }\r\n    }\r\n    rl.save_history(\"history.txt\")?;\r\n    Ok(())\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","binder","aggregate.rs"],"content":"use ahash::RandomState;\r\nuse itertools::Itertools;\r\nuse sqlparser::ast::{Expr, OrderByExpr};\r\nuse std::collections::HashSet;\r\n\r\nuse crate::errors::*;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::{\r\n    expression::ScalarExpression,\r\n    planner::operator::{aggregate::AggregateOperator, sort::SortField},\r\n};\r\n\r\nuse super::Binder;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub fn bind_aggregate(\r\n        \u0026mut self,\r\n        children: LogicalPlan,\r\n        agg_calls: Vec\u003cScalarExpression\u003e,\r\n        groupby_exprs: Vec\u003cScalarExpression\u003e,\r\n    ) -\u003e LogicalPlan {\r\n        AggregateOperator::build(children, agg_calls, groupby_exprs, false)\r\n    }\r\n\r\n    pub fn extract_select_aggregate(\r\n        \u0026mut self,\r\n        select_items: \u0026mut [ScalarExpression],\r\n    ) -\u003e Result\u003c()\u003e {\r\n        for column in select_items {\r\n            self.visit_column_agg_expr(column)?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub fn extract_group_by_aggregate(\r\n        \u0026mut self,\r\n        select_list: \u0026mut [ScalarExpression],\r\n        groupby: \u0026[Expr],\r\n    ) -\u003e Result\u003c()\u003e {\r\n        self.validate_groupby_illegal_column(select_list, groupby)?;\r\n\r\n        for gb in groupby {\r\n            let mut expr = self.bind_expr(gb)?;\r\n            self.visit_group_by_expr(select_list, \u0026mut expr);\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub fn extract_having_orderby_aggregate(\r\n        \u0026mut self,\r\n        having: \u0026Option\u003cExpr\u003e,\r\n        orderbys: \u0026[OrderByExpr],\r\n    ) -\u003e Result\u003c(Option\u003cScalarExpression\u003e, Option\u003cVec\u003cSortField\u003e\u003e)\u003e {\r\n        // Extract having expression.\r\n        let return_having = if let Some(having) = having {\r\n            let mut having = self.bind_expr(having)?;\r\n            self.visit_column_agg_expr(\u0026mut having)?;\r\n\r\n            Some(having)\r\n        } else {\r\n            None\r\n        };\r\n\r\n        // Extract orderby expression.\r\n        let return_orderby = if !orderbys.is_empty() {\r\n            let mut return_orderby = vec![];\r\n            for orderby in orderbys {\r\n                let OrderByExpr {\r\n                    expr,\r\n                    asc,\r\n                    nulls_first,\r\n                } = orderby;\r\n                let mut expr = self.bind_expr(expr)?;\r\n                self.visit_column_agg_expr(\u0026mut expr)?;\r\n\r\n                return_orderby.push(SortField::new(\r\n                    expr,\r\n                    asc.map_or(true, |asc| asc),\r\n                    nulls_first.map_or(false, |first| first),\r\n                ));\r\n            }\r\n            Some(return_orderby)\r\n        } else {\r\n            None\r\n        };\r\n        Ok((return_having, return_orderby))\r\n    }\r\n\r\n    fn visit_column_agg_expr(\u0026mut self, expr: \u0026mut ScalarExpression) -\u003e Result\u003c()\u003e {\r\n        match expr {\r\n            ScalarExpression::AggCall { .. } =\u003e {\r\n                self.context.agg_calls.push(expr.clone());\r\n            }\r\n            ScalarExpression::TypeCast { expr, .. } =\u003e self.visit_column_agg_expr(expr)?,\r\n            ScalarExpression::IsNull { expr, .. } =\u003e self.visit_column_agg_expr(expr)?,\r\n            ScalarExpression::Unary { expr, .. } =\u003e self.visit_column_agg_expr(expr)?,\r\n            ScalarExpression::Alias { expr, .. } =\u003e self.visit_column_agg_expr(expr)?,\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                ..\r\n            } =\u003e {\r\n                self.visit_column_agg_expr(left_expr)?;\r\n                self.visit_column_agg_expr(right_expr)?;\r\n            }\r\n            ScalarExpression::In { expr, args, .. } =\u003e {\r\n                self.visit_column_agg_expr(expr)?;\r\n                for arg in args {\r\n                    self.visit_column_agg_expr(arg)?;\r\n                }\r\n            }\r\n            ScalarExpression::Constant(_) | ScalarExpression::ColumnRef { .. } =\u003e {}\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// Validate select exprs must appear in the GROUP BY clause or be used in\r\n    /// an aggregate function.\r\n    /// e.g. SELECT a,count(b) FROM t GROUP BY a. it's ok.\r\n    ///      SELECT a,b FROM t GROUP BY a.        it's error.\r\n    ///      SELECT a,count(b) FROM t GROUP BY b. it's error.\r\n    fn validate_groupby_illegal_column(\r\n        \u0026mut self,\r\n        select_items: \u0026[ScalarExpression],\r\n        groupby: \u0026[Expr],\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let mut group_raw_exprs = vec![];\r\n        for expr in groupby {\r\n            let expr = self.bind_expr(expr)?;\r\n\r\n            if let ScalarExpression::Alias { alias, .. } = expr {\r\n                let alias_expr = select_items.iter().find(|column| {\r\n                    if let ScalarExpression::Alias {\r\n                        alias: inner_alias, ..\r\n                    } = \u0026column\r\n                    {\r\n                        alias == *inner_alias\r\n                    } else {\r\n                        false\r\n                    }\r\n                });\r\n\r\n                if let Some(inner_expr) = alias_expr {\r\n                    group_raw_exprs.push(inner_expr.clone());\r\n                }\r\n            } else {\r\n                group_raw_exprs.push(expr);\r\n            }\r\n        }\r\n        let mut group_raw_set: HashSet\u003c\u0026ScalarExpression, RandomState\u003e =\r\n            HashSet::from_iter(group_raw_exprs.iter());\r\n\r\n        for expr in select_items {\r\n            if expr.has_agg_call() {\r\n                continue;\r\n            }\r\n            group_raw_set.remove(expr);\r\n\r\n            if !group_raw_exprs.iter().contains(expr) {\r\n                return Err(DatabaseError::AggMiss(format!(\r\n                    \"{:?} must appear in the GROUP BY clause or be used in an aggregate function\",\r\n                    expr\r\n                )));\r\n            }\r\n        }\r\n\r\n        if !group_raw_set.is_empty() {\r\n            return Err(DatabaseError::AggMiss(\r\n                \"In the GROUP BY clause the field must be in the select clause\".to_string(),\r\n            ));\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn visit_group_by_expr(\r\n        \u0026mut self,\r\n        select_list: \u0026mut [ScalarExpression],\r\n        expr: \u0026mut ScalarExpression,\r\n    ) {\r\n        if let ScalarExpression::Alias { alias, .. } = expr {\r\n            if let Some(i) = select_list.iter().position(|inner_expr| {\r\n                if let ScalarExpression::Alias {\r\n                    alias: inner_alias, ..\r\n                } = \u0026inner_expr\r\n                {\r\n                    alias == inner_alias\r\n                } else {\r\n                    false\r\n                }\r\n            }) {\r\n                self.context.group_by_exprs.push(select_list[i].clone());\r\n                return;\r\n            }\r\n        }\r\n\r\n        if let Some(i) = select_list.iter().position(|column| column == expr) {\r\n            self.context.group_by_exprs.push(select_list[i].clone())\r\n        }\r\n    }\r\n\r\n    /// Validate having or orderby clause is valid, if SQL has group by clause.\r\n    pub fn validate_having_orderby(\u0026self, expr: \u0026ScalarExpression) -\u003e Result\u003c()\u003e {\r\n        if self.context.group_by_exprs.is_empty() {\r\n            return Ok(());\r\n        }\r\n\r\n        match expr {\r\n            ScalarExpression::AggCall { .. } =\u003e {\r\n                if self.context.group_by_exprs.contains(expr)\r\n                    || self.context.agg_calls.contains(expr)\r\n                {\r\n                    return Ok(());\r\n                }\r\n\r\n                Err(DatabaseError::AggMiss(\r\n                    format!(\r\n                        \"column {:?} must appear in the GROUP BY clause or be used in an aggregate function\",\r\n                        expr\r\n                    )\r\n                ))\r\n            }\r\n            ScalarExpression::ColumnRef { .. } | ScalarExpression::Alias { .. } =\u003e {\r\n                if self.context.group_by_exprs.contains(expr) {\r\n                    return Ok(());\r\n                }\r\n                if matches!(expr, ScalarExpression::Alias { .. }) {\r\n                    return self.validate_having_orderby(expr.unpack_alias());\r\n                }\r\n\r\n                Err(DatabaseError::AggMiss(\r\n                    format!(\r\n                        \"column {:?} must appear in the GROUP BY clause or be used in an aggregate function\",\r\n                        expr\r\n                    )\r\n                ))\r\n            }\r\n\r\n            ScalarExpression::TypeCast { expr, .. } =\u003e self.validate_having_orderby(expr),\r\n            ScalarExpression::IsNull { expr, .. } =\u003e self.validate_having_orderby(expr),\r\n            ScalarExpression::Unary { expr, .. } =\u003e self.validate_having_orderby(expr),\r\n            ScalarExpression::In { expr, args, .. } =\u003e {\r\n                self.validate_having_orderby(expr)?;\r\n                for arg in args {\r\n                    self.validate_having_orderby(arg)?;\r\n                }\r\n                Ok(())\r\n            }\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                ..\r\n            } =\u003e {\r\n                self.validate_having_orderby(left_expr)?;\r\n                self.validate_having_orderby(right_expr)?;\r\n                Ok(())\r\n            }\r\n\r\n            ScalarExpression::Constant(_) =\u003e Ok(()),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":15204152342002794496},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":15636497906230362112},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":15636497906230362112},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":14195346025471803392},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":15636497906230362112},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null}],"covered":69,"coverable":134},{"path":["E:","\\","sql-layer","src","binder","alter_table.rs"],"content":"use crate::errors::*;\r\nuse sqlparser::ast::{AlterTableOperation, ObjectName};\r\n\r\nuse std::sync::Arc;\r\n\r\nuse super::{is_valid_identifier, Binder};\r\nuse crate::binder::{lower_case_name, split_name};\r\nuse crate::planner::operator::alter_table::AddColumnOperator;\r\nuse crate::planner::operator::alter_table::DropColumnOperator;\r\nuse crate::planner::operator::scan::ScanOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_alter_table(\r\n        \u0026mut self,\r\n        name: \u0026ObjectName,\r\n        operation: \u0026AlterTableOperation,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let name = lower_case_name(name);\r\n        let table_name: Arc\u003cString\u003e = Arc::new(split_name(\u0026name)?.1.to_string());\r\n\r\n        if let Some(table) = self.context.table(table_name.clone()) {\r\n            let plan = match operation {\r\n                AlterTableOperation::AddColumn {\r\n                    column_keyword: _,\r\n                    if_not_exists,\r\n                    column_def,\r\n                } =\u003e {\r\n                    let plan = ScanOperator::build(table_name.clone(), \u0026table);\r\n                    let column = self.bind_column(column_def)?;\r\n                    if !is_valid_identifier(column.name()) {\r\n                        return Err(DatabaseError::InvalidColumn(\r\n                            \"illegal column naming\".to_string(),\r\n                        ));\r\n                    }\r\n                    LogicalPlan::new(\r\n                        Operator::AddColumn(AddColumnOperator {\r\n                            table_name,\r\n                            if_not_exists: *if_not_exists,\r\n                            column: self.bind_column(column_def)?,\r\n                        }),\r\n                        vec![plan],\r\n                    )\r\n                }\r\n                AlterTableOperation::DropColumn {\r\n                    column_name,\r\n                    if_exists,\r\n                    ..\r\n                } =\u003e {\r\n                    let plan = ScanOperator::build(table_name.clone(), \u0026table);\r\n                    let column_name = column_name.value.clone();\r\n                    LogicalPlan::new(\r\n                        Operator::DropColumn(DropColumnOperator {\r\n                            table_name,\r\n                            if_exists: *if_exists,\r\n                            column_name,\r\n                        }),\r\n                        vec![plan],\r\n                    )\r\n                }\r\n                AlterTableOperation::DropPrimaryKey =\u003e todo!(),\r\n                AlterTableOperation::RenameColumn {\r\n                    old_column_name: _,\r\n                    new_column_name: _,\r\n                } =\u003e todo!(),\r\n                AlterTableOperation::RenameTable { table_name: _ } =\u003e todo!(),\r\n                AlterTableOperation::ChangeColumn {\r\n                    old_name: _,\r\n                    new_name: _,\r\n                    data_type: _,\r\n                    options: _,\r\n                } =\u003e todo!(),\r\n                AlterTableOperation::AlterColumn {\r\n                    column_name: _,\r\n                    op: _,\r\n                } =\u003e todo!(),\r\n                _ =\u003e todo!(),\r\n            };\r\n\r\n            Ok(plan)\r\n        } else {\r\n            Err(DatabaseError::InvalidTable(format!(\r\n                \"not found table {}\",\r\n                table_name\r\n            )))\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":47},{"path":["E:","\\","sql-layer","src","binder","copy.rs"],"content":"use crate::planner::operator::copy_from_file::CopyFromFileOperator;\r\nuse crate::planner::operator::Operator;\r\nuse serde::{Deserialize, Serialize};\r\nuse sqlparser::ast::{CopyOption, CopySource, CopyTarget};\r\nuse std::{path::PathBuf, sync::Arc};\r\n\r\nuse super::*;\r\n\r\n#[derive(Debug, PartialEq, PartialOrd, Ord, Hash, Eq, Clone, Serialize, Deserialize)]\r\npub struct ExtSource {\r\n    pub path: PathBuf,\r\n    pub format: FileFormat,\r\n}\r\n\r\n/// File format.\r\n#[derive(Debug, PartialEq, PartialOrd, Ord, Hash, Eq, Clone, Serialize, Deserialize)]\r\npub enum FileFormat {\r\n    Csv {\r\n        /// Delimiter to parse.\r\n        delimiter: char,\r\n        /// Quote to use.\r\n        quote: char,\r\n        /// Escape character to use.\r\n        escape: Option\u003cchar\u003e,\r\n        /// Whether or not the file has a header line.\r\n        header: bool,\r\n    },\r\n}\r\n\r\nimpl std::fmt::Display for ExtSource {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        write!(f, \"{self:?}\")\r\n    }\r\n}\r\n\r\nimpl std::fmt::Display for FileFormat {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        write!(f, \"{self:?}\")\r\n    }\r\n}\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(super) fn bind_copy(\r\n        \u0026mut self,\r\n        source: CopySource,\r\n        target: CopyTarget,\r\n        options: \u0026[CopyOption],\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let (table_name, ..) = match source {\r\n            CopySource::Table {\r\n                table_name,\r\n                columns,\r\n            } =\u003e (table_name, columns),\r\n            CopySource::Query(_) =\u003e {\r\n                return Err(DatabaseError::UnsupportedCopySource(\r\n                    \"bad copy source\".to_string(),\r\n                ));\r\n            }\r\n        };\r\n\r\n        if let Some(table) = self\r\n            .context\r\n            .table(Arc::new(table_name.to_string().to_lowercase()))\r\n        {\r\n            let schema_ref = table.all_columns();\r\n            let ext_source = ExtSource {\r\n                path: match target {\r\n                    CopyTarget::File { filename } =\u003e filename.into(),\r\n                    t =\u003e todo!(\"unsupported copy target: {:?}\", t),\r\n                },\r\n                format: FileFormat::from_options(options),\r\n            };\r\n            // COPY \u003cdest_table\u003e FROM \u003csource_file\u003e\r\n\r\n            Ok(LogicalPlan::new(\r\n                Operator::CopyFromFile(CopyFromFileOperator {\r\n                    source: ext_source,\r\n                    schema_ref,\r\n                    table: table_name.to_string().to_lowercase(),\r\n                }),\r\n                vec![],\r\n            ))\r\n        } else {\r\n            Err(DatabaseError::InvalidTable(format!(\r\n                \"not found table {}\",\r\n                table_name\r\n            )))\r\n        }\r\n    }\r\n}\r\n\r\nimpl FileFormat {\r\n    /// Create from copy options.\r\n    pub fn from_options(options: \u0026[CopyOption]) -\u003e Self {\r\n        let mut delimiter = ',';\r\n        let mut quote = '\"';\r\n        let mut escape = None;\r\n        let mut header = false;\r\n        for opt in options {\r\n            match opt {\r\n                CopyOption::Format(fmt) =\u003e {\r\n                    assert_eq!(fmt.value.to_lowercase(), \"csv\", \"only support CSV format\")\r\n                }\r\n                CopyOption::Delimiter(c) =\u003e delimiter = *c,\r\n                CopyOption::Header(b) =\u003e header = *b,\r\n                CopyOption::Quote(c) =\u003e quote = *c,\r\n                CopyOption::Escape(c) =\u003e escape = Some(*c),\r\n                o =\u003e panic!(\"unsupported copy option: {:?}\", o),\r\n            }\r\n        }\r\n        FileFormat::Csv {\r\n            delimiter,\r\n            quote,\r\n            escape,\r\n            header,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1684},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":1684},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1684},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1684},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1684},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":3368},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1684},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":3368},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":41},{"path":["E:","\\","sql-layer","src","binder","create_index.rs"],"content":"use crate::errors::*;\r\nuse std::sync::Arc;\r\n\r\nuse itertools::Itertools;\r\nuse sqlparser::ast::{ObjectName, OrderByExpr};\r\n\r\nuse crate::{\r\n    binder::lower_case_name,\r\n    planner::{\r\n        operator::{create_index::CreateIndexOperator, Operator},\r\n        LogicalPlan,\r\n    },\r\n    storage::Transaction,\r\n};\r\n\r\nuse super::Binder;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_create_index(\r\n        \u0026mut self,\r\n        index_name: \u0026ObjectName,\r\n        table_name: \u0026ObjectName,\r\n        columns: \u0026[OrderByExpr],\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let table_name = lower_case_name(table_name);\r\n        let index_name = lower_case_name(index_name);\r\n        let table_name = Arc::new(table_name.to_string());\r\n        let index_name = Arc::new(index_name.to_string());\r\n\r\n        let col_ident = columns\r\n            .iter()\r\n            .filter_map(|col| match \u0026col.expr {\r\n                sqlparser::ast::Expr::Identifier(ident) =\u003e Some(ident.to_string()),\r\n                _ =\u003e unreachable!(),\r\n            })\r\n            .collect_vec();\r\n        //now only support unique index\r\n        assert_eq!(col_ident.len(), 1);\r\n        let col_name = col_ident[0].clone();\r\n        Ok(LogicalPlan::new(\r\n            Operator::CreateIndex(CreateIndexOperator {\r\n                table_name,\r\n                index_name,\r\n                col_name,\r\n            }),\r\n            vec![],\r\n        ))\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":17},{"path":["E:","\\","sql-layer","src","binder","create_table.rs"],"content":"use crate::errors::*;\r\nuse itertools::Itertools;\r\nuse sqlparser::ast::{ColumnDef, ColumnOption, ObjectName, TableConstraint};\r\nuse std::collections::HashSet;\r\nuse std::sync::Arc;\r\n\r\nuse super::{is_valid_identifier, Binder};\r\nuse crate::binder::{lower_case_name, split_name};\r\nuse crate::catalog::{ColumnCatalog, ColumnDesc};\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::create_table::CreateTableOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::value::DataValue;\r\nuse crate::types::LogicalType;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    // TODO: TableConstraint\r\n    pub(crate) fn bind_create_table(\r\n        \u0026mut self,\r\n        name: \u0026ObjectName,\r\n        columns: \u0026[ColumnDef],\r\n        constraints: \u0026[TableConstraint],\r\n        if_not_exists: bool,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let name = lower_case_name(name);\r\n        let (_, name) = split_name(\u0026name)?;\r\n        let table_name = Arc::new(name.to_string());\r\n\r\n        if !is_valid_identifier(\u0026table_name) {\r\n            return Err(DatabaseError::InvalidTable(\r\n                \"illegal table naming\".to_string(),\r\n            ));\r\n        }\r\n\r\n        {\r\n            // check duplicated column names\r\n            let mut set = HashSet::new();\r\n            for col in columns.iter() {\r\n                let col_name = \u0026col.name.value;\r\n                if !set.insert(col_name.clone()) {\r\n                    return Err(DatabaseError::AmbiguousColumn(col_name.to_lowercase()));\r\n                }\r\n                if !is_valid_identifier(col_name) {\r\n                    return Err(DatabaseError::InvalidColumn(\r\n                        \"illegal column naming\".to_string(),\r\n                    ));\r\n                }\r\n            }\r\n        }\r\n        let mut columns: Vec\u003cColumnCatalog\u003e = columns\r\n            .iter()\r\n            .map(|col| self.bind_column(col))\r\n            .try_collect()?;\r\n        for constraint in constraints {\r\n            match constraint {\r\n                TableConstraint::Unique {\r\n                    columns: column_names,\r\n                    is_primary,\r\n                    ..\r\n                } =\u003e {\r\n                    for column_name in column_names {\r\n                        if let Some(column) = columns\r\n                            .iter_mut()\r\n                            .find(|column| column.name() == column_name.to_string())\r\n                        {\r\n                            if *is_primary {\r\n                                column.desc.is_primary = true;\r\n                            } else {\r\n                                column.desc.is_unique = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                _ =\u003e todo!(),\r\n            }\r\n        }\r\n        //experiment\r\n        //allow table no primary key\r\n        // if columns.iter().filter(|col| col.desc.is_primary).count() != 1 {\r\n        //     return Err(DatabaseError::InvalidTable(\r\n        //         \"The primary key field must exist and have at least one\".to_string(),\r\n        //     ));\r\n        // }\r\n\r\n        Ok(LogicalPlan::new(\r\n            Operator::CreateTable(CreateTableOperator {\r\n                table_name,\r\n                columns,\r\n                if_not_exists,\r\n            }),\r\n            vec![],\r\n        ))\r\n    }\r\n\r\n    pub fn bind_column(\u0026mut self, column_def: \u0026ColumnDef) -\u003e Result\u003cColumnCatalog\u003e {\r\n        let column_name = column_def.name.to_string();\r\n        let mut column_desc = ColumnDesc::new(\r\n            LogicalType::try_from(column_def.data_type.clone())?,\r\n            false,\r\n            false,\r\n            None,\r\n        );\r\n        let mut nullable = true;\r\n\r\n        // TODO: \r\n        for option_def in \u0026column_def.options {\r\n            match \u0026option_def.option {\r\n                ColumnOption::Null =\u003e nullable = true,\r\n                ColumnOption::NotNull =\u003e nullable = false,\r\n                ColumnOption::Unique { is_primary } =\u003e {\r\n                    if *is_primary {\r\n                        column_desc.is_primary = true;\r\n                        nullable = false;\r\n                        // Skip other options when using primary key\r\n                        break;\r\n                    } else {\r\n                        column_desc.is_unique = true;\r\n                    }\r\n                }\r\n                ColumnOption::Default(expr) =\u003e {\r\n                    if let ScalarExpression::Constant(value) = self.bind_expr(expr)? {\r\n                        let cast_value =\r\n                            DataValue::clone(\u0026value).cast(\u0026column_desc.column_datatype)?;\r\n                        column_desc.default = Some(Arc::new(cast_value));\r\n                    } else {\r\n                        unreachable!(\"'default' only for constant\")\r\n                    }\r\n                }\r\n                _ =\u003e todo!(),\r\n            }\r\n        }\r\n\r\n        Ok(ColumnCatalog::new(column_name, nullable, column_desc))\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1369094286720630785},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1801439850948198400},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null}],"covered":29,"coverable":57},{"path":["E:","\\","sql-layer","src","binder","delete.rs"],"content":"use crate::binder::{lower_case_name, split_name, Binder};\r\nuse crate::errors::*;\r\nuse crate::planner::operator::delete::DeleteOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse sqlparser::ast::{Expr, TableFactor, TableWithJoins};\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_delete(\r\n        \u0026mut self,\r\n        from: \u0026TableWithJoins,\r\n        selection: \u0026Option\u003cExpr\u003e,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        if let TableFactor::Table { name, alias, .. } = \u0026from.relation {\r\n            let name = lower_case_name(name);\r\n            let (_, name) = split_name(\u0026name)?;\r\n            let (table_name, mut plan) =\r\n                self._bind_single_table_ref(None, name, Self::trans_alias(alias))?;\r\n\r\n            if let Some(predicate) = selection {\r\n                plan = self.bind_where(plan, predicate)?;\r\n            }\r\n\r\n            Ok(LogicalPlan::new(\r\n                Operator::Delete(DeleteOperator { table_name }),\r\n                vec![plan],\r\n            ))\r\n        } else {\r\n            unreachable!(\"only table\")\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":9,"coverable":11},{"path":["E:","\\","sql-layer","src","binder","describe.rs"],"content":"use crate::binder::Binder;\r\nuse crate::errors::DatabaseError;\r\nuse crate::planner::operator::describe::DescribeOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse sqlparser::ast::ObjectName;\r\nuse std::sync::Arc;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_describe(\r\n        \u0026mut self,\r\n        name: \u0026ObjectName,\r\n    ) -\u003e Result\u003cLogicalPlan, DatabaseError\u003e {\r\n        let table_name = Arc::new(name.to_string());\r\n\r\n        Ok(LogicalPlan::new(\r\n            Operator::Describe(DescribeOperator { table_name }),\r\n            vec![],\r\n        ))\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["E:","\\","sql-layer","src","binder","distinct.rs"],"content":"use crate::binder::Binder;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::aggregate::AggregateOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub fn bind_distinct(\r\n        \u0026mut self,\r\n        children: LogicalPlan,\r\n        select_list: Vec\u003cScalarExpression\u003e,\r\n    ) -\u003e LogicalPlan {\r\n        AggregateOperator::build(children, vec![], select_list, true)\r\n    }\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":2,"coverable":2},{"path":["E:","\\","sql-layer","src","binder","drop_index.rs"],"content":"use std::sync::Arc;\r\n\r\nuse sqlparser::ast::ObjectName;\r\n\r\nuse crate::errors::*;\r\nuse crate::{\r\n    planner::{\r\n        operator::{drop_index::DropIndexOperator, Operator},\r\n        LogicalPlan,\r\n    },\r\n    storage::Transaction,\r\n};\r\n\r\nuse super::Binder;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_drop_index(\r\n        \u0026mut self,\r\n        names: \u0026ObjectName,\r\n        if_exists: \u0026bool,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let object_name = \u0026names.0;\r\n        let table_name = object_name[0].value.to_string();\r\n        let index_name = object_name[1].value.to_string();\r\n\r\n        let table_name = Arc::new(table_name);\r\n        let index_name = Arc::new(index_name);\r\n\r\n        //now only support unique index\r\n\r\n        let plan = LogicalPlan::new(\r\n            Operator::DropIndex(DropIndexOperator {\r\n                table_name,\r\n                index_name,\r\n                if_exists: *if_exists,\r\n            }),\r\n            vec![],\r\n        );\r\n        Ok(plan)\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["E:","\\","sql-layer","src","binder","drop_table.rs"],"content":"use crate::binder::{lower_case_name, split_name, Binder};\r\nuse crate::errors::*;\r\nuse crate::planner::operator::drop_table::DropTableOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse sqlparser::ast::ObjectName;\r\nuse std::sync::Arc;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_drop_table(\r\n        \u0026mut self,\r\n        name: \u0026ObjectName,\r\n        if_exists: \u0026bool,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let name = lower_case_name(name);\r\n        let (_, name) = split_name(\u0026name)?;\r\n        let table_name = Arc::new(name.to_string());\r\n\r\n        let plan = LogicalPlan::new(\r\n            Operator::DropTable(DropTableOperator {\r\n                table_name,\r\n                if_exists: *if_exists,\r\n            }),\r\n            vec![],\r\n        );\r\n\r\n        Ok(plan)\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":9},{"path":["E:","\\","sql-layer","src","binder","explain.rs"],"content":"use crate::binder::Binder;\r\nuse crate::errors::*;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_explain(\u0026mut self, plan: LogicalPlan) -\u003e Result\u003cLogicalPlan\u003e {\r\n        Ok(LogicalPlan::new(Operator::Explain, vec![plan]))\r\n    }\r\n}\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["E:","\\","sql-layer","src","binder","expr.rs"],"content":"use crate::catalog::ColumnCatalog;\r\n\r\nuse crate::errors::*;\r\nuse crate::expression;\r\nuse crate::expression::agg::Aggregate;\r\nuse crate::planner::LogicalPlan;\r\nuse itertools::Itertools;\r\nuse sqlparser::ast::Query;\r\nuse sqlparser::ast::{\r\n    BinaryOperator, DataType, Expr, Function, FunctionArg, FunctionArgExpr, Ident, UnaryOperator,\r\n};\r\nuse std::slice;\r\nuse std::sync::Arc;\r\n\r\nuse super::Binder;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::storage::Transaction;\r\nuse crate::types::value::DataValue;\r\nuse crate::types::LogicalType;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_expr(\u0026mut self, expr: \u0026Expr) -\u003e Result\u003cScalarExpression\u003e {\r\n        match expr {\r\n            Expr::Identifier(ident) =\u003e {\r\n                self.bind_column_ref_from_identifiers(slice::from_ref(ident), None)\r\n            }\r\n            Expr::CompoundIdentifier(idents) =\u003e self.bind_column_ref_from_identifiers(idents, None),\r\n            Expr::BinaryOp { left, right, op } =\u003e self.bind_binary_op_internal(left, right, op),\r\n            Expr::Value(v) =\u003e Ok(ScalarExpression::Constant(Arc::new(v.into()))),\r\n            Expr::Function(func) =\u003e self.bind_function(func),\r\n            Expr::Nested(expr) =\u003e self.bind_expr(expr),\r\n            Expr::UnaryOp { expr, op } =\u003e self.bind_unary_op_internal(expr, op),\r\n            Expr::Like {\r\n                negated,\r\n                expr,\r\n                pattern,\r\n                ..\r\n            } =\u003e self.bind_like(*negated, expr, pattern),\r\n            Expr::IsNull(expr) =\u003e self.bind_is_null(expr, false),\r\n            Expr::IsNotNull(expr) =\u003e self.bind_is_null(expr, true),\r\n            Expr::InList {\r\n                expr,\r\n                list,\r\n                negated,\r\n            } =\u003e self.bind_is_in(expr, list, *negated),\r\n            Expr::Cast { expr, data_type } =\u003e self.bind_cast(expr, data_type),\r\n            Expr::Subquery(subquery)=\u003e{\r\n                let (sub_query, column) = self.bind_subquery(subquery)?;\r\n                let (expr, _sub_query) =(ScalarExpression::ColumnRef(column), sub_query);\r\n\r\n                Ok(expr)\r\n            }\r\n            _ =\u003e {\r\n                println!(\"expr: {:#?} not support\", expr);\r\n                todo!()\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    fn bind_subquery(\r\n        \u0026mut self,\r\n        subquery: \u0026Query,\r\n    ) -\u003e Result\u003c(LogicalPlan, Arc\u003cColumnCatalog\u003e)\u003e {\r\n        let mut sub_query = self.bind_query(subquery)?;\r\n        let sub_query_schema = sub_query.output_schema();\r\n\r\n        assert!(sub_query_schema.len() == 1);\r\n\r\n        let column = sub_query_schema[0].clone();\r\n        Ok((sub_query, column))\r\n    }\r\n\r\n    pub fn bind_like(\r\n        \u0026mut self,\r\n        negated: bool,\r\n        expr: \u0026Expr,\r\n        pattern: \u0026Expr,\r\n    ) -\u003e Result\u003cScalarExpression\u003e {\r\n        let left_expr = Box::new(self.bind_expr(expr)?);\r\n        let right_expr = Box::new(self.bind_expr(pattern)?);\r\n        let op = if negated {\r\n            expression::BinaryOperator::NotLike\r\n        } else {\r\n            expression::BinaryOperator::Like\r\n        };\r\n        Ok(ScalarExpression::Binary {\r\n            op,\r\n            left_expr,\r\n            right_expr,\r\n            ty: LogicalType::Boolean,\r\n        })\r\n    }\r\n\r\n    pub fn bind_column_ref_from_identifiers(\r\n        \u0026mut self,\r\n        idents: \u0026[Ident],\r\n        bind_table_name: Option\u003c\u0026String\u003e,\r\n    ) -\u003e Result\u003cScalarExpression\u003e {\r\n        let idents = idents\r\n            .iter()\r\n            .map(|ident| Ident::new(ident.value.to_lowercase()))\r\n            .collect_vec();\r\n        let (_schema_name, table_name, column_name) = match idents.as_slice() {\r\n            [column] =\u003e (None, None, \u0026column.value),\r\n            [table, column] =\u003e (None, Some(\u0026table.value), \u0026column.value),\r\n            [schema, table, column] =\u003e (Some(\u0026schema.value), Some(\u0026table.value), \u0026column.value),\r\n            _ =\u003e {\r\n                return Err(DatabaseError::InvalidColumn(\r\n                    idents\r\n                        .iter()\r\n                        .map(|ident| ident.value.clone())\r\n                        .join(\".\")\r\n                        .to_string(),\r\n                ))\r\n            }\r\n        };\r\n\r\n        if let Some(table) = table_name.or(bind_table_name) {\r\n            let table_catalog = self\r\n                .context\r\n                .table(Arc::new(table.clone()))\r\n                .ok_or_else(|| DatabaseError::InvalidTable(table.to_string()))?;\r\n\r\n            let column_catalog = table_catalog\r\n                .get_column_by_name(column_name)\r\n                .ok_or_else(|| DatabaseError::InvalidColumn(column_name.to_string()))?;\r\n            Ok(ScalarExpression::ColumnRef(column_catalog.clone()))\r\n        } else {\r\n            // handle col syntax\r\n            let mut got_column = None;\r\n            for (table_catalog, _) in self.context.bind_table.values() {\r\n                if let Some(column_catalog) = table_catalog.get_column_by_name(column_name) {\r\n                    if got_column.is_some() {\r\n                        return Err(DatabaseError::InvalidColumn(column_name.to_string()));\r\n                    }\r\n                    got_column = Some(column_catalog);\r\n                }\r\n            }\r\n            if got_column.is_none() {\r\n                if let Some(expr) = self.context.aliases.get(column_name) {\r\n                    return Ok(ScalarExpression::Alias {\r\n                        expr: Box::new(expr.clone()),\r\n                        alias: column_name.clone(),\r\n                    });\r\n                }\r\n            }\r\n            let column_catalog =\r\n                got_column.ok_or_else(|| DatabaseError::InvalidColumn(column_name.to_string()))?;\r\n            Ok(ScalarExpression::ColumnRef(column_catalog.clone()))\r\n        }\r\n    }\r\n\r\n    fn bind_binary_op_internal(\r\n        \u0026mut self,\r\n        left: \u0026Expr,\r\n        right: \u0026Expr,\r\n        op: \u0026BinaryOperator,\r\n    ) -\u003e Result\u003cScalarExpression\u003e {\r\n        let left_expr = Box::new(self.bind_expr(left)?);\r\n        let right_expr = Box::new(self.bind_expr(right)?);\r\n\r\n        let ty = match op {\r\n            BinaryOperator::Plus\r\n            | BinaryOperator::Minus\r\n            | BinaryOperator::Multiply\r\n            | BinaryOperator::Divide\r\n            | BinaryOperator::Modulo =\u003e {\r\n                LogicalType::max_logical_type(\u0026left_expr.return_type(), \u0026right_expr.return_type())?\r\n            }\r\n            BinaryOperator::Gt\r\n            | BinaryOperator::Lt\r\n            | BinaryOperator::GtEq\r\n            | BinaryOperator::LtEq\r\n            | BinaryOperator::Eq\r\n            | BinaryOperator::NotEq\r\n            | BinaryOperator::And\r\n            | BinaryOperator::Or\r\n            | BinaryOperator::Xor =\u003e LogicalType::Boolean,\r\n            _ =\u003e todo!(),\r\n        };\r\n\r\n        Ok(ScalarExpression::Binary {\r\n            op: (op.clone()).into(),\r\n            left_expr,\r\n            right_expr,\r\n            ty,\r\n        })\r\n    }\r\n\r\n    fn bind_unary_op_internal(\r\n        \u0026mut self,\r\n        expr: \u0026Expr,\r\n        op: \u0026UnaryOperator,\r\n    ) -\u003e Result\u003cScalarExpression\u003e {\r\n        let expr = Box::new(self.bind_expr(expr)?);\r\n        let ty = if let UnaryOperator::Not = op {\r\n            LogicalType::Boolean\r\n        } else {\r\n            expr.return_type()\r\n        };\r\n\r\n        Ok(ScalarExpression::Unary {\r\n            op: (*op).into(),\r\n            expr,\r\n            ty,\r\n        })\r\n    }\r\n\r\n    fn bind_function(\u0026mut self, func: \u0026Function) -\u003e Result\u003cScalarExpression\u003e {\r\n        let mut args = Vec::with_capacity(func.args.len());\r\n\r\n        for arg in func.args.iter() {\r\n            let arg_expr = match arg {\r\n                FunctionArg::Named { arg, .. } =\u003e arg,\r\n                FunctionArg::Unnamed(arg) =\u003e arg,\r\n            };\r\n            match arg_expr {\r\n                FunctionArgExpr::Expr(expr) =\u003e args.push(self.bind_expr(expr)?),\r\n                FunctionArgExpr::Wildcard =\u003e args.push(Self::wildcard_expr()),\r\n                _ =\u003e todo!(),\r\n            }\r\n        }\r\n\r\n        Ok(match func.name.to_string().as_str() {\r\n            \"count\" =\u003e ScalarExpression::AggCall {\r\n                distinct: func.distinct,\r\n                kind: Aggregate::Count,\r\n                args,\r\n                ty: LogicalType::Integer,\r\n            },\r\n            \"sum\" =\u003e {\r\n                let ty = args[0].return_type();\r\n\r\n                ScalarExpression::AggCall {\r\n                    distinct: func.distinct,\r\n                    kind: Aggregate::Sum,\r\n                    args,\r\n                    ty,\r\n                }\r\n            }\r\n            \"min\" =\u003e {\r\n                let ty = args[0].return_type();\r\n\r\n                ScalarExpression::AggCall {\r\n                    distinct: func.distinct,\r\n                    kind: Aggregate::Min,\r\n                    args,\r\n                    ty,\r\n                }\r\n            }\r\n            \"max\" =\u003e {\r\n                let ty = args[0].return_type();\r\n                ScalarExpression::AggCall {\r\n                    distinct: func.distinct,\r\n                    kind: Aggregate::Max,\r\n                    args,\r\n                    ty,\r\n                }\r\n            }\r\n            \"avg\" =\u003e {\r\n                let ty = args[0].return_type();\r\n                ScalarExpression::AggCall {\r\n                    distinct: func.distinct,\r\n                    kind: Aggregate::Avg,\r\n                    args,\r\n                    ty,\r\n                }\r\n            }\r\n            \"current_schema\" =\u003e {\r\n                let schemas = self.context.transaction.show_tables()?.join(\" \");\r\n\r\n                ScalarExpression::Constant(Arc::new(DataValue::Utf8(Some(schemas))))\r\n            }\r\n            _ =\u003e todo!(),\r\n        })\r\n    }\r\n\r\n    fn bind_is_null(\u0026mut self, expr: \u0026Expr, negated: bool) -\u003e Result\u003cScalarExpression\u003e {\r\n        Ok(ScalarExpression::IsNull {\r\n            negated,\r\n            expr: Box::new(self.bind_expr(expr)?),\r\n        })\r\n    }\r\n\r\n    fn bind_is_in(\r\n        \u0026mut self,\r\n        expr: \u0026Expr,\r\n        list: \u0026[Expr],\r\n        negated: bool,\r\n    ) -\u003e Result\u003cScalarExpression\u003e {\r\n        let args = list.iter().map(|expr| self.bind_expr(expr)).try_collect()?;\r\n\r\n        Ok(ScalarExpression::In {\r\n            negated,\r\n            expr: Box::new(self.bind_expr(expr)?),\r\n            args,\r\n        })\r\n    }\r\n\r\n    fn bind_cast(\u0026mut self, expr: \u0026Expr, ty: \u0026DataType) -\u003e Result\u003cScalarExpression\u003e {\r\n        Ok(ScalarExpression::TypeCast {\r\n            expr: Box::new(self.bind_expr(expr)?),\r\n            ty: LogicalType::try_from(ty.clone())?,\r\n        })\r\n    }\r\n\r\n    fn wildcard_expr() -\u003e ScalarExpression {\r\n        ScalarExpression::Constant(Arc::new(DataValue::Utf8(Some(\"*\".to_string()))))\r\n    }\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":8430738502437568512},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":8430738502437568512},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":8502796096475496447},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":8502796096475496447},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":9583660007044415488},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":9583660007044415488},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":10304235947423694848},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":9583660007044415488},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":10808639105689190400},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1801439850948198400},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":3602879701896396800},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":104,"coverable":180},{"path":["E:","\\","sql-layer","src","binder","insert.rs"],"content":"use crate::binder::{lower_case_name, split_name, Binder};\r\nuse crate::catalog::ColumnRef;\r\nuse crate::errors::*;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::insert::InsertOperator;\r\nuse crate::planner::operator::values::ValuesOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::value::{DataValue, ValueRef};\r\nuse sqlparser::ast::{Expr, Ident, ObjectName};\r\nuse std::slice;\r\nuse std::sync::Arc;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_insert(\r\n        \u0026mut self,\r\n        name: ObjectName,\r\n        idents: \u0026[Ident],\r\n        expr_rows: \u0026Vec\u003cVec\u003cExpr\u003e\u003e,\r\n        is_overwrite: bool,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let name = lower_case_name(\u0026name);\r\n        let (_, name) = split_name(\u0026name)?;\r\n        let table_name = Arc::new(name.to_string());\r\n\r\n        if let Some(table) = self.context.table(table_name.clone()) {\r\n            let mut columns = Vec::new();\r\n            let values_len = expr_rows[0].len();\r\n\r\n            if idents.is_empty() {\r\n                columns = table.all_columns();\r\n                if values_len \u003e columns.len() {\r\n                    return Err(DatabaseError::ValuesLenMismatch(columns.len(), values_len));\r\n                }\r\n            } else {\r\n                let bind_table_name = Some(table_name.to_string());\r\n                for ident in idents {\r\n                    match self.bind_column_ref_from_identifiers(\r\n                        slice::from_ref(ident),\r\n                        bind_table_name.as_ref(),\r\n                    )? {\r\n                        ScalarExpression::ColumnRef(catalog) =\u003e columns.push(catalog),\r\n                        _ =\u003e unreachable!(),\r\n                    }\r\n                }\r\n                if values_len != columns.len() {\r\n                    return Err(DatabaseError::ValuesLenMismatch(columns.len(), values_len));\r\n                }\r\n            }\r\n            let mut rows = Vec::with_capacity(expr_rows.len());\r\n            for expr_row in expr_rows {\r\n                if expr_row.len() != values_len {\r\n                    return Err(DatabaseError::ValuesLenNotSame());\r\n                }\r\n                let mut row = Vec::with_capacity(expr_row.len());\r\n\r\n                for (i, expr) in expr_row.iter().enumerate() {\r\n                    match \u0026self.bind_expr(expr)? {\r\n                        ScalarExpression::Constant(value) =\u003e {\r\n                            // Check if the value length is too long\r\n                            value.check_len(columns[i].datatype())?;\r\n                            let cast_value = DataValue::clone(value).cast(columns[i].datatype())?;\r\n                            row.push(Arc::new(cast_value))\r\n                        }\r\n                        ScalarExpression::Unary { expr, op, .. } =\u003e {\r\n                            if let ScalarExpression::Constant(value) = expr.as_ref() {\r\n                                row.push(Arc::new(\r\n                                    DataValue::unary_op(value, op)?.cast(columns[i].datatype())?,\r\n                                ))\r\n                            } else {\r\n                                unreachable!()\r\n                            }\r\n                        }\r\n                        _ =\u003e unreachable!(),\r\n                    }\r\n                }\r\n\r\n                rows.push(row);\r\n            }\r\n            let values_plan = self.bind_values(rows, columns);\r\n\r\n            Ok(LogicalPlan::new(\r\n                Operator::Insert(InsertOperator {\r\n                    table_name,\r\n                    is_overwrite,\r\n                }),\r\n                vec![values_plan],\r\n            ))\r\n        } else {\r\n            Err(DatabaseError::InvalidTable(format!(\r\n                \"not found table {}\",\r\n                table_name\r\n            )))\r\n        }\r\n    }\r\n\r\n    pub(crate) fn bind_values(\r\n        \u0026mut self,\r\n        rows: Vec\u003cVec\u003cValueRef\u003e\u003e,\r\n        columns: Vec\u003cColumnRef\u003e,\r\n    ) -\u003e LogicalPlan {\r\n        LogicalPlan::new(Operator::Values(ValuesOperator { rows, columns }), vec![])\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null}],"covered":27,"coverable":42},{"path":["E:","\\","sql-layer","src","binder","mod.rs"],"content":"pub mod aggregate;\r\nmod alter_table;\r\npub(crate) mod copy;\r\nmod create_index;\r\nmod create_table;\r\nmod delete;\r\nmod describe;\r\nmod distinct;\r\nmod drop_index;\r\nmod drop_table;\r\nmod explain;\r\npub mod expr;\r\nmod insert;\r\nmod select;\r\nmod set_var;\r\nmod show;\r\nmod update;\r\n\r\nuse crate::errors::*;\r\n\r\nuse sqlparser::ast::{Ident, ObjectName, ObjectType, SetExpr, Statement};\r\nuse std::collections::BTreeMap;\r\n\r\nuse crate::catalog::{TableCatalog, TableName, DEFAULT_SCHEMA_NAME};\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::join::JoinType;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\npub enum InputRefType {\r\n    AggCall,\r\n    GroupBy,\r\n}\r\n\r\n#[derive(Clone)]\r\npub struct BinderContext\u003c'a, T: Transaction\u003e {\r\n    transaction: \u0026'a T,\r\n    pub(crate) bind_table: BTreeMap\u003cTableName, (TableCatalog, Option\u003cJoinType\u003e)\u003e,\r\n    aliases: BTreeMap\u003cString, ScalarExpression\u003e,\r\n    table_aliases: BTreeMap\u003cString, TableName\u003e,\r\n    group_by_exprs: Vec\u003cScalarExpression\u003e,\r\n    pub(crate) agg_calls: Vec\u003cScalarExpression\u003e,\r\n}\r\n\r\nimpl\u003c'a, T: Transaction\u003e BinderContext\u003c'a, T\u003e {\r\n    pub fn new(transaction: \u0026'a T) -\u003e Self {\r\n        BinderContext {\r\n            transaction,\r\n            bind_table: Default::default(),\r\n            aliases: Default::default(),\r\n            table_aliases: Default::default(),\r\n            group_by_exprs: vec![],\r\n            agg_calls: Default::default(),\r\n        }\r\n    }\r\n\r\n    pub fn table(\u0026self, table_name: TableName) -\u003e Option\u003cTableCatalog\u003e {\r\n        if let Some(real_name) = self.table_aliases.get(table_name.as_ref()) {\r\n            self.transaction.table(real_name.clone())\r\n        } else {\r\n            self.transaction.table(table_name)\r\n        }\r\n    }\r\n\r\n    // Tips: The order of this index is based on Aggregate being bound first.\r\n    pub fn input_ref_index(\u0026self, ty: InputRefType) -\u003e usize {\r\n        match ty {\r\n            InputRefType::AggCall =\u003e self.agg_calls.len(),\r\n            InputRefType::GroupBy =\u003e self.agg_calls.len() + self.group_by_exprs.len(),\r\n        }\r\n    }\r\n\r\n    pub fn add_alias(\u0026mut self, alias: String, expr: ScalarExpression) -\u003e Result\u003c()\u003e {\r\n        let is_exist = self.aliases.insert(alias.clone(), expr).is_some();\r\n        if is_exist {\r\n            return Err(DatabaseError::InvalidColumn(format!(\r\n                \"{} duplicated\",\r\n                alias\r\n            )));\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub fn add_table_alias(\u0026mut self, alias: String, table: TableName) -\u003e Result\u003c()\u003e {\r\n        let is_alias_exist = self\r\n            .table_aliases\r\n            .insert(alias.clone(), table.clone())\r\n            .is_some();\r\n        if is_alias_exist {\r\n            return Err(DatabaseError::InvalidTable(format!(\"{} duplicated\", alias)));\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub fn add_bind_table(\r\n        \u0026mut self,\r\n        table: TableName,\r\n        table_catalog: TableCatalog,\r\n        join_type: Option\u003cJoinType\u003e,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let is_bound = self\r\n            .bind_table\r\n            .insert(table.clone(), (table_catalog.clone(), join_type))\r\n            .is_some();\r\n        if is_bound {\r\n            return Err(DatabaseError::InvalidTable(format!(\"{} duplicated\", table)));\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub fn has_agg_call(\u0026self, expr: \u0026ScalarExpression) -\u003e bool {\r\n        self.group_by_exprs.contains(expr)\r\n    }\r\n}\r\n\r\npub struct Binder\u003c'a, T: Transaction\u003e {\r\n    context: BinderContext\u003c'a, T\u003e,\r\n}\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub fn new(context: BinderContext\u003c'a, T\u003e) -\u003e Self {\r\n        Binder { context }\r\n    }\r\n\r\n    pub fn bind(\u0026mut self, stmt: \u0026Statement) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let plan = match stmt {\r\n            Statement::Query(query) =\u003e self.bind_query(query)?,\r\n            Statement::AlterTable { name, operation } =\u003e self.bind_alter_table(name, operation)?,\r\n            Statement::CreateTable {\r\n                name,\r\n                columns,\r\n                constraints,\r\n                if_not_exists,\r\n                ..\r\n            } =\u003e self.bind_create_table(name, columns, constraints, *if_not_exists)?,\r\n            Statement::Drop {\r\n                object_type,\r\n                names,\r\n                if_exists,\r\n                ..\r\n            } =\u003e match object_type {\r\n                ObjectType::Table =\u003e self.bind_drop_table(\u0026names[0], if_exists)?,\r\n                ObjectType::Index =\u003e self.bind_drop_index(\u0026names[0], if_exists)?,\r\n                _ =\u003e todo!(),\r\n            },\r\n            Statement::Insert {\r\n                table_name,\r\n                columns,\r\n                source,\r\n                overwrite,\r\n                ..\r\n            } =\u003e {\r\n                if let SetExpr::Values(values) = source.body.as_ref() {\r\n                    self.bind_insert(table_name.to_owned(), columns, \u0026values.rows, *overwrite)?\r\n                } else {\r\n                    todo!()\r\n                }\r\n            }\r\n            Statement::Update {\r\n                table,\r\n                selection,\r\n                assignments,\r\n                ..\r\n            } =\u003e {\r\n                if !table.joins.is_empty() {\r\n                    unimplemented!()\r\n                } else {\r\n                    self.bind_update(table, selection, assignments)?\r\n                }\r\n            }\r\n            Statement::Delete {\r\n                from, selection, ..\r\n            } =\u003e {\r\n                let table = \u0026from[0];\r\n\r\n                if !table.joins.is_empty() {\r\n                    unimplemented!()\r\n                } else {\r\n                    self.bind_delete(table, selection)?\r\n                }\r\n            }\r\n            Statement::Explain { statement, .. } =\u003e {\r\n                let plan = self.bind(statement)?;\r\n                self.bind_explain(plan)?\r\n            }\r\n            Statement::CreateIndex {\r\n                name,\r\n                table_name,\r\n                columns,\r\n                ..\r\n            } =\u003e {\r\n                //we only support single column index yet\r\n                self.bind_create_index(name, table_name, columns)?\r\n            }\r\n            // Statement::Truncate { table_name, .. } =\u003e self.bind_truncate(table_name)?,\r\n            Statement::ShowTables { .. } =\u003e self.bind_show_tables()?,\r\n            Statement::SetVariable {\r\n                variable, value, ..\r\n            } =\u003e {\r\n                //only support set transaction's  isolation level\r\n                assert_eq!(value.len(), 1);\r\n                self.bind_set_var(variable.to_string(), value[0].to_string())?\r\n            }\r\n            Statement::Copy {\r\n                source,\r\n                target,\r\n                options,\r\n                ..\r\n            } =\u003e self.bind_copy(source.clone(), target.clone(), options)?,\r\n            Statement::ExplainTable {\r\n                describe_alias: true,\r\n                table_name,\r\n            } =\u003e self.bind_describe(table_name)?,\r\n\r\n            _ =\u003e return Err(DatabaseError::UnsupportedStmt(stmt.to_string())),\r\n        };\r\n        Ok(plan)\r\n    }\r\n}\r\n\r\n/// Convert an object name into lower case\r\nfn lower_case_name(name: \u0026ObjectName) -\u003e ObjectName {\r\n    ObjectName(\r\n        name.0\r\n            .iter()\r\n            .map(|ident| Ident::new(ident.value.to_lowercase()))\r\n            .collect(),\r\n    )\r\n}\r\n\r\n/// Split an object name into `(schema name, table name)`.\r\nfn split_name(name: \u0026ObjectName) -\u003e Result\u003c(\u0026str, \u0026str)\u003e {\r\n    Ok(match name.0.as_slice() {\r\n        [table] =\u003e (DEFAULT_SCHEMA_NAME, \u0026table.value),\r\n        [schema, table] =\u003e (\u0026schema.value, \u0026table.value),\r\n        _ =\u003e return Err(DatabaseError::InvalidTable(name.to_string())),\r\n    })\r\n}\r\npub(crate) fn is_valid_identifier(s: \u0026str) -\u003e bool {\r\n    s.chars().all(|c| c.is_alphanumeric() || c == '_')\r\n        \u0026\u0026 !s.chars().next().unwrap_or_default().is_numeric()\r\n        \u0026\u0026 !s.chars().all(|c| c == '_')\r\n}\r\n\r\n#[cfg(test)]\r\npub mod test {\r\n    use super::*;\r\n    use crate::binder::{Binder, BinderContext};\r\n    use crate::catalog::{ColumnCatalog, ColumnDesc};\r\n    \r\n    use crate::parser;\r\n    use crate::planner::LogicalPlan;\r\n    use crate::storage::piggy_stroage::PiggyKVStroage;\r\n    use crate::storage::{Storage, Transaction};\r\n    use crate::types::LogicalType::Integer;\r\n    use std::sync::Arc;\r\n    use tempfile::TempDir;\r\n    pub(crate) async fn build_test_catalog() -\u003e Result\u003cPiggyKVStroage\u003e {\r\n        let path = tempdir::TempDir::new(\"piggydb\")\r\n            .unwrap()\r\n            .path()\r\n            .join(\"piggydb\");\r\n        let storage=PiggyKVStroage::new(path, None);\r\n\r\n        let mut transaction = storage.transaction().await?;\r\n\r\n        let _ = transaction.create_table(\r\n            Arc::new(\"t1\".to_string()),\r\n            vec![\r\n                ColumnCatalog::new(\r\n                    \"c1\".to_string(),\r\n                    false,\r\n                    ColumnDesc::new(Integer, true, false, None),\r\n                    // None,\r\n                ),\r\n                ColumnCatalog::new(\r\n                    \"c2\".to_string(),\r\n                    false,\r\n                    ColumnDesc::new(Integer, false, true, None),\r\n                    // None,\r\n                ),\r\n            ],\r\n            false,\r\n        )?;\r\n\r\n        let _ = transaction.create_table(\r\n            Arc::new(\"t2\".to_string()),\r\n            vec![\r\n                ColumnCatalog::new(\r\n                    \"c3\".to_string(),\r\n                    false,\r\n                    ColumnDesc::new(Integer, true, false, None),\r\n                    // None,\r\n                ),\r\n                ColumnCatalog::new(\r\n                    \"c4\".to_string(),\r\n                    false,\r\n                    ColumnDesc::new(Integer, false, false, None),\r\n                    // None,\r\n                ),\r\n            ],\r\n            false,\r\n        )?;\r\n\r\n        transaction.commit().await?;\r\n\r\n        Ok(storage)\r\n    }\r\n\r\n    pub async fn select_sql_run(sql: \u0026str) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let _temp_dir = TempDir::new().expect(\"unable to create temporary working directory\");\r\n        let storage = build_test_catalog().await?;\r\n        let transaction = storage.transaction().await?;\r\n        let mut binder = Binder::new(BinderContext::new(\u0026transaction));\r\n        let stmt = parser::parse(sql)?;\r\n\r\n        Ok(binder.bind(\u0026stmt[0])?)\r\n    }\r\n\r\n    #[test]\r\n    pub fn test_valid_identifier() {\r\n        assert!(is_valid_identifier(\"valid_table\"));\r\n        assert!(is_valid_identifier(\"valid_column\"));\r\n        assert!(is_valid_identifier(\"_valid_column\"));\r\n        assert!(is_valid_identifier(\"valid_column_1\"));\r\n\r\n        assert!(!is_valid_identifier(\"invalid_name\u0026\"));\r\n        assert!(!is_valid_identifier(\"1_invalid_name\"));\r\n        assert!(!is_valid_identifier(\"____\"));\r\n    }\r\n}\r\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":15348267530078650368},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":15348267530078650368},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":15348267530078650368},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":12249790986447749120},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":3891110078048108544},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null}],"covered":65,"coverable":122},{"path":["E:","\\","sql-layer","src","binder","select.rs"],"content":"use std::borrow::Borrow;\r\nuse std::sync::Arc;\r\n\r\nuse crate::{\r\n    expression::ScalarExpression,\r\n    planner::{\r\n        operator::{\r\n            filter::FilterOperator, join::JoinOperator as LJoinOperator, limit::LimitOperator,\r\n            project::ProjectOperator, Operator,\r\n        },\r\n        operator::{join::JoinType, scan::ScanOperator},\r\n    },\r\n    types::value::DataValue,\r\n};\r\n\r\nuse super::{lower_case_name, Binder};\r\n\r\nuse crate::catalog::{\r\n    ColumnCatalog, TableCatalog, TableName, DEFAULT_DATABASE_NAME, DEFAULT_SCHEMA_NAME,\r\n};\r\nuse crate::errors::*;\r\nuse crate::expression::BinaryOperator;\r\nuse crate::planner::operator::join::JoinCondition;\r\nuse crate::planner::operator::sort::{SortField, SortOperator};\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::LogicalType;\r\nuse itertools::Itertools;\r\nuse sqlparser::ast;\r\nuse sqlparser::ast::{\r\n    Distinct, Expr, Ident, Join, JoinConstraint, JoinOperator, Offset, OrderByExpr, Query, Select,\r\n    SelectItem, SetExpr, TableAlias, TableFactor, TableWithJoins,\r\n};\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_query(\u0026mut self, query: \u0026Query) -\u003e Result\u003cLogicalPlan\u003e {\r\n        if let Some(_with) = \u0026query.with {\r\n            // TODO support with clause.\r\n        }\r\n\r\n        let mut plan = match query.body.borrow() {\r\n            SetExpr::Select(select) =\u003e self.bind_select(select, \u0026query.order_by),\r\n            SetExpr::Query(query) =\u003e self.bind_query(query),\r\n            _ =\u003e unimplemented!(),\r\n        }?;\r\n\r\n        let limit = \u0026query.limit;\r\n        let offset = \u0026query.offset;\r\n\r\n        if limit.is_some() || offset.is_some() {\r\n            plan = self.bind_limit(plan, limit, offset)?;\r\n        }\r\n\r\n        Ok(plan)\r\n    }\r\n\r\n    fn bind_select(\u0026mut self, select: \u0026Select, orderby: \u0026[OrderByExpr]) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let mut plan = self.bind_table_ref(\u0026select.from)?;\r\n\r\n        let mut select_list = self.normalize_select_item(\u0026select.projection)?;\r\n\r\n        self.extract_select_join(\u0026mut select_list);\r\n\r\n        if let Some(predicate) = \u0026select.selection {\r\n            plan = self.bind_where(plan, predicate)?;\r\n        }\r\n\r\n        self.extract_select_aggregate(\u0026mut select_list)?;\r\n\r\n        if !select.group_by.is_empty() {\r\n            self.extract_group_by_aggregate(\u0026mut select_list, \u0026select.group_by)?;\r\n        }\r\n\r\n        let mut having_orderby = (None, None);\r\n\r\n        if select.having.is_some() || !orderby.is_empty() {\r\n            having_orderby = self.extract_having_orderby_aggregate(\u0026select.having, orderby)?;\r\n        }\r\n\r\n        if !self.context.agg_calls.is_empty() || !self.context.group_by_exprs.is_empty() {\r\n            plan = self.bind_aggregate(\r\n                plan,\r\n                self.context.agg_calls.clone(),\r\n                self.context.group_by_exprs.clone(),\r\n            );\r\n        }\r\n\r\n        if let Some(having) = having_orderby.0 {\r\n            plan = self.bind_having(plan, having)?;\r\n        }\r\n\r\n        if let Some(Distinct::Distinct) = select.distinct {\r\n            plan = self.bind_distinct(plan, select_list.clone());\r\n        }\r\n\r\n        if let Some(orderby) = having_orderby.1 {\r\n            plan = self.bind_sort(plan, orderby);\r\n        }\r\n\r\n        plan = self.bind_project(plan, select_list);\r\n        // println!(\"plan:\");\r\n        // println!(\"{:?}\", plan);\r\n        Ok(plan)\r\n    }\r\n\r\n    pub(crate) fn bind_table_ref(\u0026mut self, from: \u0026[TableWithJoins]) -\u003e Result\u003cLogicalPlan\u003e {\r\n        assert!(from.len() \u003c 2, \"not support yet.\");\r\n        if from.is_empty() {\r\n            return Ok(LogicalPlan::new(Operator::Dummy, vec![]));\r\n        }\r\n\r\n        let TableWithJoins { relation, joins } = \u0026from[0];\r\n\r\n        let (left_name, mut plan) = self.bind_single_table_ref(relation, None)?;\r\n\r\n        if !joins.is_empty() {\r\n            let left_name = Self::unpack_name(left_name, true);\r\n\r\n            for join in joins {\r\n                plan = self.bind_join(left_name.clone(), plan, join)?;\r\n            }\r\n        }\r\n        Ok(plan)\r\n    }\r\n\r\n    fn unpack_name(table_name: Option\u003cTableName\u003e, is_left: bool) -\u003e TableName {\r\n        let title = if is_left { \"Left\" } else { \"Right\" };\r\n        table_name.unwrap_or_else(|| panic!(\"{}: Table is not named\", title))\r\n    }\r\n\r\n    fn bind_single_table_ref(\r\n        \u0026mut self,\r\n        table: \u0026TableFactor,\r\n        joint_type: Option\u003cJoinType\u003e,\r\n    ) -\u003e Result\u003c(Option\u003cTableName\u003e, LogicalPlan)\u003e {\r\n        let plan_with_name = match table {\r\n            TableFactor::Table { name, alias, .. } =\u003e {\r\n                let obj_name = name\r\n                    .0\r\n                    .iter()\r\n                    .map(|ident| Ident::new(ident.value.to_string()))\r\n                    .collect_vec();\r\n\r\n                let (_database, _schema, table): (\u0026str, \u0026str, \u0026str) = match obj_name.as_slice() {\r\n                    [table] =\u003e (DEFAULT_DATABASE_NAME, DEFAULT_SCHEMA_NAME, \u0026table.value),\r\n                    [schema, table] =\u003e (DEFAULT_DATABASE_NAME, \u0026schema.value, \u0026table.value),\r\n                    [database, schema, table] =\u003e (\u0026database.value, \u0026schema.value, \u0026table.value),\r\n                    _ =\u003e return Err(DatabaseError::InvalidTable(name.to_string())),\r\n                };\r\n\r\n                let (table, plan) =\r\n                    self._bind_single_table_ref(joint_type, table, Self::trans_alias(alias))?;\r\n                (Some(table), plan)\r\n            }\r\n            TableFactor::Derived {\r\n                subquery, alias, ..\r\n            } =\u003e {\r\n                let plan = self.bind_query(subquery)?;\r\n                let mut tables = plan.referenced_table();\r\n\r\n                if let Some(alias) = Self::trans_alias(alias) {\r\n                    let alias = Arc::new(alias.clone());\r\n\r\n                    if tables.len() \u003e 1 {\r\n                        todo!(\"Implement virtual tables for multiple table aliases\");\r\n                    }\r\n                    self.context\r\n                        .add_table_alias(alias.to_string(), tables.remove(0))?;\r\n\r\n                    (Some(alias), plan)\r\n                } else {\r\n                    ((tables.len() \u003e 1).then(|| tables.pop()).flatten(), plan)\r\n                }\r\n            }\r\n            _ =\u003e unimplemented!(),\r\n        };\r\n\r\n        Ok(plan_with_name)\r\n    }\r\n\r\n    pub(crate) fn trans_alias(alias: \u0026Option\u003cTableAlias\u003e) -\u003e Option\u003c\u0026String\u003e {\r\n        alias.as_ref().map(|alias| \u0026alias.name.value)\r\n    }\r\n\r\n    pub(crate) fn _bind_single_table_ref(\r\n        \u0026mut self,\r\n        join_type: Option\u003cJoinType\u003e,\r\n        table: \u0026str,\r\n        alias: Option\u003c\u0026String\u003e,\r\n    ) -\u003e Result\u003c(Arc\u003cString\u003e, LogicalPlan)\u003e {\r\n        let table_name = Arc::new(table.to_string());\r\n\r\n        let table_catalog = self\r\n            .context\r\n            .table(table_name.clone())\r\n            .ok_or_else(|| DatabaseError::InvalidTable(format!(\"bind table {}\", table)))?;\r\n\r\n        self.context\r\n            .add_bind_table(table_name.clone(), table_catalog.clone(), join_type)?;\r\n\r\n        if let Some(alias) = alias {\r\n            self.context\r\n                .add_table_alias(alias.to_string(), table_name.clone())?;\r\n        }\r\n\r\n        Ok((\r\n            table_name.clone(),\r\n            ScanOperator::build(table_name, \u0026table_catalog),\r\n        ))\r\n    }\r\n\r\n    /// Normalize select item.\r\n    ///\r\n    /// - Qualified name, e.g. `SELECT t.a FROM t`\r\n    /// - Qualified name with wildcard, e.g. `SELECT t.* FROM t,t1`\r\n    /// - Scalar expression or aggregate expression, e.g. `SELECT COUNT(*) + 1 AS count FROM t`\r\n    ///  \r\n    fn normalize_select_item(\u0026mut self, items: \u0026[SelectItem]) -\u003e Result\u003cVec\u003cScalarExpression\u003e\u003e {\r\n        let mut select_items = vec![];\r\n\r\n        for item in items.iter().enumerate() {\r\n            match item.1 {\r\n                SelectItem::UnnamedExpr(expr) =\u003e select_items.push(self.bind_expr(expr)?),\r\n                SelectItem::ExprWithAlias { expr, alias } =\u003e {\r\n                    let expr = self.bind_expr(expr)?;\r\n                    let alias_name = alias.to_string();\r\n\r\n                    self.context.add_alias(alias_name.clone(), expr.clone())?;\r\n\r\n                    select_items.push(ScalarExpression::Alias {\r\n                        expr: Box::new(expr),\r\n                        alias: alias_name,\r\n                    });\r\n                }\r\n                SelectItem::Wildcard(_) =\u003e {\r\n                    select_items.extend_from_slice(self.bind_all_column_refs()?.as_slice());\r\n                }\r\n                SelectItem::QualifiedWildcard(table_name, _) =\u003e {\r\n                    self.bind_table_column_refs(\r\n                        \u0026mut select_items,\r\n                        Arc::new(lower_case_name(table_name).to_string()),\r\n                    )?;\r\n                }\r\n            };\r\n        }\r\n\r\n        Ok(select_items)\r\n    }\r\n\r\n    fn bind_table_column_refs(\r\n        \u0026 self,\r\n        exprs: \u0026mut Vec\u003cScalarExpression\u003e,\r\n        table_name: TableName,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let table = self\r\n            .context\r\n            .table(table_name.clone())\r\n            .ok_or(DatabaseError::TableNotFound)?;\r\n\r\n        let append = table\r\n            .all_columns()\r\n            .into_iter()\r\n            .map(ScalarExpression::ColumnRef)\r\n            .collect_vec();\r\n        exprs.extend(append);\r\n        Ok(())\r\n    }\r\n\r\n    fn bind_all_column_refs(\u0026mut self) -\u003e Result\u003cVec\u003cScalarExpression\u003e\u003e {\r\n        let mut exprs = vec![];\r\n        for table_name in self.context.bind_table.keys() {\r\n            let table = self\r\n                .context\r\n                .table(table_name.clone())\r\n                .ok_or_else(|| DatabaseError::InvalidTable(table_name.to_string()))?;\r\n            for col in table.all_columns() {\r\n                exprs.push(ScalarExpression::ColumnRef(col));\r\n            }\r\n        }\r\n\r\n        Ok(exprs)\r\n    }\r\n\r\n    fn bind_join(\r\n        \u0026mut self,\r\n        left_table: TableName,\r\n        left: LogicalPlan,\r\n        join: \u0026Join,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let Join {\r\n            relation,\r\n            join_operator,\r\n        } = join;\r\n\r\n        let (join_type, joint_condition) = match join_operator {\r\n            JoinOperator::Inner(constraint) =\u003e (JoinType::Inner, Some(constraint)),\r\n            JoinOperator::LeftOuter(constraint) =\u003e (JoinType::Left, Some(constraint)),\r\n            JoinOperator::RightOuter(constraint) =\u003e (JoinType::Right, Some(constraint)),\r\n            JoinOperator::FullOuter(constraint) =\u003e (JoinType::Full, Some(constraint)),\r\n            JoinOperator::CrossJoin =\u003e (JoinType::Cross, None),\r\n            _ =\u003e unimplemented!(),\r\n        };\r\n        let (right_table, right) = self.bind_single_table_ref(relation, Some(join_type))?;\r\n        let right_table = Self::unpack_name(right_table, false);\r\n\r\n        let left_table = self.context.table(left_table.clone()).ok_or_else(|| {\r\n            DatabaseError::InvalidTable(format!(\"Left: {} not found\", left_table))\r\n        })?;\r\n        let right_table = self.context.table(right_table.clone()).ok_or_else(|| {\r\n            DatabaseError::InvalidTable(format!(\"Right: {} not found\", right_table))\r\n        })?;\r\n\r\n        let on = match joint_condition {\r\n            Some(constraint) =\u003e self.bind_join_constraint(\u0026left_table, \u0026right_table, constraint)?,\r\n            None =\u003e JoinCondition::None,\r\n        };\r\n\r\n        Ok(LJoinOperator::build(left, right, on, join_type))\r\n    }\r\n\r\n    pub(crate) fn bind_where(\r\n        \u0026mut self,\r\n        children: LogicalPlan,\r\n        predicate: \u0026Expr,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        Ok(FilterOperator::build(\r\n            self.bind_expr(predicate)?,\r\n            children,\r\n            false,\r\n        ))\r\n    }\r\n\r\n    fn bind_having(\r\n        \u0026mut self,\r\n        children: LogicalPlan,\r\n        having: ScalarExpression,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        self.validate_having_orderby(\u0026having)?;\r\n        Ok(FilterOperator::build(having, children, true))\r\n    }\r\n\r\n    fn bind_project(\r\n        \u0026mut self,\r\n        children: LogicalPlan,\r\n        select_list: Vec\u003cScalarExpression\u003e,\r\n    ) -\u003e LogicalPlan {\r\n        LogicalPlan::new(\r\n            Operator::Project(ProjectOperator { exprs: select_list }),\r\n            vec![children],\r\n        )\r\n    }\r\n\r\n    fn bind_sort(\u0026mut self, children: LogicalPlan, sort_fields: Vec\u003cSortField\u003e) -\u003e LogicalPlan {\r\n        LogicalPlan::new(\r\n            Operator::Sort(SortOperator {\r\n                sort_fields,\r\n                limit: None,\r\n            }),\r\n            vec![children],\r\n        )\r\n    }\r\n\r\n    fn bind_limit(\r\n        \u0026mut self,\r\n        children: LogicalPlan,\r\n        limit_expr: \u0026Option\u003cExpr\u003e,\r\n        offset_expr: \u0026Option\u003cOffset\u003e,\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let mut limit = None;\r\n        let mut offset = None;\r\n        if let Some(expr) = limit_expr {\r\n            let expr = self.bind_expr(expr)?;\r\n            match expr {\r\n                ScalarExpression::Constant(dv) =\u003e match dv.as_ref() {\r\n                    DataValue::Int32(Some(v)) if *v \u003e= 0 =\u003e limit = Some(*v as usize),\r\n                    DataValue::Int64(Some(v)) if *v \u003e= 0 =\u003e limit = Some(*v as usize),\r\n                    _ =\u003e return Err(DatabaseError::InvalidType),\r\n                },\r\n                _ =\u003e {\r\n                    return Err(DatabaseError::InvalidColumn(\r\n                        \"invalid limit expression.\".to_owned(),\r\n                    ))\r\n                }\r\n            }\r\n        }\r\n\r\n        if let Some(expr) = offset_expr {\r\n            let expr = self.bind_expr(\u0026expr.value)?;\r\n            match expr {\r\n                ScalarExpression::Constant(dv) =\u003e match dv.as_ref() {\r\n                    DataValue::Int32(Some(v)) if *v \u003e 0 =\u003e offset = Some(*v as usize),\r\n                    DataValue::Int64(Some(v)) if *v \u003e 0 =\u003e offset = Some(*v as usize),\r\n                    _ =\u003e return Err(DatabaseError::InvalidType),\r\n                },\r\n                _ =\u003e {\r\n                    return Err(DatabaseError::InvalidColumn(\r\n                        \"invalid limit expression.\".to_string(),\r\n                    ))\r\n                }\r\n            }\r\n        }\r\n\r\n        // TODO: validate limit and offset is correct use statistic.\r\n\r\n        Ok(LimitOperator::build(offset, limit, children))\r\n    }\r\n\r\n    pub fn extract_select_join(\u0026mut self, select_items: \u0026mut [ScalarExpression]) {\r\n        let bind_tables = \u0026self.context.bind_table;\r\n        if bind_tables.len() \u003c 2 {\r\n            return;\r\n        }\r\n\r\n        let mut table_force_nullable = Vec::with_capacity(bind_tables.len());\r\n        let mut left_table_force_nullable = false;\r\n        let mut left_table = None;\r\n\r\n        for (table, join_option) in bind_tables.values() {\r\n            if let Some(join_type) = join_option {\r\n                let (left_force_nullable, right_force_nullable) = match join_type {\r\n                    JoinType::Inner =\u003e (false, false),\r\n                    JoinType::Left =\u003e (false, true),\r\n                    JoinType::Right =\u003e (true, false),\r\n                    JoinType::Full =\u003e (true, true),\r\n                    JoinType::Cross =\u003e (true, true),\r\n                };\r\n                table_force_nullable.push((table, right_force_nullable));\r\n                left_table_force_nullable = left_force_nullable;\r\n            } else {\r\n                left_table = Some(table);\r\n            }\r\n        }\r\n\r\n        if let Some(table) = left_table {\r\n            table_force_nullable.push((table, left_table_force_nullable));\r\n        }\r\n\r\n        for column in select_items {\r\n            if let ScalarExpression::ColumnRef(col) = column {\r\n                let _ = table_force_nullable\r\n                    .iter()\r\n                    .find(|(table, _)| table.contains_column(col.name()))\r\n                    .map(|(_, nullable)| {\r\n                        let mut new_col = ColumnCatalog::clone(col);\r\n                        new_col.nullable = *nullable;\r\n\r\n                        *col = Arc::new(new_col);\r\n                    });\r\n            }\r\n        }\r\n    }\r\n\r\n    fn bind_join_constraint(\r\n        \u0026mut self,\r\n        left_table: \u0026TableCatalog,\r\n        right_table: \u0026TableCatalog,\r\n        constraint: \u0026JoinConstraint,\r\n    ) -\u003e Result\u003cJoinCondition\u003e {\r\n        match constraint {\r\n            JoinConstraint::On(expr) =\u003e {\r\n                // left and right columns that match equi-join pattern\r\n                let mut on_keys: Vec\u003c(ScalarExpression, ScalarExpression)\u003e = vec![];\r\n                // expression that didn't match equi-join pattern\r\n                let mut filter = vec![];\r\n\r\n                self.extract_join_keys(expr, \u0026mut on_keys, \u0026mut filter, left_table, right_table)?;\r\n\r\n                // combine multiple filter exprs into one BinaryExpr\r\n                let join_filter = filter\r\n                    .into_iter()\r\n                    .reduce(|acc, expr| ScalarExpression::Binary {\r\n                        op: BinaryOperator::And,\r\n                        left_expr: Box::new(acc),\r\n                        right_expr: Box::new(expr),\r\n                        ty: LogicalType::Boolean,\r\n                    });\r\n                // TODO: handle cross join if on_keys is empty\r\n                Ok(JoinCondition::On {\r\n                    on: on_keys,\r\n                    filter: join_filter,\r\n                })\r\n            }\r\n            _ =\u003e unimplemented!(\"not supported join constraint {:?}\", constraint),\r\n        }\r\n    }\r\n\r\n    /// for sqlrs\r\n    /// original idea from datafusion plan.rs\r\n    /// Extracts equijoin ON condition be a single Eq or multiple conjunctive Eqs\r\n    /// Filters matching this pattern are added to `accum`\r\n    /// Filters that don't match this pattern are added to `accum_filter`\r\n    /// Examples:\r\n    /// ```text\r\n    /// foo = bar =\u003e accum=[(foo, bar)] accum_filter=[]\r\n    /// foo = bar AND bar = baz =\u003e accum=[(foo, bar), (bar, baz)] accum_filter=[]\r\n    /// foo = bar AND baz \u003e 1 =\u003e accum=[(foo, bar)] accum_filter=[baz \u003e 1]\r\n    /// ```\r\n    fn extract_join_keys(\r\n        \u0026mut self,\r\n        expr: \u0026Expr,\r\n        accum: \u0026mut Vec\u003c(ScalarExpression, ScalarExpression)\u003e,\r\n        accum_filter: \u0026mut Vec\u003cScalarExpression\u003e,\r\n        left_schema: \u0026TableCatalog,\r\n        right_schema: \u0026TableCatalog,\r\n    ) -\u003e Result\u003c()\u003e {\r\n\r\n        match expr {\r\n            Expr::BinaryOp { left, op, right } =\u003e match op {\r\n                ast::BinaryOperator::Eq =\u003e {\r\n                    let left = self.bind_expr(left)?;\r\n                    let right = self.bind_expr(right)?;\r\n\r\n                    match (\u0026left, \u0026right) {\r\n                        // example: foo = bar\r\n                        (ScalarExpression::ColumnRef(l), ScalarExpression::ColumnRef(r)) =\u003e {\r\n                            // reorder left and right joins keys to pattern: (left, right)\r\n                            if left_schema.contains_column(l.name())\r\n                                \u0026\u0026 right_schema.contains_column(r.name())\r\n                            {\r\n                                accum.push((left, right));\r\n                            } else if left_schema.contains_column(r.name())\r\n                                \u0026\u0026 right_schema.contains_column(l.name())\r\n                            {\r\n                                accum.push((right, left));\r\n                            } else {\r\n                                accum_filter.push(self.bind_expr(expr)?);\r\n                            }\r\n                        }\r\n                        // example: baz = 1\r\n                        _other =\u003e {\r\n                            accum_filter.push(self.bind_expr(expr)?);\r\n                        }\r\n                    }\r\n                }\r\n                ast::BinaryOperator::And =\u003e {\r\n                    // example: foo = bar AND baz \u003e 1\r\n                    if let Expr::BinaryOp { left, op: _, right } = expr {\r\n                        self.extract_join_keys(\r\n                            left,\r\n                            accum,\r\n                            accum_filter,\r\n                            left_schema,\r\n                            right_schema,\r\n                        )?;\r\n                        self.extract_join_keys(\r\n                            right,\r\n                            accum,\r\n                            accum_filter,\r\n                            left_schema,\r\n                            right_schema,\r\n                        )?;\r\n                    }\r\n                }\r\n                // ast::BinaryOperator::Or=\u003e{\r\n\r\n                // }\r\n\r\n                _other =\u003e {\r\n                    // example: baz \u003e 1\r\n                    accum_filter.push(self.bind_expr(expr)?);\r\n                }\r\n            },\r\n            _other =\u003e {\r\n                // example: baz in (xxx), something else will convert to filter logic\r\n                accum_filter.push(self.bind_expr(expr)?);\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":10232178353385766912},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":10232178353385766912},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":10232178353385766912},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":10304235947423694848},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":10232178353385766912},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":7349874591868649472},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":12970366926827028480},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":12970366926827028480},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":10808639105689190400},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":5692549928996306944},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":7493989779944505344},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":3746994889972252672},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":3746994889972252672},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":9799832789158199296},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":9799832789158199296},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":12321848580485677056},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":3746994889972252672},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":2666130979403333632},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":2666130979403333632},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":2666130979403333632},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":2666130979403333632},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":5116089176692883456},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":3891110078048108544},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":12465963768561532928},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":11240984669916758016},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":5620492334958379008},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":11240984669916758016},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":5620492334958379008},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":5620492334958379008},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":5620492334958379008},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null}],"covered":173,"coverable":270},{"path":["E:","\\","sql-layer","src","binder","set_var.rs"],"content":"use crate::binder::Binder;\r\nuse crate::planner::operator::set_var::SetVarOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\nuse crate::errors::*;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_set_var(\u0026mut self, var: String, val: String) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let op = SetVarOperator {\r\n            variable: var,\r\n            value: val,\r\n        };\r\n        let plan = LogicalPlan::new(Operator::SetVar(op), vec![]);\r\n        Ok(plan)\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["E:","\\","sql-layer","src","binder","show.rs"],"content":"use crate::binder::Binder;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\nuse crate::errors::*;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_show_tables(\u0026mut self) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let plan = LogicalPlan::new(Operator::Show, vec![]);\r\n        Ok(plan)\r\n    }\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":3,"coverable":3},{"path":["E:","\\","sql-layer","src","binder","update.rs"],"content":"use crate::binder::{lower_case_name, split_name, Binder};\r\nuse crate::errors::*;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::update::UpdateOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\nuse sqlparser::ast::{Assignment, Expr, TableFactor, TableWithJoins};\r\nuse std::slice;\r\nuse std::sync::Arc;\r\n\r\nimpl\u003c'a, T: Transaction\u003e Binder\u003c'a, T\u003e {\r\n    pub(crate) fn bind_update(\r\n        \u0026mut self,\r\n        to: \u0026TableWithJoins,\r\n        selection: \u0026Option\u003cExpr\u003e,\r\n        assignments: \u0026[Assignment],\r\n    ) -\u003e Result\u003cLogicalPlan\u003e {\r\n        if let TableFactor::Table { name, .. } = \u0026to.relation {\r\n            let name = lower_case_name(name);\r\n            let (_, name) = split_name(\u0026name)?;\r\n            let table_name = Arc::new(name.to_string());\r\n\r\n            let mut plan = self.bind_table_ref(slice::from_ref(to))?;\r\n\r\n            if let Some(predicate) = selection {\r\n                plan = self.bind_where(plan, predicate)?;\r\n            }\r\n\r\n            let bind_table_name = Some(table_name.to_string());\r\n\r\n            let mut columns = Vec::with_capacity(assignments.len());\r\n\r\n            let mut set_expr = Vec::with_capacity(assignments.len());\r\n\r\n            for assignment in assignments {\r\n                //set x= expr,  the expr as value\r\n                let value = self.bind_expr(\u0026assignment.value)?;\r\n\r\n                for ident in \u0026assignment.id {\r\n                    match self.bind_column_ref_from_identifiers(\r\n                        slice::from_ref(ident),\r\n                        bind_table_name.as_ref(),\r\n                    )? {\r\n                        ScalarExpression::ColumnRef(catalog) =\u003e {\r\n                            columns.push(catalog);\r\n                            set_expr.push(value.clone());\r\n                        }\r\n                        _ =\u003e unreachable!(),\r\n                    }\r\n                }\r\n            }\r\n            // let values_plan = self.bind_values(vec![], columns);\r\n            Ok(LogicalPlan::new(\r\n                Operator::Update(UpdateOperator {\r\n                    columns,\r\n                    set_expr,\r\n                    table_name,\r\n                }),\r\n                vec![plan],\r\n            ))\r\n        } else {\r\n            unreachable!(\"only table\")\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null}],"covered":21,"coverable":26},{"path":["E:","\\","sql-layer","src","catalog","column.rs"],"content":"\r\nuse serde::{Deserialize, Serialize};\r\nuse std::fmt::Display;\r\nuse std::hash::Hash;\r\nuse std::sync::Arc;\r\n\r\nuse crate::types::value::ValueRef;\r\nuse crate::types::{ColumnId, LogicalType};\r\n\r\nuse super::TableName;\r\n\r\npub type ColumnRef = Arc\u003cColumnCatalog\u003e;\r\npub type SchemaRef = Arc\u003cVec\u003cColumnRef\u003e\u003e;\r\npub type Schema=Vec\u003cColumnRef\u003e;\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]\r\npub struct ColumnCatalog {\r\n    pub summary: ColumnSummary,\r\n    pub nullable: bool,\r\n    pub desc: ColumnDesc,\r\n}\r\n\r\nimpl Display for ColumnCatalog {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        write!(\r\n            f,\r\n            \"col name:{},type:{}\",\r\n            self.summary.name, self.desc.column_datatype\r\n        )\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Hash, Eq, PartialEq)]\r\npub struct ColumnSummary {\r\n    pub id: Option\u003cColumnId\u003e,\r\n    pub name: String,\r\n    pub table_name: Option\u003cTableName\u003e,\r\n}\r\n\r\nimpl ColumnCatalog {\r\n    pub(crate) fn new(\r\n        column_name: String,\r\n        nullable: bool,\r\n        column_desc: ColumnDesc,\r\n        // ref_expr: Option\u003cScalarExpression\u003e,\r\n    ) -\u003e ColumnCatalog {\r\n        ColumnCatalog {\r\n            summary: ColumnSummary {\r\n                id: None,\r\n                name: column_name,\r\n                table_name: None,\r\n            },\r\n            nullable,\r\n            desc: column_desc,\r\n            // ref_expr,\r\n        }\r\n    }\r\n\r\n    pub(crate) fn new_dummy(column_name: String) -\u003e ColumnCatalog {\r\n        ColumnCatalog {\r\n            summary: ColumnSummary {\r\n                id: Some(0),\r\n                name: column_name,\r\n                table_name: None,\r\n            },\r\n            nullable: false,\r\n            desc: ColumnDesc::new(LogicalType::Varchar(None), false, false, None),\r\n            // ref_expr: None,\r\n        }\r\n    }\r\n    pub fn table_name(\u0026self) -\u003e Option\u003c\u0026TableName\u003e {\r\n        self.summary.table_name.as_ref()\r\n    }\r\n\r\n    pub fn set_table_name(\u0026mut self, table_name: TableName) {\r\n        self.summary.table_name = Some(table_name);\r\n    }\r\n\r\n    pub(crate) fn summary(\u0026self) -\u003e \u0026ColumnSummary {\r\n        \u0026self.summary\r\n    }\r\n\r\n    pub(crate) fn id(\u0026self) -\u003e Option\u003cColumnId\u003e {\r\n        self.summary.id\r\n    }\r\n\r\n    pub fn name(\u0026self) -\u003e \u0026str {\r\n        \u0026self.summary.name\r\n    }\r\n\r\n    pub(crate) fn datatype(\u0026self) -\u003e \u0026LogicalType {\r\n        \u0026self.desc.column_datatype\r\n    }\r\n\r\n    pub(crate) fn default_value(\u0026self) -\u003e Option\u003cValueRef\u003e {\r\n        self.desc.default.clone()\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    pub(crate) fn desc(\u0026self) -\u003e \u0026ColumnDesc {\r\n        \u0026self.desc\r\n    }\r\n}\r\n\r\n/// The descriptor of a column.\r\n#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Hash)]\r\npub struct ColumnDesc {\r\n    pub(crate) column_datatype: LogicalType,\r\n    pub(crate) is_primary: bool,\r\n    pub(crate) is_unique: bool,\r\n    pub(crate) default: Option\u003cValueRef\u003e,\r\n}\r\n\r\nimpl ColumnDesc {\r\n    pub(crate) const fn new(\r\n        column_datatype: LogicalType,\r\n        is_primary: bool,\r\n        is_unique: bool,\r\n        default: Option\u003cValueRef\u003e,\r\n    ) -\u003e ColumnDesc {\r\n        ColumnDesc {\r\n            column_datatype,\r\n            is_primary,\r\n            is_unique,\r\n            default,\r\n        }\r\n    }\r\n    #[allow(dead_code)]\r\n    pub(crate) fn is_index(\u0026self) -\u003e bool {\r\n        self.is_unique || self.is_primary\r\n    }\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1008806316530991107},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1008806316530991107},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":1008806316530991107},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":5980780305148018688},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":5980780305148018688},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":15204152342002794513},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":15204152342002794513},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":4107282860161892353},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":4107282860161892353},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":3674937295934324741},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":3674937295934324741},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":144115188075855874},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":144115188075855874},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":14555633995661443072},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":16,"coverable":28},{"path":["E:","\\","sql-layer","src","catalog","mod.rs"],"content":"// Module: catalog\r\n\r\npub(crate) use self::column::*;\r\npub(crate) use self::table::*;\r\n\r\npub(crate) static DEFAULT_DATABASE_NAME: \u0026str = \"Piggysql\";\r\npub(crate) static DEFAULT_SCHEMA_NAME: \u0026str = \"Piggysql\";\r\n\r\nmod column;\r\nmod table;\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","catalog","table.rs"],"content":"use std::collections::BTreeMap;\r\nuse std::sync::Arc;\r\n\r\nuse itertools::Itertools;\r\n\r\nuse super::column::{ColumnCatalog, ColumnRef};\r\nuse crate::errors::*;\r\nuse crate::types::index::{IndexId, IndexMeta, IndexMetaRef};\r\nuse crate::types::{ColumnId, LogicalType};\r\n\r\npub type TableName = Arc\u003cString\u003e;\r\npub type IndexName = Arc\u003cString\u003e;\r\n\r\n#[derive(Debug, Clone, PartialEq)]\r\npub struct TableCatalog {\r\n    pub(crate) name: TableName,\r\n    /// Mapping from column names to column ids\r\n    column_idxs: BTreeMap\u003cString, ColumnId\u003e,\r\n    pub(crate) columns: BTreeMap\u003cColumnId, ColumnRef\u003e,\r\n    pub(crate) indexes: Vec\u003cIndexMetaRef\u003e,\r\n}\r\n\r\nimpl TableCatalog {\r\n    pub(crate) fn get_unique_index(\u0026self, col_id: \u0026ColumnId) -\u003e Option\u003c\u0026IndexMetaRef\u003e {\r\n        self.indexes\r\n            .iter()\r\n            .find(|meta| meta.is_unique \u0026\u0026 \u0026meta.column_ids[0] == col_id)\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    pub(crate) fn get_column_by_id(\u0026self, id: \u0026ColumnId) -\u003e Option\u003c\u0026ColumnRef\u003e {\r\n        self.columns.get(id)\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    pub(crate) fn get_column_id_by_name(\u0026self, name: \u0026str) -\u003e Option\u003cColumnId\u003e {\r\n        self.column_idxs.get(name).cloned()\r\n    }\r\n\r\n    pub(crate) fn get_column_by_name(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026ColumnRef\u003e {\r\n        let id = self.column_idxs.get(name)?;\r\n        self.columns.get(id)\r\n    }\r\n    #[allow(dead_code)]\r\n    pub(crate) fn types(\u0026self) -\u003e Vec\u003cLogicalType\u003e {\r\n        self.columns\r\n            .values()\r\n            .map(|column| *column.datatype())\r\n            .collect_vec()\r\n    }\r\n\r\n    pub(crate) fn contains_column(\u0026self, name: \u0026str) -\u003e bool {\r\n        self.column_idxs.contains_key(name)\r\n    }\r\n\r\n    pub(crate) fn all_columns_with_id(\u0026self) -\u003e Vec\u003c(\u0026ColumnId, \u0026ColumnRef)\u003e {\r\n        self.columns.iter().collect()\r\n    }\r\n\r\n    pub(crate) fn all_columns(\u0026self) -\u003e Vec\u003cColumnRef\u003e {\r\n        self.columns.values().map(Arc::clone).collect()\r\n    }\r\n\r\n    /// Add a column to the table catalog.\r\n    pub(crate) fn add_column(\u0026mut self, mut col: ColumnCatalog) -\u003e Result\u003cColumnId\u003e {\r\n        if self.column_idxs.contains_key(col.name()) {\r\n            return Err(DatabaseError::Duplicated(\"column\", col.name().to_string()));\r\n        }\r\n\r\n        let col_id = self.columns.len() as u32;\r\n\r\n        col.summary.id = Some(col_id);\r\n        col.summary.table_name = Some(self.name.clone());\r\n        self.column_idxs.insert(col.name().to_string(), col_id);\r\n        self.columns.insert(col_id, Arc::new(col));\r\n\r\n        Ok(col_id)\r\n    }\r\n\r\n    pub(crate) fn add_index_meta(\r\n        \u0026mut self,\r\n        name: String,\r\n        column_ids: Vec\u003cColumnId\u003e,\r\n        is_unique: bool,\r\n        is_primary: bool,\r\n    ) -\u003e \u0026IndexMeta {\r\n        let index_id = self.indexes.len();\r\n\r\n        let index = IndexMeta {\r\n            id: index_id as u32,\r\n            column_ids,\r\n            name,\r\n            is_unique,\r\n            is_primary,\r\n        };\r\n        self.indexes.push(Arc::new(index));\r\n\r\n        \u0026self.indexes[index_id]\r\n    }\r\n    #[allow(dead_code)]\r\n    pub(crate) fn get_index_by_name(\u0026mut self, name: IndexName) -\u003e Result\u003cIndexId\u003e {\r\n        // let index_id = self.indexes.len();\r\n        let pos = self\r\n            .indexes\r\n            .iter()\r\n            .find_position(|idx| idx.name == format!(\"{}_{}\", \"uk\", name));\r\n        match pos {\r\n            Some(pos) =\u003e Ok(self.indexes[pos.0].id),\r\n            None =\u003e Err(DatabaseError::NotFound(\"index\", name.to_string())),\r\n        }\r\n    }\r\n    pub(crate) fn new(name: TableName, columns: Vec\u003cColumnCatalog\u003e) -\u003e Result\u003cTableCatalog\u003e {\r\n        if columns.is_empty() {\r\n            return Err(DatabaseError::ColumnsEmpty);\r\n        }\r\n        let mut table_catalog = TableCatalog {\r\n            name,\r\n            column_idxs: BTreeMap::new(),\r\n            columns: BTreeMap::new(),\r\n            indexes: vec![],\r\n        };\r\n        for col_catalog in columns.into_iter() {\r\n            let _ = table_catalog.add_column(col_catalog)?;\r\n        }\r\n\r\n        Ok(table_catalog)\r\n    }\r\n\r\n    pub(crate) fn new_with_indexes(\r\n        name: TableName,\r\n        columns: Vec\u003cColumnCatalog\u003e,\r\n        indexes: Vec\u003cIndexMetaRef\u003e,\r\n    ) -\u003e Result\u003cTableCatalog\u003e {\r\n        let mut catalog = TableCatalog::new(name, columns)?;\r\n        catalog.indexes = indexes;\r\n\r\n        Ok(catalog)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::catalog::column::ColumnDesc;\r\n    use crate::types::LogicalType;\r\n\r\n    #[test]\r\n    // | a (Int32) | b (Bool) |\r\n    // |-----------|----------|\r\n    // | 1         | true     |\r\n    // | 2         | false    |\r\n    fn test_table_catalog() {\r\n        let col0 = ColumnCatalog::new(\r\n            \"a\".into(),\r\n            false,\r\n            ColumnDesc::new(LogicalType::Integer, false, false, None),\r\n            // None,\r\n        );\r\n        let col1 = ColumnCatalog::new(\r\n            \"b\".into(),\r\n            false,\r\n            ColumnDesc::new(LogicalType::Boolean, false, false, None),\r\n            // None,\r\n        );\r\n        let col_catalogs = vec![col0, col1];\r\n        let table_catalog = TableCatalog::new(Arc::new(\"test\".to_string()), col_catalogs).unwrap();\r\n\r\n        assert_eq!(table_catalog.contains_column(\u0026\"a\".to_string()), true);\r\n        assert_eq!(table_catalog.contains_column(\u0026\"b\".to_string()), true);\r\n        assert_eq!(table_catalog.contains_column(\u0026\"c\".to_string()), false);\r\n\r\n        let col_a_id = table_catalog\r\n            .get_column_id_by_name(\u0026\"a\".to_string())\r\n            .unwrap();\r\n        let col_b_id = table_catalog\r\n            .get_column_id_by_name(\u0026\"b\".to_string())\r\n            .unwrap();\r\n        assert!(col_a_id \u003c col_b_id);\r\n\r\n        let column_catalog = table_catalog.get_column_by_id(\u0026col_a_id).unwrap();\r\n        assert_eq!(column_catalog.name(), \"a\");\r\n        assert_eq!(*column_catalog.datatype(), LogicalType::Integer,);\r\n\r\n        let column_catalog = table_catalog.get_column_by_id(\u0026col_b_id).unwrap();\r\n        assert_eq!(column_catalog.name(), \"b\");\r\n        assert_eq!(*column_catalog.datatype(), LogicalType::Boolean,);\r\n    }\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":12610078956637388800},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":6773413839565225984},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":11240984669916758016},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":11240984669916758016},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":12970366926827028481},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":9151314442816847872},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":9151314442816847872},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":9151314442816847872},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":9151314442816847872},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":9151314442816847872},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":12970366926827028480},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":12970366926827028480},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":36,"coverable":50},{"path":["E:","\\","sql-layer","src","db.rs"],"content":"\r\n\r\nuse crate::binder::{Binder, BinderContext};\r\nuse crate::catalog::SchemaRef;\r\nuse crate::execution::executor::{build, Source};\r\nuse crate::optimizer::apply_optimization;\r\nuse crate::parser;\r\n\r\nuse crate::errors::{DatabaseError, Result};\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::piggy_stroage::PiggyKVStroage;\r\nuse crate::storage::{Storage, Transaction};\r\nuse crate::types::tuple::Tuple;\r\npub struct Database\u003cS: Storage\u003e {\r\n    pub(crate) storage: S,\r\n}\r\nimpl Database\u003cPiggyKVStroage\u003e {\r\n    pub fn new_lsm(path: std::path::PathBuf) -\u003e Result\u003cSelf\u003e {\r\n        Ok(Database {\r\n            storage: PiggyKVStroage::new(path, None),\r\n        })\r\n    }\r\n}\r\n// impl Database\u003cMVCCLayer\u003cMemory\u003e\u003e {\r\n//     pub fn new_memory() -\u003e Result\u003cSelf\u003e {\r\n//         Ok(Database {\r\n//             storage: MVCCLayer::new_memory(),\r\n//         })\r\n//     }\r\n// }\r\n\r\nimpl\u003cS: Storage\u003e Database\u003cS\u003e {\r\n    /// Create a new Database instance.\r\n    pub fn new(storage: S) -\u003e Result\u003cSelf\u003e {\r\n        Ok(Database { storage })\r\n    }\r\n\r\n    // /// Run SQL queries.\r\n    pub async fn run(\u0026self, sql: \u0026str) -\u003e Result\u003c(SchemaRef, Vec\u003cTuple\u003e)\u003e {\r\n        let mut transaction = self.storage.transaction().await?;\r\n        let (schema, tuples) = match Self::_run(sql, \u0026mut transaction) {\r\n            Ok((schema, tuples)) =\u003e (schema, tuples),\r\n            Err(e) =\u003e {\r\n                transaction.rollback().await?;\r\n                return Err(e);\r\n            }\r\n        };\r\n\r\n        transaction.commit().await?;\r\n\r\n        Ok((schema, tuples?))\r\n    }\r\n\r\n    pub async fn new_transaction(\u0026self) -\u003e Result\u003cDBTransaction\u003cS\u003e\u003e {\r\n        let transaction = self.storage.transaction().await?;\r\n\r\n        Ok(DBTransaction { inner: transaction })\r\n    }\r\n    pub async fn prepare_sql(\u0026self, sql: \u0026str) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let mut txn = self.storage.transaction().await?;\r\n        let stmts = parser::parse(sql)?;\r\n        if stmts.is_empty() {\r\n            return Err(DatabaseError::EmptyStatement);\r\n        }\r\n        let mut binder = Binder::new(BinderContext::new(\u0026mut txn));\r\n        let source_plan = binder.bind(\u0026stmts[0])?;\r\n        // println!(\"source_plan plan: {:#?}\", source_plan);\r\n        let best_plan = apply_optimization(source_plan)?;\r\n        txn.rollback().await?;\r\n        Ok(best_plan)\r\n    }\r\n    fn _run(\r\n        sql: \u0026str,\r\n        transaction: \u0026mut \u003cS as Storage\u003e::TransactionType,\r\n    ) -\u003e Result\u003c(SchemaRef, Source)\u003e {\r\n        // parse\r\n        let stmts = parser::parse(sql)?;\r\n        if stmts.is_empty() {\r\n            return Err(DatabaseError::EmptyStatement);\r\n        }\r\n        let mut binder = Binder::new(BinderContext::new(transaction));\r\n        let source_plan = binder.bind(\u0026stmts[0])?;\r\n        // println!(\"source_plan plan: {:#?}\", source_plan);\r\n        let mut best_plan = apply_optimization(source_plan)?;\r\n        // println!(\"best_plan plan: {}\", best_plan.explain(0));\r\n        let schema = best_plan.output_schema().clone();\r\n        Ok((schema, build(best_plan, transaction)))\r\n    }\r\n}\r\n\r\npub struct DBTransaction\u003cS: Storage\u003e {\r\n    inner: S::TransactionType,\r\n}\r\n\r\nimpl\u003cS: Storage\u003e DBTransaction\u003cS\u003e {\r\n    pub async fn run(\u0026mut self, sql: \u0026str) -\u003e Result\u003c(SchemaRef, Vec\u003cTuple\u003e)\u003e {\r\n        let (schema, tuples) = Database::\u003cS\u003e::_run(sql, \u0026mut self.inner)?;\r\n        Ok((schema, tuples?))\r\n    }\r\n    pub async fn commit(self) -\u003e Result\u003c()\u003e {\r\n        self.inner.commit().await?;\r\n\r\n        Ok(())\r\n    }\r\n    pub async fn rollback(self) -\u003e Result\u003c()\u003e {\r\n        self.inner.rollback().await?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n\r\n    use crate::db::Database;\r\n    use crate::types::tuple::create_table;\r\n    use crate::types::value::DataValue;\r\n\r\n    use std::sync::Arc;\r\n    #[tokio::test]\r\n    async fn playground() -\u003e Result\u003c()\u003e {\r\n        let path = tempdir::TempDir::new(\"piggydb\")\r\n            .unwrap()\r\n            .path()\r\n            .join(\"piggydb\");\r\n\r\n        let database = Database::new_lsm(path)?;\r\n        database\r\n            .run(\"create table halloween (id int primary key,salary int)\")\r\n            .await?;\r\n\r\n        let tuple = database.run(\"show tables;\").await?;\r\n        println!(\"tuple: {:#?}\", tuple);\r\n        Ok(())\r\n    }\r\n    #[tokio::test]\r\n    async fn test_transaction_sql() -\u003e Result\u003c()\u003e {\r\n        let path = tempdir::TempDir::new(\"piggydb\")\r\n            .unwrap()\r\n            .path()\r\n            .join(\"piggydb\");\r\n\r\n        let database = Database::new_lsm(path)?;\r\n\r\n        database\r\n            .run(\"create table halloween (id int primary key,salary int)\")\r\n            .await?;\r\n        database\r\n            .run(\"insert into halloween values (1,1000), (2,2000), (3,3000), (4,4000)\")\r\n            .await?;\r\n        database\r\n            .run(\"update halloween set salary = salary + 1000 where salary \u003c 3000\")\r\n            .await?;\r\n        let (_, tuple) = database.run(\"select salary from halloween;\").await?;\r\n        assert_eq!(tuple.len(), 4);\r\n        assert_eq!(tuple[0].values[0], Arc::new(DataValue::Int32(Some(2000))));\r\n        assert_eq!(tuple[1].values[0], Arc::new(DataValue::Int32(Some(3000))));\r\n        assert_eq!(tuple[2].values[0], Arc::new(DataValue::Int32(Some(3000))));\r\n        assert_eq!(tuple[3].values[0], Arc::new(DataValue::Int32(Some(4000))));\r\n\r\n        Ok(())\r\n    }\r\n    #[tokio::test]\r\n\r\n    async fn test_crud_sql() -\u003e Result\u003c()\u003e {\r\n        let path = tempdir::TempDir::new(\"piggydb\")\r\n            .unwrap()\r\n            .path()\r\n            .join(\"piggydb\");\r\n\r\n        let database = Database::new_lsm(path)?;\r\n\r\n        let _ = database.run(\r\n            \"create table t1 (a int primary key, b int unique null, k int, z varchar unique null)\",\r\n        ).await?;\r\n        let _ = database\r\n            .run(\"create table t2 (c int primary key, d int unsigned null, e datetime)\")\r\n            .await?;\r\n        let _ = database.run(\"insert into t1 (a, b, k, z) values (-99, 1, 1, 'k'), (-1, 2, 2, 'i'), (5, 3, 2, 'p'), (29, 4, 2, 'db')\").await?;\r\n        let _ = database.run(\"insert into t2 (d, c, e) values (2, 1, '2021-05-20 21:00:00'), (3, 4, '2023-09-10 00:00:00')\").await?;\r\n\r\n        println!(\"full t1:\");\r\n        let tuples_full_fields_t1 = database.run(\"select * from t1\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_full_fields_t1));\r\n\r\n        println!(\"full t2:\");\r\n        let tuples_full_fields_t2 = database.run(\"select * from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_full_fields_t2));\r\n\r\n        println!(\"projection_and_filter:\");\r\n        let tuples_projection_and_filter = database.run(\"select a from t1 where b \u003e 1\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_projection_and_filter));\r\n\r\n        println!(\"projection_and_sort:\");\r\n        let tuples_projection_and_sort = database.run(\"select * from t1 order by a, b\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_projection_and_sort));\r\n\r\n        println!(\"like t1 1:\");\r\n        let tuples_like_1_t1 = database.run(\"select * from t1 where z like '%k'\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_like_1_t1));\r\n\r\n        println!(\"like t1 2:\");\r\n        let tuples_like_2_t1 = database.run(\"select * from t1 where z like '_b'\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_like_2_t1));\r\n\r\n        println!(\"not like t1:\");\r\n        let tuples_not_like_t1 = database\r\n            .run(\"select * from t1 where z not like '_b'\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_not_like_t1));\r\n\r\n        println!(\"in t1:\");\r\n        let tuples_in_t1 = database.run(\"select * from t1 where a in (5, 29)\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_in_t1));\r\n\r\n        println!(\"not in t1:\");\r\n        let tuples_not_in_t1 = database\r\n            .run(\"select * from t1 where a not in (5, 29)\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_not_in_t1));\r\n\r\n        println!(\"limit:\");\r\n        let tuples_limit = database.run(\"select * from t1 limit 1 offset 1\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_limit));\r\n\r\n        println!(\"inner join:\");\r\n        let tuples_inner_join = database\r\n            .run(\"select * from t1 inner join t2 on a = c\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_inner_join));\r\n\r\n        println!(\"left join:\");\r\n        let tuples_left_join = database\r\n            .run(\"select * from t1 left join t2 on a = c\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_left_join));\r\n\r\n        println!(\"right join:\");\r\n        let tuples_right_join = database\r\n            .run(\"select * from t1 right join t2 on a = c\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_right_join));\r\n\r\n        println!(\"full join:\");\r\n        let tuples_full_join = database\r\n            .run(\"select * from t1 full join t2 on a = c\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_full_join));\r\n\r\n        println!(\"count agg:\");\r\n        let tuples_count_agg = database.run(\"select count(d) from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_count_agg));\r\n\r\n        println!(\"count wildcard agg:\");\r\n        let tuples_count_wildcard_agg = database.run(\"select count(*) from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_count_wildcard_agg));\r\n\r\n        println!(\"count distinct agg:\");\r\n        let tuples_count_distinct_agg = database.run(\"select count(distinct d) from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_count_distinct_agg));\r\n\r\n        println!(\"sum agg:\");\r\n        let tuples_sum_agg = database.run(\"select sum(d) from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_sum_agg));\r\n\r\n        println!(\"sum distinct agg:\");\r\n        let tuples_sum_distinct_agg = database.run(\"select sum(distinct d) from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_sum_distinct_agg));\r\n\r\n        println!(\"avg agg:\");\r\n        let tuples_avg_agg = database.run(\"select avg(d) from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_avg_agg));\r\n\r\n        println!(\"min_max agg:\");\r\n        let tuples_min_max_agg = database.run(\"select min(d), max(d) from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_min_max_agg));\r\n\r\n        println!(\"group agg:\");\r\n        let tuples_group_agg = database\r\n            .run(\"select c, max(d) from t2 group by c having c = 1\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_group_agg));\r\n\r\n        println!(\"alias:\");\r\n        let tuples_group_agg = database.run(\"select c as o from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_group_agg));\r\n\r\n        println!(\"alias agg:\");\r\n        let tuples_group_agg = database\r\n            .run(\"select c, max(d) as max_d from t2 group by c having c = 1\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_group_agg));\r\n\r\n        println!(\"time max:\");\r\n        let tuples_time_max = database.run(\"select max(e) as max_time from t2\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_time_max));\r\n\r\n        println!(\"time where:\");\r\n        let tuples_time_where_t2 = database\r\n            .run(\"select (c + 1) from t2 where e \u003e '2021-05-20'\")\r\n            .await?;\r\n        println!(\"{}\", create_table(\u0026tuples_time_where_t2));\r\n\r\n        println!(\"distinct t1:\");\r\n        let tuples_distinct_t1 = database.run(\"select distinct b, k from t1\").await?;\r\n        println!(\"{}\", create_table(\u0026tuples_distinct_t1));\r\n\r\n        println!(\"update t1 with filter:\");\r\n        let _ = database.run(\"update t1 set b = 0 where b = 1\").await?;\r\n        println!(\"after t1:\");\r\n        let update_after_full_t1 = database.run(\"select * from t1\").await?;\r\n        println!(\"{}\", create_table(\u0026update_after_full_t1));\r\n\r\n        println!(\"insert overwrite t1:\");\r\n        let _ = database\r\n            .run(\"insert overwrite t1 (a, b, k) values (-99, 1, 0)\")\r\n            .await?;\r\n        println!(\"after t1:\");\r\n        let insert_overwrite_after_full_t1 = database.run(\"select * from t1\").await?;\r\n        println!(\"{}\", create_table(\u0026insert_overwrite_after_full_t1));\r\n\r\n        assert!(database\r\n            .run(\"insert overwrite t1 (a, b, k) values (-1, 1, 0)\")\r\n            .await\r\n            .is_err());\r\n\r\n        println!(\"delete t1 with filter:\");\r\n        let _ = database.run(\"delete from t1 where b = 0\").await?;\r\n        println!(\"after t1:\");\r\n        let delete_after_full_t1 = database.run(\"select * from t1\").await?;\r\n        println!(\"{}\", create_table(\u0026delete_after_full_t1));\r\n\r\n        println!(\"drop t1:\");\r\n        let _ = database.run(\"drop table t1\").await?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":14,"coverable":45},{"path":["E:","\\","sql-layer","src","errors.rs"],"content":"use std::{\r\n    array::TryFromSliceError,\r\n    num::{ParseFloatError, ParseIntError, TryFromIntError},\r\n    str::ParseBoolError,\r\n    string::FromUtf8Error,\r\n};\r\n\r\nuse chrono::ParseError;\r\nuse sqlparser::parser::ParserError;\r\npub type Result\u003cT\u003e = std::result::Result\u003cT, DatabaseError\u003e;\r\nuse crate::{\r\n    expression::BinaryOperator,\r\n    types::{value::DataValue, LogicalType},\r\n};\r\n\r\n#[derive(thiserror::Error, Debug)]\r\npub enum DatabaseError {\r\n    #[error(\"sql statement is empty\")]\r\n    EmptyStatement,\r\n    #[error(\"invalid type\")]\r\n    InvalidType,\r\n    #[error(\"must contain PrimaryKey!\")]\r\n    PrimaryKeyNotFound,\r\n    #[error(\"not implemented sqlparser datatype: {0}\")]\r\n    NotImplementedSqlparserDataType(String),\r\n    #[error(\"Type:{0},lhs:{1} cast to {2} fail\")]\r\n    CastFail(LogicalType, DataValue, LogicalType),\r\n    #[error(\"too long\")]\r\n    TooLong,\r\n    #[error(\"cannot be Null\")]\r\n    NotNull,\r\n    #[error(\"try from int: {0}\")]\r\n    TryFromInt(\r\n        #[source]\r\n        #[from]\r\n        TryFromIntError,\r\n    ),\r\n    #[error(\"parser int: {0}\")]\r\n    ParseInt(\r\n        #[source]\r\n        #[from]\r\n        ParseIntError,\r\n    ),\r\n    #[error(\"parser bool: {0}\")]\r\n    ParseBool(\r\n        #[source]\r\n        #[from]\r\n        ParseBoolError,\r\n    ),\r\n    #[error(\"parser float: {0}\")]\r\n    ParseFloat(\r\n        #[source]\r\n        #[from]\r\n        ParseFloatError,\r\n    ),\r\n    #[error(\"parser date: {0}\")]\r\n    ParseDate(\r\n        #[source]\r\n        #[from]\r\n        ParseError,\r\n    ),\r\n    #[error(\"parser sql: {0}\")]\r\n    ParserSql(\r\n        #[source]\r\n        #[from]\r\n        ParserError,\r\n    ),\r\n    #[error(\"bindcode: {0}\")]\r\n    Bincode(\r\n        #[source]\r\n        #[from]\r\n        Box\u003cbincode::ErrorKind\u003e,\r\n    ),\r\n    #[error(\"from utf8: {0}\")]\r\n    FromUtf8Error(\r\n        #[source]\r\n        #[from]\r\n        FromUtf8Error,\r\n    ),\r\n    #[error(\"try from decimal\")]\r\n    TryFromDecimal(\r\n        #[source]\r\n        #[from]\r\n        rust_decimal::Error,\r\n    ),\r\n\r\n    #[error(\"{0} and {1} do not match\")]\r\n    MisMatch(String, String),\r\n    #[error(\"io: {0}\")]\r\n    IO(\r\n        #[source]\r\n        #[from]\r\n        std::io::Error,\r\n    ),\r\n    #[error(\"the same primary key data already exists\")]\r\n    DuplicatePrimaryKey,\r\n    #[error(\"the column has been declared unique and the value already exists\")]\r\n    DuplicateUniqueValue,\r\n    #[error(\"the table not found\")]\r\n    TableNotFound,\r\n    #[error(\"the some column already exists\")]\r\n    DuplicateColumn,\r\n    #[error(\"add column must be nullable or specify a default value\")]\r\n    NeedNullAbleOrDefault,\r\n    #[error(\"the table already exists\")]\r\n    TableExists,\r\n    #[error(\"plan is empty\")]\r\n    EmptyPlan,\r\n    #[error(\"this column must belong to a table\")]\r\n    OwnerLessColumn,\r\n    #[error(\"there are more buckets: {0} than elements: {1}\")]\r\n    TooManyBuckets(usize, usize),\r\n    #[error(\"tuple length mismatch: expected {expected} but got {actual}\")]\r\n    LengthMismatch { expected: usize, actual: usize },\r\n    #[error(\"join error\")]\r\n    JoinError(\r\n        #[from]\r\n        #[source]\r\n        tokio::task::JoinError,\r\n    ),\r\n    #[error(\"invalid index\")]\r\n    InvalidIndex,\r\n    #[error(\"{0} not found: {1}\")]\r\n    NotFound(\u0026'static str, String),\r\n    #[error(\"duplicated {0}: {1}\")]\r\n    Duplicated(\u0026'static str, String),\r\n    #[error(\"columns empty\")]\r\n    ColumnsEmpty,\r\n    #[error(\"unsupported statement {0}\")]\r\n    UnsupportedStmt(String),\r\n    #[error(\"invalid table {0}\")]\r\n    InvalidTable(String),\r\n    #[error(\"invalid column {0}\")]\r\n    InvalidColumn(String),\r\n    #[error(\"ambiguous column {0}\")]\r\n    AmbiguousColumn(String),\r\n    #[error(\"values length not match, expect {0}, got {1}\")]\r\n    ValuesLenMismatch(usize, usize),\r\n    #[error(\"values list must all be the same length\")]\r\n    ValuesLenNotSame(),\r\n    #[error(\"binary operator types mismatch: {0} != {1}\")]\r\n    BinaryOpTypeMismatch(String, String),\r\n    #[error(\"subquery error: {0}\")]\r\n    Subquery(String),\r\n    #[error(\"agg miss: {0}\")]\r\n    AggMiss(String),\r\n    #[error(\"copy error: {0}\")]\r\n    UnsupportedCopySource(String),\r\n    #[error(\"can not compare two types: {0} and {1}\")]\r\n    Incomparable(LogicalType, LogicalType),\r\n\r\n    #[error(\"transaction already exists\")]\r\n    TransactionAlreadyExists,\r\n    #[error(\"no transaction begin\")]\r\n    NoTransactionBegin,\r\n\r\n    #[error(\"W-W conflict error\")]\r\n    Serialization,\r\n    #[error(\"{0}\")]\r\n    InternalError(String),\r\n    #[error(\"type cast error {0}\")]\r\n    CastError(\r\n        #[from]\r\n        #[source]\r\n        TryFromSliceError,\r\n    ),\r\n\r\n    #[error(\"sled error {0}\")]\r\n    SledError(\r\n        #[from]\r\n        #[source]\r\n        sled::Error,\r\n    ),\r\n    #[error(\"csv error: {0}\")]\r\n    Csv(\r\n        #[from]\r\n        #[source]\r\n        csv::Error,\r\n    ),\r\n    #[error(\"the {0} cannot support {1} for calculations\")]\r\n    UnsupportedBinaryOperator(LogicalType, BinaryOperator),\r\n\r\n    #[error(\"the DDL must run in serial,already running in: {0} transaction\")]\r\n    DDLSerialError(usize),\r\n\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","execution","executor","ddl","alter_table.rs"],"content":"use crate::execution::executor::{build, DatabaseError, Source};\r\nuse crate::planner::operator::alter_table::{AddColumnOperator, DropColumnOperator};\r\n\r\nuse crate::planner::LogicalPlan;\r\nuse crate::types::tuple_builder::TupleBuilder;\r\nuse crate::types::value::DataValue;\r\n\r\nuse std::sync::Arc;\r\n\r\nuse crate::types::index::Index;\r\nuse crate::{execution::executor::Executor, storage::Transaction};\r\n\r\npub struct AddColumn {\r\n    op: AddColumnOperator,\r\n    input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(AddColumnOperator, LogicalPlan)\u003e for AddColumn {\r\n    fn from((op, input): (AddColumnOperator, LogicalPlan)) -\u003e Self {\r\n        Self { op, input }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for AddColumn {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let AddColumn { op, input } = self;\r\n        let mut input = build(input, transaction)?;\r\n        let mut unique_values = op.column.desc().is_unique.then(Vec::new);\r\n\r\n        for tuple in input.iter_mut() {\r\n            // tuple.columns.push(Arc::new(column.clone()));\r\n            if let Some(value) = op.column.default_value() {\r\n                if let Some(unique_values) = \u0026mut unique_values {\r\n                    unique_values.push((tuple.id.clone().unwrap(), value.clone()));\r\n                }\r\n                tuple.values.push(value);\r\n            } else {\r\n                tuple.values.push(Arc::new(DataValue::Null));\r\n            }\r\n            transaction.append(\u0026op.table_name, tuple.clone(), true)?;\r\n        }\r\n        let col_id = transaction.add_column(\u0026op.table_name, \u0026op.column, op.if_not_exists)?;\r\n\r\n        // Unique Index\r\n        let table = transaction\r\n            .table(op.table_name.clone())\r\n            .expect(\"table fetch error\");\r\n        let unique_meta = table.get_unique_index(\u0026col_id).cloned();\r\n        if let (Some(unique_values), Some(unique_meta)) = (unique_values, unique_meta) {\r\n            for (tuple_id, value) in unique_values {\r\n                let index = Index {\r\n                    id: unique_meta.id,\r\n                    column_values: vec![value],\r\n                };\r\n                transaction.add_index(\u0026op.table_name, index, vec![tuple_id], true)?;\r\n            }\r\n        }\r\n\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple = tuple_builder.push_result(\"ALTER TABLE SUCCESS\", \"1\")?;\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n\r\npub struct DropColumn {\r\n    op: DropColumnOperator,\r\n    input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(DropColumnOperator, LogicalPlan)\u003e for DropColumn {\r\n    fn from((op, input): (DropColumnOperator, LogicalPlan)) -\u003e Self {\r\n        Self { op, input }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for DropColumn {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let DropColumnOperator {\r\n            table_name,\r\n            column_name,\r\n            if_exists,\r\n        } = \u0026self.op;\r\n        let DropColumn { mut input, .. } = self;\r\n        let schema = input.output_schema().clone();\r\n        let mut input = build(input, transaction)?;\r\n        let mut option_column_index = None;\r\n\r\n        for tuple in input.iter_mut() {\r\n            if option_column_index.is_none() {\r\n                if let Some((column_index, is_primary)) = schema\r\n                    .iter()\r\n                    .enumerate()\r\n                    .find(|(_, column)| column.name() == column_name)\r\n                    .map(|(i, column)| (i, column.desc.is_primary))\r\n                {\r\n                    if is_primary {\r\n                        Err(DatabaseError::InvalidColumn(\r\n                            \"drop of primary key column is not allowed.\".to_owned(),\r\n                        ))?;\r\n                    }\r\n                    option_column_index = Some(column_index);\r\n                }\r\n            }\r\n            if option_column_index.is_none() \u0026\u0026 *if_exists {\r\n                return Ok(vec![]);\r\n            }\r\n            let column_index = option_column_index\r\n                .ok_or_else(|| DatabaseError::InvalidColumn(\"not found column\".to_string()))?;\r\n\r\n            let _ = tuple.values.remove(column_index);\r\n\r\n            transaction.append(table_name, tuple.clone(), true)?;\r\n        }\r\n        transaction.drop_column(table_name, column_name, *if_exists)?;\r\n\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple = tuple_builder.push_result(\"ALTER TABLE SUCCESS\", \"1\")?;\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":54},{"path":["E:","\\","sql-layer","src","execution","executor","ddl","create_index.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::planner::operator::create_index::CreateIndexOperator;\r\nuse crate::storage::Transaction;\r\n\r\nuse crate::types::tuple_builder::TupleBuilder;\r\n\r\npub struct CreateIndex {\r\n    op: CreateIndexOperator,\r\n}\r\n\r\nimpl From\u003cCreateIndexOperator\u003e for CreateIndex {\r\n    fn from(op: CreateIndexOperator) -\u003e Self {\r\n        CreateIndex { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for CreateIndex {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let CreateIndexOperator {\r\n            table_name,\r\n            index_name,\r\n            col_name,\r\n        } = self.op;\r\n        let _ = transaction.create_index(table_name.clone(), index_name, \u0026col_name)?;\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple = tuple_builder\r\n            .push_result(\"CREATE INDEX SUCCESS\", format!(\"{}\", table_name).as_str())?;\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["E:","\\","sql-layer","src","execution","executor","ddl","create_table.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::planner::operator::create_table::CreateTableOperator;\r\nuse crate::storage::Transaction;\r\n\r\nuse crate::types::tuple_builder::TupleBuilder;\r\n\r\npub struct CreateTable {\r\n    op: CreateTableOperator,\r\n}\r\n\r\nimpl From\u003cCreateTableOperator\u003e for CreateTable {\r\n    fn from(op: CreateTableOperator) -\u003e Self {\r\n        CreateTable { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for CreateTable {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let CreateTableOperator {\r\n            table_name,\r\n            columns,\r\n            if_not_exists,\r\n        } = self.op;\r\n        let _ = transaction.create_table(table_name.clone(), columns, if_not_exists)?;\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple =\r\n            tuple_builder.push_result(\"CREATE TABLE\", format!(\"{}\", table_name).as_str())?;\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null}],"covered":11,"coverable":12},{"path":["E:","\\","sql-layer","src","execution","executor","ddl","drop_index.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::planner::operator::drop_index::DropIndexOperator;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple_builder::TupleBuilder;\r\n\r\npub struct DropIndex {\r\n    op: DropIndexOperator,\r\n}\r\n\r\nimpl From\u003cDropIndexOperator\u003e for DropIndex {\r\n    fn from(op: DropIndexOperator) -\u003e Self {\r\n        DropIndex { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for DropIndex {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let DropIndexOperator {\r\n            index_name,\r\n            table_name,\r\n            if_exists,\r\n        } = self.op;\r\n\r\n        transaction.drop_index(table_name, index_name.clone(), if_exists)?;\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple =\r\n            tuple_builder.push_result(\"DROP INDEX SUCCESS\", format!(\"{}\", index_name).as_str())?;\r\n\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["E:","\\","sql-layer","src","execution","executor","ddl","drop_table.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::planner::operator::drop_table::DropTableOperator;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple_builder::TupleBuilder;\r\n\r\npub struct DropTable {\r\n    op: DropTableOperator,\r\n}\r\n\r\nimpl From\u003cDropTableOperator\u003e for DropTable {\r\n    fn from(op: DropTableOperator) -\u003e Self {\r\n        DropTable { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for DropTable {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let DropTableOperator {\r\n            table_name,\r\n            if_exists,\r\n        } = self.op;\r\n\r\n        transaction.drop_table(\u0026table_name.clone(), if_exists)?;\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple =\r\n            tuple_builder.push_result(\"DROP TABLE SUCCESS\", format!(\"{}\", table_name).as_str())?;\r\n\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":10,"coverable":11},{"path":["E:","\\","sql-layer","src","execution","executor","ddl","mod.rs"],"content":"pub(crate) mod alter_table;\npub(crate) mod create_index;\npub(crate) mod create_table;\npub(crate) mod drop_index;\npub(crate) mod drop_table;\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","execution","executor","dml","copy.rs"],"content":"use crate::binder::copy::FileFormat;\r\nuse crate::errors::*;\r\nuse crate::execution::executor::{Executor, Source};\r\nuse crate::planner::operator::copy_from_file::CopyFromFileOperator;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::tuple_builder::TupleBuilder;\r\nuse csv::Terminator;\r\nuse itertools::Itertools;\r\nuse std::fs::File;\r\nuse std::io::BufReader;\r\nuse tracing::debug;\r\n#[allow(dead_code)]\r\npub struct CopyFromFile {\r\n    op: CopyFromFileOperator,\r\n    size: usize,\r\n}\r\nimpl From\u003cCopyFromFileOperator\u003e for CopyFromFile {\r\n    fn from(op: CopyFromFileOperator) -\u003e Self {\r\n        CopyFromFile { op, size: 0 }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for CopyFromFile {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let table_name = self.op.table.clone();\r\n        let tuples = self.read_file_blocking()?;\r\n        let mut size = 0_usize;\r\n        for tuple in tuples {\r\n            transaction.append(\u0026table_name, tuple, false)?;\r\n            size += 1;\r\n        }\r\n\r\n        let res = return_result(size)?;\r\n        Ok(vec![res])\r\n    }\r\n}\r\nfn return_result(size: usize) -\u003e Result\u003cTuple\u003e {\r\n    let builder = TupleBuilder::new_result();\r\n    let tuple = builder.push_result(\"COPY FROM SOURCE\", \u0026format!(\"import {} rows\", size))?;\r\n\r\n    Ok(tuple)\r\n}\r\n\r\nimpl CopyFromFile {\r\n    /// Read records from file using blocking IO.\r\n    fn read_file_blocking(mut self) -\u003e Result\u003cVec\u003cTuple\u003e\u003e {\r\n        let file = File::open(self.op.source.path)?;\r\n        let mut buf_reader = BufReader::new(file);\r\n        let mut reader = match self.op.source.format {\r\n            FileFormat::Csv {\r\n                delimiter: _,\r\n                quote,\r\n                escape,\r\n                header,\r\n            } =\u003e csv::ReaderBuilder::new()\r\n                .delimiter(b'|')\r\n                .quote(quote as u8)\r\n                .escape(escape.map(|c| c as u8))\r\n                .has_headers(header)\r\n                .terminator(Terminator::CRLF)\r\n                .from_reader(\u0026mut buf_reader),\r\n        };\r\n\r\n        let column_count = self.op.schema_ref.len();\r\n\r\n        debug!(\"column count: {}\", column_count);\r\n        let tuple_builder = TupleBuilder::new(self.op.schema_ref.clone());\r\n        let mut tuples = vec![];\r\n        for record in reader.records() {\r\n            // read records and push raw str rows into data chunk builder\r\n            let record = record?;\r\n\r\n            if !(record.len() == column_count\r\n                || record.len() == column_count + 1 \u0026\u0026 record.get(column_count) == Some(\"\"))\r\n            {\r\n                return Err(DatabaseError::LengthMismatch {\r\n                    expected: column_count,\r\n                    actual: record.len(),\r\n                });\r\n            }\r\n\r\n            self.size += 1;\r\n            tuples.push(tuple_builder.build_with_row(record.iter().take(column_count))?);\r\n        }\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":28},{"path":["E:","\\","sql-layer","src","execution","executor","dml","delete.rs"],"content":"use crate::catalog::TableName;\r\nuse crate::execution::executor::{build, Executor, Source};\r\n\r\nuse crate::planner::operator::delete::DeleteOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::index::Index;\r\nuse crate::types::tuple_builder::TupleBuilder;\r\n\r\nuse itertools::Itertools;\r\n\r\npub struct Delete {\r\n    table_name: TableName,\r\n    input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(DeleteOperator, LogicalPlan)\u003e for Delete {\r\n    fn from((DeleteOperator { table_name }, input): (DeleteOperator, LogicalPlan)) -\u003e Self {\r\n        Delete { table_name, input }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Delete {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let Delete { table_name, input } = self;\r\n        let input = build(input, transaction)?;\r\n        let option_index_metas = transaction.table(table_name.clone()).map(|table_catalog| {\r\n            table_catalog\r\n                .all_columns()\r\n                .into_iter()\r\n                .enumerate()\r\n                .filter_map(|(i, col)| {\r\n                    col.desc\r\n                        .is_unique\r\n                        .then(|| {\r\n                            col.id().and_then(|col_id| {\r\n                                table_catalog\r\n                                    .get_unique_index(\u0026col_id)\r\n                                    .map(|index_meta| (i, index_meta.clone()))\r\n                            })\r\n                        })\r\n                        .flatten()\r\n                })\r\n                .collect_vec()\r\n        });\r\n        if let Some(index_metas) = option_index_metas {\r\n            for tuple in input.iter() {\r\n                for (i, index_meta) in index_metas.iter() {\r\n                    let value = \u0026tuple.values[*i];\r\n\r\n                    if !value.is_null() {\r\n                        let index = Index {\r\n                            id: index_meta.id,\r\n                            column_values: vec![value.clone()],\r\n                        };\r\n\r\n                        transaction.del_index(\u0026table_name, \u0026index)?;\r\n                    }\r\n                }\r\n\r\n                if let Some(tuple_id) = tuple.id.clone() {\r\n                    transaction.delete(\u0026table_name, tuple_id)?;\r\n                }\r\n            }\r\n        }\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple = tuple_builder.push_result(\"DELETE SUCCESS\", \u0026format!(\"{}\", input.len()))?;\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927938},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":23,"coverable":32},{"path":["E:","\\","sql-layer","src","execution","executor","dml","insert.rs"],"content":"use crate::catalog::TableName;\r\nuse crate::errors::*;\r\nuse crate::execution::executor::{build, Executor, Source};\r\nuse crate::planner::operator::insert::InsertOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::index::Index;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::tuple_builder::TupleBuilder;\r\nuse crate::types::value::DataValue;\r\n\r\nuse std::collections::HashMap;\r\nuse std::sync::Arc;\r\n\r\npub struct Insert {\r\n    table_name: TableName,\r\n    input: LogicalPlan,\r\n    is_overwrite: bool,\r\n}\r\n\r\nimpl From\u003c(InsertOperator, LogicalPlan)\u003e for Insert {\r\n    fn from(\r\n        (\r\n            InsertOperator {\r\n                table_name,\r\n                is_overwrite,\r\n            },\r\n            input,\r\n        ): (InsertOperator, LogicalPlan),\r\n    ) -\u003e Self {\r\n        Insert {\r\n            table_name,\r\n            input,\r\n            is_overwrite,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Insert {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let Insert {\r\n            table_name,\r\n            mut input,\r\n            is_overwrite,\r\n        } = self;\r\n        let schema = input.output_schema().clone();\r\n        let input = build(input, transaction)?;\r\n        let mut primary_key_index = None;\r\n        let mut unique_values = HashMap::new();\r\n        if let Some(table_catalog) = transaction.table(table_name.clone()) {\r\n            for tuple in input.iter() {\r\n                let Tuple { values, .. } = tuple;\r\n                let mut tuple_map = HashMap::new();\r\n                for (i, value) in values.iter().enumerate() {\r\n                    let col = \u0026schema[i];\r\n\r\n                    if let Some(col_id) = col.id() {\r\n                        tuple_map.insert(col_id, value.clone());\r\n                    }\r\n                }\r\n                let primary_col_id = primary_key_index.get_or_insert_with(|| {\r\n                    schema\r\n                        .iter()\r\n                        .find(|col| col.desc.is_primary)\r\n                        .map(|col| col.id().unwrap())\r\n                });\r\n                let all_columns = table_catalog.all_columns_with_id();\r\n                let tuple_id = match primary_col_id {\r\n                    Some(primary_col_id) =\u003e tuple_map.get(primary_col_id).cloned(),\r\n                    None =\u003e None,\r\n                };\r\n\r\n                // tuple_map.get(primary_col_id).cloned().unwrap();\r\n                let mut tuple = Tuple {\r\n                    id: tuple_id.clone(),\r\n                    values: Vec::with_capacity(all_columns.len()),\r\n                };\r\n                for (col_id, col) in all_columns {\r\n                    let value = tuple_map\r\n                        .remove(col_id)\r\n                        .or_else(|| col.default_value())\r\n                        .unwrap_or_else(|| Arc::new(DataValue::none(col.datatype())));\r\n\r\n                    if col.desc.is_unique \u0026\u0026 !value.is_null() {\r\n                        unique_values\r\n                            .entry(col.id())\r\n                            .or_insert_with(Vec::new)\r\n                            .push((tuple_id.clone(), value.clone()))\r\n                    }\r\n                    if value.is_null() \u0026\u0026 !col.nullable {\r\n                        return Err(DatabaseError::InternalError(format!(\r\n                            \"Non-null fields do not allow null values to be passed in: {:?}\",\r\n                            col\r\n                        )));\r\n                    }\r\n\r\n                    tuple.values.push(value)\r\n                }\r\n\r\n                transaction.append(\u0026table_name, tuple, is_overwrite)?;\r\n            }\r\n            // Unique Index\r\n            for (col_id, values) in unique_values {\r\n                if let Some(index_meta) = table_catalog.get_unique_index(\u0026col_id.unwrap()) {\r\n                    for (tuple_id, value) in values {\r\n                        let index = Index {\r\n                            id: index_meta.id,\r\n                            column_values: vec![value],\r\n                        };\r\n\r\n                        transaction.add_index(\u0026table_name, index, vec![tuple_id.unwrap()], true)?;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple = tuple_builder.push_result(\"INSERT SUCCESS\", \u0026format!(\"{}\", input.len()))?;\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":5188146770730811392},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6341068275337658368},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null}],"covered":42,"coverable":55},{"path":["E:","\\","sql-layer","src","execution","executor","dml","mod.rs"],"content":"pub(crate) mod copy;\r\npub(crate) mod delete;\r\npub(crate) mod insert;\r\npub(crate) mod update;\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","execution","executor","dml","update.rs"],"content":"use crate::catalog::{ColumnCatalog, TableName};\r\n\r\nuse crate::execution::executor::{build, Executor, Source};\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::update::UpdateOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::index::Index;\r\nuse crate::types::tuple_builder::TupleBuilder;\r\n\r\nuse std::collections::HashSet;\r\nuse std::sync::Arc;\r\n\r\npub struct Update {\r\n    table_name: TableName,\r\n    input: LogicalPlan, //select source for update\r\n    columns: Vec\u003cArc\u003cColumnCatalog\u003e\u003e,\r\n    set_expr: Vec\u003cScalarExpression\u003e,\r\n}\r\n\r\nimpl From\u003c(UpdateOperator, LogicalPlan)\u003e for Update {\r\n    fn from(\r\n        (\r\n            UpdateOperator {\r\n                columns,\r\n                set_expr,\r\n                table_name,\r\n            },\r\n            input,\r\n        ): (UpdateOperator, LogicalPlan),\r\n    ) -\u003e Self {\r\n        Update {\r\n            table_name,\r\n            input,\r\n            columns,\r\n            set_expr,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Update {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let Update {\r\n            table_name,\r\n            mut input,\r\n            columns,\r\n            set_expr,\r\n        } = self;\r\n        let schema = input.output_schema().clone();\r\n        let input = build(input, transaction)?;\r\n        let input_len = input.len();\r\n\r\n        if let Some(table_catalog) = transaction.table(table_name.clone()) {\r\n            //halloween\r\n            let mut update_col = HashSet::new();\r\n            let mut update_batch = vec![];\r\n            let mut index_update_batch = vec![];\r\n\r\n            for col in columns.iter() {\r\n                update_col.insert(col.id());\r\n            }\r\n\r\n            //Seqscan\r\n            for tuple in input {\r\n                let mut is_overwrite = true;\r\n\r\n                let mut tuple = tuple;\r\n                // eprintln!(\"tuple:{}\", tuple);\r\n\r\n                for (i, column) in schema\r\n                    .iter()\r\n                    .filter(|col| update_col.contains(\u0026col.id()))\r\n                    .enumerate()\r\n                {\r\n                    let value = set_expr[i].eval(\u0026tuple, \u0026schema)?;\r\n\r\n                    if column.desc.is_primary {\r\n                        //refuse to update primary key\r\n                        let old_key = tuple.id.replace(value.clone()).unwrap();\r\n                        transaction.delete(\u0026table_name, old_key)?;\r\n                        is_overwrite = false;\r\n                        // return Err(DatabaseError::InternalError(\"Update Primary key\".into()));\r\n                    }\r\n                    //\r\n                    if column.desc.is_unique \u0026\u0026 value != tuple.values[column.id().unwrap() as usize]\r\n                    {\r\n                        if let Some(index_meta) =\r\n                            table_catalog.get_unique_index(\u0026column.id().unwrap())\r\n                        {\r\n                            let mut index = Index {\r\n                                id: index_meta.id,\r\n                                column_values: vec![tuple.values[i].clone()],\r\n                            };\r\n                            transaction.del_index(\u0026table_name, \u0026index)?;\r\n\r\n                            if !value.is_null() {\r\n                                index.column_values[0] = value.clone();\r\n                                // transaction.add_index(\r\n                                //     \u0026table_name,\r\n                                //     index,\r\n                                //     vec![tuple.id.clone().unwrap()],\r\n                                //     true,\r\n                                // )?;\r\n                                index_update_batch.push((\r\n                                    index,\r\n                                    vec![tuple.id.clone().unwrap()],\r\n                                    true,\r\n                                ));\r\n                            }\r\n                        }\r\n                    }\r\n                    // transaction.delete(\u0026table_name, tuple.id.clone().unwrap())?;\r\n                    tuple.values[column.id().unwrap() as usize] = value.clone();\r\n                }\r\n                update_batch.push((tuple, is_overwrite));\r\n                // transaction.append(\u0026table_name, tuple.clone(), is_overwrite)?;\r\n            }\r\n            for index_item in index_update_batch {\r\n                transaction.add_index(\u0026table_name, index_item.0, index_item.1, index_item.2)?;\r\n            }\r\n            for tuple in update_batch {\r\n                transaction.append(\u0026table_name, tuple.0, tuple.1)?;\r\n            }\r\n        }\r\n        let tuple_builder = TupleBuilder::new_result();\r\n        let tuple = tuple_builder.push_result(\"DELETE SUCCESS\", \u0026format!(\"{}\", input_len))?;\r\n\r\n        Ok(vec![tuple])\r\n    }\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null}],"covered":33,"coverable":50},{"path":["E:","\\","sql-layer","src","execution","executor","dql","agg","avg.rs"],"content":"use crate::errors::*;\r\nuse crate::expression::BinaryOperator;\r\nuse crate::types::value::{DataValue, ValueRef};\r\nuse crate::types::LogicalType;\r\nuse std::sync::Arc;\r\n\r\nuse super::sum::SumAccumulator;\r\nuse super::Accumulator;\r\n\r\npub struct AvgAccumulator {\r\n    inner: SumAccumulator,\r\n    count: usize,\r\n}\r\n\r\nimpl AvgAccumulator {\r\n    pub fn new(ty: \u0026LogicalType) -\u003e Self {\r\n        Self {\r\n            inner: SumAccumulator::new(ty),\r\n            count: 0,\r\n        }\r\n    }\r\n}\r\n\r\nimpl Accumulator for AvgAccumulator {\r\n    fn update_value(\u0026mut self, value: \u0026ValueRef) -\u003e Result\u003c()\u003e {\r\n        if !value.is_null() {\r\n            self.inner.update_value(value)?;\r\n            self.count += 1;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn evaluate(\u0026self) -\u003e Result\u003cValueRef\u003e {\r\n        let value = self.inner.evaluate()?;\r\n\r\n        let quantity = if value.logical_type().is_signed_numeric() {\r\n            DataValue::Int64(Some(self.count as i64))\r\n        } else {\r\n            DataValue::UInt32(Some(self.count as u32))\r\n        };\r\n\r\n        Ok(Arc::new(DataValue::binary_op(\r\n            \u0026value,\r\n            \u0026quantity,\r\n            \u0026BinaryOperator::Divide,\r\n        )?))\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":11,"coverable":12},{"path":["E:","\\","sql-layer","src","execution","executor","dql","agg","count.rs"],"content":"use crate::types::value::{DataValue, ValueRef};\r\nuse ahash::RandomState;\r\nuse std::collections::HashSet;\r\nuse std::sync::Arc;\r\n\r\nuse super::Accumulator;\r\nuse crate::errors::*;\r\n\r\npub struct CountAccumulator {\r\n    result: i32,\r\n}\r\n\r\nimpl CountAccumulator {\r\n    pub fn new() -\u003e Self {\r\n        Self { result: 0 }\r\n    }\r\n}\r\n\r\nimpl Accumulator for CountAccumulator {\r\n    fn update_value(\u0026mut self, value: \u0026ValueRef) -\u003e Result\u003c()\u003e {\r\n        if !value.is_null() {\r\n            self.result += 1;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn evaluate(\u0026self) -\u003e Result\u003cValueRef\u003e {\r\n        Ok(Arc::new(DataValue::Int32(Some(self.result))))\r\n    }\r\n}\r\n\r\npub struct DistinctCountAccumulator {\r\n    distinct_values: HashSet\u003cValueRef, RandomState\u003e,\r\n}\r\n\r\nimpl DistinctCountAccumulator {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            distinct_values: HashSet::default(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Accumulator for DistinctCountAccumulator {\r\n    fn update_value(\u0026mut self, value: \u0026ValueRef) -\u003e Result\u003c()\u003e {\r\n        if !value.is_null() {\r\n            self.distinct_values.insert(value.clone());\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn evaluate(\u0026self) -\u003e Result\u003cValueRef\u003e {\r\n        Ok(Arc::new(DataValue::Int32(Some(\r\n            self.distinct_values.len() as i32\r\n        ))))\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":16,"coverable":16},{"path":["E:","\\","sql-layer","src","execution","executor","dql","agg","hash_agg.rs"],"content":"use crate::execution::executor::{build, Executor, Source};\r\n\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::aggregate::AggregateOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::value::ValueRef;\r\nuse ahash::{HashMap, HashMapExt};\r\n\r\nuse itertools::Itertools;\r\n\r\nuse super::create_accumulators;\r\n\r\npub struct HashAggExecutor {\r\n    pub agg_calls: Vec\u003cScalarExpression\u003e,\r\n    pub groupby_exprs: Vec\u003cScalarExpression\u003e,\r\n    pub input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(AggregateOperator, LogicalPlan)\u003e for HashAggExecutor {\r\n    fn from(\r\n        (\r\n            AggregateOperator {\r\n                agg_calls,\r\n                groupby_exprs,\r\n                ..\r\n            },\r\n            input,\r\n        ): (AggregateOperator, LogicalPlan),\r\n    ) -\u003e Self {\r\n        HashAggExecutor {\r\n            agg_calls,\r\n            groupby_exprs,\r\n            input,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for HashAggExecutor {\r\n    fn execute\u003c'a\u003e(self, transaction: \u0026mut T) -\u003e Source {\r\n        let HashAggExecutor {\r\n            agg_calls,\r\n            groupby_exprs,\r\n            mut input,\r\n        } = self;\r\n        let schema = input.output_schema().clone();\r\n        let input = build(input, transaction)?;\r\n        let mut group_and_agg_columns_option = None;\r\n        let mut group_hash_accs = HashMap::new();\r\n        let mut tuples = Vec::new();\r\n\r\n        for tuple in input {\r\n            // 1. build group and agg columns for hash_agg columns.\r\n            // Tips: AggCall First\r\n            group_and_agg_columns_option.get_or_insert_with(|| {\r\n                agg_calls\r\n                    .iter()\r\n                    .chain(groupby_exprs.iter())\r\n                    .map(|expr| expr.output_columns())\r\n                    .collect_vec()\r\n            });\r\n\r\n            // 2.1 evaluate agg exprs and collect the result values for later accumulators.\r\n            let values: Vec\u003cValueRef\u003e = agg_calls\r\n                .iter()\r\n                .map(|expr| {\r\n                    if let ScalarExpression::AggCall { args, .. } = expr {\r\n                        args[0].eval(\u0026tuple, \u0026schema)\r\n                    } else {\r\n                        unreachable!()\r\n                    }\r\n                })\r\n                .try_collect()?;\r\n\r\n            let group_keys: Vec\u003cValueRef\u003e = groupby_exprs\r\n                .iter()\r\n                .map(|expr| expr.eval(\u0026tuple, \u0026schema))\r\n                .try_collect()?;\r\n\r\n            for (acc, value) in group_hash_accs\r\n                .entry(group_keys)\r\n                .or_insert_with(|| create_accumulators(\u0026agg_calls))\r\n                .iter_mut()\r\n                .zip_eq(values.iter())\r\n            {\r\n                acc.update_value(value)?;\r\n            }\r\n        }\r\n        if let Some(_group_and_agg_columns) = group_and_agg_columns_option {\r\n            for (group_keys, accs) in group_hash_accs {\r\n                // Tips: Accumulator First\r\n                let values: Vec\u003cValueRef\u003e = accs\r\n                    .iter()\r\n                    .map(|acc| acc.evaluate())\r\n                    .chain(group_keys.into_iter().map(Ok))\r\n                    .try_collect()?;\r\n                tuples.push(Tuple { id: None, values });\r\n            }\r\n        }\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":216172782113792369},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":216172782113792369},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":216172782113792369},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":216172782113792369},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":216172782113792369},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":216172782113792369},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":216172782113792369},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":432345564227584738},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1369094286720647906},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":576460752303432049},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":576460752303432049},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null}],"covered":30,"coverable":39},{"path":["E:","\\","sql-layer","src","execution","executor","dql","agg","min_max.rs"],"content":"use crate::expression::BinaryOperator;\r\nuse crate::types::value::{DataValue, ValueRef};\r\nuse crate::types::LogicalType;\r\nuse std::sync::Arc;\r\n\r\nuse super::Accumulator;\r\nuse crate::errors::*;\r\n\r\npub struct MinMaxAccumulator {\r\n    inner: Option\u003cValueRef\u003e,\r\n    op: BinaryOperator,\r\n    ty: LogicalType,\r\n}\r\n\r\nimpl MinMaxAccumulator {\r\n    pub fn new(ty: \u0026LogicalType, is_max: bool) -\u003e Self {\r\n        let op = if is_max {\r\n            BinaryOperator::Lt\r\n        } else {\r\n            BinaryOperator::Gt\r\n        };\r\n\r\n        Self {\r\n            inner: None,\r\n            op,\r\n            ty: *ty,\r\n        }\r\n    }\r\n}\r\n\r\nimpl Accumulator for MinMaxAccumulator {\r\n    fn update_value(\u0026mut self, value: \u0026ValueRef) -\u003e Result\u003c()\u003e {\r\n        if !value.is_null() {\r\n            if let Some(inner_value) = \u0026self.inner {\r\n                if let DataValue::Boolean(Some(result)) =\r\n                    DataValue::binary_op(inner_value, value, \u0026self.op)?\r\n                {\r\n                    result\r\n                } else {\r\n                    unreachable!()\r\n                }\r\n            } else {\r\n                true\r\n            }\r\n            .then(|| self.inner = Some(value.clone()));\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn evaluate(\u0026self) -\u003e Result\u003cValueRef\u003e {\r\n        Ok(self\r\n            .inner\r\n            .clone()\r\n            .unwrap_or_else(|| Arc::new(DataValue::none(\u0026self.ty))))\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":504403158265495811},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":1008806316530991622},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037928195},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null}],"covered":17,"coverable":18},{"path":["E:","\\","sql-layer","src","execution","executor","dql","agg","mod.rs"],"content":"mod avg;\r\nmod count;\r\npub mod hash_agg;\r\nmod min_max;\r\npub mod simple_agg;\r\nmod sum;\r\nuse crate::errors::*;\r\n\r\nuse crate::expression::agg::Aggregate;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::types::value::ValueRef;\r\n\r\nuse self::{\r\n    avg::AvgAccumulator,\r\n    count::{CountAccumulator, DistinctCountAccumulator},\r\n    min_max::MinMaxAccumulator,\r\n    sum::{DistinctSumAccumulator, SumAccumulator},\r\n};\r\n\r\n/// Tips: Idea for sqlrs\r\n/// An accumulator represents a stateful object that lives throughout the evaluation of multiple\r\n/// rows and generically accumulates values.\r\npub trait Accumulator: Send + Sync {\r\n    /// updates the accumulator's state from a vector of arrays.\r\n    fn update_value(\u0026mut self, value: \u0026ValueRef) -\u003e Result\u003c()\u003e;\r\n\r\n    /// returns its value based on its current state.\r\n    fn evaluate(\u0026self) -\u003e Result\u003cValueRef\u003e;\r\n}\r\n\r\nfn create_accumulator(expr: \u0026ScalarExpression) -\u003e Box\u003cdyn Accumulator\u003e {\r\n    if let ScalarExpression::AggCall {\r\n        kind, ty, distinct, ..\r\n    } = expr\r\n    {\r\n        match (kind, distinct) {\r\n            (Aggregate::Count, false) =\u003e Box::new(CountAccumulator::new()),\r\n            (Aggregate::Count, true) =\u003e Box::new(DistinctCountAccumulator::new()),\r\n            (Aggregate::Sum, false) =\u003e Box::new(SumAccumulator::new(ty)),\r\n            (Aggregate::Sum, true) =\u003e Box::new(DistinctSumAccumulator::new(ty)),\r\n            (Aggregate::Min, _) =\u003e Box::new(MinMaxAccumulator::new(ty, false)),\r\n            (Aggregate::Max, _) =\u003e Box::new(MinMaxAccumulator::new(ty, true)),\r\n            (Aggregate::Avg, _) =\u003e Box::new(AvgAccumulator::new(ty)),\r\n        }\r\n    } else {\r\n        unreachable!(\r\n            \"create_accumulator called with non-aggregate expression {:?}\",\r\n            expr\r\n        );\r\n    }\r\n}\r\n\r\nfn create_accumulators(exprs: \u0026[ScalarExpression]) -\u003e Vec\u003cBox\u003cdyn Accumulator\u003e\u003e {\r\n    exprs.iter().map(create_accumulator).collect()\r\n}\r\n","traces":[{"line":53,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null}],"covered":2,"coverable":2},{"path":["E:","\\","sql-layer","src","execution","executor","dql","agg","simple_agg.rs"],"content":"use crate::execution::executor::{build, Executor, Source};\r\n\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::aggregate::AggregateOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::value::ValueRef;\r\n\r\nuse itertools::Itertools;\r\n\r\nuse super::create_accumulators;\r\n\r\npub struct SimpleAggExecutor {\r\n    pub agg_calls: Vec\u003cScalarExpression\u003e,\r\n    pub input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(AggregateOperator, LogicalPlan)\u003e for SimpleAggExecutor {\r\n    fn from(\r\n        (AggregateOperator { agg_calls, .. }, input): (AggregateOperator, LogicalPlan),\r\n    ) -\u003e Self {\r\n        SimpleAggExecutor { agg_calls, input }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for SimpleAggExecutor {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let SimpleAggExecutor {\r\n            agg_calls,\r\n            mut input,\r\n        } = self;\r\n\r\n        let mut accs = create_accumulators(\u0026agg_calls);\r\n        let mut columns_option = None;\r\n        let mut tuples = Vec::new();\r\n        let schema = input.output_schema().clone();\r\n        let input = build(input, transaction)?;\r\n        for tuple in input {\r\n            columns_option.get_or_insert_with(|| {\r\n                agg_calls\r\n                    .iter()\r\n                    .map(|expr| expr.output_columns())\r\n                    .collect_vec()\r\n            });\r\n\r\n            let values: Vec\u003cValueRef\u003e = agg_calls\r\n                .iter()\r\n                .map(|expr| match expr {\r\n                    ScalarExpression::AggCall { args, .. } =\u003e args[0].eval(\u0026tuple, \u0026schema),\r\n                    _ =\u003e unreachable!(),\r\n                })\r\n                .try_collect()?;\r\n\r\n            for (acc, value) in accs.iter_mut().zip_eq(values.iter()) {\r\n                acc.update_value(value)?;\r\n            }\r\n        }\r\n        if let Some(_columns) = columns_option {\r\n            let values: Vec\u003cValueRef\u003e = accs.into_iter().map(|acc| acc.evaluate()).try_collect()?;\r\n            tuples.push(Tuple { id: None, values });\r\n        }\r\n\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1801439850948198400},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null}],"covered":26,"coverable":27},{"path":["E:","\\","sql-layer","src","execution","executor","dql","agg","sum.rs"],"content":"use crate::errors::*;\r\nuse crate::expression::BinaryOperator;\r\nuse crate::types::value::{DataValue, ValueRef};\r\nuse crate::types::LogicalType;\r\nuse ahash::RandomState;\r\nuse std::collections::HashSet;\r\nuse std::sync::Arc;\r\n\r\nuse super::Accumulator;\r\n\r\npub struct SumAccumulator {\r\n    result: DataValue,\r\n}\r\n\r\nimpl SumAccumulator {\r\n    pub fn new(ty: \u0026LogicalType) -\u003e Self {\r\n        assert!(ty.is_numeric());\r\n\r\n        Self {\r\n            result: DataValue::init(ty),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Accumulator for SumAccumulator {\r\n    fn update_value(\u0026mut self, value: \u0026ValueRef) -\u003e Result\u003c()\u003e {\r\n        if !value.is_null() {\r\n            self.result = DataValue::binary_op(\u0026self.result, value, \u0026BinaryOperator::Plus)?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn evaluate(\u0026self) -\u003e Result\u003cValueRef\u003e {\r\n        Ok(Arc::new(self.result.clone()))\r\n    }\r\n}\r\n\r\npub struct DistinctSumAccumulator {\r\n    distinct_values: HashSet\u003cValueRef, RandomState\u003e,\r\n    inner: SumAccumulator,\r\n}\r\n\r\nimpl DistinctSumAccumulator {\r\n    pub fn new(ty: \u0026LogicalType) -\u003e Self {\r\n        Self {\r\n            distinct_values: HashSet::default(),\r\n            inner: SumAccumulator::new(ty),\r\n        }\r\n    }\r\n}\r\n\r\nimpl Accumulator for DistinctSumAccumulator {\r\n    fn update_value(\u0026mut self, value: \u0026ValueRef) -\u003e Result\u003c()\u003e {\r\n        if !self.distinct_values.contains(value) {\r\n            self.distinct_values.insert(value.clone());\r\n            self.inner.update_value(value)?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn evaluate(\u0026self) -\u003e Result\u003cValueRef\u003e {\r\n        self.inner.evaluate()\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":19,"coverable":19},{"path":["E:","\\","sql-layer","src","execution","executor","dql","describe.rs"],"content":"use crate::catalog::{ColumnCatalog, TableName};\r\nuse crate::execution::executor::{DatabaseError, Executor, Source};\r\nuse crate::planner::operator::describe::DescribeOperator;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::value::{DataValue, ValueRef};\r\nuse lazy_static::lazy_static;\r\n\r\nuse std::sync::Arc;\r\n\r\nlazy_static! {\r\n    static ref PRIMARY_KEY_TYPE: ValueRef =\r\n        Arc::new(DataValue::Utf8(Some(String::from(\"PRIMARY\"))));\r\n    static ref UNIQUE_KEY_TYPE: ValueRef = Arc::new(DataValue::Utf8(Some(String::from(\"UNIQUE\"))));\r\n    static ref EMPTY_KEY_TYPE: ValueRef = Arc::new(DataValue::Utf8(Some(String::from(\"EMPTY\"))));\r\n}\r\n\r\npub struct Describe {\r\n    table_name: TableName,\r\n}\r\n\r\nimpl From\u003cDescribeOperator\u003e for Describe {\r\n    fn from(op: DescribeOperator) -\u003e Self {\r\n        Describe {\r\n            table_name: op.table_name,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Describe {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let table = transaction\r\n            .table(self.table_name.clone())\r\n            .ok_or(DatabaseError::TableNotFound)?;\r\n        let key_fn = |column: \u0026ColumnCatalog| {\r\n            if column.desc.is_primary {\r\n                PRIMARY_KEY_TYPE.clone()\r\n            } else if column.desc.is_unique {\r\n                UNIQUE_KEY_TYPE.clone()\r\n            } else {\r\n                EMPTY_KEY_TYPE.clone()\r\n            }\r\n        };\r\n        let mut tuples = vec![];\r\n        // let schema=vec![\r\n        //     Arc::new(ColumnCatalog::new_dummy(\"FIELD\".to_string())),\r\n        //     Arc::new(ColumnCatalog::new_dummy(\"TYPE\".to_string())),\r\n        //     Arc::new(ColumnCatalog::new_dummy(\"NULL\".to_string())),\r\n        //     Arc::new(ColumnCatalog::new_dummy(\"Key\".to_string())),\r\n        //     Arc::new(ColumnCatalog::new_dummy(\"DEFAULT\".to_string())),\r\n        // ];\r\n        for column in table.all_columns() {\r\n            let values = vec![\r\n                Arc::new(DataValue::Utf8(Some(column.name().to_string()))),\r\n                Arc::new(DataValue::Utf8(Some(column.datatype().to_string()))),\r\n                Arc::new(DataValue::Utf8(Some(column.nullable.to_string()))),\r\n                key_fn(\u0026column),\r\n                column\r\n                    .default_value()\r\n                    .unwrap_or_else(|| Arc::new(DataValue::none(column.datatype()))),\r\n            ];\r\n            tuples.push(Tuple { id: None, values });\r\n        }\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":50},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":24},{"path":["E:","\\","sql-layer","src","execution","executor","dql","dummy.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\n\r\npub struct Dummy {}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Dummy {\r\n    fn execute(self, _transaction: \u0026mut T) -\u003e Source {\r\n        Ok(vec![Tuple {\r\n            id: None,\r\n            values: vec![],\r\n        }])\r\n    }\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["E:","\\","sql-layer","src","execution","executor","dql","explain.rs"],"content":"use std::sync::Arc;\r\n\r\nuse crate::{\r\n    execution::executor::{Executor, Source},\r\n    planner::LogicalPlan,\r\n    storage::Transaction,\r\n    types::{tuple::Tuple, value::DataValue},\r\n};\r\n\r\npub struct Explain {\r\n    plan: LogicalPlan,\r\n}\r\nimpl From\u003cLogicalPlan\u003e for Explain {\r\n    fn from(plan: LogicalPlan) -\u003e Self {\r\n        Explain { plan }\r\n    }\r\n}\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Explain {\r\n    fn execute(self, _: \u0026mut T) -\u003e Source {\r\n        let values = vec![Arc::new(DataValue::Utf8(Some(self.plan.explain(0))))];\r\n        Ok(vec![Tuple { id: None, values }])\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["E:","\\","sql-layer","src","execution","executor","dql","filter.rs"],"content":"use crate::execution::executor::{build, Executor, Source};\r\n\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::filter::FilterOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\nuse crate::types::value::DataValue;\r\n\r\npub struct Filter {\r\n    predicate: ScalarExpression,\r\n    input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(FilterOperator, LogicalPlan)\u003e for Filter {\r\n    fn from((FilterOperator { predicate, .. }, input): (FilterOperator, LogicalPlan)) -\u003e Self {\r\n        Filter { predicate, input }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Filter {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let Filter {\r\n            predicate,\r\n            mut input,\r\n        } = self;\r\n        let mut tuples = Vec::new();\r\n        let schema = input.output_schema().clone();\r\n        let input = build(input, transaction)?;\r\n        for tuple in input {\r\n            if let DataValue::Boolean(option) = predicate.eval(\u0026tuple, \u0026schema)?.as_ref() {\r\n                if let Some(true) = option {\r\n                    tuples.push(tuple.clone());\r\n                } else {\r\n                    continue;\r\n                }\r\n            } else {\r\n                unreachable!(\"only bool\");\r\n            }\r\n        }\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":864691128455135233},"fn_name":null}],"covered":1,"coverable":1},{"path":["E:","\\","sql-layer","src","execution","executor","dql","index_scan.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::errors::*;\r\nuse crate::planner::operator::scan::ScanOperator;\r\nuse crate::storage::{Iter, Transaction};\r\n\r\npub(crate) struct IndexScan {\r\n    op: ScanOperator,\r\n}\r\n\r\nimpl From\u003cScanOperator\u003e for IndexScan {\r\n    fn from(op: ScanOperator) -\u003e Self {\r\n        IndexScan { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for IndexScan {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let ScanOperator {\r\n            table_name,\r\n            columns,\r\n\r\n            index_by,\r\n            ..\r\n        } = self.op;\r\n\r\n        let (index_meta, binaries) = index_by.ok_or(DatabaseError::InvalidType)?;\r\n        let mut iter = transaction.read_by_index(table_name, columns, index_meta, binaries)?;\r\n        let tuples = iter.fetch_tuple()?;\r\n        match tuples {\r\n            Some(tuple) =\u003e Ok(tuple),\r\n            None =\u003e Ok(vec![]),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":12,"coverable":14},{"path":["E:","\\","sql-layer","src","execution","executor","dql","join","hash_join.rs"],"content":"use crate::planner::operator::join::JoinType;\r\n\r\nuse crate::catalog::{ColumnCatalog, ColumnRef, SchemaRef};\r\nuse crate::execution::executor::{build, Executor, Source};\r\n\r\nuse crate::errors::*;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::join::{JoinCondition, JoinOperator};\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::value::DataValue;\r\nuse ahash::{HashMap, HashMapExt, HashSet, HashSetExt, RandomState};\r\n\r\nuse itertools::Itertools;\r\nuse std::sync::Arc;\r\n\r\nuse super::joins_nullable;\r\n/// R  S  tuples  Join   \r\n/// Join Attributes  Join Attributes  hash function   \r\n/// Join  tables  hash  tuples  Join   \r\npub struct HashJoin {\r\n    on: JoinCondition,\r\n    ty: JoinType,\r\n    left_input: LogicalPlan,\r\n    right_input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(JoinOperator, LogicalPlan, LogicalPlan)\u003e for HashJoin {\r\n    fn from(\r\n        (JoinOperator { on, join_type }, left_input, right_input): (\r\n            JoinOperator,\r\n            LogicalPlan,\r\n            LogicalPlan,\r\n        ),\r\n    ) -\u003e Self {\r\n        HashJoin {\r\n            on,\r\n            ty: join_type,\r\n            left_input,\r\n            right_input,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for HashJoin {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let mut tuples = Vec::new();\r\n        let HashJoin {\r\n            on,\r\n            ty,\r\n            mut left_input,\r\n            mut right_input,\r\n        } = self;\r\n        let left_schema = left_input.output_schema().clone();\r\n        let right_schema = right_input.output_schema().clone();\r\n        let left_input = build(left_input, transaction)?;\r\n        let right_input = build(right_input, transaction)?;\r\n        // println!(\"right_input len: {}\", right_input.len());\r\n        // println!(\"type: {}\", ty);\r\n        if ty == JoinType::Cross {\r\n            unreachable!(\"Cross join should not be in HashJoinExecutor\");\r\n        }\r\n        let ((on_left_keys, on_right_keys), filter): (\r\n            (Vec\u003cScalarExpression\u003e, Vec\u003cScalarExpression\u003e),\r\n            _,\r\n        ) = match on {\r\n            JoinCondition::On { on, filter } =\u003e (on.into_iter().unzip(), filter),\r\n            JoinCondition::None =\u003e unreachable!(\"HashJoin must has on condition\"),\r\n        };\r\n\r\n        let mut join_columns = Vec::new();\r\n        let mut used_set = HashSet::\u003cu64\u003e::new();\r\n        let mut left_map = HashMap::new();\r\n\r\n        let hash_random_state = RandomState::with_seeds(0, 0, 0, 0);\r\n        let (left_force_nullable, right_force_nullable) = joins_nullable(\u0026ty);\r\n        //Outer Table\r\n        // build phase:\r\n        // 1.construct hashtable, one hash key may contains multiple rows indices.\r\n        // 2.merged all left tuples.\r\n        let mut left_init_flag = false;\r\n        for tuple in left_input {\r\n            let hash = Self::hash_row(\u0026on_left_keys, \u0026left_schema, \u0026hash_random_state, \u0026tuple)?;\r\n\r\n            if !left_init_flag {\r\n                Self::columns_filling(\u0026left_schema, \u0026mut join_columns, left_force_nullable);\r\n                left_init_flag = true;\r\n                // for iter in join_columns.iter() {\r\n                //     println!(\"left join_columns: {}\", iter);\r\n                // }\r\n            }\r\n\r\n            left_map.entry(hash).or_insert(Vec::new()).push(tuple);\r\n        }\r\n        // println!(\"left_map: {:#?}\", left_map);\r\n        // probe phase\r\n        Self::columns_filling(\u0026right_schema, \u0026mut join_columns, right_force_nullable);\r\n        // for iter in join_columns.iter() {\r\n        //     println!(\"right join_columns: {}\", iter);\r\n        // }\r\n\r\n        for tuple in right_input {\r\n            let right_cols_len = right_schema.len();\r\n            //hash\r\n            let hash = Self::hash_row(\u0026on_right_keys, \u0026right_schema, \u0026hash_random_state, \u0026tuple)?;\r\n            //join columns\r\n\r\n            let mut join_tuples = if let Some(tuples) = left_map.get(\u0026hash) {\r\n                let _ = used_set.insert(hash);\r\n\r\n                tuples\r\n                    .iter()\r\n                    .map(|Tuple { values, .. }| {\r\n                        let full_values = values\r\n                            .iter()\r\n                            .cloned()\r\n                            .chain(tuple.values.clone())\r\n                            .collect_vec();\r\n\r\n                        Tuple {\r\n                            id: None,\r\n                            values: full_values,\r\n                        }\r\n                    })\r\n                    .collect_vec()\r\n            } else if matches!(ty, JoinType::Right | JoinType::Full) {\r\n                let empty_len = join_columns.len() - right_cols_len;\r\n                let values = join_columns[..empty_len]\r\n                    .iter()\r\n                    .map(|col| Arc::new(DataValue::none(col.datatype())))\r\n                    .chain(tuple.values)\r\n                    .collect_vec();\r\n\r\n                vec![Tuple { id: None, values }]\r\n            } else {\r\n                vec![]\r\n            };\r\n\r\n            // on filter\r\n            if let (Some(expr), false) = (\r\n                \u0026filter,\r\n                join_tuples.is_empty() || matches!(ty, JoinType::Full | JoinType::Cross),\r\n            ) {\r\n                let mut filter_tuples = Vec::with_capacity(join_tuples.len());\r\n\r\n                for mut tuple in join_tuples {\r\n                    if let DataValue::Boolean(option) = expr.eval(\u0026tuple, \u0026join_columns)?.as_ref() {\r\n                        if let Some(false) | None = option {\r\n                            let full_cols_len = join_columns.len();\r\n                            let left_cols_len = full_cols_len - right_cols_len;\r\n\r\n                            match ty {\r\n                                JoinType::Left =\u003e {\r\n                                    for i in left_cols_len..full_cols_len {\r\n                                        let value_type = join_columns[i].datatype();\r\n\r\n                                        tuple.values[i] = Arc::new(DataValue::none(value_type))\r\n                                    }\r\n                                    filter_tuples.push(tuple)\r\n                                }\r\n                                JoinType::Right =\u003e {\r\n                                    for i in 0..left_cols_len {\r\n                                        let value_type = left_schema[i].datatype();\r\n\r\n                                        tuple.values[i] = Arc::new(DataValue::none(value_type))\r\n                                    }\r\n                                    filter_tuples.push(tuple)\r\n                                }\r\n                                _ =\u003e (),\r\n                            }\r\n                        } else {\r\n                            filter_tuples.push(tuple)\r\n                        }\r\n                    } else {\r\n                        unreachable!(\"only bool\");\r\n                    }\r\n                }\r\n\r\n                join_tuples = filter_tuples;\r\n            }\r\n\r\n            for tuple in join_tuples {\r\n                tuples.push(tuple);\r\n            }\r\n        }\r\n\r\n        if matches!(ty, JoinType::Left | JoinType::Full) {\r\n            // println!(\"reach\");\r\n\r\n            for (hash, tuple) in left_map {\r\n                if used_set.contains(\u0026hash) {\r\n                    continue;\r\n                }\r\n\r\n                for Tuple { mut values, .. } in tuple {\r\n                    let mut right_empties = join_columns[left_schema.len()..]\r\n                        .iter()\r\n                        .map(|col| Arc::new(DataValue::none(col.datatype())))\r\n                        .collect_vec();\r\n\r\n                    values.append(\u0026mut right_empties);\r\n                    tuples.push(Tuple { id: None, values });\r\n                }\r\n            }\r\n        }\r\n        // for iter in tuples.iter() {\r\n        //     println!(\"tuples: {}\", iter);\r\n        // }\r\n        Ok(tuples)\r\n    }\r\n}\r\n\r\nimpl HashJoin {\r\n    pub(super) fn columns_filling(\r\n        schema: \u0026SchemaRef,\r\n        join_columns: \u0026mut Vec\u003cColumnRef\u003e,\r\n        force_nullable: bool,\r\n    ) {\r\n        let mut new_columns = schema\r\n            .iter()\r\n            .cloned()\r\n            .map(|col| {\r\n                let mut new_catalog = ColumnCatalog::clone(\u0026col);\r\n                new_catalog.nullable = force_nullable;\r\n\r\n                Arc::new(new_catalog)\r\n            })\r\n            .collect_vec();\r\n\r\n        join_columns.append(\u0026mut new_columns);\r\n    }\r\n\r\n    pub(super) fn hash_row(\r\n        on_keys: \u0026[ScalarExpression],\r\n        schema: \u0026SchemaRef,\r\n        hash_random_state: \u0026RandomState,\r\n        tuple: \u0026Tuple,\r\n    ) -\u003e Result\u003cu64\u003e {\r\n        let mut values = Vec::with_capacity(on_keys.len());\r\n\r\n        for expr in on_keys {\r\n            values.push(expr.eval(tuple, schema)?);\r\n        }\r\n\r\n        Ok(hash_random_state.hash_one(values))\r\n    }\r\n}\r\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":288230376151711832},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":288230376151711746},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":288230376151711746},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":288230376151711746},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":288230376151711746},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":288230376151711746},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":288230376151711746},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":288230376151711746},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":288230376151711746},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":288230376151711746},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":288230376151711746},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":576460752303423492},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":288230376151711746},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":288230376151711746},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":288230376151711746},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":288230376151711746},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":288230376151711746},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2594073385365405700},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1152921504606846978},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":5188146770730811392},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null}],"covered":56,"coverable":100},{"path":["E:","\\","sql-layer","src","execution","executor","dql","join","nested_loop_join.rs"],"content":"use crate::catalog::{ColumnCatalog, ColumnRef, Schema, SchemaRef};\r\nuse crate::errors::*;\r\nuse crate::execution::executor::dql::projection::Projection;\r\nuse crate::execution::executor::{build, Executor, Source};\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::join::{JoinCondition, JoinOperator, JoinType};\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::value::{DataValue, NULL_VALUE};\r\nuse itertools::Itertools;\r\nuse std::sync::Arc;\r\n\r\nuse super::joins_nullable;\r\n\r\n/// Equivalent condition\r\nstruct EqualCondition {\r\n    on_left_keys: Vec\u003cScalarExpression\u003e,\r\n    on_right_keys: Vec\u003cScalarExpression\u003e,\r\n    left_schema: SchemaRef,\r\n    right_schema: SchemaRef,\r\n}\r\n\r\nimpl EqualCondition {\r\n    /// Constructs a new `EqualCondition`\r\n    /// If the `on_left_keys` and `on_right_keys` are empty, it means no equivalent condition\r\n    /// Note: `on_left_keys` and `on_right_keys` are either all empty or none of them.\r\n    fn new(\r\n        on_left_keys: Vec\u003cScalarExpression\u003e,\r\n        on_right_keys: Vec\u003cScalarExpression\u003e,\r\n        left_schema: Arc\u003cSchema\u003e,\r\n        right_schema: Arc\u003cSchema\u003e,\r\n    ) -\u003e EqualCondition {\r\n        if !on_left_keys.is_empty() \u0026\u0026 on_left_keys.len() != on_right_keys.len() {\r\n            unreachable!(\"Unexpected join on condition.\")\r\n        }\r\n        EqualCondition {\r\n            on_left_keys,\r\n            on_right_keys,\r\n            left_schema,\r\n            right_schema,\r\n        }\r\n    }\r\n\r\n    /// Compare left tuple and right tuple on equivalent condition\r\n    /// `left_tuple` must be from the [`NestedLoopJoin::left_input`]\r\n    /// `right_tuple` must be from the [`NestedLoopJoin::right_input`]\r\n    fn equals(\u0026self, left_tuple: \u0026Tuple, right_tuple: \u0026Tuple) -\u003e Result\u003cbool\u003e {\r\n        if self.on_left_keys.is_empty() {\r\n            return Ok(true);\r\n        }\r\n        let left_values =\r\n            Projection::projection(left_tuple, \u0026self.on_left_keys, \u0026self.left_schema)?;\r\n        let right_values =\r\n            Projection::projection(right_tuple, \u0026self.on_right_keys, \u0026self.right_schema)?;\r\n\r\n        Ok(left_values == right_values)\r\n    }\r\n}\r\n\r\n/// NestedLoopJoin using nested loop join algorithm to execute a join operation.\r\n/// One input will be selected to be the inner table and the other will be the outer\r\n/// | JoinType                       |  Inner-table   |   Outer-table  |  \r\n/// |--------------------------------|----------------|----------------|  \r\n/// | Inner/Left                     |    right       |      left      |  \r\n/// |--------------------------------|----------------|----------------|  \r\n/// | Right                          |    left        |      right     |  \r\n/// |--------------------------------|----------------|----------------|  \r\n/// | Full                           |  not supported |  not supported |  \r\npub struct NestedLoopJoin {\r\n    left_input: LogicalPlan,\r\n    right_input: LogicalPlan,\r\n    output_schema_ref: SchemaRef,\r\n    ty: JoinType,\r\n    filter: Option\u003cScalarExpression\u003e,\r\n    eq_cond: EqualCondition,\r\n}\r\n\r\nimpl From\u003c(JoinOperator, LogicalPlan, LogicalPlan)\u003e for NestedLoopJoin {\r\n    fn from(\r\n        (JoinOperator { on, join_type, .. }, left_input, right_input): (\r\n            JoinOperator,\r\n            LogicalPlan,\r\n            LogicalPlan,\r\n        ),\r\n    ) -\u003e Self {\r\n        let ((mut on_left_keys, mut on_right_keys), filter) = match on {\r\n            JoinCondition::On { on, filter } =\u003e (on.into_iter().unzip(), filter),\r\n            JoinCondition::None =\u003e ((vec![], vec![]), None),\r\n        };\r\n\r\n        let (mut left_input, mut right_input) = (left_input, right_input);\r\n        let mut left_schema = left_input.output_schema().clone();\r\n        let mut right_schema = right_input.output_schema().clone();\r\n        let output_schema_ref = Self::merge_schema(\u0026left_schema, \u0026right_schema, join_type);\r\n\r\n        if matches!(join_type, JoinType::Right) {\r\n            std::mem::swap(\u0026mut left_input, \u0026mut right_input);\r\n            std::mem::swap(\u0026mut on_left_keys, \u0026mut on_right_keys);\r\n            std::mem::swap(\u0026mut left_schema, \u0026mut right_schema);\r\n        }\r\n\r\n        let eq_cond = EqualCondition::new(\r\n            on_left_keys,\r\n            on_right_keys,\r\n            left_schema.clone(),\r\n            right_schema.clone(),\r\n        );\r\n\r\n        NestedLoopJoin {\r\n            ty: join_type,\r\n            left_input,\r\n            right_input,\r\n            output_schema_ref,\r\n            filter,\r\n            eq_cond,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for NestedLoopJoin {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let NestedLoopJoin {\r\n            ty,\r\n            left_input,\r\n            right_input,\r\n            output_schema_ref,\r\n            filter,\r\n            eq_cond,\r\n            ..\r\n        } = self;\r\n        if matches!(self.ty, JoinType::Full) {\r\n            unreachable!(\"{} cannot be handled in nested loop join\", self.ty)\r\n        }\r\n        let mut tuples = vec![];\r\n        let right_schema_len = eq_cond.right_schema.len();\r\n        let left_tuples = build(left_input, transaction)?;\r\n        let right_tuples = build(right_input.clone(), transaction)?;\r\n\r\n        for left_tuple in left_tuples {\r\n            let mut has_matched = false;\r\n\r\n            for right_tuple in right_tuples.iter() {\r\n                let tuple = match (filter.as_ref(), eq_cond.equals(\u0026left_tuple, right_tuple)?) {\r\n                    (None, true) if matches!(ty, JoinType::Right) =\u003e {\r\n                        Self::emit_tuple(right_tuple, \u0026left_tuple, ty, true)\r\n                    }\r\n                    (None, true) =\u003e Self::emit_tuple(\u0026left_tuple, right_tuple, ty, true),\r\n                    (Some(filter), true) =\u003e {\r\n                        let new_tuple = Self::merge_tuple(\u0026left_tuple, right_tuple, \u0026ty);\r\n                        let value = filter.eval(\u0026new_tuple, \u0026output_schema_ref)?;\r\n                        match value.as_ref() {\r\n                            DataValue::Boolean(Some(true)) =\u003e {\r\n                                let tuple = match ty {\r\n                                    JoinType::Right =\u003e {\r\n                                        Self::emit_tuple(right_tuple, \u0026left_tuple, ty, true)\r\n                                    }\r\n                                    _ =\u003e Self::emit_tuple(\u0026left_tuple, right_tuple, ty, true),\r\n                                };\r\n                                has_matched = true;\r\n                                tuple\r\n                            }\r\n                            DataValue::Boolean(Some(_) | None) =\u003e None,\r\n                            _ =\u003e return Err(DatabaseError::InvalidType),\r\n                        }\r\n                    }\r\n                    _ =\u003e None,\r\n                };\r\n\r\n                if let Some(tuple) = tuple {\r\n                    tuples.push(tuple);\r\n                }\r\n\r\n            }\r\n\r\n            // handle no matched tuple case\r\n            let tuple = match ty {\r\n                JoinType::Left | JoinType::Right if !has_matched =\u003e {\r\n                    let right_tuple = Tuple {\r\n                        id: None,\r\n                        values: vec![NULL_VALUE.clone(); right_schema_len],\r\n                    };\r\n                    if matches!(ty, JoinType::Right) {\r\n                        Self::emit_tuple(\u0026right_tuple, \u0026left_tuple, ty, false)\r\n                    } else {\r\n                        Self::emit_tuple(\u0026left_tuple, \u0026right_tuple, ty, false)\r\n                    }\r\n                }\r\n                _ =\u003e None,\r\n            };\r\n            if let Some(tuple) = tuple {\r\n                tuples.push(tuple);\r\n            }\r\n        }\r\n        tuples.iter().for_each(|tuple|println!(\"tuple: {}\", tuple));\r\n        Ok(tuples)\r\n    }\r\n}\r\n\r\nimpl NestedLoopJoin {\r\n    /// Emit a tuple according to the join type.\r\n    ///\r\n    /// `left_tuple`: left tuple to be included.\r\n    /// `right_tuple` right tuple to be included.\r\n    /// `ty`: the type of join\r\n    /// `is_match`: whether [`NestedLoopJoin::left_input`] and [`NestedLoopJoin::right_input`] are matched\r\n    fn emit_tuple(\r\n        left_tuple: \u0026Tuple,\r\n        right_tuple: \u0026Tuple,\r\n        ty: JoinType,\r\n        is_matched: bool,\r\n    ) -\u003e Option\u003cTuple\u003e {\r\n        let left_len = left_tuple.values.len();\r\n        let mut values = left_tuple\r\n            .values\r\n            .iter()\r\n            .cloned()\r\n            .chain(right_tuple.values.clone())\r\n            .collect_vec();\r\n        match ty {\r\n            JoinType::Inner | JoinType::Cross if !is_matched =\u003e values.clear(),\r\n            JoinType::Left if !is_matched =\u003e {\r\n                values\r\n                    .iter_mut()\r\n                    .skip(left_len)\r\n                    .for_each(|v| *v = NULL_VALUE.clone());\r\n            }\r\n            JoinType::Right if !is_matched =\u003e {\r\n                (0..left_len).for_each(|i| {\r\n                    values[i] = NULL_VALUE.clone();\r\n                });\r\n            }\r\n            JoinType::Full =\u003e todo!(\"Not support now.\"),\r\n            _ =\u003e (),\r\n        };\r\n\r\n        if values.is_empty() {\r\n            return None;\r\n        }\r\n\r\n        Some(Tuple { id: None, values })\r\n    }\r\n\r\n    /// Merge the two tuples.\r\n    /// `left_tuple` must be from the `NestedLoopJoin.left_input`\r\n    /// `right_tuple` must be from the `NestedLoopJoin.right_input`\r\n    fn merge_tuple(left_tuple: \u0026Tuple, right_tuple: \u0026Tuple, ty: \u0026JoinType) -\u003e Tuple {\r\n        match ty {\r\n            JoinType::Right =\u003e Tuple {\r\n                id: None,\r\n                values: right_tuple\r\n                    .values\r\n                    .iter()\r\n                    .cloned()\r\n                    .chain(left_tuple.clone().values)\r\n                    .collect_vec(),\r\n            },\r\n            _ =\u003e Tuple {\r\n                id: None,\r\n                values: left_tuple\r\n                    .values\r\n                    .iter()\r\n                    .cloned()\r\n                    .chain(right_tuple.clone().values)\r\n                    .collect_vec(),\r\n            },\r\n        }\r\n    }\r\n\r\n    fn merge_schema(\r\n        left_schema: \u0026[ColumnRef],\r\n        right_schema: \u0026[ColumnRef],\r\n        ty: JoinType,\r\n    ) -\u003e Arc\u003cVec\u003cColumnRef\u003e\u003e {\r\n        let (left_force_nullable, right_force_nullable) = joins_nullable(\u0026ty);\r\n\r\n        let mut join_schema = vec![];\r\n        for column in left_schema.iter() {\r\n            let mut temp = ColumnCatalog::clone(column);\r\n            temp.nullable = left_force_nullable;\r\n            join_schema.push(Arc::new(temp));\r\n        }\r\n        for column in right_schema.iter() {\r\n            let mut temp = ColumnCatalog::clone(column);\r\n            temp.nullable = right_force_nullable;\r\n            join_schema.push(Arc::new(temp));\r\n        }\r\n        Arc::new(join_schema)\r\n    }\r\n}\r\n","traces":[{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":102},{"path":["E:","\\","sql-layer","src","execution","executor","dql","join.rs"],"content":"use crate::planner::operator::join::JoinType;\r\n\r\npub(crate) mod hash_join;\r\npub(crate) mod nested_loop_join;\r\n\r\n\r\n\r\npub fn joins_nullable(join_type: \u0026JoinType) -\u003e (bool, bool) {\r\n    match join_type {\r\n        JoinType::Inner =\u003e (false, false),\r\n        JoinType::Left =\u003e (false, true),\r\n        JoinType::Right =\u003e (true, false),\r\n        JoinType::Full =\u003e (true, true),\r\n        JoinType::Cross =\u003e (true, true),\r\n    }\r\n}\r\n\r\n\r\n\r\n","traces":[{"line":8,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":6,"coverable":7},{"path":["E:","\\","sql-layer","src","execution","executor","dql","limit.rs"],"content":"use crate::execution::executor::{build, Executor, Source};\r\n\r\nuse crate::planner::operator::limit::LimitOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\n\r\npub struct Limit {\r\n    offset: Option\u003cusize\u003e,\r\n    limit: Option\u003cusize\u003e,\r\n    input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(LimitOperator, LogicalPlan)\u003e for Limit {\r\n    fn from((LimitOperator { offset, limit }, input): (LimitOperator, LogicalPlan)) -\u003e Self {\r\n        Limit {\r\n            offset,\r\n            limit,\r\n            input,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Limit {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let mut tuples = Vec::new();\r\n        let Limit {\r\n            offset,\r\n            limit,\r\n            input,\r\n        } = self;\r\n        let input = build(input, transaction)?;\r\n        if limit.is_some() \u0026\u0026 limit.unwrap_or(0) == 0 {\r\n            return Ok(tuples);\r\n        }\r\n        // println!(\"limit input tuple {}\", input.len());\r\n\r\n        let offset_val = offset.unwrap_or(0);\r\n        let limit = limit.unwrap_or(usize::MAX);\r\n        // debug!(\"offset  {}\", offset_val);\r\n        // debug!(\"limit  {}\", limit);\r\n\r\n        for (i, tuple) in input.iter().skip(offset_val).enumerate() {\r\n            if i \u003e= limit {\r\n                break;\r\n            }\r\n            tuples.push(tuple.clone());\r\n        }\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":18},{"path":["E:","\\","sql-layer","src","execution","executor","dql","mod.rs"],"content":"pub(crate) mod agg;\r\npub(crate) mod describe;\r\npub(crate) mod dummy;\r\npub(crate) mod explain;\r\npub(crate) mod filter;\r\npub(crate) mod index_scan;\r\npub(crate) mod join;\r\npub(crate) mod limit;\r\npub(crate) mod projection;\r\npub(crate) mod seq_scan;\r\npub(crate) mod sort;\r\npub(crate) mod values;\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","execution","executor","dql","projection.rs"],"content":"\r\n\r\nuse crate::catalog::ColumnRef;\r\nuse crate::errors::*;\r\nuse crate::execution::executor::{build, Executor, Source};\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::operator::project::ProjectOperator;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::value::ValueRef;\r\n\r\npub struct Projection {\r\n    pub(crate) exprs: Vec\u003cScalarExpression\u003e,\r\n    input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(ProjectOperator, LogicalPlan)\u003e for Projection {\r\n    fn from((ProjectOperator { exprs }, input): (ProjectOperator, LogicalPlan)) -\u003e Self {\r\n        Projection { exprs, input }\r\n    }\r\n}\r\nimpl Projection {\r\n    pub fn projection(\r\n        tuple: \u0026Tuple,\r\n        exprs: \u0026[ScalarExpression],\r\n        schmea: \u0026[ColumnRef],\r\n    ) -\u003e Result\u003cVec\u003cValueRef\u003e\u003e {\r\n        let mut values = Vec::with_capacity(exprs.len());\r\n        // println!(\"exprs:{}\",exprs.iter().map(|expr|expr.to_string()).join(\",\"));\r\n        for expr in exprs.iter() {\r\n            values.push(expr.eval(tuple, schmea)?);\r\n        }\r\n        Ok(values)\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Projection {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let Projection { exprs, mut input } = self;\r\n        let mut tuples = Vec::new();\r\n        let schema = input.output_schema().clone();\r\n        let mut data_source = build(input, transaction)?;\r\n        for tuple in data_source.iter_mut() {\r\n            // println!(\"projection before: {}\", tuple);\r\n            // let tuple = tuple;\r\n            let values = Self::projection(tuple, \u0026exprs, \u0026schema)?;\r\n            // println!(\"projection after: {}\",values.iter().map(|v| v.to_string()).join(\",\"));\r\n\r\n            tuple.values = values;\r\n            tuples.push(tuple.clone());\r\n        }\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":17437937757178560512},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2233785415175766055},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2233785415175766055},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":2233785415175766055},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2233785415175766055},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4467570830351532110},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":9943947977234055168},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":9943947977234055168},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null}],"covered":14,"coverable":16},{"path":["E:","\\","sql-layer","src","execution","executor","dql","seq_scan.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::planner::operator::scan::ScanOperator;\r\nuse crate::storage::{Iter, Transaction};\r\n\r\npub(crate) struct SeqScan {\r\n    op: ScanOperator,\r\n}\r\n\r\nimpl From\u003cScanOperator\u003e for SeqScan {\r\n    fn from(op: ScanOperator) -\u003e Self {\r\n        SeqScan { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for SeqScan {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let ScanOperator {\r\n            table_name,\r\n            columns,\r\n            limit,\r\n            ..\r\n        } = self.op;\r\n        let mut iter = transaction.read(table_name, limit, columns)?;\r\n        let tuples = iter.fetch_tuple()?.unwrap_or(vec![]);\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":5044031582654955520},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":5044031582654955520},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null}],"covered":11,"coverable":11},{"path":["E:","\\","sql-layer","src","execution","executor","dql","sort.rs"],"content":"use crate::execution::executor::{build, Executor, Source};\r\n\r\nuse crate::planner::operator::sort::{SortField, SortOperator};\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\n\r\nuse std::cmp::Ordering;\r\n\r\npub struct Sort {\r\n    sort_fields: Vec\u003cSortField\u003e,\r\n    limit: Option\u003cusize\u003e,\r\n    input: LogicalPlan,\r\n}\r\n\r\nimpl From\u003c(SortOperator, LogicalPlan)\u003e for Sort {\r\n    fn from((SortOperator { sort_fields, limit }, input): (SortOperator, LogicalPlan)) -\u003e Self {\r\n        Sort {\r\n            sort_fields,\r\n            limit,\r\n            input,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Sort {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let Sort {\r\n            sort_fields,\r\n            limit,\r\n            mut input,\r\n        } = self;\r\n        let mut tuples: Vec\u003cTuple\u003e = vec![];\r\n        let schema = input.output_schema().clone();\r\n        let input = build(input, transaction)?;\r\n        for tuple in input {\r\n            tuples.push(tuple);\r\n        }\r\n        tuples.sort_by(|tuple_1, tuple_2| {\r\n            let mut ordering = Ordering::Equal;\r\n\r\n            for SortField {\r\n                expr,\r\n                asc,\r\n                nulls_first,\r\n            } in \u0026sort_fields\r\n            {\r\n                let value_1 = expr.eval(tuple_1, \u0026schema).unwrap();\r\n                let value_2 = expr.eval(tuple_2, \u0026schema).unwrap();\r\n\r\n                ordering = value_1.partial_cmp(\u0026value_2).unwrap_or_else(|| {\r\n                    match (value_1.is_null(), value_2.is_null()) {\r\n                        (false, true) =\u003e {\r\n                            if *nulls_first {\r\n                                Ordering::Less\r\n                            } else {\r\n                                Ordering::Greater\r\n                            }\r\n                        }\r\n                        (true, false) =\u003e {\r\n                            if *nulls_first {\r\n                                Ordering::Greater\r\n                            } else {\r\n                                Ordering::Less\r\n                            }\r\n                        }\r\n                        _ =\u003e Ordering::Equal,\r\n                    }\r\n                });\r\n\r\n                if !*asc {\r\n                    ordering = ordering.reverse();\r\n                }\r\n\r\n                if ordering != Ordering::Equal {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            ordering\r\n        });\r\n        let len = limit.unwrap_or(tuples.len());\r\n        tuples = tuples.drain(..len).collect();\r\n\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":24,"coverable":40},{"path":["E:","\\","sql-layer","src","execution","executor","dql","values.rs"],"content":"use crate::execution::executor::{Executor, Source};\r\n\r\nuse crate::planner::operator::values::ValuesOperator;\r\nuse crate::storage::Transaction;\r\nuse crate::types::tuple::Tuple;\r\n\r\nuse itertools::Itertools;\r\n\r\npub struct Values {\r\n    op: ValuesOperator,\r\n}\r\n\r\nimpl From\u003cValuesOperator\u003e for Values {\r\n    fn from(op: ValuesOperator) -\u003e Self {\r\n        Values { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for Values {\r\n    fn execute(self, _transaction: \u0026mut T) -\u003e Source {\r\n        let ValuesOperator { columns: _, rows } = self.op;\r\n        // eprintln!(\"values executor result :{:#?}\",columns);\r\n\r\n        Ok(rows\r\n            .iter()\r\n            .map(|val| Tuple {\r\n                id: None,\r\n                values: val.clone(),\r\n            })\r\n            .collect_vec())\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null}],"covered":9,"coverable":9},{"path":["E:","\\","sql-layer","src","execution","executor","mod.rs"],"content":"pub(crate) mod ddl;\r\npub(crate) mod dml;\r\npub(crate) mod dql;\r\npub(crate) mod set;\r\npub(crate) mod show;\r\nuse crate::{\r\n    planner::{\r\n        operator::{join::JoinCondition, Operator},\r\n        LogicalPlan,\r\n    },\r\n    storage::Transaction,\r\n    types::tuple::Tuple,\r\n};\r\n\r\nuse self::{\r\n    ddl::{\r\n        alter_table::{AddColumn, DropColumn},\r\n        create_index::CreateIndex,\r\n        create_table::CreateTable,\r\n        drop_index::DropIndex,\r\n        drop_table::DropTable,\r\n    },\r\n    dml::{copy::CopyFromFile, delete::Delete, insert::Insert, update::Update},\r\n    dql::{\r\n        agg::{hash_agg::HashAggExecutor, simple_agg::SimpleAggExecutor},\r\n        describe::Describe,\r\n        dummy::Dummy,\r\n        explain::Explain,\r\n        filter::Filter,\r\n        index_scan::IndexScan,\r\n        join::*,\r\n        limit::Limit,\r\n        projection::Projection,\r\n        seq_scan::SeqScan,\r\n        sort::Sort,\r\n        values::Values,\r\n    },\r\n    hash_join::HashJoin,\r\n    nested_loop_join::NestedLoopJoin,\r\n    set::SetVariable,\r\n    show::ShowTables,\r\n};\r\nuse crate::errors::*;\r\n\r\npub type Source = Result\u003cVec\u003cTuple\u003e\u003e;\r\n\r\npub trait Executor\u003cT: Transaction\u003e {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source;\r\n}\r\npub fn build\u003cT: Transaction\u003e(plan: LogicalPlan, transaction: \u0026mut T) -\u003e Source {\r\n    let LogicalPlan {\r\n        operator,\r\n        mut childrens,\r\n        ..\r\n    } = plan;\r\n\r\n    match operator {\r\n        Operator::Dummy =\u003e Dummy {}.execute(transaction),\r\n        Operator::Aggregate(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n            // let input = build(childrens.remove(0), transaction);\r\n\r\n            if op.groupby_exprs.is_empty() {\r\n                SimpleAggExecutor::from((op, input)).execute(transaction)\r\n            } else {\r\n                HashAggExecutor::from((op, input)).execute(transaction)\r\n            }\r\n        }\r\n        Operator::Filter(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n\r\n            Filter::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::Join(op) =\u003e {\r\n            let right_input = childrens.pop().unwrap();\r\n            let left_input = childrens.pop().unwrap();\r\n            match \u0026op.on {\r\n                JoinCondition::On { on, .. } if !on.is_empty() =\u003e {\r\n                    HashJoin::from((op, left_input, right_input)).execute(transaction)\r\n                }\r\n                _ =\u003e NestedLoopJoin::from((op, left_input, right_input)).execute(transaction),\r\n            }\r\n        }\r\n        Operator::Project(op) =\u003e {\r\n            // let input = build(childrens.remove(0), transaction);\r\n            let input = childrens.pop().unwrap();\r\n\r\n            Projection::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::Scan(op) =\u003e {\r\n            if op.index_by.is_some() {\r\n                // println!(\"build index scan\");\r\n                IndexScan::from(op).execute(transaction)\r\n            } else {\r\n                // println!(\"build seq scan\");\r\n\r\n                SeqScan::from(op).execute(transaction)\r\n            }\r\n        }\r\n        Operator::Sort(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n\r\n            Sort::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::Limit(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n\r\n            Limit::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::Insert(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n            Insert::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::Update(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n            // let values = build(childrens.remove(0), transaction);\r\n\r\n            Update::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::Delete(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n\r\n            Delete::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::Values(op) =\u003e Values::from(op).execute(transaction),\r\n        Operator::AddColumn(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n            AddColumn::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::DropColumn(op) =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n            DropColumn::from((op, input)).execute(transaction)\r\n        }\r\n        Operator::CreateTable(op) =\u003e CreateTable::from(op).execute(transaction),\r\n        Operator::DropTable(op) =\u003e DropTable::from(op).execute(transaction),\r\n        Operator::CreateIndex(op) =\u003e CreateIndex::from(op).execute(transaction),\r\n        Operator::Explain =\u003e {\r\n            let input = childrens.pop().unwrap();\r\n\r\n            Explain::from(input).execute(transaction)\r\n        }\r\n        Operator::DropIndex(op) =\u003e DropIndex::from(op).execute(transaction),\r\n        Operator::Show =\u003e ShowTables.execute(transaction),\r\n        Operator::SetVar(op) =\u003e SetVariable::from(op).execute(transaction),\r\n        Operator::CopyFromFile(op) =\u003e CopyFromFile::from(op).execute(transaction),\r\n        Operator::Describe(op) =\u003e Describe::from(op).execute(transaction),\r\n    }\r\n}\r\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":44,"coverable":62},{"path":["E:","\\","sql-layer","src","execution","executor","set","mod.rs"],"content":"use crate::{planner::operator::set_var::SetVarOperator, storage::Transaction};\r\n\r\nuse super::{Executor, Source};\r\n\r\npub struct SetVariable {\r\n    op: SetVarOperator,\r\n}\r\n\r\nimpl From\u003cSetVarOperator\u003e for SetVariable {\r\n    fn from(op: SetVarOperator) -\u003e Self {\r\n        SetVariable { op }\r\n    }\r\n}\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for SetVariable {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        if self.op.value == \"serializable\" {\r\n            transaction.set_isolation(true)?;\r\n        } else {\r\n            transaction.set_isolation(false)?;\r\n        }\r\n\r\n        Ok(vec![])\r\n    }\r\n}\r\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["E:","\\","sql-layer","src","execution","executor","show","mod.rs"],"content":"use std::sync::Arc;\r\n\r\nuse crate::{\r\n    storage::Transaction,\r\n    types::{tuple::Tuple, value::DataValue},\r\n};\r\n\r\nuse super::{Executor, Source};\r\n\r\npub struct ShowTables;\r\n\r\nimpl\u003cT: Transaction\u003e Executor\u003cT\u003e for ShowTables {\r\n    fn execute(self, transaction: \u0026mut T) -\u003e Source {\r\n        let metas = transaction.show_tables()?;\r\n        let mut tuples = Vec::new();\r\n        for meta in metas {\r\n            let values = vec![Arc::new(DataValue::Utf8(Some(meta)))];\r\n            tuples.push(Tuple { id: None, values })\r\n        }\r\n        Ok(tuples)\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":6,"coverable":7},{"path":["E:","\\","sql-layer","src","execution","mod.rs"],"content":"pub mod executor;\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","expression","agg.rs"],"content":"use serde::{Deserialize, Serialize};\r\n\r\n#[derive(Debug, PartialEq, Eq, Clone, Hash, Serialize, Deserialize)]\r\n\r\npub enum Aggregate {\r\n    Avg,\r\n    Max,\r\n    Min,\r\n    Sum,\r\n    Count,\r\n}\r\nimpl Aggregate {\r\n    pub fn allow_distinct(\u0026self) -\u003e bool {\r\n        match self {\r\n            Aggregate::Avg =\u003e false,\r\n            Aggregate::Max =\u003e false,\r\n            Aggregate::Min =\u003e false,\r\n            Aggregate::Sum =\u003e true,\r\n            Aggregate::Count =\u003e true,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":5476377146882523136},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":5476377146882523136},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null}],"covered":7,"coverable":7},{"path":["E:","\\","sql-layer","src","expression","evaluator.rs"],"content":"use crate::catalog::ColumnRef;\r\nuse crate::errors::*;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::types::tuple::Tuple;\r\nuse crate::types::value::{DataValue, ValueRef};\r\nuse itertools::Itertools;\r\nuse lazy_static::lazy_static;\r\nuse std::sync::Arc;\r\n\r\nlazy_static! {\r\n    static ref NULL_VALUE: ValueRef = Arc::new(DataValue::Null);\r\n}\r\n\r\nimpl ScalarExpression {\r\n    ///  \r\n    ///\r\n    pub fn eval(\u0026self, tuple: \u0026Tuple, schema: \u0026[ColumnRef]) -\u003e Result\u003cValueRef\u003e {\r\n        // \r\n        // if let Some(value) = Self::eval_with_name(tuple, self.output_columns().name(), schema) {\r\n        //     return Ok(value.clone());\r\n        // }\r\n        if let Some(value) = schema\r\n            .iter()\r\n            .find_position(|tul_col| tul_col.summary() == self.output_columns().summary())\r\n            .map(|(i, _)| \u0026tuple.values[i])\r\n        {\r\n            return Ok(value.clone());\r\n        }\r\n        match \u0026self {\r\n            ScalarExpression::Constant(val) =\u003e Ok(val.clone()),\r\n            ScalarExpression::ColumnRef(col) =\u003e {\r\n                // println!(\"schema:{:?}\", schema);\r\n                // println!(\"col:{:?}\", col.summary());\r\n                let value = schema\r\n                    .iter()\r\n                    .find_position(|tul_col| tul_col.summary() == col.summary())\r\n                    .map(|(i, _)| \u0026tuple.values[i])\r\n                    .unwrap_or(\u0026NULL_VALUE)\r\n                    .clone();\r\n                Ok(value)\r\n            }\r\n            ScalarExpression::Alias { expr, alias } =\u003e {\r\n                if let Some(value) = Self::eval_with_name(tuple, alias, schema) {\r\n                    return Ok(value.clone());\r\n                }\r\n\r\n                expr.eval(tuple, schema)\r\n            }\r\n            ScalarExpression::TypeCast { expr, ty, .. } =\u003e {\r\n                let value = expr.eval(tuple, schema)?;\r\n\r\n                Ok(Arc::new(DataValue::clone(\u0026value).cast(ty)?))\r\n            }\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                op,\r\n                ..\r\n            } =\u003e {\r\n                let left = left_expr.eval(tuple, schema)?;\r\n                let right = right_expr.eval(tuple, schema)?;\r\n\r\n                Ok(Arc::new(DataValue::binary_op(\u0026left, \u0026right, op)?))\r\n            }\r\n            ScalarExpression::IsNull { expr, negated } =\u003e {\r\n                let mut is_null = expr.eval(tuple, schema)?.is_null();\r\n                if *negated {\r\n                    is_null = !is_null;\r\n                }\r\n                Ok(Arc::new(DataValue::Boolean(Some(is_null))))\r\n            }\r\n            ScalarExpression::In {\r\n                expr,\r\n                args,\r\n                negated,\r\n            } =\u003e {\r\n                let value = expr.eval(tuple, schema)?;\r\n                let mut is_in = false;\r\n                for arg in args {\r\n                    if arg.eval(tuple, schema)? == value {\r\n                        is_in = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if *negated {\r\n                    is_in = !is_in;\r\n                }\r\n                Ok(Arc::new(DataValue::Boolean(Some(is_in))))\r\n            }\r\n            ScalarExpression::Unary { expr, op, .. } =\u003e {\r\n                let value = expr.eval(tuple, schema)?;\r\n\r\n                Ok(Arc::new(DataValue::unary_op(\u0026value, op)?))\r\n            }\r\n            ScalarExpression::AggCall { .. } =\u003e {\r\n                // println!(\"{}\",schema.iter().map(|item|item.to_string()).join(\",\"));\r\n                // schema.iter().for_each(|item|)\r\n                let value = schema\r\n                    .iter()\r\n                    .find_position(|tul_col| tul_col.summary() == self.output_columns().summary())\r\n                    .map(|(i, _)| \u0026tuple.values[i])\r\n                    .unwrap_or(\u0026NULL_VALUE)\r\n                    .clone();\r\n                Ok(value)\r\n            }\r\n        }\r\n    }\r\n\r\n    fn eval_with_name\u003c'a\u003e(\r\n        tuple: \u0026'a Tuple,\r\n        name: \u0026str,\r\n        schema: \u0026[ColumnRef],\r\n    ) -\u003e Option\u003c\u0026'a ValueRef\u003e {\r\n        schema\r\n            .iter()\r\n            .find_position(|tul_col| tul_col.name() == name)\r\n            .map(|(i, _)| \u0026tuple.values[i])\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":1224979098644774917},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":12898309332789100551},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":14987979559889010698},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":14123288431433875473},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":7998392938210000899},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":3674937295934324736},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":288230376151711747},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null}],"covered":18,"coverable":53},{"path":["E:","\\","sql-layer","src","expression","mod.rs"],"content":"use itertools::Itertools;\r\nuse serde::{Deserialize, Serialize};\r\nuse std::fmt::{self};\r\nuse std::fmt::{Debug, Formatter};\r\nuse std::sync::Arc;\r\n\r\nuse sqlparser::ast::{BinaryOperator as SqlBinaryOperator, UnaryOperator as SqlUnaryOperator};\r\n\r\nuse self::agg::Aggregate;\r\nuse crate::catalog::{ColumnCatalog, ColumnDesc, ColumnRef};\r\n\r\nuse crate::types::value::ValueRef;\r\nuse crate::types::LogicalType;\r\n\r\npub mod agg;\r\nmod evaluator;\r\npub mod simplify;\r\npub mod value_compute;\r\n\r\n#[derive(Debug, PartialEq, Eq, Clone, Hash)]\r\npub enum AliasType {\r\n    Name(String),\r\n    Expr(Box\u003cScalarExpression\u003e),\r\n}\r\n\r\n/// ScalarExpression represnet all scalar expression in SQL.\r\n/// SELECT a+1, b FROM t1.\r\n/// a+1 -\u003e ScalarExpression::Unary(a + 1)\r\n/// b   -\u003e ScalarExpression::ColumnRef()\r\n#[derive(Debug, PartialEq, Eq, Clone, Hash, Serialize, Deserialize)]\r\npub enum ScalarExpression {\r\n    Constant(ValueRef),\r\n    ColumnRef(ColumnRef),\r\n    Alias {\r\n        expr: Box\u003cScalarExpression\u003e,\r\n        alias: String,\r\n    },\r\n    TypeCast {\r\n        expr: Box\u003cScalarExpression\u003e,\r\n        ty: LogicalType,\r\n    },\r\n    IsNull {\r\n        negated: bool,\r\n        expr: Box\u003cScalarExpression\u003e,\r\n    },\r\n    Unary {\r\n        op: UnaryOperator,\r\n        expr: Box\u003cScalarExpression\u003e,\r\n        ty: LogicalType,\r\n    },\r\n    Binary {\r\n        op: BinaryOperator,\r\n        left_expr: Box\u003cScalarExpression\u003e,\r\n        right_expr: Box\u003cScalarExpression\u003e,\r\n        ty: LogicalType,\r\n    },\r\n    AggCall {\r\n        distinct: bool,\r\n        kind: Aggregate,\r\n        args: Vec\u003cScalarExpression\u003e,\r\n        ty: LogicalType,\r\n    },\r\n    In {\r\n        negated: bool,\r\n        expr: Box\u003cScalarExpression\u003e,\r\n        args: Vec\u003cScalarExpression\u003e,\r\n    },\r\n}\r\n\r\nimpl ScalarExpression {\r\n    pub fn unpack_alias(\u0026self) -\u003e \u0026ScalarExpression {\r\n        if let ScalarExpression::Alias { expr, .. } = self {\r\n            expr.unpack_alias()\r\n        } else {\r\n            self\r\n        }\r\n    }\r\n\r\n    pub fn has_count_star(\u0026self) -\u003e bool {\r\n        match self {\r\n            ScalarExpression::Alias { expr, .. } =\u003e expr.has_count_star(),\r\n            ScalarExpression::TypeCast { expr, .. } =\u003e expr.has_count_star(),\r\n            ScalarExpression::IsNull { expr, .. } =\u003e expr.has_count_star(),\r\n            ScalarExpression::Unary { expr, .. } =\u003e expr.has_count_star(),\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                ..\r\n            } =\u003e left_expr.has_count_star() || right_expr.has_count_star(),\r\n            ScalarExpression::AggCall { args, .. } =\u003e args.iter().any(Self::has_count_star),\r\n            _ =\u003e false,\r\n        }\r\n    }\r\n\r\n    pub fn return_type(\u0026self) -\u003e LogicalType {\r\n        match self {\r\n            Self::Constant(v) =\u003e v.logical_type(),\r\n            Self::ColumnRef(col) =\u003e *col.datatype(),\r\n            Self::Binary {\r\n                ty: return_type, ..\r\n            } =\u003e *return_type,\r\n            Self::Unary {\r\n                ty: return_type, ..\r\n            } =\u003e *return_type,\r\n            Self::TypeCast {\r\n                ty: return_type, ..\r\n            } =\u003e *return_type,\r\n            Self::AggCall {\r\n                ty: return_type, ..\r\n            } =\u003e *return_type,\r\n            Self::IsNull { .. } | Self::In { .. } =\u003e LogicalType::Boolean,\r\n            Self::Alias { expr, .. } =\u003e expr.return_type(),\r\n        }\r\n    }\r\n\r\n    pub fn referenced_columns(\u0026self, only_column_ref: bool) -\u003e Vec\u003cColumnRef\u003e {\r\n        fn columns_collect(\r\n            expr: \u0026ScalarExpression,\r\n            vec: \u0026mut Vec\u003cColumnRef\u003e,\r\n            only_column_ref: bool,\r\n        ) {\r\n            // When `ScalarExpression` is a complex type, it itself is also a special Column\r\n            if !only_column_ref {\r\n                vec.push(expr.output_columns());\r\n            }\r\n            match expr {\r\n                ScalarExpression::ColumnRef(col) =\u003e {\r\n                    vec.push(col.clone());\r\n                }\r\n                ScalarExpression::Alias { expr, .. } =\u003e columns_collect(expr, vec, only_column_ref),\r\n                ScalarExpression::TypeCast { expr, .. } =\u003e {\r\n                    columns_collect(expr, vec, only_column_ref)\r\n                }\r\n                ScalarExpression::IsNull { expr, .. } =\u003e {\r\n                    columns_collect(expr, vec, only_column_ref)\r\n                }\r\n                ScalarExpression::Unary { expr, .. } =\u003e columns_collect(expr, vec, only_column_ref),\r\n                ScalarExpression::Binary {\r\n                    left_expr,\r\n                    right_expr,\r\n                    ..\r\n                } =\u003e {\r\n                    columns_collect(left_expr, vec, only_column_ref);\r\n                    columns_collect(right_expr, vec, only_column_ref);\r\n                }\r\n                ScalarExpression::AggCall { args, .. } =\u003e {\r\n                    for expr in args {\r\n                        columns_collect(expr, vec, only_column_ref)\r\n                    }\r\n                }\r\n                ScalarExpression::In { expr, args, .. } =\u003e {\r\n                    columns_collect(expr, vec, only_column_ref);\r\n                    for arg in args {\r\n                        columns_collect(arg, vec, only_column_ref)\r\n                    }\r\n                }\r\n                _ =\u003e (),\r\n            }\r\n        }\r\n        let mut exprs = Vec::new();\r\n\r\n        columns_collect(self, \u0026mut exprs, only_column_ref);\r\n\r\n        exprs\r\n    }\r\n\r\n    pub fn has_agg_call(\u0026self) -\u003e bool {\r\n        match self {\r\n            ScalarExpression::AggCall { .. } =\u003e true,\r\n            ScalarExpression::Constant(_) =\u003e false,\r\n            ScalarExpression::ColumnRef(_) =\u003e false,\r\n            ScalarExpression::Alias { expr, .. } =\u003e expr.has_agg_call(),\r\n            ScalarExpression::TypeCast { expr, .. } =\u003e expr.has_agg_call(),\r\n            ScalarExpression::IsNull { expr, .. } =\u003e expr.has_agg_call(),\r\n            ScalarExpression::Unary { expr, .. } =\u003e expr.has_agg_call(),\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                ..\r\n            } =\u003e left_expr.has_agg_call() || right_expr.has_agg_call(),\r\n            ScalarExpression::In { expr, args, .. } =\u003e {\r\n                expr.has_agg_call() || args.iter().any(|arg| arg.has_agg_call())\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn output_columns(\u0026self) -\u003e ColumnRef {\r\n        match self {\r\n            ScalarExpression::ColumnRef(col) =\u003e col.clone(),\r\n            ScalarExpression::Constant(value) =\u003e Arc::new(ColumnCatalog::new(\r\n                format!(\"{}\", value),\r\n                true,\r\n                ColumnDesc::new(value.logical_type(), false, false, None),\r\n                // Some(self.clone()),\r\n            )),\r\n            ScalarExpression::Alias { expr, alias } =\u003e Arc::new(ColumnCatalog::new(\r\n                alias.to_string(),\r\n                true,\r\n                ColumnDesc::new(expr.return_type(), false, false, None),\r\n                // Some(self.clone()),\r\n            )),\r\n            ScalarExpression::AggCall {\r\n                kind,\r\n                args,\r\n                ty,\r\n                distinct,\r\n            } =\u003e {\r\n                let args_str = args\r\n                    .iter()\r\n                    .map(|expr| expr.output_columns().name().to_string())\r\n                    .join(\", \");\r\n                let op = |allow_distinct, distinct| {\r\n                    if allow_distinct \u0026\u0026 distinct {\r\n                        \"DISTINCT \"\r\n                    } else {\r\n                        \"\"\r\n                    }\r\n                };\r\n                let column_name = format!(\r\n                    \"{:?}({}{})\",\r\n                    kind,\r\n                    op(kind.allow_distinct(), *distinct),\r\n                    args_str\r\n                );\r\n\r\n                Arc::new(ColumnCatalog::new(\r\n                    column_name,\r\n                    true,\r\n                    ColumnDesc::new(*ty, false, false, None),\r\n                    // Some(self.clone()),\r\n                ))\r\n            }\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                op,\r\n                ty,\r\n            } =\u003e {\r\n                let column_name = format!(\r\n                    \"({} {} {})\",\r\n                    left_expr.output_columns().name(),\r\n                    op,\r\n                    right_expr.output_columns().name(),\r\n                );\r\n\r\n                Arc::new(ColumnCatalog::new(\r\n                    column_name,\r\n                    true,\r\n                    ColumnDesc::new(*ty, false, false, None),\r\n                    // Some(self.clone()),\r\n                ))\r\n            }\r\n            ScalarExpression::Unary { expr, op, ty } =\u003e {\r\n                let column_name = format!(\"{}{}\", op, expr.output_columns().name());\r\n                Arc::new(ColumnCatalog::new(\r\n                    column_name,\r\n                    true,\r\n                    ColumnDesc::new(*ty, false, false, None),\r\n                    // Some(self.clone()),\r\n                ))\r\n            }\r\n            ScalarExpression::IsNull { negated, expr } =\u003e {\r\n                let suffix = if *negated { \"is not null\" } else { \"is null\" };\r\n                Arc::new(ColumnCatalog::new(\r\n                    format!(\"{} {}\", expr.output_columns().name(), suffix),\r\n                    true,\r\n                    ColumnDesc::new(LogicalType::Boolean, false, false, None),\r\n                    // Some(self.clone()),\r\n                ))\r\n            }\r\n            ScalarExpression::In {\r\n                negated,\r\n                expr,\r\n                args,\r\n            } =\u003e {\r\n                let args_string = args\r\n                    .iter()\r\n                    .map(|arg| arg.output_columns().name().to_string())\r\n                    .join(\", \");\r\n                let op_string = if *negated { \"not in\" } else { \"in\" };\r\n                Arc::new(ColumnCatalog::new(\r\n                    format!(\r\n                        \"{} {} ({})\",\r\n                        expr.output_columns().name(),\r\n                        op_string,\r\n                        args_string\r\n                    ),\r\n                    true,\r\n                    ColumnDesc::new(LogicalType::Boolean, false, false, None),\r\n                    // Some(self.clone()),\r\n                ))\r\n            }\r\n            ScalarExpression::TypeCast { expr, ty } =\u003e Arc::new(ColumnCatalog::new(\r\n                format!(\"CAST({} as {})\", expr.output_columns().name(), ty),\r\n                true,\r\n                ColumnDesc::new(*ty, false, false, None),\r\n                // Some(self.clone()),\r\n            )),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\r\npub enum UnaryOperator {\r\n    Plus,\r\n    Minus,\r\n    Not,\r\n}\r\n\r\nimpl From\u003cSqlUnaryOperator\u003e for UnaryOperator {\r\n    fn from(value: SqlUnaryOperator) -\u003e Self {\r\n        match value {\r\n            SqlUnaryOperator::Plus =\u003e UnaryOperator::Plus,\r\n            SqlUnaryOperator::Minus =\u003e UnaryOperator::Minus,\r\n            SqlUnaryOperator::Not =\u003e UnaryOperator::Not,\r\n            _ =\u003e unimplemented!(\"not support!\"),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\r\npub enum BinaryOperator {\r\n    Plus,\r\n    Minus,\r\n    Multiply,\r\n    Divide,\r\n\r\n    Modulo,\r\n    StringConcat,\r\n\r\n    Gt,\r\n    Lt,\r\n    GtEq,\r\n    LtEq,\r\n    Spaceship,\r\n    Eq,\r\n    NotEq,\r\n    Like,\r\n    NotLike,\r\n\r\n    And,\r\n    Or,\r\n    Xor,\r\n}\r\n\r\nimpl fmt::Display for ScalarExpression {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"{}\", self.output_columns().name())\r\n    }\r\n}\r\n\r\nimpl fmt::Display for BinaryOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        match self {\r\n            BinaryOperator::Plus =\u003e write!(f, \"+\"),\r\n            BinaryOperator::Minus =\u003e write!(f, \"-\"),\r\n            BinaryOperator::Multiply =\u003e write!(f, \"*\"),\r\n            BinaryOperator::Divide =\u003e write!(f, \"/\"),\r\n            BinaryOperator::Modulo =\u003e write!(f, \"mod\"),\r\n            BinaryOperator::StringConcat =\u003e write!(f, \"\u0026\"),\r\n            BinaryOperator::Gt =\u003e write!(f, \"\u003e\"),\r\n            BinaryOperator::Lt =\u003e write!(f, \"\u003c\"),\r\n            BinaryOperator::GtEq =\u003e write!(f, \"\u003e=\"),\r\n            BinaryOperator::LtEq =\u003e write!(f, \"\u003c=\"),\r\n            BinaryOperator::Spaceship =\u003e write!(f, \"\u003c=\u003e\"),\r\n            BinaryOperator::Eq =\u003e write!(f, \"=\"),\r\n            BinaryOperator::NotEq =\u003e write!(f, \"!=\"),\r\n            BinaryOperator::And =\u003e write!(f, \"\u0026\u0026\"),\r\n            BinaryOperator::Or =\u003e write!(f, \"||\"),\r\n            BinaryOperator::Xor =\u003e write!(f, \"^\"),\r\n            BinaryOperator::Like =\u003e write!(f, \"like\"),\r\n            BinaryOperator::NotLike =\u003e write!(f, \"not like\"),\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for UnaryOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        match self {\r\n            UnaryOperator::Plus =\u003e write!(f, \"+\"),\r\n            UnaryOperator::Minus =\u003e write!(f, \"-\"),\r\n            UnaryOperator::Not =\u003e write!(f, \"!\"),\r\n        }\r\n    }\r\n}\r\n\r\nimpl From\u003cSqlBinaryOperator\u003e for BinaryOperator {\r\n    fn from(value: SqlBinaryOperator) -\u003e Self {\r\n        match value {\r\n            SqlBinaryOperator::Plus =\u003e BinaryOperator::Plus,\r\n            SqlBinaryOperator::Minus =\u003e BinaryOperator::Minus,\r\n            SqlBinaryOperator::Multiply =\u003e BinaryOperator::Multiply,\r\n            SqlBinaryOperator::Divide =\u003e BinaryOperator::Divide,\r\n            SqlBinaryOperator::Modulo =\u003e BinaryOperator::Modulo,\r\n            SqlBinaryOperator::StringConcat =\u003e BinaryOperator::StringConcat,\r\n            SqlBinaryOperator::Gt =\u003e BinaryOperator::Gt,\r\n            SqlBinaryOperator::Lt =\u003e BinaryOperator::Lt,\r\n            SqlBinaryOperator::GtEq =\u003e BinaryOperator::GtEq,\r\n            SqlBinaryOperator::LtEq =\u003e BinaryOperator::LtEq,\r\n            SqlBinaryOperator::Spaceship =\u003e BinaryOperator::Spaceship,\r\n            SqlBinaryOperator::Eq =\u003e BinaryOperator::Eq,\r\n            SqlBinaryOperator::NotEq =\u003e BinaryOperator::NotEq,\r\n            SqlBinaryOperator::And =\u003e BinaryOperator::And,\r\n            SqlBinaryOperator::Or =\u003e BinaryOperator::Or,\r\n            SqlBinaryOperator::Xor =\u003e BinaryOperator::Xor,\r\n            _ =\u003e unimplemented!(\"not support!\"),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":12465963768561532928},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":9007199254740992000},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":9655717601082343424},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":12465963768561532928},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":13330654897016668160},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":14339461213547659264},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":14339461213547659264},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":14339461213547659264},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":14339461213547659264},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":14339461213547659264},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":14339461213547659264},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":14699749183737298944},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":17870283321406128128},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":14699749183737298944},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":13258597302978740224},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":13258597302978740224},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":13835058055282163712},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":13402712491054596096},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":14771806777775226880},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":5044031582654955520},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":5044031582654955520},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":5332261958806667276},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":11385099857992613866},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":11385099857992613866},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":11385099857992613866},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":11385099857992613866},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":792633534417207305},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":792633534417207305},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":792633534417207305},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":792633534417207305},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":16429131440647569410},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":10952754293765046273},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":5476377146882523137},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":720575940379279359},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":5908722711110090752},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":1801439850948198400},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":129,"coverable":187},{"path":["E:","\\","sql-layer","src","expression","simplify.rs"],"content":"use crate::catalog::ColumnRef;\r\nuse crate::errors::*;\r\nuse crate::expression::{BinaryOperator, ScalarExpression, UnaryOperator};\r\nuse crate::types::value::{DataValue, ValueRef, NULL_VALUE};\r\nuse crate::types::{ColumnId, LogicalType};\r\nuse ahash::RandomState;\r\nuse itertools::Itertools;\r\nuse std::cmp::Ordering;\r\nuse std::collections::{Bound, HashSet};\r\nuse std::fmt::{self, Formatter};\r\nuse std::mem;\r\nuse std::sync::Arc;\r\n\r\n#[derive(Debug, PartialEq, Eq, Clone, Hash)]\r\npub enum ConstantBinary {\r\n    Scope {\r\n        min: Bound\u003cValueRef\u003e,\r\n        max: Bound\u003cValueRef\u003e,\r\n    },\r\n    Eq(ValueRef),\r\n    NotEq(ValueRef),\r\n\r\n    // ConstantBinary in And can only be Scope\\Eq\\NotEq\r\n    And(Vec\u003cConstantBinary\u003e),\r\n    // ConstantBinary in Or can only be Scope\\Eq\\NotEq\\And\r\n    Or(Vec\u003cConstantBinary\u003e),\r\n}\r\n\r\nimpl ConstantBinary {\r\n    #[allow(dead_code)]\r\n    fn is_null(\u0026self) -\u003e Result\u003cbool\u003e {\r\n        match self {\r\n            ConstantBinary::Scope { min, max } =\u003e {\r\n                let op = |bound: \u0026Bound\u003cValueRef\u003e| {\r\n                    if let Bound::Included(val) | Bound::Excluded(val) = bound {\r\n                        val.is_null()\r\n                    } else {\r\n                        false\r\n                    }\r\n                };\r\n                if op(min) || op(max) {\r\n                    return Ok(true);\r\n                }\r\n\r\n                Ok(matches!((min, max), (Bound::Unbounded, Bound::Unbounded)))\r\n            }\r\n            ConstantBinary::Eq(val) | ConstantBinary::NotEq(val) =\u003e Ok(val.is_null()),\r\n            _ =\u003e Err(DatabaseError::InvalidType),\r\n        }\r\n    }\r\n\r\n    pub fn rearrange(self) -\u003e Result\u003cVec\u003cConstantBinary\u003e\u003e {\r\n        match self {\r\n            ConstantBinary::Or(binaries) =\u003e {\r\n                if binaries.is_empty() {\r\n                    return Ok(vec![]);\r\n                }\r\n\r\n                let mut condition_binaries = Vec::new();\r\n\r\n                for binary in binaries {\r\n                    match binary {\r\n                        ConstantBinary::Or(_) =\u003e return Err(DatabaseError::InvalidType),\r\n                        ConstantBinary::And(mut and_binaries) =\u003e {\r\n                            condition_binaries.append(\u0026mut and_binaries);\r\n                        }\r\n                        ConstantBinary::Scope {\r\n                            min: Bound::Unbounded,\r\n                            max: Bound::Unbounded,\r\n                        } =\u003e (),\r\n                        source =\u003e condition_binaries.push(source),\r\n                    }\r\n                }\r\n                // Sort\r\n                condition_binaries.sort_by(|a, b| {\r\n                    let op = |binary: \u0026ConstantBinary| match binary {\r\n                        ConstantBinary::Scope { min, .. } =\u003e min.clone(),\r\n                        ConstantBinary::Eq(val) =\u003e Bound::Included(val.clone()),\r\n                        ConstantBinary::NotEq(val) =\u003e Bound::Excluded(val.clone()),\r\n                        _ =\u003e unreachable!(),\r\n                    };\r\n\r\n                    Self::bound_compared(\u0026op(a), \u0026op(b), true).unwrap_or(Ordering::Equal)\r\n                });\r\n\r\n                let mut merged_binaries: Vec\u003cConstantBinary\u003e = Vec::new();\r\n\r\n                for condition in condition_binaries {\r\n                    let op = |binary: \u0026ConstantBinary| match binary {\r\n                        ConstantBinary::Scope { min, max } =\u003e (min.clone(), max.clone()),\r\n                        ConstantBinary::Eq(val) =\u003e (Bound::Unbounded, Bound::Included(val.clone())),\r\n                        ConstantBinary::NotEq(val) =\u003e {\r\n                            (Bound::Unbounded, Bound::Excluded(val.clone()))\r\n                        }\r\n                        _ =\u003e unreachable!(),\r\n                    };\r\n                    let mut is_push = merged_binaries.is_empty();\r\n\r\n                    for binary in merged_binaries.iter_mut().rev() {\r\n                        if let ConstantBinary::Scope { max, .. } = binary {\r\n                            let (condition_min, condition_max) = op(\u0026condition);\r\n                            let is_lt_min = Self::bound_compared(max, \u0026condition_min, false)\r\n                                .unwrap_or(Ordering::Equal)\r\n                                .is_lt();\r\n                            let is_lt_max = Self::bound_compared(max, \u0026condition_max, false)\r\n                                .unwrap_or(Ordering::Equal)\r\n                                .is_lt();\r\n\r\n                            if !is_lt_min \u0026\u0026 is_lt_max {\r\n                                let _ = mem::replace(max, condition_max);\r\n                            } else if !matches!(condition, ConstantBinary::Scope { .. }) {\r\n                                is_push = is_lt_max;\r\n                            } else if is_lt_min \u0026\u0026 is_lt_max {\r\n                                is_push = true\r\n                            }\r\n\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if is_push {\r\n                        merged_binaries.push(condition);\r\n                    }\r\n                }\r\n\r\n                Ok(merged_binaries)\r\n            }\r\n            ConstantBinary::And(binaries) =\u003e Ok(binaries),\r\n            source =\u003e Ok(vec![source]),\r\n        }\r\n    }\r\n\r\n    pub fn scope_aggregation(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        match self {\r\n            // `Or` is allowed to contain And, `Scope`, `Eq/NotEq`\r\n            // Tips: Only single-level `And`\r\n            ConstantBinary::Or(binaries) =\u003e {\r\n                let mut or_binaries = Vec::new();\r\n                for binary in binaries {\r\n                    match binary {\r\n                        ConstantBinary::And(and_binaries) =\u003e {\r\n                            or_binaries.append(\u0026mut Self::and_scope_aggregation(and_binaries)?);\r\n                        }\r\n                        ConstantBinary::Or(_) =\u003e {\r\n                            unreachable!(\"`Or` does not allow nested `Or`\")\r\n                        }\r\n                        cb =\u003e {\r\n                            or_binaries.push(cb.clone());\r\n                        }\r\n                    }\r\n                }\r\n                let or_binaries = Self::or_scope_aggregation(\u0026or_binaries);\r\n                let _ = mem::replace(self, ConstantBinary::Or(or_binaries));\r\n            }\r\n            // `And` is allowed to contain Scope, `Eq/NotEq`\r\n            ConstantBinary::And(binaries) =\u003e {\r\n                let and_binaries = Self::and_scope_aggregation(binaries)?;\r\n                let _ = mem::replace(self, ConstantBinary::And(and_binaries));\r\n            }\r\n            _ =\u003e (),\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn bound_compared(\r\n        left_bound: \u0026Bound\u003cValueRef\u003e,\r\n        right_bound: \u0026Bound\u003cValueRef\u003e,\r\n        is_min: bool,\r\n    ) -\u003e Option\u003cOrdering\u003e {\r\n        let op = |is_min, order: Ordering| {\r\n            if is_min {\r\n                order\r\n            } else {\r\n                order.reverse()\r\n            }\r\n        };\r\n\r\n        match (left_bound, right_bound) {\r\n            (Bound::Unbounded, Bound::Unbounded) =\u003e Some(Ordering::Equal),\r\n            (Bound::Unbounded, _) =\u003e Some(op(is_min, Ordering::Less)),\r\n            (_, Bound::Unbounded) =\u003e Some(op(is_min, Ordering::Greater)),\r\n            (Bound::Included(left), Bound::Included(right)) =\u003e left.partial_cmp(right),\r\n            (Bound::Included(left), Bound::Excluded(right)) =\u003e left\r\n                .partial_cmp(right)\r\n                .map(|order| order.then(op(is_min, Ordering::Less))),\r\n            (Bound::Excluded(left), Bound::Excluded(right)) =\u003e left.partial_cmp(right),\r\n            (Bound::Excluded(left), Bound::Included(right)) =\u003e left\r\n                .partial_cmp(right)\r\n                .map(|order| order.then(op(is_min, Ordering::Greater))),\r\n        }\r\n    }\r\n\r\n    // Tips: It only makes sense if the condition is and aggregation\r\n    fn and_scope_aggregation(binaries: \u0026[ConstantBinary]) -\u003e Result\u003cVec\u003cConstantBinary\u003e\u003e {\r\n        if binaries.is_empty() {\r\n            return Ok(vec![]);\r\n        }\r\n\r\n        let mut scope_min = Bound::Unbounded;\r\n        let mut scope_max = Bound::Unbounded;\r\n        let mut eq_set = HashSet::with_hasher(RandomState::new());\r\n\r\n        let sort_op = |binary: \u0026\u0026ConstantBinary| match binary {\r\n            ConstantBinary::Scope { .. } =\u003e 3,\r\n            ConstantBinary::NotEq(_) =\u003e 2,\r\n            ConstantBinary::Eq(_) =\u003e 1,\r\n            ConstantBinary::And(_) | ConstantBinary::Or(_) =\u003e 0,\r\n        };\r\n\r\n        // Aggregate various ranges to get the minimum range\r\n        for binary in binaries.iter().sorted_by_key(sort_op) {\r\n            match binary {\r\n                ConstantBinary::Scope { min, max } =\u003e {\r\n                    // Skip if eq or noteq exists\r\n                    if !eq_set.is_empty() {\r\n                        continue;\r\n                    }\r\n\r\n                    if let Some(order) = Self::bound_compared(\u0026scope_min, min, true) {\r\n                        if order.is_lt() {\r\n                            scope_min = min.clone();\r\n                        }\r\n                    }\r\n\r\n                    if let Some(order) = Self::bound_compared(\u0026scope_max, max, false) {\r\n                        if order.is_gt() {\r\n                            scope_max = max.clone();\r\n                        }\r\n                    }\r\n                }\r\n                ConstantBinary::Eq(val) =\u003e {\r\n                    let _ = eq_set.insert(val.clone());\r\n                }\r\n                ConstantBinary::NotEq(val) =\u003e {\r\n                    let _ = eq_set.remove(val);\r\n                }\r\n                ConstantBinary::Or(_) | ConstantBinary::And(_) =\u003e {\r\n                    return Err(DatabaseError::InvalidType)\r\n                }\r\n            }\r\n        }\r\n\r\n        let eq_option = eq_set\r\n            .into_iter()\r\n            .sorted_by(|a, b| a.partial_cmp(b).unwrap_or(Ordering::Equal))\r\n            .next()\r\n            .map(ConstantBinary::Eq);\r\n\r\n        if let Some(eq) = eq_option {\r\n            Ok(vec![eq])\r\n        } else if !matches!(\r\n            (\u0026scope_min, \u0026scope_max),\r\n            (Bound::Unbounded, Bound::Unbounded)\r\n        ) {\r\n            let scope_binary = ConstantBinary::Scope {\r\n                min: scope_min,\r\n                max: scope_max,\r\n            };\r\n\r\n            Ok(vec![scope_binary])\r\n        } else {\r\n            Ok(vec![])\r\n        }\r\n    }\r\n\r\n    // Tips: It only makes sense if the condition is or aggregation\r\n    fn or_scope_aggregation(binaries: \u0026Vec\u003cConstantBinary\u003e) -\u003e Vec\u003cConstantBinary\u003e {\r\n        if binaries.is_empty() {\r\n            return vec![];\r\n        }\r\n        let mut scopes = Vec::new();\r\n        let mut eqs = Vec::new();\r\n\r\n        let mut scope_margin = None;\r\n\r\n        for binary in binaries {\r\n            if matches!(scope_margin, Some((Bound::Unbounded, Bound::Unbounded))) {\r\n                break;\r\n            }\r\n            match binary {\r\n                ConstantBinary::Scope {\r\n                    min: Bound::Unbounded,\r\n                    max: Bound::Unbounded,\r\n                } =\u003e {\r\n                    scope_margin = Some((Bound::Unbounded, Bound::Unbounded));\r\n                    break;\r\n                }\r\n                ConstantBinary::Scope { min, max } =\u003e {\r\n                    if let Some((scope_min, scope_max)) = \u0026mut scope_margin {\r\n                        if matches!(\r\n                            Self::bound_compared(scope_min, min, true).map(Ordering::is_gt),\r\n                            Some(true)\r\n                        ) {\r\n                            let _ = mem::replace(scope_min, min.clone());\r\n                        }\r\n                        if matches!(\r\n                            Self::bound_compared(scope_max, max, false).map(Ordering::is_lt),\r\n                            Some(true)\r\n                        ) {\r\n                            let _ = mem::replace(scope_max, max.clone());\r\n                        }\r\n                    } else {\r\n                        scope_margin = Some((min.clone(), max.clone()))\r\n                    }\r\n\r\n                    scopes.push((min, max))\r\n                }\r\n                ConstantBinary::Eq(val) =\u003e eqs.push(val),\r\n                _ =\u003e (),\r\n            }\r\n        }\r\n        if matches!(\r\n            scope_margin,\r\n            Some((Bound::Unbounded, Bound::Unbounded)) | None\r\n        ) {\r\n            return vec![];\r\n        }\r\n\r\n        let mut merge_scopes: Vec\u003c(Bound\u003cValueRef\u003e, Bound\u003cValueRef\u003e)\u003e = Vec::new();\r\n\r\n        match scope_margin {\r\n            Some((Bound::Unbounded, _)) =\u003e {\r\n                if let Some((_, max)) = scopes.iter().max_by(|(_, max_a), (_, max_b)| {\r\n                    Self::bound_compared(max_a, max_b, false).unwrap()\r\n                }) {\r\n                    merge_scopes.push((Bound::Unbounded, (**max).clone()))\r\n                }\r\n            }\r\n            Some((_, Bound::Unbounded)) =\u003e {\r\n                if let Some((min, _)) = scopes.iter().min_by(|(min_a, _), (min_b, _)| {\r\n                    Self::bound_compared(min_a, min_b, true).unwrap()\r\n                }) {\r\n                    merge_scopes.push(((**min).clone(), Bound::Unbounded))\r\n                }\r\n            }\r\n            _ =\u003e {\r\n                scopes.sort_by(|(min_a, _), (min_b, _)| {\r\n                    Self::bound_compared(min_a, min_b, true).unwrap()\r\n                });\r\n\r\n                for i in 0..scopes.len() {\r\n                    let (min, max) = scopes[i];\r\n                    if merge_scopes.is_empty() {\r\n                        merge_scopes.push((min.clone(), max.clone()));\r\n                        continue;\r\n                    }\r\n\r\n                    let last_pos = merge_scopes.len() - 1;\r\n                    let last_scope: \u0026mut _ = \u0026mut merge_scopes[last_pos];\r\n                    if Self::bound_compared(\u0026last_scope.0, min, true)\r\n                        .unwrap()\r\n                        .is_gt()\r\n                    {\r\n                        merge_scopes.push((min.clone(), max.clone()));\r\n                    } else if Self::bound_compared(\u0026last_scope.1, max, false)\r\n                        .unwrap()\r\n                        .is_lt()\r\n                    {\r\n                        last_scope.1 = max.clone();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        merge_scopes\r\n            .into_iter()\r\n            .map(|(min, max)| ConstantBinary::Scope {\r\n                min: min.clone(),\r\n                max: max.clone(),\r\n            })\r\n            .chain(eqs.into_iter().map(|val| ConstantBinary::Eq(val.clone())))\r\n            .collect_vec()\r\n    }\r\n    fn join_write(f: \u0026mut Formatter, binaries: \u0026[ConstantBinary], op: \u0026str) -\u003e fmt::Result {\r\n        let binaries = binaries.iter().map(|binary| format!(\"{}\", binary)).join(op);\r\n        write!(f, \" {} \", binaries)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug)]\r\nenum Replace {\r\n    Binary(ReplaceBinary),\r\n    Unary(ReplaceUnary),\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct ReplaceBinary {\r\n    column_expr: ScalarExpression,\r\n    val_expr: ScalarExpression,\r\n    op: BinaryOperator,\r\n    ty: LogicalType,\r\n    is_column_left: bool,\r\n}\r\n\r\n#[derive(Debug)]\r\nstruct ReplaceUnary {\r\n    child_expr: ScalarExpression,\r\n    op: UnaryOperator,\r\n    ty: LogicalType,\r\n}\r\n\r\nimpl ScalarExpression {\r\n    pub fn exist_column(\u0026self, col_id: \u0026ColumnId) -\u003e bool {\r\n        match self {\r\n            ScalarExpression::ColumnRef(col) =\u003e col.id() == Some(*col_id),\r\n            ScalarExpression::Alias { expr, .. } =\u003e expr.exist_column(col_id),\r\n            ScalarExpression::TypeCast { expr, .. } =\u003e expr.exist_column(col_id),\r\n            ScalarExpression::IsNull { expr, .. } =\u003e expr.exist_column(col_id),\r\n            ScalarExpression::Unary { expr, .. } =\u003e expr.exist_column(col_id),\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                ..\r\n            } =\u003e left_expr.exist_column(col_id) || right_expr.exist_column(col_id),\r\n            ScalarExpression::In { expr, args, .. } =\u003e {\r\n                expr.exist_column(col_id) || args.iter().any(|expr| expr.exist_column(col_id))\r\n            }\r\n\r\n            _ =\u003e false,\r\n        }\r\n    }\r\n\r\n    fn unpack_val(\u0026self) -\u003e Option\u003cValueRef\u003e {\r\n        match self {\r\n            ScalarExpression::Constant(val) =\u003e Some(val.clone()),\r\n            ScalarExpression::Alias { expr, .. } =\u003e expr.unpack_val(),\r\n            ScalarExpression::TypeCast { expr, ty, .. } =\u003e expr\r\n                .unpack_val()\r\n                .and_then(|val| DataValue::clone(\u0026val).cast(ty).ok().map(Arc::new)),\r\n            ScalarExpression::IsNull { expr, .. } =\u003e {\r\n                let is_null = expr.unpack_val().map(|val| val.is_null());\r\n\r\n                Some(Arc::new(DataValue::Boolean(is_null)))\r\n            }\r\n            ScalarExpression::Unary { expr, op, .. } =\u003e {\r\n                let val = expr.unpack_val()?;\r\n\r\n                DataValue::unary_op(\u0026val, op).ok().map(Arc::new)\r\n            }\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                op,\r\n                ..\r\n            } =\u003e {\r\n                let left = left_expr.unpack_val()?;\r\n                let right = right_expr.unpack_val()?;\r\n\r\n                DataValue::binary_op(\u0026left, \u0026right, op).ok().map(Arc::new)\r\n            }\r\n            _ =\u003e None,\r\n        }\r\n    }\r\n\r\n    fn unpack_col(\u0026self, is_deep: bool) -\u003e Option\u003cColumnRef\u003e {\r\n        match self {\r\n            ScalarExpression::ColumnRef(col) =\u003e Some(col.clone()),\r\n            ScalarExpression::Alias { expr, .. } =\u003e expr.unpack_col(is_deep),\r\n            ScalarExpression::Unary { expr, .. } =\u003e expr.unpack_col(is_deep),\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                ..\r\n            } =\u003e {\r\n                if !is_deep {\r\n                    return None;\r\n                }\r\n\r\n                left_expr\r\n                    .unpack_col(true)\r\n                    .or_else(|| right_expr.unpack_col(true))\r\n            }\r\n            _ =\u003e None,\r\n        }\r\n    }\r\n\r\n    pub fn simplify(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        self._simplify(\u0026mut Vec::new())\r\n    }\r\n\r\n    pub fn constant_calculation(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        match self {\r\n            ScalarExpression::Unary { expr, op, .. } =\u003e {\r\n                expr.constant_calculation()?;\r\n\r\n                if let ScalarExpression::Constant(unary_val) = expr.as_ref() {\r\n                    let value = DataValue::unary_op(unary_val, op)?;\r\n                    let _ = mem::replace(self, ScalarExpression::Constant(Arc::new(value)));\r\n                }\r\n            }\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                op,\r\n                ..\r\n            } =\u003e {\r\n                left_expr.constant_calculation()?;\r\n                right_expr.constant_calculation()?;\r\n\r\n                if let (\r\n                    ScalarExpression::Constant(left_val),\r\n                    ScalarExpression::Constant(right_val),\r\n                ) = (left_expr.as_ref(), right_expr.as_ref())\r\n                {\r\n                    let value = DataValue::binary_op(left_val, right_val, op)?;\r\n                    let _ = mem::replace(self, ScalarExpression::Constant(Arc::new(value)));\r\n                }\r\n            }\r\n            ScalarExpression::Alias { expr, .. } =\u003e expr.constant_calculation()?,\r\n            ScalarExpression::TypeCast { expr, .. } =\u003e expr.constant_calculation()?,\r\n            ScalarExpression::IsNull { expr, .. } =\u003e expr.constant_calculation()?,\r\n            ScalarExpression::AggCall { args, .. } =\u003e {\r\n                for expr in args {\r\n                    expr.constant_calculation()?;\r\n                }\r\n            }\r\n            _ =\u003e (),\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    // Tips: Indirect expressions like `ScalarExpression:Alias` will be lost\r\n    fn _simplify(\u0026mut self, replaces: \u0026mut Vec\u003cReplace\u003e) -\u003e Result\u003c()\u003e {\r\n        match self {\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                op,\r\n                ty,\r\n            } =\u003e {\r\n                Self::fix_expr(replaces, left_expr, right_expr, op)?;\r\n\r\n                // `(c1 - 1) and (c1 + 2)` cannot fix!\r\n                Self::fix_expr(replaces, right_expr, left_expr, op)?;\r\n\r\n                if Self::is_arithmetic(op) {\r\n                    match (left_expr.unpack_col(false), right_expr.unpack_col(false)) {\r\n                        (Some(col), None) =\u003e {\r\n                            replaces.push(Replace::Binary(ReplaceBinary {\r\n                                column_expr: ScalarExpression::ColumnRef(col),\r\n                                val_expr: right_expr.as_ref().clone(),\r\n                                op: *op,\r\n                                ty: *ty,\r\n                                is_column_left: true,\r\n                            }));\r\n                        }\r\n                        (None, Some(col)) =\u003e {\r\n                            replaces.push(Replace::Binary(ReplaceBinary {\r\n                                column_expr: ScalarExpression::ColumnRef(col),\r\n                                val_expr: left_expr.as_ref().clone(),\r\n                                op: *op,\r\n                                ty: *ty,\r\n                                is_column_left: false,\r\n                            }));\r\n                        }\r\n                        (None, None) =\u003e {\r\n                            if replaces.is_empty() {\r\n                                return Ok(());\r\n                            }\r\n\r\n                            match (left_expr.unpack_col(true), right_expr.unpack_col(true)) {\r\n                                (Some(col), None) =\u003e {\r\n                                    replaces.push(Replace::Binary(ReplaceBinary {\r\n                                        column_expr: ScalarExpression::ColumnRef(col),\r\n                                        val_expr: right_expr.as_ref().clone(),\r\n                                        op: *op,\r\n                                        ty: *ty,\r\n                                        is_column_left: true,\r\n                                    }));\r\n                                }\r\n                                (None, Some(col)) =\u003e {\r\n                                    replaces.push(Replace::Binary(ReplaceBinary {\r\n                                        column_expr: ScalarExpression::ColumnRef(col),\r\n                                        val_expr: left_expr.as_ref().clone(),\r\n                                        op: *op,\r\n                                        ty: *ty,\r\n                                        is_column_left: false,\r\n                                    }));\r\n                                }\r\n                                _ =\u003e (),\r\n                            }\r\n                        }\r\n                        _ =\u003e (),\r\n                    }\r\n                }\r\n            }\r\n            ScalarExpression::In {\r\n                expr,\r\n                negated,\r\n                args,\r\n            } =\u003e {\r\n                if args.is_empty() {\r\n                    return Ok(());\r\n                }\r\n\r\n                let (op_1, op_2) = if *negated {\r\n                    (BinaryOperator::NotEq, BinaryOperator::And)\r\n                } else {\r\n                    (BinaryOperator::Eq, BinaryOperator::Or)\r\n                };\r\n                let mut new_expr = ScalarExpression::Binary {\r\n                    op: op_1,\r\n                    left_expr: expr.clone(),\r\n                    right_expr: Box::new(args.remove(0)),\r\n                    ty: LogicalType::Boolean,\r\n                };\r\n\r\n                for arg in args.drain(..) {\r\n                    new_expr = ScalarExpression::Binary {\r\n                        op: op_2,\r\n                        left_expr: Box::new(ScalarExpression::Binary {\r\n                            op: op_1,\r\n                            left_expr: expr.clone(),\r\n                            right_expr: Box::new(arg),\r\n                            ty: LogicalType::Boolean,\r\n                        }),\r\n                        right_expr: Box::new(new_expr),\r\n                        ty: LogicalType::Boolean,\r\n                    }\r\n                }\r\n\r\n                let _ = mem::replace(self, new_expr);\r\n            }\r\n\r\n            ScalarExpression::Alias { expr, .. } =\u003e expr._simplify(replaces)?,\r\n            ScalarExpression::TypeCast { expr, .. } =\u003e {\r\n                if let Some(val) = expr.unpack_val() {\r\n                    let _ = mem::replace(self, ScalarExpression::Constant(val));\r\n                }\r\n            }\r\n            ScalarExpression::IsNull { expr, .. } =\u003e {\r\n                if let Some(val) = expr.unpack_val() {\r\n                    let _ = mem::replace(\r\n                        self,\r\n                        ScalarExpression::Constant(Arc::new(DataValue::Boolean(Some(\r\n                            val.is_null(),\r\n                        )))),\r\n                    );\r\n                }\r\n            }\r\n            ScalarExpression::Unary { expr, op, ty } =\u003e {\r\n                if let Some(val) = expr.unpack_val() {\r\n                    let new_expr =\r\n                        ScalarExpression::Constant(Arc::new(DataValue::unary_op(\u0026val, op)?));\r\n                    let _ = mem::replace(self, new_expr);\r\n                } else {\r\n                    replaces.push(Replace::Unary(ReplaceUnary {\r\n                        child_expr: expr.as_ref().clone(),\r\n                        op: *op,\r\n                        ty: *ty,\r\n                    }));\r\n                }\r\n            }\r\n            _ =\u003e (),\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn is_arithmetic(op: \u0026mut BinaryOperator) -\u003e bool {\r\n        matches!(\r\n            op,\r\n            BinaryOperator::Plus\r\n                | BinaryOperator::Divide\r\n                | BinaryOperator::Minus\r\n                | BinaryOperator::Multiply\r\n        )\r\n    }\r\n\r\n    fn fix_expr(\r\n        replaces: \u0026mut Vec\u003cReplace\u003e,\r\n        left_expr: \u0026mut Box\u003cScalarExpression\u003e,\r\n        right_expr: \u0026mut Box\u003cScalarExpression\u003e,\r\n        op: \u0026mut BinaryOperator,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        left_expr._simplify(replaces)?;\r\n\r\n        if Self::is_arithmetic(op) {\r\n            return Ok(());\r\n        }\r\n        while let Some(replace) = replaces.pop() {\r\n            match replace {\r\n                Replace::Binary(binary) =\u003e Self::fix_binary(binary, left_expr, right_expr, op),\r\n                Replace::Unary(unary) =\u003e {\r\n                    Self::fix_unary(unary, left_expr, right_expr, op);\r\n                    Self::fix_expr(replaces, left_expr, right_expr, op)?;\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn fix_unary(\r\n        replace_unary: ReplaceUnary,\r\n        col_expr: \u0026mut Box\u003cScalarExpression\u003e,\r\n        val_expr: \u0026mut Box\u003cScalarExpression\u003e,\r\n        op: \u0026mut BinaryOperator,\r\n    ) {\r\n        let ReplaceUnary {\r\n            child_expr,\r\n            op: fix_op,\r\n            ty: fix_ty,\r\n        } = replace_unary;\r\n        let _ = mem::replace(col_expr, Box::new(child_expr));\r\n        let _ = mem::replace(\r\n            val_expr,\r\n            Box::new(ScalarExpression::Unary {\r\n                op: fix_op,\r\n                expr: val_expr.clone(),\r\n                ty: fix_ty,\r\n            }),\r\n        );\r\n        let _ = mem::replace(\r\n            op,\r\n            match fix_op {\r\n                UnaryOperator::Plus =\u003e *op,\r\n                UnaryOperator::Minus =\u003e match *op {\r\n                    BinaryOperator::Plus =\u003e BinaryOperator::Minus,\r\n                    BinaryOperator::Minus =\u003e BinaryOperator::Plus,\r\n                    BinaryOperator::Multiply =\u003e BinaryOperator::Divide,\r\n                    BinaryOperator::Divide =\u003e BinaryOperator::Multiply,\r\n                    BinaryOperator::Gt =\u003e BinaryOperator::Lt,\r\n                    BinaryOperator::Lt =\u003e BinaryOperator::Gt,\r\n                    BinaryOperator::GtEq =\u003e BinaryOperator::LtEq,\r\n                    BinaryOperator::LtEq =\u003e BinaryOperator::GtEq,\r\n                    source_op =\u003e source_op,\r\n                },\r\n                UnaryOperator::Not =\u003e match *op {\r\n                    BinaryOperator::Gt =\u003e BinaryOperator::Lt,\r\n                    BinaryOperator::Lt =\u003e BinaryOperator::Gt,\r\n                    BinaryOperator::GtEq =\u003e BinaryOperator::LtEq,\r\n                    BinaryOperator::LtEq =\u003e BinaryOperator::GtEq,\r\n                    source_op =\u003e source_op,\r\n                },\r\n            },\r\n        );\r\n    }\r\n\r\n    fn fix_binary(\r\n        replace_binary: ReplaceBinary,\r\n        left_expr: \u0026mut Box\u003cScalarExpression\u003e,\r\n        right_expr: \u0026mut Box\u003cScalarExpression\u003e,\r\n        op: \u0026mut BinaryOperator,\r\n    ) {\r\n        let ReplaceBinary {\r\n            column_expr,\r\n            val_expr,\r\n            op: fix_op,\r\n            ty: fix_ty,\r\n            is_column_left,\r\n        } = replace_binary;\r\n        let op_flip = |op: BinaryOperator| match op {\r\n            BinaryOperator::Plus =\u003e BinaryOperator::Minus,\r\n            BinaryOperator::Minus =\u003e BinaryOperator::Plus,\r\n            BinaryOperator::Multiply =\u003e BinaryOperator::Divide,\r\n            BinaryOperator::Divide =\u003e BinaryOperator::Multiply,\r\n            _ =\u003e unreachable!(),\r\n        };\r\n        let comparison_flip = |op: BinaryOperator| match op {\r\n            BinaryOperator::Gt =\u003e BinaryOperator::Lt,\r\n            BinaryOperator::GtEq =\u003e BinaryOperator::LtEq,\r\n            BinaryOperator::Lt =\u003e BinaryOperator::Gt,\r\n            BinaryOperator::LtEq =\u003e BinaryOperator::GtEq,\r\n            source_op =\u003e source_op,\r\n        };\r\n        let (fixed_op, fixed_left_expr, fixed_right_expr) = if is_column_left {\r\n            (op_flip(fix_op), right_expr.clone(), Box::new(val_expr))\r\n        } else {\r\n            if matches!(fix_op, BinaryOperator::Minus | BinaryOperator::Multiply) {\r\n                let _ = mem::replace(op, comparison_flip(*op));\r\n            }\r\n            (fix_op, Box::new(val_expr), right_expr.clone())\r\n        };\r\n\r\n        let _ = mem::replace(left_expr, Box::new(column_expr));\r\n        let _ = mem::replace(\r\n            right_expr,\r\n            Box::new(ScalarExpression::Binary {\r\n                op: fixed_op,\r\n                left_expr: fixed_left_expr,\r\n                right_expr: fixed_right_expr,\r\n                ty: fix_ty,\r\n            }),\r\n        );\r\n    }\r\n\r\n    /// The definition of Or is not the Or in the Where condition.\r\n    /// The And and Or of ConstantBinary are concerned with the data range that needs to be aggregated.\r\n    /// - `ConstantBinary::And`: Aggregate the minimum range of all conditions in and\r\n    /// - `ConstantBinary::Or`: Rearrange and sort the range of each OR data\r\n    pub fn convert_binary(\u0026self, col_id: \u0026ColumnId) -\u003e Result\u003cOption\u003cConstantBinary\u003e\u003e {\r\n        match self {\r\n            ScalarExpression::Binary {\r\n                left_expr,\r\n                right_expr,\r\n                op,\r\n                ..\r\n            } =\u003e {\r\n                match (\r\n                    left_expr.convert_binary(col_id)?,\r\n                    right_expr.convert_binary(col_id)?,\r\n                ) {\r\n                    (Some(left_binary), Some(right_binary)) =\u003e match (left_binary, right_binary) {\r\n                        (ConstantBinary::And(mut left), ConstantBinary::And(mut right)) =\u003e match op\r\n                        {\r\n                            BinaryOperator::And =\u003e {\r\n                                left.append(\u0026mut right);\r\n\r\n                                Ok(Some(ConstantBinary::And(left)))\r\n                            }\r\n                            BinaryOperator::Or =\u003e Ok(Some(ConstantBinary::Or(vec![\r\n                                ConstantBinary::And(left),\r\n                                ConstantBinary::And(right),\r\n                            ]))),\r\n                            BinaryOperator::Xor =\u003e todo!(),\r\n                            _ =\u003e unreachable!(),\r\n                        },\r\n                        (ConstantBinary::Or(mut left), ConstantBinary::Or(mut right)) =\u003e match op {\r\n                            BinaryOperator::And | BinaryOperator::Or =\u003e {\r\n                                left.append(\u0026mut right);\r\n\r\n                                Ok(Some(ConstantBinary::Or(left)))\r\n                            }\r\n                            BinaryOperator::Xor =\u003e todo!(),\r\n                            _ =\u003e unreachable!(),\r\n                        },\r\n                        (ConstantBinary::And(mut left), ConstantBinary::Or(mut right)) =\u003e {\r\n                            right.append(\u0026mut left);\r\n\r\n                            Ok(Some(ConstantBinary::Or(right)))\r\n                        }\r\n                        (ConstantBinary::Or(mut left), ConstantBinary::And(mut right)) =\u003e {\r\n                            left.append(\u0026mut right);\r\n\r\n                            Ok(Some(ConstantBinary::Or(left)))\r\n                        }\r\n                        (ConstantBinary::And(mut binaries), binary)\r\n                        | (binary, ConstantBinary::And(mut binaries)) =\u003e {\r\n                            binaries.push(binary);\r\n\r\n                            Ok(Some(ConstantBinary::And(binaries)))\r\n                        }\r\n                        (ConstantBinary::Or(mut binaries), binary)\r\n                        | (binary, ConstantBinary::Or(mut binaries)) =\u003e {\r\n                            binaries.push(binary);\r\n\r\n                            Ok(Some(ConstantBinary::Or(binaries)))\r\n                        }\r\n                        (left, right) =\u003e match op {\r\n                            BinaryOperator::And =\u003e Ok(Some(ConstantBinary::And(vec![left, right]))),\r\n                            BinaryOperator::Or =\u003e Ok(Some(ConstantBinary::Or(vec![left, right]))),\r\n                            BinaryOperator::Xor =\u003e todo!(),\r\n                            _ =\u003e Ok(None),\r\n                        },\r\n                    },\r\n                    (None, None) =\u003e {\r\n                        if let (Some(col), Some(val)) =\r\n                            (left_expr.unpack_col(false), right_expr.unpack_val())\r\n                        {\r\n                            return Ok(Self::new_binary(col_id, *op, col, val, false));\r\n                        }\r\n                        if let (Some(val), Some(col)) =\r\n                            (left_expr.unpack_val(), right_expr.unpack_col(false))\r\n                        {\r\n                            return Ok(Self::new_binary(col_id, *op, col, val, true));\r\n                        }\r\n\r\n                        Ok(None)\r\n                    }\r\n                    (Some(binary), None) =\u003e Ok(Self::check_or(col_id, right_expr, op, binary)),\r\n                    (None, Some(binary)) =\u003e Ok(Self::check_or(col_id, left_expr, op, binary)),\r\n                }\r\n            }\r\n            ScalarExpression::Alias { expr, .. }\r\n            | ScalarExpression::TypeCast { expr, .. }\r\n            | ScalarExpression::In { expr, .. }\r\n            | ScalarExpression::Unary { expr, .. } =\u003e expr.convert_binary(col_id),\r\n            ScalarExpression::IsNull { expr, negated } =\u003e match expr.as_ref() {\r\n                ScalarExpression::ColumnRef(column) =\u003e {\r\n                    if let Some(id) = column.id() {\r\n                        if id == *col_id {\r\n                            return Ok(Some(if *negated {\r\n                                ConstantBinary::NotEq(NULL_VALUE.clone())\r\n                            } else {\r\n                                ConstantBinary::Eq(NULL_VALUE.clone())\r\n                            }));\r\n                        }\r\n                    }\r\n\r\n                    Ok(None)\r\n                }\r\n                ScalarExpression::Constant(_)\r\n                | ScalarExpression::Alias { .. }\r\n                | ScalarExpression::TypeCast { .. }\r\n                | ScalarExpression::IsNull { .. }\r\n                | ScalarExpression::Unary { .. }\r\n                | ScalarExpression::Binary { .. }\r\n                | ScalarExpression::AggCall { .. }\r\n                | ScalarExpression::In { .. } =\u003e expr.convert_binary(col_id),\r\n            },\r\n            _ =\u003e Ok(None),\r\n        }\r\n    }\r\n\r\n    /// check if: c1 \u003e c2 or c1 \u003e 1\r\n    /// this case it makes no sense to just extract c1 \u003e 1\r\n    fn check_or(\r\n        col_id: \u0026ColumnId,\r\n        right_expr: \u0026ScalarExpression,\r\n        op: \u0026BinaryOperator,\r\n        binary: ConstantBinary,\r\n    ) -\u003e Option\u003cConstantBinary\u003e {\r\n        if matches!(op, BinaryOperator::Or) \u0026\u0026 right_expr.exist_column(col_id) {\r\n            return None;\r\n        }\r\n\r\n        Some(binary)\r\n    }\r\n\r\n    fn new_binary(\r\n        col_id: \u0026ColumnId,\r\n        mut op: BinaryOperator,\r\n        col: ColumnRef,\r\n        val: ValueRef,\r\n        is_flip: bool,\r\n    ) -\u003e Option\u003cConstantBinary\u003e {\r\n        if col.id() != Some(*col_id) {\r\n            return None;\r\n        }\r\n\r\n        if is_flip {\r\n            op = match op {\r\n                BinaryOperator::Gt =\u003e BinaryOperator::Lt,\r\n                BinaryOperator::Lt =\u003e BinaryOperator::Gt,\r\n                BinaryOperator::GtEq =\u003e BinaryOperator::LtEq,\r\n                BinaryOperator::LtEq =\u003e BinaryOperator::GtEq,\r\n                source_op =\u003e source_op,\r\n            };\r\n        }\r\n\r\n        match op {\r\n            BinaryOperator::Gt =\u003e Some(ConstantBinary::Scope {\r\n                min: Bound::Excluded(val.clone()),\r\n                max: Bound::Unbounded,\r\n            }),\r\n            BinaryOperator::Lt =\u003e Some(ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(val.clone()),\r\n            }),\r\n            BinaryOperator::GtEq =\u003e Some(ConstantBinary::Scope {\r\n                min: Bound::Included(val.clone()),\r\n                max: Bound::Unbounded,\r\n            }),\r\n            BinaryOperator::LtEq =\u003e Some(ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Included(val.clone()),\r\n            }),\r\n            BinaryOperator::Eq | BinaryOperator::Spaceship =\u003e Some(ConstantBinary::Eq(val.clone())),\r\n            BinaryOperator::NotEq =\u003e Some(ConstantBinary::NotEq(val.clone())),\r\n            _ =\u003e None,\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for ConstantBinary {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        match self {\r\n            ConstantBinary::Scope { min, max } =\u003e {\r\n                match min {\r\n                    Bound::Unbounded =\u003e write!(f, \"-\")?,\r\n                    Bound::Included(value) =\u003e write!(f, \"[{}\", value)?,\r\n                    Bound::Excluded(value) =\u003e write!(f, \"({}\", value)?,\r\n                }\r\n\r\n                write!(f, \", \")?;\r\n\r\n                match max {\r\n                    Bound::Unbounded =\u003e write!(f, \"+\")?,\r\n                    Bound::Included(value) =\u003e write!(f, \"{}]\", value)?,\r\n                    Bound::Excluded(value) =\u003e write!(f, \"{})\", value)?,\r\n                }\r\n\r\n                Ok(())\r\n            }\r\n            ConstantBinary::Eq(value) =\u003e write!(f, \"{}\", value),\r\n            ConstantBinary::NotEq(value) =\u003e write!(f, \"!{}\", value),\r\n            ConstantBinary::And(binaries) =\u003e Self::join_write(f, binaries, \" AND \"),\r\n            ConstantBinary::Or(binaries) =\u003e Self::join_write(f, binaries, \" OR \"),\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n    use crate::catalog::{ColumnCatalog, ColumnDesc, ColumnSummary};\r\n    use crate::expression::simplify::ConstantBinary;\r\n    use crate::expression::{BinaryOperator, ScalarExpression};\r\n    use crate::types::value::DataValue;\r\n    use crate::types::LogicalType;\r\n    use std::collections::Bound;\r\n    use std::sync::Arc;\r\n\r\n    #[test]\r\n    fn test_convert_binary_simple() -\u003e Result\u003c()\u003e {\r\n        let col_1 = Arc::new(ColumnCatalog {\r\n            summary: ColumnSummary {\r\n                id: Some(0),\r\n                name: \"c1\".to_string(),\r\n                table_name: None,\r\n                \r\n            },\r\n            nullable: false,\r\n            desc: ColumnDesc {\r\n                column_datatype: LogicalType::Integer,\r\n                is_primary: false,\r\n                is_unique: false,\r\n                default: None,\r\n            },\r\n            // ref_expr: None,\r\n        });\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n\r\n        let binary_eq = ScalarExpression::Binary {\r\n            op: BinaryOperator::Eq,\r\n            left_expr: Box::new(ScalarExpression::Constant(val_1.clone())),\r\n            right_expr: Box::new(ScalarExpression::ColumnRef(col_1.clone())),\r\n            ty: LogicalType::Boolean,\r\n        }\r\n        .convert_binary(\u00260)?\r\n        .unwrap();\r\n\r\n        assert_eq!(binary_eq, ConstantBinary::Eq(val_1.clone()));\r\n\r\n        let binary_not_eq = ScalarExpression::Binary {\r\n            op: BinaryOperator::NotEq,\r\n            left_expr: Box::new(ScalarExpression::Constant(val_1.clone())),\r\n            right_expr: Box::new(ScalarExpression::ColumnRef(col_1.clone())),\r\n            ty: LogicalType::Boolean,\r\n        }\r\n        .convert_binary(\u00260)?\r\n        .unwrap();\r\n\r\n        assert_eq!(binary_not_eq, ConstantBinary::NotEq(val_1.clone()));\r\n\r\n        let binary_lt = ScalarExpression::Binary {\r\n            op: BinaryOperator::Lt,\r\n            left_expr: Box::new(ScalarExpression::ColumnRef(col_1.clone())),\r\n            right_expr: Box::new(ScalarExpression::Constant(val_1.clone())),\r\n            ty: LogicalType::Boolean,\r\n        }\r\n        .convert_binary(\u00260)?\r\n        .unwrap();\r\n\r\n        assert_eq!(\r\n            binary_lt,\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(val_1.clone())\r\n            }\r\n        );\r\n\r\n        let binary_lteq = ScalarExpression::Binary {\r\n            op: BinaryOperator::LtEq,\r\n            left_expr: Box::new(ScalarExpression::ColumnRef(col_1.clone())),\r\n            right_expr: Box::new(ScalarExpression::Constant(val_1.clone())),\r\n            ty: LogicalType::Boolean,\r\n        }\r\n        .convert_binary(\u00260)?\r\n        .unwrap();\r\n\r\n        assert_eq!(\r\n            binary_lteq,\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Included(val_1.clone())\r\n            }\r\n        );\r\n\r\n        let binary_gt = ScalarExpression::Binary {\r\n            op: BinaryOperator::Gt,\r\n            left_expr: Box::new(ScalarExpression::ColumnRef(col_1.clone())),\r\n            right_expr: Box::new(ScalarExpression::Constant(val_1.clone())),\r\n            ty: LogicalType::Boolean,\r\n        }\r\n        .convert_binary(\u00260)?\r\n        .unwrap();\r\n\r\n        assert_eq!(\r\n            binary_gt,\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Unbounded\r\n            }\r\n        );\r\n\r\n        let binary_gteq = ScalarExpression::Binary {\r\n            op: BinaryOperator::GtEq,\r\n            left_expr: Box::new(ScalarExpression::ColumnRef(col_1.clone())),\r\n            right_expr: Box::new(ScalarExpression::Constant(val_1.clone())),\r\n            ty: LogicalType::Boolean,\r\n        }\r\n        .convert_binary(\u00260)?\r\n        .unwrap();\r\n\r\n        assert_eq!(\r\n            binary_gteq,\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_1.clone()),\r\n                max: Bound::Unbounded\r\n            }\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_eq_noteq() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(0)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n        let val_2 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_3 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::And(vec![\r\n            ConstantBinary::Eq(val_0.clone()),\r\n            ConstantBinary::NotEq(val_1.clone()),\r\n            ConstantBinary::Eq(val_2.clone()),\r\n            ConstantBinary::NotEq(val_3.clone()),\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(binary, ConstantBinary::And(vec![ConstantBinary::Eq(val_0)]));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_eq_noteq_cover() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(0)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n        let val_2 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_3 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::And(vec![\r\n            ConstantBinary::Eq(val_0.clone()),\r\n            ConstantBinary::NotEq(val_1.clone()),\r\n            ConstantBinary::Eq(val_2.clone()),\r\n            ConstantBinary::NotEq(val_3.clone()),\r\n            ConstantBinary::NotEq(val_0.clone()),\r\n            ConstantBinary::NotEq(val_1.clone()),\r\n            ConstantBinary::NotEq(val_2.clone()),\r\n            ConstantBinary::NotEq(val_3.clone()),\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(binary, ConstantBinary::And(vec![]));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_scope() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(0)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n        let val_2 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_3 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::And(vec![\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_0.clone()),\r\n                max: Bound::Included(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_1.clone()),\r\n                max: Bound::Excluded(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Included(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Excluded(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Unbounded,\r\n            },\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(\r\n            binary,\r\n            ConstantBinary::And(vec![ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Excluded(val_2.clone()),\r\n            }])\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_mixed() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(0)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n        let val_2 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_3 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::And(vec![\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_0.clone()),\r\n                max: Bound::Included(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_1.clone()),\r\n                max: Bound::Excluded(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Included(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Excluded(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Unbounded,\r\n            },\r\n            ConstantBinary::Eq(val_1.clone()),\r\n            ConstantBinary::Eq(val_0.clone()),\r\n            ConstantBinary::NotEq(val_1.clone()),\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(\r\n            binary,\r\n            ConstantBinary::And(vec![ConstantBinary::Eq(val_0.clone())])\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_or() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(0)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n        let val_2 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_3 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::Or(vec![\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_0.clone()),\r\n                max: Bound::Included(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_1.clone()),\r\n                max: Bound::Excluded(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Included(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Excluded(val_3.clone()),\r\n            },\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(\r\n            binary,\r\n            ConstantBinary::Or(vec![ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Included(val_3.clone()),\r\n            }])\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_or_unbounded() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(0)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n        let val_2 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_3 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::Or(vec![\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Included(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Unbounded,\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Unbounded,\r\n            },\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(binary, ConstantBinary::Or(vec![]));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_or_lower_unbounded() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::Or(vec![\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(val_0.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Included(val_0.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(val_1.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Included(val_1.clone()),\r\n            },\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(\r\n            binary,\r\n            ConstantBinary::Or(vec![ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Included(val_1.clone()),\r\n            }])\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_scope_aggregation_or_upper_unbounded() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let mut binary = ConstantBinary::Or(vec![\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_0.clone()),\r\n                max: Bound::Unbounded,\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Unbounded,\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Unbounded,\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_1.clone()),\r\n                max: Bound::Unbounded,\r\n            },\r\n        ]);\r\n\r\n        binary.scope_aggregation()?;\r\n\r\n        assert_eq!(\r\n            binary,\r\n            ConstantBinary::Or(vec![ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Unbounded,\r\n            }])\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_rearrange() -\u003e Result\u003c()\u003e {\r\n        let val_0 = Arc::new(DataValue::Int32(Some(0)));\r\n        let val_1 = Arc::new(DataValue::Int32(Some(1)));\r\n        let val_2 = Arc::new(DataValue::Int32(Some(2)));\r\n        let val_3 = Arc::new(DataValue::Int32(Some(3)));\r\n\r\n        let val_5 = Arc::new(DataValue::Int32(Some(5)));\r\n\r\n        let val_6 = Arc::new(DataValue::Int32(Some(6)));\r\n        let val_7 = Arc::new(DataValue::Int32(Some(7)));\r\n        let val_8 = Arc::new(DataValue::Int32(Some(8)));\r\n\r\n        let val_10 = Arc::new(DataValue::Int32(Some(10)));\r\n\r\n        let binary = ConstantBinary::Or(vec![\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_6.clone()),\r\n                max: Bound::Included(val_10.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_0.clone()),\r\n                max: Bound::Included(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_1.clone()),\r\n                max: Bound::Excluded(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Excluded(val_1.clone()),\r\n                max: Bound::Included(val_2.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_0.clone()),\r\n                max: Bound::Excluded(val_3.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Included(val_6.clone()),\r\n                max: Bound::Included(val_7.clone()),\r\n            },\r\n            ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Unbounded,\r\n            },\r\n            ConstantBinary::NotEq(val_8.clone()),\r\n            ConstantBinary::Eq(val_5.clone()),\r\n            ConstantBinary::Eq(val_0.clone()),\r\n            ConstantBinary::Eq(val_1.clone()),\r\n        ]);\r\n\r\n        assert_eq!(\r\n            binary.rearrange()?,\r\n            vec![\r\n                ConstantBinary::Scope {\r\n                    min: Bound::Included(val_0.clone()),\r\n                    max: Bound::Included(val_3.clone()),\r\n                },\r\n                ConstantBinary::Eq(val_5.clone()),\r\n                ConstantBinary::Scope {\r\n                    min: Bound::Included(val_6.clone()),\r\n                    max: Bound::Included(val_10.clone()),\r\n                }\r\n            ]\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":2954361355555045376},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":11457157452030541824},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":5836665117072162816},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":11745387828182253568},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":11745387828182253568},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":7277816997830721536},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":3098476543630901248},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":13186539708940812288},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":13186539708940812288},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":11601272640106397696},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":11601272640106397696},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":494,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":495,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":505,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":2161727821137838066},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":13},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":15852670688344145921},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":10664523917613334519},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":11601272640106397708},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":2377900603251621888},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":546,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":547,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":576,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":612,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":288230376151711745},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":1008806316530991105},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":7493989779944505344},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":7493989779944505344},"fn_name":null},{"line":673,"address":[],"length":0,"stats":{"Line":11529215046068469762},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":11529215046068469763},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":11529215046068469761},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":4755801206503243776},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":11961560610296037378},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":1152921504606846977},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":1152921504606846977},"fn_name":null},{"line":689,"address":[],"length":0,"stats":{"Line":1152921504606846978},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":6773413839565225984},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":710,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":713,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":718,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":726,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":733,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":749,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":751,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":754,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":755,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":756,"address":[],"length":0,"stats":{"Line":2377900603251621888},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":764,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":766,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":800,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":7638104968020361216},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":808,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":815,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":817,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":826,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":831,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":832,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":834,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":837,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":843,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":847,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":849,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":857,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":861,"address":[],"length":0,"stats":{"Line":5044031582654955520},"fn_name":null},{"line":862,"address":[],"length":0,"stats":{"Line":6413125869375586304},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":5044031582654955520},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":872,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":875,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":879,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":880,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":881,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":883,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":884,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":886,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":887,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":903,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":905,"address":[],"length":0,"stats":{"Line":12249790986447749120},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":917,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":918,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":921,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":5980780305148018688},"fn_name":null},{"line":931,"address":[],"length":0,"stats":{"Line":5980780305148018688},"fn_name":null},{"line":932,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":935,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":936,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":937,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":938,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":939,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":940,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":941,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":945,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":946,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":947,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":948,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":950,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":951,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":952,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":954,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":955,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":956,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":958,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":959,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":960,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":962,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":963,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":964,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":970,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":971,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":972,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":973,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":974,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":975,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":976,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":979,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":981,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":982,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":983,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":984,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":987,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":989,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":992,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":392,"coverable":517},{"path":["E:","\\","sql-layer","src","expression","value_compute.rs"],"content":"use crate::errors::*;\r\nuse crate::expression::{BinaryOperator, UnaryOperator};\r\nuse crate::types::value::DataValue;\r\nuse crate::types::LogicalType;\r\nuse regex::Regex;\r\n\r\nfn unpack_i32(value: DataValue) -\u003e Option\u003ci32\u003e {\r\n    match value {\r\n        DataValue::Int32(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_i64(value: DataValue) -\u003e Option\u003ci64\u003e {\r\n    match value {\r\n        DataValue::Int64(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_u32(value: DataValue) -\u003e Option\u003cu32\u003e {\r\n    match value {\r\n        DataValue::UInt32(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_u64(value: DataValue) -\u003e Option\u003cu64\u003e {\r\n    match value {\r\n        DataValue::UInt64(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_f64(value: DataValue) -\u003e Option\u003cf64\u003e {\r\n    match value {\r\n        DataValue::Float64(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_f32(value: DataValue) -\u003e Option\u003cf32\u003e {\r\n    match value {\r\n        DataValue::Float32(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_bool(value: DataValue) -\u003e Option\u003cbool\u003e {\r\n    match value {\r\n        DataValue::Boolean(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_date(value: DataValue) -\u003e Option\u003ci64\u003e {\r\n    match value {\r\n        DataValue::Date64(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\n\r\nfn unpack_utf8(value: DataValue) -\u003e Option\u003cString\u003e {\r\n    match value {\r\n        DataValue::Utf8(inner) =\u003e inner,\r\n        _ =\u003e None,\r\n    }\r\n}\r\nimpl DataValue {\r\n    pub fn unary_op(value: \u0026DataValue, op: \u0026UnaryOperator) -\u003e Result\u003cDataValue\u003e {\r\n        let mut value_type = value.logical_type();\r\n        let mut value = value.clone();\r\n\r\n        if value_type.is_numeric() \u0026\u0026 matches!(op, UnaryOperator::Plus | UnaryOperator::Minus) {\r\n            if value_type.is_unsigned_numeric() {\r\n                match value_type {\r\n                    LogicalType::UTinyint =\u003e value_type = LogicalType::Tinyint,\r\n                    LogicalType::USmallint =\u003e value_type = LogicalType::Smallint,\r\n                    LogicalType::UInteger =\u003e value_type = LogicalType::Integer,\r\n                    LogicalType::UBigint =\u003e value_type = LogicalType::Bigint,\r\n                    _ =\u003e unreachable!(),\r\n                };\r\n                value = value.cast(\u0026value_type)?;\r\n            }\r\n\r\n            let result = match op {\r\n                UnaryOperator::Plus =\u003e value,\r\n                UnaryOperator::Minus =\u003e match value {\r\n                    DataValue::Float32(option) =\u003e DataValue::Float32(option.map(|v| -v)),\r\n                    DataValue::Float64(option) =\u003e DataValue::Float64(option.map(|v| -v)),\r\n                    DataValue::Int8(option) =\u003e DataValue::Int8(option.map(|v| -v)),\r\n                    DataValue::Int16(option) =\u003e DataValue::Int16(option.map(|v| -v)),\r\n                    DataValue::Int32(option) =\u003e DataValue::Int32(option.map(|v| -v)),\r\n                    DataValue::Int64(option) =\u003e DataValue::Int64(option.map(|v| -v)),\r\n                    _ =\u003e unreachable!(),\r\n                },\r\n                _ =\u003e unreachable!(),\r\n            };\r\n\r\n            Ok(result)\r\n        } else if matches!((value_type, op), (LogicalType::Boolean, UnaryOperator::Not)) {\r\n            match value {\r\n                DataValue::Boolean(option) =\u003e Ok(DataValue::Boolean(option.map(|v| !v))),\r\n                _ =\u003e unreachable!(),\r\n            }\r\n        } else {\r\n            Err(DatabaseError::InvalidType)\r\n        }\r\n    }\r\n\r\n    /// Tips:\r\n    /// - Null values operate as null values\r\n    pub fn binary_op(\r\n        left: \u0026DataValue,\r\n        right: \u0026DataValue,\r\n        op: \u0026BinaryOperator,\r\n    ) -\u003e Result\u003cDataValue\u003e {\r\n        if matches!(op, BinaryOperator::Like | BinaryOperator::NotLike) {\r\n            let value_option = unpack_utf8(left.clone().cast(\u0026LogicalType::Varchar(None))?);\r\n            let pattern_option = unpack_utf8(right.clone().cast(\u0026LogicalType::Varchar(None))?);\r\n\r\n            let mut is_match = if let (Some(value), Some(pattern)) = (value_option, pattern_option)\r\n            {\r\n                let regex_pattern = pattern.replace('%', \".*\").replace('_', \".\");\r\n\r\n                Regex::new(\u0026regex_pattern).unwrap().is_match(\u0026value)\r\n            } else {\r\n                unreachable!(\"The left and right values calculated by Like cannot be Null values.\")\r\n            };\r\n            if op == \u0026BinaryOperator::NotLike {\r\n                is_match = !is_match;\r\n            }\r\n            return Ok(DataValue::Boolean(Some(is_match)));\r\n        }\r\n        let unified_type =\r\n            LogicalType::max_logical_type(\u0026left.logical_type(), \u0026right.logical_type())?;\r\n\r\n        let value = match \u0026unified_type {\r\n            LogicalType::Integer =\u003e {\r\n                let left_value = unpack_i32(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_i32(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Plus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 + v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Int32(value)\r\n                    }\r\n                    BinaryOperator::Minus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 - v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Int32(value)\r\n                    }\r\n                    BinaryOperator::Multiply =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 * v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Int32(value)\r\n                    }\r\n                    BinaryOperator::Divide =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 as f64 / v2 as f64)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::Bigint =\u003e {\r\n                let left_value = unpack_i64(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_i64(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Plus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 + v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Int64(value)\r\n                    }\r\n                    BinaryOperator::Minus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 - v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Int64(value)\r\n                    }\r\n                    BinaryOperator::Multiply =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 * v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Int64(value)\r\n                    }\r\n                    BinaryOperator::Divide =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 as f64 / v2 as f64)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::UInteger =\u003e {\r\n                let left_value = unpack_u32(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_u32(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Plus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 + v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::UInt32(value)\r\n                    }\r\n                    BinaryOperator::Minus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 - v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::UInt32(value)\r\n                    }\r\n                    BinaryOperator::Multiply =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 * v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::UInt32(value)\r\n                    }\r\n                    BinaryOperator::Divide =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 as f64 / v2 as f64)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::UBigint =\u003e {\r\n                let left_value = unpack_u64(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_u64(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Plus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 + v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::UInt64(value)\r\n                    }\r\n                    BinaryOperator::Minus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 - v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::UInt64(value)\r\n                    }\r\n                    BinaryOperator::Multiply =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 * v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::UInt64(value)\r\n                    }\r\n                    BinaryOperator::Divide =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 as f64 / v2 as f64)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::Double =\u003e {\r\n                let left_value = unpack_f64(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_f64(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Plus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 + v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n                    BinaryOperator::Minus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 - v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n                    BinaryOperator::Multiply =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 * v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n                    BinaryOperator::Divide =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 / v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::Boolean =\u003e {\r\n                let left_value = unpack_bool(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_bool(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::And =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u0026\u0026 v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Or =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 || v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::Float =\u003e {\r\n                let left_value = unpack_f32(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_f32(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Plus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 + v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float32(value)\r\n                    }\r\n                    BinaryOperator::Minus =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 - v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float32(value)\r\n                    }\r\n                    BinaryOperator::Multiply =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 * v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float32(value)\r\n                    }\r\n                    BinaryOperator::Divide =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 as f64 / v2 as f64)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Float64(value)\r\n                    }\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::SqlNull =\u003e DataValue::Boolean(None),\r\n            LogicalType::DateTime =\u003e {\r\n                let left_value = unpack_date(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_date(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            LogicalType::Decimal(_, _) =\u003e {\r\n                let left_value = left.clone().cast(\u0026unified_type)?;\r\n                let right_value = right.clone().cast(\u0026unified_type)?;\r\n\r\n                match op {\r\n                    BinaryOperator::Plus =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 + v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Decimal(value)\r\n                    }\r\n                    BinaryOperator::Minus =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 - v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Decimal(value)\r\n                    }\r\n                    BinaryOperator::Multiply =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 * v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Decimal(value)\r\n                    }\r\n                    BinaryOperator::Divide =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 / v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Decimal(value)\r\n                    }\r\n\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 \u003e v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 \u003c v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 \u003e= v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value =\r\n                            if let (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\r\n                                (left_value, right_value)\r\n                            {\r\n                                Some(v1 \u003c= v2)\r\n                            } else {\r\n                                None\r\n                            };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\u003e {\r\n                                Some(v1 == v2)\r\n                            }\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (DataValue::Decimal(Some(v1)), DataValue::Decimal(Some(v2))) =\u003e {\r\n                                Some(v1 != v2)\r\n                            }\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e return Err(DatabaseError::UnsupportedBinaryOperator(unified_type, *op)),\r\n                }\r\n            }\r\n            LogicalType::Varchar(None) =\u003e {\r\n                let left_value = unpack_utf8(left.clone().cast(\u0026unified_type)?);\r\n                let right_value = unpack_utf8(right.clone().cast(\u0026unified_type)?);\r\n\r\n                match op {\r\n                    BinaryOperator::Gt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Lt =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::GtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003e= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::LtEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 \u003c= v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::Eq =\u003e {\r\n                        let value = match (left_value, right_value) {\r\n                            (Some(v1), Some(v2)) =\u003e Some(v1 == v2),\r\n                            (None, None) =\u003e Some(true),\r\n                            (_, _) =\u003e None,\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    BinaryOperator::NotEq =\u003e {\r\n                        let value = if let (Some(v1), Some(v2)) = (left_value, right_value) {\r\n                            Some(v1 != v2)\r\n                        } else {\r\n                            None\r\n                        };\r\n\r\n                        DataValue::Boolean(value)\r\n                    }\r\n                    _ =\u003e todo!(\"unsupported operator\"),\r\n                }\r\n            }\r\n            // Utf8\r\n            _ =\u003e todo!(\"unsupported data type\"),\r\n        };\r\n\r\n        Ok(value)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n    use crate::expression::BinaryOperator;\r\n    use crate::types::value::DataValue;\r\n\r\n    #[test]\r\n    fn test_binary_op_arithmetic_plus() -\u003e Result\u003c()\u003e {\r\n        let plus_i32_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_i32_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_i32_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_i32_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n\r\n        assert_eq!(plus_i32_1, plus_i32_2);\r\n        assert_eq!(plus_i32_2, plus_i32_3);\r\n        assert_eq!(plus_i32_4, DataValue::Int32(Some(2)));\r\n\r\n        let plus_i64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_i64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_i64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_i64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n\r\n        assert_eq!(plus_i64_1, plus_i64_2);\r\n        assert_eq!(plus_i64_2, plus_i64_3);\r\n        assert_eq!(plus_i64_4, DataValue::Int64(Some(2)));\r\n\r\n        let plus_f64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_f64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_f64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let plus_f64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n\r\n        assert_eq!(plus_f64_1, plus_f64_2);\r\n        assert_eq!(plus_f64_2, plus_f64_3);\r\n        assert_eq!(plus_f64_4, DataValue::Float64(Some(2.0)));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_arithmetic_minus() -\u003e Result\u003c()\u003e {\r\n        let minus_i32_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_i32_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_i32_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_i32_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n\r\n        assert_eq!(minus_i32_1, minus_i32_2);\r\n        assert_eq!(minus_i32_2, minus_i32_3);\r\n        assert_eq!(minus_i32_4, DataValue::Int32(Some(0)));\r\n\r\n        let minus_i64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_i64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_i64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_i64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n\r\n        assert_eq!(minus_i64_1, minus_i64_2);\r\n        assert_eq!(minus_i64_2, minus_i64_3);\r\n        assert_eq!(minus_i64_4, DataValue::Int64(Some(0)));\r\n\r\n        let minus_f64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_f64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_f64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n        let minus_f64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Minus,\r\n        )?;\r\n\r\n        assert_eq!(minus_f64_1, minus_f64_2);\r\n        assert_eq!(minus_f64_2, minus_f64_3);\r\n        assert_eq!(minus_f64_4, DataValue::Float64(Some(0.0)));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_arithmetic_multiply() -\u003e Result\u003c()\u003e {\r\n        let multiply_i32_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_i32_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_i32_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_i32_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n\r\n        assert_eq!(multiply_i32_1, multiply_i32_2);\r\n        assert_eq!(multiply_i32_2, multiply_i32_3);\r\n        assert_eq!(multiply_i32_4, DataValue::Int32(Some(1)));\r\n\r\n        let multiply_i64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_i64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_i64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_i64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n\r\n        assert_eq!(multiply_i64_1, multiply_i64_2);\r\n        assert_eq!(multiply_i64_2, multiply_i64_3);\r\n        assert_eq!(multiply_i64_4, DataValue::Int64(Some(1)));\r\n\r\n        let multiply_f64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_f64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_f64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n        let multiply_f64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Multiply,\r\n        )?;\r\n\r\n        assert_eq!(multiply_f64_1, multiply_f64_2);\r\n        assert_eq!(multiply_f64_2, multiply_f64_3);\r\n        assert_eq!(multiply_f64_4, DataValue::Float64(Some(1.0)));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_arithmetic_divide() -\u003e Result\u003c()\u003e {\r\n        let divide_i32_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_i32_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(None),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_i32_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(None),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_i32_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n\r\n        assert_eq!(divide_i32_1, divide_i32_2);\r\n        assert_eq!(divide_i32_2, divide_i32_3);\r\n        assert_eq!(divide_i32_4, DataValue::Float64(Some(1.0)));\r\n\r\n        let divide_i64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_i64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(None),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_i64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(None),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_i64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n\r\n        assert_eq!(divide_i64_1, divide_i64_2);\r\n        assert_eq!(divide_i64_2, divide_i64_3);\r\n        assert_eq!(divide_i64_4, DataValue::Float64(Some(1.0)));\r\n\r\n        let divide_f64_1 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_f64_2 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(None),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_f64_3 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(None),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n        let divide_f64_4 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026BinaryOperator::Divide,\r\n        )?;\r\n\r\n        assert_eq!(divide_f64_1, divide_f64_2);\r\n        assert_eq!(divide_f64_2, divide_f64_3);\r\n        assert_eq!(divide_f64_4, DataValue::Float64(Some(1.0)));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_cast() -\u003e Result\u003c()\u003e {\r\n        let i32_cast_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int8(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let i32_cast_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026DataValue::Int16(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n\r\n        assert_eq!(i32_cast_1, i32_cast_2);\r\n\r\n        let i64_cast_1 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int8(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let i64_cast_2 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int16(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        let i64_cast_3 = DataValue::binary_op(\r\n            \u0026DataValue::Int64(Some(1)),\r\n            \u0026DataValue::Int32(Some(1)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n\r\n        assert_eq!(i64_cast_1, i64_cast_2);\r\n        assert_eq!(i64_cast_2, i64_cast_3);\r\n\r\n        let f64_cast_1 = DataValue::binary_op(\r\n            \u0026DataValue::Float64(Some(1.0)),\r\n            \u0026DataValue::Float32(Some(1.0)),\r\n            \u0026BinaryOperator::Plus,\r\n        )?;\r\n        assert_eq!(f64_cast_1, DataValue::Float64(Some(2.0)));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_i32_compare() -\u003e Result\u003c()\u003e {\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026DataValue::Int32(Some(0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026DataValue::Int32(Some(0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(None),\r\n                \u0026DataValue::Int32(Some(0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(None),\r\n                \u0026DataValue::Int32(Some(0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(None),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(None),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(None),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(None),\r\n                \u0026DataValue::Int32(Some(1)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int32(None),\r\n                \u0026DataValue::Int32(None),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_i64_compare() -\u003e Result\u003c()\u003e {\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026DataValue::Int64(Some(0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026DataValue::Int64(Some(0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(None),\r\n                \u0026DataValue::Int64(Some(0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(None),\r\n                \u0026DataValue::Int64(Some(0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(None),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(None),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(None),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(None),\r\n                \u0026DataValue::Int64(Some(1)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Int64(None),\r\n                \u0026DataValue::Int64(None),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_f64_compare() -\u003e Result\u003c()\u003e {\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026DataValue::Float64(Some(0.0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026DataValue::Float64(Some(0.0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(None),\r\n                \u0026DataValue::Float64(Some(0.0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(None),\r\n                \u0026DataValue::Float64(Some(0.0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(None),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(None),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(None),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(None),\r\n                \u0026DataValue::Float64(Some(1.0)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float64(None),\r\n                \u0026DataValue::Float64(None),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_f32_compare() -\u003e Result\u003c()\u003e {\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026DataValue::Float32(Some(0.0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026DataValue::Float32(Some(0.0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(None),\r\n                \u0026DataValue::Float32(Some(0.0)),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(None),\r\n                \u0026DataValue::Float32(Some(0.0)),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(None),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(None),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(None),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(None),\r\n                \u0026DataValue::Float32(Some(1.0)),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Float32(None),\r\n                \u0026DataValue::Float32(None),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_bool_compare() -\u003e Result\u003c()\u003e {\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026BinaryOperator::And\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(Some(false)),\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026BinaryOperator::And\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(Some(false)),\r\n                \u0026DataValue::Boolean(Some(false)),\r\n                \u0026BinaryOperator::And\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(None),\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026BinaryOperator::And\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026BinaryOperator::Or\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(Some(false)),\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026BinaryOperator::Or\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(Some(false)),\r\n                \u0026DataValue::Boolean(Some(false)),\r\n                \u0026BinaryOperator::Or\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Boolean(None),\r\n                \u0026DataValue::Boolean(Some(true)),\r\n                \u0026BinaryOperator::Or\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_binary_op_utf8_compare() -\u003e Result\u003c()\u003e {\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026DataValue::Utf8(Some(\"b\".to_string())),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026DataValue::Utf8(Some(\"b\".to_string())),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(Some(false))\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::Eq\r\n            )?,\r\n            DataValue::Boolean(Some(true))\r\n        );\r\n\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(None),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::Gt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(None),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::Lt\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(None),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::GtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(None),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::LtEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n        assert_eq!(\r\n            DataValue::binary_op(\r\n                \u0026DataValue::Utf8(None),\r\n                \u0026DataValue::Utf8(Some(\"a\".to_string())),\r\n                \u0026BinaryOperator::NotEq\r\n            )?,\r\n            DataValue::Boolean(None)\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":8,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":9,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":4323455642275676160},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":4323455642275676160},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":4323455642275676160},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":4539628424389459968},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":15276209936040722432},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":11240984669916758016},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":15204152342002794496},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":4539628424389459968},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":452,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":491,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":518,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":527,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":4323455642275676160},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":562,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":597,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":599,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":662,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":675,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":684,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":694,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":730,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":732,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":747,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":766,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":768,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":775,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":810,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":822,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":823,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":828,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":829,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":831,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":840,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":841,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":843,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":852,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":857,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":863,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":869,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":876,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":877,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":880,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":882,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":888,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":890,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":892,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":900,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":901,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":906,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":914,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":918,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":926,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":934,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":935,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":936,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":938,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":943,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":947,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":948,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":952,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":953,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":955,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":961,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":962,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":964,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":970,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":971,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":973,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":979,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":980,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":982,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":988,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":989,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":990,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":991,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":998,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":1000,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":205,"coverable":370},{"path":["E:","\\","sql-layer","src","lib.rs"],"content":"pub mod binder;\r\npub mod catalog;\r\npub mod db;\r\npub mod errors;\r\npub mod execution;\r\npub mod expression;\r\npub mod optimizer;\r\npub mod parser;\r\npub mod planner;\r\npub mod server;\r\npub mod storage;\r\npub mod types;\r\n\r\n\r\nuse lazy_static::lazy_static;\r\nlazy_static! {\r\n    pub static ref CONFIG_MAP: std::collections::HashMap\u003cString, String\u003e = config::Config::builder()\r\n        .add_source(config::File::with_name(\"config/Settings.toml\"))\r\n        .build()\r\n        .unwrap()\r\n        .try_deserialize()\r\n        .unwrap();\r\n\r\n}","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","main.rs"],"content":"use std::path::PathBuf;\r\n\r\nuse piggysql::{\r\n    server::Server,\r\n    storage::{engine::piggykv::lsm_storage::LsmStorageOptions, piggy_stroage::PiggyKVStroage},\r\n    CONFIG_MAP,\r\n};\r\nuse tracing::Level;\r\n\r\nuse tracing_subscriber::FmtSubscriber;\r\n\r\n#[tokio::main(worker_threads = 8)]\r\nasync fn main() {\r\n    let log_level = CONFIG_MAP.get(\"log_level\").unwrap();\r\n    let log_level = match log_level.to_lowercase().as_str() {\r\n        \"info\" =\u003e Level::INFO,\r\n        \"debug\" =\u003e Level::DEBUG,\r\n        \"warn\" =\u003e Level::WARN,\r\n        \"error\" =\u003e Level::ERROR,\r\n        \"trace\" =\u003e Level::TRACE,\r\n        _ =\u003e Level::INFO,\r\n    };\r\n    let file_appender = tracing_appender::rolling::hourly(\"./\", \"db.log\");\r\n    let (non_blocking, _guard) = tracing_appender::non_blocking(file_appender);\r\n\r\n    let subscriber = FmtSubscriber::builder()\r\n        // all spans/events with a level higher than TRACE (e.g, debug, info, warn, etc.)\r\n        // will be written to stdout.\r\n        .with_max_level(log_level)\r\n        .with_writer(non_blocking)\r\n        // completes the builder.\r\n        .finish();\r\n\r\n    tracing::subscriber::set_global_default(subscriber).expect(\"setting default subscriber failed\");\r\n    let filename = CONFIG_MAP.get(\"filename\").unwrap();\r\n    let bloom_false_positive_rate = CONFIG_MAP\r\n        .get(\"bloom_false_positive_rate\")\r\n        .cloned()\r\n        .unwrap_or(\"0.01\".to_string())\r\n        .parse::\u003cf64\u003e()\r\n        .unwrap_or(0.01);\r\n    let compaction = CONFIG_MAP.get(\"compaction\").unwrap().clone();\r\n    let option = match compaction.to_lowercase().as_str() {\r\n        \"leveled\" =\u003e LsmStorageOptions::leveled_compaction()\r\n            .with_bloom_false_positive_rate(bloom_false_positive_rate),\r\n        \"simple\" =\u003e {\r\n            LsmStorageOptions::default().with_bloom_false_positive_rate(bloom_false_positive_rate)\r\n        }\r\n        _ =\u003e LsmStorageOptions::no_compaction()\r\n            .with_bloom_false_positive_rate(bloom_false_positive_rate),\r\n    };\r\n    let store = PiggyKVStroage::new(PathBuf::from(filename), Some(option));\r\n    let server = Server::new(store).await.unwrap();\r\n    Server::run(server).await;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","optimizer","core","mod.rs"],"content":"pub(crate) mod pattern;\r\npub(crate) mod rule;\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","optimizer","core","pattern.rs"],"content":"use crate::planner::operator::Operator;\r\n\r\npub enum PatternChildrenPredicate {\r\n    /// all childrens nodes match all\r\n    Recursive,\r\n    /// match many pattern at the time\r\n    Predicate(Vec\u003cPattern\u003e),\r\n    /// childrens jump out match\r\n    None,\r\n}\r\n\r\n/// The pattern tree to match a plan tree. It defined in `Rule` and used in `PatternMatcher`.\r\npub struct Pattern {\r\n    /// The root node predicate, not contains the children.\r\n    pub predicate: fn(\u0026Operator) -\u003e bool,\r\n    /// The children's predicate of current node.\r\n    pub children: PatternChildrenPredicate,\r\n}\r\n\r\npub trait PatternMatcher {\r\n    fn match_opt_expr(\u0026self) -\u003e bool;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","optimizer","core","rule.rs"],"content":"use crate::errors::*;\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\n\r\nuse super::pattern::Pattern;\r\n\r\n/// A rule is to transform logically equivalent expression\r\npub trait Rule {\r\n    /// The pattern to determine whether the rule can be applied.\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern;\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e;\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","optimizer","heuristic","batch.rs"],"content":"use crate::optimizer::rule::RuleImpl;\r\n\r\n/// A batch of rules.\r\n#[derive(Clone)]\r\npub struct HepBatch {\r\n    pub name: String,\r\n    pub strategy: HepBatchStrategy,\r\n    pub rules: Vec\u003cRuleImpl\u003e,\r\n}\r\n\r\nimpl HepBatch {\r\n    pub fn new(name: String, strategy: HepBatchStrategy, rules: Vec\u003cRuleImpl\u003e) -\u003e Self {\r\n        Self {\r\n            name,\r\n            strategy,\r\n            rules,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Clone)]\r\npub struct HepBatchStrategy {\r\n    /// An execution_ap strategy for rules that indicates the maximum number of executions. If the\r\n    /// execution_ap reaches fix point (i.e. converge) before maxIterations, it will stop.\r\n    ///\r\n    /// Fix Point means that plan tree not changed after applying all rules.\r\n    pub max_iteration: usize,\r\n    /// An order to traverse the plan tree nodes.\r\n    pub match_order: HepMatchOrder,\r\n}\r\n\r\nimpl HepBatchStrategy {\r\n    pub fn once_topdown() -\u003e Self {\r\n        HepBatchStrategy {\r\n            max_iteration: 1,\r\n            match_order: HepMatchOrder::TopDown,\r\n        }\r\n    }\r\n\r\n    pub fn fix_point_topdown(max_iteration: usize) -\u003e Self {\r\n        HepBatchStrategy {\r\n            max_iteration,\r\n            match_order: HepMatchOrder::TopDown,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Clone, Copy)]\r\npub enum HepMatchOrder {\r\n    /// Match from root down. A match attempt at an ancestor always precedes all match attempts at\r\n    /// its descendants.\r\n    TopDown,\r\n    /// Match from leaves up. A match attempt at a descendant precedes all match attempts at its\r\n    /// ancestors.\r\n    #[allow(dead_code)]\r\n    BottomUp,\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":5620492334958379009},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":12970366926827028480},"fn_name":null}],"covered":3,"coverable":3},{"path":["E:","\\","sql-layer","src","optimizer","heuristic","graph.rs"],"content":"use crate::optimizer::heuristic::batch::HepMatchOrder;\r\nuse crate::planner::operator::Operator;\r\nuse crate::planner::LogicalPlan;\r\nuse itertools::Itertools;\r\nuse petgraph::stable_graph::{NodeIndex, StableDiGraph};\r\nuse petgraph::visit::{Bfs, EdgeRef};\r\nuse std::mem;\r\npub type OptExprNodeId = usize;\r\n\r\n/// HepNodeId is used in optimizer to identify a node.\r\npub type HepNodeId = NodeIndex\u003cOptExprNodeId\u003e;\r\n\r\n#[derive(Debug)]\r\npub struct HepGraph {\r\n    graph: StableDiGraph\u003cOperator, usize, usize\u003e,\r\n    root_index: HepNodeId,\r\n    pub version: usize,\r\n}\r\n\r\nimpl HepGraph {\r\n    pub fn new(root: LogicalPlan) -\u003e Self {\r\n        fn graph_filling(\r\n            graph: \u0026mut StableDiGraph\u003cOperator, usize, usize\u003e,\r\n            LogicalPlan {\r\n                operator,\r\n                childrens,\r\n                ..\r\n            }: LogicalPlan,\r\n        ) -\u003e HepNodeId {\r\n            let index = graph.add_node(operator);\r\n\r\n            for (order, child) in childrens.into_iter().enumerate() {\r\n                let child_index = graph_filling(graph, child);\r\n                let _ = graph.add_edge(index, child_index, order);\r\n            }\r\n\r\n            index\r\n        }\r\n\r\n        let mut graph = StableDiGraph::\u003cOperator, usize, usize\u003e::default();\r\n\r\n        let root_index = graph_filling(\u0026mut graph, root);\r\n\r\n        HepGraph {\r\n            graph,\r\n            root_index,\r\n            version: 0,\r\n        }\r\n    }\r\n\r\n    pub fn parent_id(\u0026self, node_id: HepNodeId) -\u003e Option\u003cHepNodeId\u003e {\r\n        self.graph\r\n            .neighbors_directed(node_id, petgraph::Direction::Incoming)\r\n            .next()\r\n    }\r\n\r\n    pub fn eldest_child_at(\u0026self, id: HepNodeId) -\u003e Option\u003cHepNodeId\u003e {\r\n        self.graph\r\n            .edges(id)\r\n            .min_by_key(|edge| edge.weight())\r\n            .map(|edge| edge.target())\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    pub fn add_root(\u0026mut self, new_node: Operator) {\r\n        let old_root_id = mem::replace(\u0026mut self.root_index, self.graph.add_node(new_node));\r\n\r\n        self.graph.add_edge(self.root_index, old_root_id, 0);\r\n        self.version += 1;\r\n    }\r\n\r\n    pub fn add_node(\r\n        \u0026mut self,\r\n        source_id: HepNodeId,\r\n        children_option: Option\u003cHepNodeId\u003e,\r\n        new_node: Operator,\r\n    ) {\r\n        let new_index = self.graph.add_node(new_node);\r\n        let mut order = self.graph.edges(source_id).count();\r\n\r\n        if let Some((children_id, old_edge_id)) = children_option.and_then(|children_id| {\r\n            self.graph\r\n                .find_edge(source_id, children_id)\r\n                .map(|old_edge_id| (children_id, old_edge_id))\r\n        }) {\r\n            order = self.graph.remove_edge(old_edge_id).unwrap_or(0);\r\n\r\n            self.graph.add_edge(new_index, children_id, 0);\r\n        }\r\n\r\n        self.graph.add_edge(source_id, new_index, order);\r\n        self.version += 1;\r\n    }\r\n\r\n    pub fn replace_node(\u0026mut self, source_id: HepNodeId, new_node: Operator) {\r\n        self.graph[source_id] = new_node;\r\n        self.version += 1;\r\n    }\r\n\r\n    pub fn swap_node(\u0026mut self, a: HepNodeId, b: HepNodeId) {\r\n        let tmp = self.graph[a].clone();\r\n\r\n        self.graph[a] = mem::replace(\u0026mut self.graph[b], tmp);\r\n        self.version += 1;\r\n    }\r\n\r\n    pub fn remove_node(\u0026mut self, source_id: HepNodeId, with_childrens: bool) -\u003e Option\u003cOperator\u003e {\r\n        if !with_childrens {\r\n            let children_ids = self\r\n                .graph\r\n                .edges(source_id)\r\n                .sorted_by_key(|edge_ref| edge_ref.weight())\r\n                .map(|edge_ref| edge_ref.target())\r\n                .collect_vec();\r\n\r\n            if let Some(parent_id) = self.parent_id(source_id) {\r\n                if let Some(edge) = self.graph.find_edge(parent_id, source_id) {\r\n                    let weight = *self.graph.edge_weight(edge).unwrap_or(\u00260);\r\n\r\n                    for (order, children_id) in children_ids.into_iter().enumerate() {\r\n                        let _ = self.graph.add_edge(parent_id, children_id, weight + order);\r\n                    }\r\n                }\r\n            } else {\r\n                assert!(children_ids.len() \u003c 2);\r\n                self.root_index = children_ids[0];\r\n            }\r\n        }\r\n\r\n        self.version += 1;\r\n        self.graph.remove_node(source_id)\r\n    }\r\n\r\n    /// Traverse the graph in BFS order.\r\n    fn bfs(\u0026self, start: HepNodeId) -\u003e Vec\u003cHepNodeId\u003e {\r\n        let mut ids = Vec::with_capacity(self.graph.node_count());\r\n        let mut iter = Bfs::new(\u0026self.graph, start);\r\n        while let Some(node_id) = iter.next(\u0026self.graph) {\r\n            ids.push(node_id);\r\n        }\r\n        ids\r\n    }\r\n\r\n    /// Use bfs to traverse the graph and return node ids\r\n    pub fn nodes_iter(\r\n        \u0026self,\r\n        order: HepMatchOrder,\r\n        start_option: Option\u003cHepNodeId\u003e,\r\n    ) -\u003e Box\u003cdyn Iterator\u003cItem = HepNodeId\u003e\u003e {\r\n        let ids = self.bfs(start_option.unwrap_or(self.root_index));\r\n        match order {\r\n            HepMatchOrder::TopDown =\u003e Box::new(ids.into_iter()),\r\n            HepMatchOrder::BottomUp =\u003e Box::new(ids.into_iter().rev()),\r\n        }\r\n    }\r\n\r\n    #[allow(dead_code)]\r\n    pub fn node(\u0026self, node_id: HepNodeId) -\u003e Option\u003c\u0026Operator\u003e {\r\n        self.graph.node_weight(node_id)\r\n    }\r\n\r\n    pub fn operator(\u0026self, node_id: HepNodeId) -\u003e \u0026Operator {\r\n        \u0026self.graph[node_id]\r\n    }\r\n\r\n    pub fn operator_mut(\u0026mut self, node_id: HepNodeId) -\u003e \u0026mut Operator {\r\n        \u0026mut self.graph[node_id]\r\n    }\r\n\r\n    pub fn to_plan(\u0026self) -\u003e LogicalPlan {\r\n        self.to_plan_with_index(self.root_index)\r\n    }\r\n\r\n    /// If input node is join, we use the edge weight to control the join chilren order.\r\n    pub fn children_at(\u0026self, id: HepNodeId) -\u003e Vec\u003cHepNodeId\u003e {\r\n        self.graph\r\n            .edges(id)\r\n            .sorted_by_key(|edge| edge.weight())\r\n            .map(|edge| edge.target())\r\n            .collect_vec()\r\n    }\r\n\r\n    pub fn to_plan_with_index(\u0026self, start_index: HepNodeId) -\u003e LogicalPlan {\r\n        let mut root_plan = LogicalPlan {\r\n            operator: self.operator(start_index).clone(),\r\n            childrens: vec![],\r\n            _output_schema_ref: None,\r\n        };\r\n\r\n        self.build_childrens(\u0026mut root_plan, start_index);\r\n\r\n        root_plan\r\n    }\r\n\r\n    fn build_childrens(\u0026self, plan: \u0026mut LogicalPlan, start: HepNodeId) {\r\n        for child_id in self.children_at(start) {\r\n            let mut child_plan = LogicalPlan {\r\n                operator: self.operator(child_id).clone(),\r\n                childrens: vec![],\r\n                _output_schema_ref: None,\r\n            };\r\n\r\n            self.build_childrens(\u0026mut child_plan, child_id);\r\n            plan.childrens.push(child_plan);\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::binder::test::select_sql_run;\r\n    use crate::errors::*;\r\n    use crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\n    use crate::planner::operator::Operator;\r\n    use petgraph::stable_graph::{EdgeIndex, NodeIndex};\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_for_plan() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let graph = HepGraph::new(plan);\r\n\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(1), NodeIndex::new(2)));\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(1), NodeIndex::new(3)));\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(0), NodeIndex::new(1)));\r\n\r\n        assert_eq!(graph.graph.edge_weight(EdgeIndex::new(0)), Some(\u00260));\r\n        assert_eq!(graph.graph.edge_weight(EdgeIndex::new(1)), Some(\u00261));\r\n        assert_eq!(graph.graph.edge_weight(EdgeIndex::new(2)), Some(\u00260));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_add_node() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let mut graph = HepGraph::new(plan);\r\n\r\n        graph.add_node(HepNodeId::new(1), None, Operator::Dummy);\r\n\r\n        graph.add_node(HepNodeId::new(1), Some(HepNodeId::new(4)), Operator::Dummy);\r\n\r\n        graph.add_node(HepNodeId::new(5), None, Operator::Dummy);\r\n\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(5), NodeIndex::new(4)));\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(1), NodeIndex::new(5)));\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(5), NodeIndex::new(6)));\r\n\r\n        assert_eq!(graph.graph.edge_weight(EdgeIndex::new(3)), Some(\u00260));\r\n        assert_eq!(graph.graph.edge_weight(EdgeIndex::new(4)), Some(\u00262));\r\n        assert_eq!(graph.graph.edge_weight(EdgeIndex::new(5)), Some(\u00261));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_replace_node() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let mut graph = HepGraph::new(plan);\r\n\r\n        graph.replace_node(HepNodeId::new(1), Operator::Dummy);\r\n\r\n        assert!(matches!(graph.operator(HepNodeId::new(1)), Operator::Dummy));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_remove_middle_node_by_single() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let mut graph = HepGraph::new(plan);\r\n\r\n        graph.remove_node(HepNodeId::new(1), false);\r\n\r\n        assert_eq!(graph.graph.edge_count(), 2);\r\n\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(0), NodeIndex::new(2)));\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(0), NodeIndex::new(3)));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_remove_middle_node_with_childrens() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let mut graph = HepGraph::new(plan);\r\n\r\n        graph.remove_node(HepNodeId::new(1), true);\r\n\r\n        assert_eq!(graph.graph.edge_count(), 0);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_swap_node() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let mut graph = HepGraph::new(plan);\r\n\r\n        let before_op_0 = graph.operator(HepNodeId::new(0)).clone();\r\n        let before_op_1 = graph.operator(HepNodeId::new(1)).clone();\r\n\r\n        graph.swap_node(HepNodeId::new(0), HepNodeId::new(1));\r\n\r\n        let op_0 = graph.operator(HepNodeId::new(0));\r\n        let op_1 = graph.operator(HepNodeId::new(1));\r\n\r\n        assert_eq!(op_0, \u0026before_op_1);\r\n        assert_eq!(op_1, \u0026before_op_0);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_add_root() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let mut graph = HepGraph::new(plan);\r\n\r\n        graph.add_root(Operator::Dummy);\r\n\r\n        assert_eq!(graph.graph.edge_count(), 4);\r\n        assert!(graph\r\n            .graph\r\n            .contains_edge(NodeIndex::new(4), NodeIndex::new(0)));\r\n        assert_eq!(graph.graph.edge_weight(EdgeIndex::new(3)), Some(\u00260));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_graph_to_plan() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3\").await?;\r\n        let graph = HepGraph::new(plan.clone());\r\n\r\n        let plan_for_graph = graph.to_plan();\r\n\r\n        assert_eq!(plan, plan_for_graph);\r\n\r\n        let plan_by_index = graph.to_plan_with_index(HepNodeId::new(1));\r\n\r\n        assert_eq!(plan.childrens[0], plan_by_index);\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":6124895493223874561},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":5980780305148018689},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":5980780305148018689},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":11889503016258109441},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":18302628885633695745},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":18302628885633695745},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":5980780305148018689},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":6124895493223874561},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":6124895493223874561},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":9655717601082343424},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":9655717601082343424},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":9655717601082343424},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":2594073385365405717},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":16140901064495857671},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":9511602413006487570},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":9511602413006487570},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":9511602413006487570},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":9511602413006487563},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":7},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":15924728282382073856},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":15924728282382073856},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":432345564227567634},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":432345564227567634},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":5620492334958379013},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":5620492334958379013},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":17509995351216488448},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":17509995351216488448},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":17509995351216488448},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":6773413839565225984},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":14627691589699371008},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":5692549928996306951},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":5692549928996306951},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":5692549928996306951},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":5692549928996306951},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":5692549928996306951},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":16645304222761353216},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":10952754293765046272},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":10952754293765046272},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":10952754293765046272},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":10952754293765046272},"fn_name":null}],"covered":83,"coverable":87},{"path":["E:","\\","sql-layer","src","optimizer","heuristic","matcher.rs"],"content":"use crate::optimizer::core::pattern::{Pattern, PatternChildrenPredicate, PatternMatcher};\r\nuse crate::optimizer::heuristic::batch::HepMatchOrder;\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\n\r\n/// Use pattern to determines which rule can be applied\r\npub struct HepMatcher\u003c'a, 'b\u003e {\r\n    pattern: \u0026'a Pattern,\r\n    start_id: HepNodeId,\r\n    graph: \u0026'b HepGraph,\r\n}\r\n\r\nimpl\u003c'a, 'b\u003e HepMatcher\u003c'a, 'b\u003e {\r\n    pub(crate) fn new(pattern: \u0026'a Pattern, start_id: HepNodeId, graph: \u0026'b HepGraph) -\u003e Self {\r\n        Self {\r\n            pattern,\r\n            start_id,\r\n            graph,\r\n        }\r\n    }\r\n}\r\n\r\nimpl PatternMatcher for HepMatcher\u003c'_, '_\u003e {\r\n    fn match_opt_expr(\u0026self) -\u003e bool {\r\n        let op = self.graph.operator(self.start_id);\r\n        // check the root node predicate\r\n        if !(self.pattern.predicate)(op) {\r\n            return false;\r\n        }\r\n\r\n        match \u0026self.pattern.children {\r\n            PatternChildrenPredicate::Recursive =\u003e {\r\n                // check\r\n                for node_id in self\r\n                    .graph\r\n                    .nodes_iter(HepMatchOrder::TopDown, Some(self.start_id))\r\n                {\r\n                    if !(self.pattern.predicate)(self.graph.operator(node_id)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n            PatternChildrenPredicate::Predicate(patterns) =\u003e {\r\n                for node_id in self.graph.children_at(self.start_id) {\r\n                    for pattern in patterns {\r\n                        if !HepMatcher::new(pattern, node_id, self.graph).match_opt_expr() {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            PatternChildrenPredicate::None =\u003e (),\r\n        }\r\n\r\n        true\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":14411518807585587216},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":14411518807585587216},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":14411518807585587216},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":11673330234144325648},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":17726168133330272268},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":8863084066665136140},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":8863084066665136140},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4035225266123964418},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":14771806777775226888},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":9727775195120271360},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":792633534417207300},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":1945555039024054278},"fn_name":null}],"covered":17,"coverable":17},{"path":["E:","\\","sql-layer","src","optimizer","heuristic","mod.rs"],"content":"pub(crate) mod batch;\r\npub(crate) mod graph;\r\npub(crate) mod matcher;\r\npub mod optimizer;\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","optimizer","heuristic","optimizer.rs"],"content":"use crate::errors::*;\r\nuse crate::optimizer::core::pattern::PatternMatcher;\r\nuse crate::optimizer::core::rule::Rule;\r\nuse crate::optimizer::heuristic::batch::{HepBatch, HepBatchStrategy};\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\nuse crate::optimizer::heuristic::matcher::HepMatcher;\r\nuse crate::optimizer::rule::RuleImpl;\r\nuse crate::planner::LogicalPlan;\r\n\r\npub struct HepOptimizer {\r\n    batches: Vec\u003cHepBatch\u003e,\r\n    pub graph: HepGraph,\r\n}\r\n\r\nimpl HepOptimizer {\r\n    pub fn new(root: LogicalPlan) -\u003e Self {\r\n        Self {\r\n            batches: vec![],\r\n            graph: HepGraph::new(root),\r\n        }\r\n    }\r\n\r\n    pub fn batch(mut self, name: String, strategy: HepBatchStrategy, rules: Vec\u003cRuleImpl\u003e) -\u003e Self {\r\n        self.batches.push(HepBatch::new(name, strategy, rules));\r\n        self\r\n    }\r\n\r\n    pub fn find_best(\u0026mut self) -\u003e Result\u003cLogicalPlan\u003e {\r\n        let batches = self.batches.clone();\r\n\r\n        for batch in batches {\r\n            let mut batch_over = false;\r\n            let mut iteration = 1usize;\r\n\r\n            while iteration \u003c= batch.strategy.max_iteration \u0026\u0026 !batch_over {\r\n                if self.apply_batch(\u0026batch)? {\r\n                    iteration += 1;\r\n                } else {\r\n                    batch_over = true\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(self.graph.to_plan())\r\n    }\r\n\r\n    fn apply_batch(\r\n        \u0026mut self,\r\n        HepBatch {\r\n            rules, strategy, ..\r\n        }: \u0026HepBatch,\r\n    ) -\u003e Result\u003cbool\u003e {\r\n        let start_ver = self.graph.version;\r\n\r\n        for rule in rules {\r\n            for node_id in self.graph.nodes_iter(strategy.match_order, None) {\r\n                if self.apply_rule(rule, node_id)? {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(start_ver != self.graph.version)\r\n    }\r\n\r\n    fn apply_rule(\u0026mut self, rule: \u0026RuleImpl, node_id: HepNodeId) -\u003e Result\u003cbool\u003e {\r\n        let after_version = self.graph.version;\r\n\r\n        if HepMatcher::new(rule.pattern(), node_id, \u0026self.graph).match_opt_expr() {\r\n            rule.apply(node_id, \u0026mut self.graph)?;\r\n        }\r\n\r\n        Ok(after_version != self.graph.version)\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":5548434740920451074},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":5548434740920451074},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":5548434740920451074},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":5548434740920451073},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":5548434740920451073},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":5836665117072162818},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":13763000461244235782},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":12610078956637388803},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":9727775195120271362},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":5548434740920451072},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":11168927075878830080},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":11168927075878830080},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":12465963768561532932},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":12393906174523604994},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":8935141660703064066},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":11168927075878830084},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":12393906174523605004},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":12393906174523605004},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":12393906174523605004},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":9655717601082343440},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null}],"covered":26,"coverable":26},{"path":["E:","\\","sql-layer","src","optimizer","mod.rs"],"content":"use std::time::Instant;\r\n\r\nuse tracing::{trace};\r\n\r\nuse crate::{optimizer::heuristic::optimizer::HepOptimizer, planner::LogicalPlan};\r\n\r\nuse self::{heuristic::batch::HepBatchStrategy, rule::RuleImpl};\r\nuse crate::errors::*;\r\nmod core;\r\npub mod heuristic;\r\npub mod rule;\r\n\r\npub fn apply_optimization(plan: LogicalPlan) -\u003e Result\u003cLogicalPlan\u003e {\r\n    let before = Instant::now();\r\n    let plan = HepOptimizer::new(plan)\r\n        .batch(\r\n            \"Column Pruning\".to_string(),\r\n            HepBatchStrategy::once_topdown(),\r\n            vec![RuleImpl::ColumnPruning],\r\n        )\r\n        .batch(\r\n            \"Simplify Filter\".to_string(),\r\n            HepBatchStrategy::fix_point_topdown(10),\r\n            vec![\r\n                RuleImpl::SimplifyFilter,\r\n                RuleImpl::ConstantFolder,\r\n                RuleImpl::CollapseProject,\r\n            ],\r\n        )\r\n        .batch(\r\n            \"Predicate Pushdown\".to_string(),\r\n            HepBatchStrategy::fix_point_topdown(10),\r\n            vec![\r\n                RuleImpl::PushPredicateThroughJoin,\r\n                RuleImpl::PushPredicateIntoScan,\r\n            ],\r\n        )\r\n        .batch(\r\n            \"Combine Operators\".to_string(),\r\n            HepBatchStrategy::fix_point_topdown(10),\r\n            vec![RuleImpl::CollapseProject, RuleImpl::CombineFilter],\r\n        )\r\n        .batch(\r\n            \"Limit Pushdown\".to_string(),\r\n            HepBatchStrategy::fix_point_topdown(10),\r\n            vec![\r\n                RuleImpl::LimitProjectTranspose,\r\n                RuleImpl::PushLimitThroughJoin,\r\n                RuleImpl::PushLimitIntoTableScan,\r\n                RuleImpl::EliminateLimits,\r\n            ],\r\n        )\r\n        .find_best();\r\n    let after = Instant::now();\r\n    trace!(\r\n        \"apply optimization cost time : {} us\",\r\n        after.duration_since(before).as_micros()\r\n    );\r\n    plan\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null}],"covered":30,"coverable":31},{"path":["E:","\\","sql-layer","src","optimizer","rule","column_pruning.rs"],"content":"use crate::catalog::ColumnSummary;\r\nuse crate::errors::*;\r\nuse crate::expression::agg::Aggregate;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::optimizer::core::pattern::{Pattern, PatternChildrenPredicate};\r\nuse crate::optimizer::core::rule::Rule;\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\nuse crate::planner::operator::Operator;\r\nuse crate::types::value::DataValue;\r\nuse crate::types::LogicalType;\r\nuse lazy_static::lazy_static;\r\nuse std::collections::HashSet;\r\nuse std::sync::Arc;\r\n\r\nlazy_static! {\r\n    static ref COLUMN_PRUNING_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |_| true,\r\n            children: PatternChildrenPredicate::None,\r\n        }\r\n    };\r\n}\r\n\r\nmacro_rules! trans_references {\r\n    ($columns:expr) =\u003e {{\r\n        let mut column_references = HashSet::with_capacity($columns.len());\r\n        for column in $columns {\r\n            column_references.insert(column.summary());\r\n        }\r\n        column_references\r\n    }};\r\n}\r\n\r\n#[derive(Clone)]\r\npub struct ColumnPruning;\r\n\r\nimpl ColumnPruning {\r\n    fn clear_exprs(column_references: \u0026HashSet\u003c\u0026ColumnSummary\u003e, exprs: \u0026mut Vec\u003cScalarExpression\u003e) {\r\n        exprs.retain(|expr| {\r\n            if column_references.contains(expr.output_columns().summary()) {\r\n                return true;\r\n            }\r\n            expr.referenced_columns(false)\r\n                .iter()\r\n                .any(|column| column_references.contains(column.summary()))\r\n        })\r\n    }\r\n\r\n    fn _apply(\r\n        column_references: HashSet\u003c\u0026ColumnSummary\u003e,\r\n        all_referenced: bool,\r\n        node_id: HepNodeId,\r\n        graph: \u0026mut HepGraph,\r\n    ) {\r\n        let operator = graph.operator_mut(node_id);\r\n\r\n        match operator {\r\n            Operator::Aggregate(op) =\u003e {\r\n                // Aggregate  COUNT(*) \r\n                if !all_referenced {\r\n                    Self::clear_exprs(\u0026column_references, \u0026mut op.agg_calls);\r\n\r\n                    if op.agg_calls.is_empty() \u0026\u0026 op.groupby_exprs.is_empty() {\r\n                        let value = Arc::new(DataValue::Utf8(Some(\"*\".to_string())));\r\n                        // only single COUNT(*) is not depend on any column\r\n                        // removed all expressions from the aggregate: push a COUNT(*)\r\n                        op.agg_calls.push(ScalarExpression::AggCall {\r\n                            distinct: false,\r\n                            kind: Aggregate::Count,\r\n                            args: vec![ScalarExpression::Constant(value)],\r\n                            ty: LogicalType::Integer,\r\n                        })\r\n                    }\r\n                }\r\n                let is_distinct = op.is_distinct;\r\n                let referenced_columns = operator.referenced_columns(false);\r\n                let mut new_column_references = trans_references!(\u0026referenced_columns);\r\n                // on distinct\r\n                if is_distinct {\r\n                    for summary in column_references {\r\n                        new_column_references.insert(summary);\r\n                    }\r\n                }\r\n\r\n                Self::recollect_apply(new_column_references, false, node_id, graph);\r\n            }\r\n            Operator::Project(op) =\u003e {\r\n                // Project \r\n\r\n                let has_count_star = op.exprs.iter().any(ScalarExpression::has_count_star);\r\n                if !has_count_star {\r\n                    if !all_referenced {\r\n                        Self::clear_exprs(\u0026column_references, \u0026mut op.exprs);\r\n                    }\r\n                    let referenced_columns = operator.referenced_columns(false);\r\n                    let new_column_references = trans_references!(\u0026referenced_columns);\r\n\r\n                    Self::recollect_apply(new_column_references, false, node_id, graph);\r\n                }\r\n            }\r\n            Operator::Sort(_) | Operator::Limit(_) | Operator::Join(_) | Operator::Filter(_) =\u003e {\r\n                let temp_columns = operator.referenced_columns(false);\r\n                let mut column_references = column_references;\r\n                for column in temp_columns.iter() {\r\n                    column_references.insert(column.summary());\r\n                }\r\n                for child_id in graph.children_at(node_id) {\r\n                    let copy_references = column_references.clone();\r\n\r\n                    Self::_apply(copy_references, all_referenced, child_id, graph);\r\n                }\r\n            }\r\n            Operator::Scan(op) =\u003e {\r\n                if !all_referenced {\r\n                    Self::clear_exprs(\u0026column_references, \u0026mut op.columns);\r\n                }\r\n            }\r\n\r\n            // Last Operator\r\n            Operator::Dummy | Operator::Values(_) =\u003e (),\r\n            // DDL Based on Other Plan\r\n            Operator::Insert(_) | Operator::Update(_) | Operator::Delete(_) =\u003e {\r\n                let referenced_columns = operator.referenced_columns(false);\r\n                let new_column_references = trans_references!(\u0026referenced_columns);\r\n\r\n                if let Some(child_id) = graph.eldest_child_at(node_id) {\r\n                    Self::recollect_apply(new_column_references, true, child_id, graph);\r\n                } else {\r\n                    unreachable!();\r\n                }\r\n            }\r\n            // DDL Single Plan\r\n            Operator::Explain =\u003e {\r\n                if let Some(child_id) = graph.eldest_child_at(node_id) {\r\n                    Self::_apply(column_references, true, child_id, graph);\r\n                } else {\r\n                    unreachable!()\r\n                }\r\n            }\r\n\r\n            _ =\u003e (),\r\n        }\r\n    }\r\n\r\n    fn recollect_apply(\r\n        referenced_columns: HashSet\u003c\u0026ColumnSummary\u003e,\r\n        all_referenced: bool,\r\n        node_id: HepNodeId,\r\n        graph: \u0026mut HepGraph,\r\n    ) {\r\n        for child_id in graph.children_at(node_id) {\r\n            let copy_references: HashSet\u003c\u0026ColumnSummary\u003e = referenced_columns.clone();\r\n\r\n            Self::_apply(copy_references, all_referenced, child_id, graph);\r\n        }\r\n\r\n        // for child_id in graph.children_at(node_id) {\r\n        //     let new_references: HashSet\u003c\u0026ColumnSummary\u003e = referenced_columns\r\n        //         .iter()\r\n        //         .map(|column| column.summary())\r\n        //         .collect();\r\n\r\n        //     Self::_apply(new_references, all_referenced, child_id, graph);\r\n        // }\r\n    }\r\n}\r\n\r\nimpl Rule for ColumnPruning {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026COLUMN_PRUNING_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        Self::_apply(HashSet::new(), true, node_id, graph);\r\n        // mark changed to skip this rule batch\r\n        graph.version += 1;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::binder::test::select_sql_run;\r\n    use crate::errors::DatabaseError;\r\n    use crate::optimizer::heuristic::batch::HepBatchStrategy;\r\n    use crate::optimizer::heuristic::optimizer::HepOptimizer;\r\n    use crate::optimizer::rule::RuleImpl;\r\n    use crate::planner::operator::join::JoinCondition;\r\n    use crate::planner::operator::Operator;\r\n\r\n    #[tokio::test]\r\n    async fn test_column_pruning() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan = select_sql_run(\"select c1, c3 from t1 left join t2 on c1 = c3\").await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan.clone())\r\n            .batch(\r\n                \"test_column_pruning\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::ColumnPruning],\r\n            )\r\n            .find_best()?;\r\n\r\n        assert_eq!(best_plan.childrens.len(), 1);\r\n        match best_plan.operator {\r\n            Operator::Project(op) =\u003e {\r\n                assert_eq!(op.exprs.len(), 2);\r\n            }\r\n            _ =\u003e unreachable!(\"Should be a project operator\"),\r\n        }\r\n        match \u0026best_plan.childrens[0].operator {\r\n            Operator::Join(op) =\u003e match \u0026op.on {\r\n                JoinCondition::On { on, filter } =\u003e {\r\n                    assert_eq!(on.len(), 1);\r\n                    assert!(filter.is_none());\r\n                }\r\n                _ =\u003e unreachable!(\"Should be a on condition\"),\r\n            },\r\n            _ =\u003e unreachable!(\"Should be a join operator\"),\r\n        }\r\n\r\n        assert_eq!(best_plan.childrens[0].childrens.len(), 2);\r\n\r\n        for grandson_plan in \u0026best_plan.childrens[0].childrens {\r\n            match \u0026grandson_plan.operator {\r\n                Operator::Scan(op) =\u003e {\r\n                    assert_eq!(op.columns.len(), 1);\r\n                }\r\n                _ =\u003e unreachable!(\"Should be a scan operator\"),\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":13258597302978743074},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":9799832789158202146},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2089670227099912994},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":2089670227099912994},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":6269010681299733282},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":8142508126285856768},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":8142508126285856768},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":8142508126285856768},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":8935141660703064064},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":4179340454199820288},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":5548434740920451072},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2666130979403333632},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":3674937295934324736},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":10304235947423694848},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null}],"covered":49,"coverable":57},{"path":["E:","\\","sql-layer","src","optimizer","rule","combine_operators.rs"],"content":"use crate::errors::*;\r\nuse crate::expression::{BinaryOperator, ScalarExpression};\r\nuse crate::optimizer::core::pattern::{Pattern, PatternChildrenPredicate};\r\nuse crate::optimizer::core::rule::Rule;\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\nuse crate::planner::operator::filter::FilterOperator;\r\nuse crate::planner::operator::Operator;\r\nuse crate::types::LogicalType;\r\nuse lazy_static::lazy_static;\r\n\r\nuse super::is_subset_exprs;\r\n\r\nlazy_static! {\r\n    static ref COLLAPSE_PROJECT_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Project(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Project(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n    static ref COMBINE_FILTERS_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Filter(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Filter(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n}\r\n\r\n/// Combine two adjacent project operators into one.\r\npub struct CollapseProject;\r\n\r\nimpl Rule for CollapseProject {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026COLLAPSE_PROJECT_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Operator::Project(op) = graph.operator(node_id) {\r\n            let child_id = graph.children_at(node_id)[0];\r\n            if let Operator::Project(child_op) = graph.operator(child_id) {\r\n                if is_subset_exprs(\u0026op.exprs, \u0026child_op.exprs) {\r\n                    graph.remove_node(child_id, false);\r\n                } else {\r\n                    graph.remove_node(node_id, false);\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n/// Combine two adjacent filter operators into one.\r\npub struct CombineFilter;\r\n\r\nimpl Rule for CombineFilter {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026COMBINE_FILTERS_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Operator::Filter(op) = graph.operator(node_id) {\r\n            let child_id = graph.children_at(node_id)[0];\r\n            if let Operator::Filter(child_op) = graph.operator(child_id) {\r\n                let new_filter_op = FilterOperator {\r\n                    predicate: ScalarExpression::Binary {\r\n                        op: BinaryOperator::And,\r\n                        left_expr: Box::new(op.predicate.clone()),\r\n                        right_expr: Box::new(child_op.predicate.clone()),\r\n                        ty: LogicalType::Boolean,\r\n                    },\r\n                    having: op.having || child_op.having,\r\n                };\r\n                graph.replace_node(node_id, Operator::Filter(new_filter_op));\r\n                graph.remove_node(child_id, false);\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::binder::test::select_sql_run;\r\n    use crate::errors::DatabaseError;\r\n    use crate::expression::ScalarExpression::Constant;\r\n    use crate::expression::{BinaryOperator, ScalarExpression};\r\n    use crate::optimizer::heuristic::batch::HepBatchStrategy;\r\n    use crate::optimizer::heuristic::graph::HepNodeId;\r\n    use crate::optimizer::heuristic::optimizer::HepOptimizer;\r\n    use crate::optimizer::rule::RuleImpl;\r\n    use crate::planner::operator::Operator;\r\n    use crate::types::value::DataValue;\r\n    use crate::types::LogicalType;\r\n    use std::sync::Arc;\r\n\r\n    #[tokio::test]\r\n    async fn test_combine_filter() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan = select_sql_run(\"select * from t1 where c1 \u003e 1\").await?;\r\n\r\n        let mut optimizer = HepOptimizer::new(plan.clone()).batch(\r\n            \"test_combine_filter\".to_string(),\r\n            HepBatchStrategy::once_topdown(),\r\n            vec![RuleImpl::CombineFilter],\r\n        );\r\n\r\n        let mut new_filter_op = optimizer.graph.operator(HepNodeId::new(1)).clone();\r\n\r\n        if let Operator::Filter(op) = \u0026mut new_filter_op {\r\n            op.predicate = ScalarExpression::Binary {\r\n                op: BinaryOperator::Eq,\r\n                left_expr: Box::new(Constant(Arc::new(DataValue::Int8(Some(1))))),\r\n                right_expr: Box::new(Constant(Arc::new(DataValue::Int8(Some(1))))),\r\n                ty: LogicalType::Boolean,\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        optimizer\r\n            .graph\r\n            .add_node(HepNodeId::new(0), Some(HepNodeId::new(1)), new_filter_op);\r\n\r\n        let best_plan = optimizer.find_best()?;\r\n\r\n        if let Operator::Filter(op) = \u0026best_plan.childrens[0].operator {\r\n            if let ScalarExpression::Binary { op, .. } = \u0026op.predicate {\r\n                assert_eq!(op, \u0026BinaryOperator::And);\r\n            } else {\r\n                unreachable!(\"Should be a and operator\")\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":12249790986447749126},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":17149707381026848770},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":10},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":5},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":8574853690513424384},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":8574853690513424384},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":16,"coverable":20},{"path":["E:","\\","sql-layer","src","optimizer","rule","constant_folder.rs"],"content":"use crate::errors::*;\r\nuse crate::{\r\n    optimizer::{\r\n        core::{\r\n            pattern::{Pattern, PatternChildrenPredicate},\r\n            rule::Rule,\r\n        },\r\n        heuristic::graph::{HepGraph, HepNodeId},\r\n    },\r\n    planner::operator::{join::JoinCondition, Operator},\r\n};\r\nuse lazy_static::lazy_static;\r\n\r\nlazy_static! {\r\n    static ref CONSTANT_CALCULATION_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |_| true,\r\n            children: PatternChildrenPredicate::None,\r\n        }\r\n    };\r\n}\r\n\r\n#[derive(Copy, Clone)]\r\npub struct ConstantFolder;\r\n\r\nimpl ConstantFolder {\r\n    fn _apply(node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        let operator = graph.operator_mut(node_id);\r\n\r\n        match operator {\r\n            Operator::Aggregate(op) =\u003e {\r\n                for expr in op.agg_calls.iter_mut().chain(op.groupby_exprs.iter_mut()) {\r\n                    expr.constant_calculation()?;\r\n                }\r\n            }\r\n            Operator::Filter(op) =\u003e {\r\n                op.predicate.constant_calculation()?;\r\n            }\r\n            Operator::Join(op) =\u003e {\r\n                if let JoinCondition::On { on, filter } = \u0026mut op.on {\r\n                    for (left_expr, right_expr) in on {\r\n                        left_expr.constant_calculation()?;\r\n                        right_expr.constant_calculation()?;\r\n                    }\r\n                    if let Some(expr) = filter {\r\n                        expr.constant_calculation()?;\r\n                    }\r\n                }\r\n            }\r\n            Operator::Project(op) =\u003e {\r\n                for expr in \u0026mut op.exprs {\r\n                    expr.constant_calculation()?;\r\n                }\r\n            }\r\n            Operator::Scan(op) =\u003e {\r\n                for expr in \u0026mut op.columns {\r\n                    expr.constant_calculation()?;\r\n                }\r\n            }\r\n            Operator::Sort(op) =\u003e {\r\n                for field in \u0026mut op.sort_fields {\r\n                    field.expr.constant_calculation()?;\r\n                }\r\n            }\r\n            _ =\u003e (),\r\n        }\r\n        for child_id in graph.children_at(node_id) {\r\n            Self::_apply(child_id, graph)?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl Rule for ConstantFolder {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026Pattern {\r\n            predicate: |_| true,\r\n            children: PatternChildrenPredicate::None,\r\n        }\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        Self::_apply(node_id, graph)?;\r\n        // mark changed to skip this rule batch\r\n        graph.version += 1;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":10736581511651262464},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":10736581511651262464},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":10736581511651262464},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":7926335344172072954},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":10808639105689190403},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":10808639105689190403},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":8718968878589280260},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":8718968878589280264},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":5764607523034234879},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":8646911284551352318},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":2882303761517117439},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":10592466323575406599},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":9007199254740992001},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":11601272640106397698},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":720575940379279361},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":3602879701896396806},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":14411518807585587200},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":7421932185906577414},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":15132094747964866564},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":10736581511651262464},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":14051230837395947520},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":14051230837395947520},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":9655717601082366274},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":14051230837395947520},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":14051230837395947521},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":14051230837395947522},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":14051230837395947520},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":14051230837395947520},"fn_name":null}],"covered":31,"coverable":37},{"path":["E:","\\","sql-layer","src","optimizer","rule","mod.rs"],"content":"use crate::expression::ScalarExpression;\r\nmod column_pruning;\r\nmod combine_operators;\r\nmod constant_folder;\r\nmod pushdown_limit;\r\nmod pushdown_predicates;\r\nmod simplification;\r\nuse crate::errors::*;\r\n\r\nuse self::{\r\n    column_pruning::ColumnPruning,\r\n    combine_operators::{CollapseProject, CombineFilter},\r\n    constant_folder::ConstantFolder,\r\n    pushdown_limit::{\r\n        EliminateLimits, LimitProjectTranspose, PushLimitIntoScan, PushLimitThroughJoin,\r\n    },\r\n    pushdown_predicates::{PushPredicateIntoScan, PushPredicateThroughJoin},\r\n    simplification::SimplifyFilter,\r\n};\r\n\r\nuse super::{\r\n    core::{pattern::Pattern, rule::Rule},\r\n    heuristic::graph::{HepGraph, HepNodeId},\r\n};\r\n\r\n#[derive(Debug, Copy, Clone)]\r\npub enum RuleImpl {\r\n    ColumnPruning,\r\n    // Combine operators\r\n    CollapseProject,\r\n    CombineFilter,\r\n    SimplifyFilter,\r\n\r\n    PushLimitIntoTableScan,\r\n    EliminateLimits,\r\n    LimitProjectTranspose,\r\n    PushLimitThroughJoin,\r\n    // PushDown predicates\r\n    PushPredicateIntoScan,\r\n    PushPredicateThroughJoin,\r\n\r\n    ConstantFolder,\r\n}\r\n\r\nimpl Rule for RuleImpl {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        match self {\r\n            RuleImpl::ColumnPruning =\u003e ColumnPruning.pattern(),\r\n            RuleImpl::PushLimitIntoTableScan =\u003e PushLimitIntoScan.pattern(),\r\n            RuleImpl::PushPredicateIntoScan =\u003e PushPredicateIntoScan.pattern(),\r\n            RuleImpl::ConstantFolder =\u003e ConstantFolder.pattern(),\r\n            RuleImpl::PushPredicateThroughJoin =\u003e PushPredicateThroughJoin.pattern(),\r\n            RuleImpl::CollapseProject =\u003e CollapseProject.pattern(),\r\n            RuleImpl::CombineFilter =\u003e CombineFilter.pattern(),\r\n            RuleImpl::SimplifyFilter =\u003e SimplifyFilter.pattern(),\r\n            RuleImpl::EliminateLimits =\u003e EliminateLimits.pattern(),\r\n            RuleImpl::LimitProjectTranspose =\u003e LimitProjectTranspose.pattern(),\r\n            RuleImpl::PushLimitThroughJoin =\u003e PushLimitThroughJoin.pattern(),\r\n        }\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        match self {\r\n            RuleImpl::ColumnPruning =\u003e ColumnPruning.apply(node_id, graph),\r\n            RuleImpl::PushLimitIntoTableScan =\u003e PushLimitIntoScan.apply(node_id, graph),\r\n            RuleImpl::PushPredicateIntoScan =\u003e PushPredicateIntoScan.apply(node_id, graph),\r\n            RuleImpl::ConstantFolder =\u003e ConstantFolder.apply(node_id, graph),\r\n            RuleImpl::PushPredicateThroughJoin =\u003e PushPredicateThroughJoin.apply(node_id, graph),\r\n            RuleImpl::CollapseProject =\u003e CollapseProject.apply(node_id, graph),\r\n            RuleImpl::CombineFilter =\u003e CombineFilter.apply(node_id, graph),\r\n            RuleImpl::SimplifyFilter =\u003e SimplifyFilter.apply(node_id, graph),\r\n            RuleImpl::EliminateLimits =\u003e EliminateLimits.apply(node_id, graph),\r\n            RuleImpl::LimitProjectTranspose =\u003e LimitProjectTranspose.apply(node_id, graph),\r\n            RuleImpl::PushLimitThroughJoin =\u003e PushLimitThroughJoin.apply(node_id, graph),\r\n        }\r\n    }\r\n}\r\n\r\n/// Return true when left is subset of right\r\npub fn is_subset_exprs(left: \u0026[ScalarExpression], right: \u0026[ScalarExpression]) -\u003e bool {\r\n    left.iter().all(|l| right.contains(l))\r\n}\r\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":3314649325744685033},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":8646911284551352324},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":9007199254740992000},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":14051230837395947520},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":504403158265495566},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":8574853690513424389},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":6629298651489370112},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":8574853690513424384},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":9655717601082343425},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":9655717601082343425},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3314649325744685055},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":14051230837395947520},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2},"fn_name":null}],"covered":28,"coverable":28},{"path":["E:","\\","sql-layer","src","optimizer","rule","pushdown_limit.rs"],"content":"use std::cmp;\r\n\r\nuse crate::optimizer::core::pattern::Pattern;\r\nuse crate::optimizer::core::pattern::PatternChildrenPredicate;\r\nuse crate::optimizer::core::rule::Rule;\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\n\r\nuse crate::errors::*;\r\n\r\nuse crate::planner::operator::join::JoinType;\r\nuse crate::planner::operator::limit::LimitOperator;\r\nuse crate::planner::operator::Operator;\r\nuse lazy_static::lazy_static;\r\n\r\nlazy_static! {\r\n    static ref LIMIT_PROJECT_TRANSPOSE_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Limit(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Project(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n    static ref PUSH_LIMIT_INTO_TABLE_SCAN_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Limit(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Scan(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n    static ref ELIMINATE_LIMITS_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Limit(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Limit(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n    static ref PUSH_LIMIT_THROUGH_JOIN_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Limit(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Join(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n}\r\n/// Push down `Limit` past a `Scan`.\r\npub struct PushLimitIntoScan;\r\n\r\nimpl Rule for PushLimitIntoScan {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026PUSH_LIMIT_INTO_TABLE_SCAN_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Operator::Limit(limit_op) = graph.operator(node_id) {\r\n            let child_index = graph.children_at(node_id)[0];\r\n            if let Operator::Scan(scan_op) = graph.operator(child_index) {\r\n                let mut new_scan_op = scan_op.clone();\r\n\r\n                new_scan_op.limit = (limit_op.offset, limit_op.limit);\r\n\r\n                graph.remove_node(node_id, false);\r\n                graph.replace_node(child_index, Operator::Scan(new_scan_op));\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\npub struct PushLimitThroughJoin;\r\n\r\nimpl Rule for PushLimitThroughJoin {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026PUSH_LIMIT_THROUGH_JOIN_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Operator::Limit(op) = graph.operator(node_id) {\r\n            if let Some(child_id) = graph.eldest_child_at(node_id) {\r\n                let join_type = if let Operator::Join(op) = graph.operator(child_id) {\r\n                    Some(op.join_type)\r\n                } else {\r\n                    None\r\n                };\r\n\r\n                if let Some(ty) = join_type {\r\n                    let children = graph.children_at(child_id);\r\n\r\n                    if let Some(grandson_id) = match ty {\r\n                        JoinType::Left =\u003e children.first(),\r\n                        JoinType::Right =\u003e children.last(),\r\n                        _ =\u003e None,\r\n                    } {\r\n                        graph.add_node(child_id, Some(*grandson_id), Operator::Limit(op.clone()));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\npub struct LimitProjectTranspose;\r\n\r\nimpl Rule for LimitProjectTranspose {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026LIMIT_PROJECT_TRANSPOSE_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Some(child_id) = graph.eldest_child_at(node_id) {\r\n            graph.swap_node(node_id, child_id);\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n/// Combines two adjacent Limit operators into one, merging the expressions into one single\r\n/// expression.\r\npub struct EliminateLimits;\r\n\r\nimpl Rule for EliminateLimits {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026ELIMINATE_LIMITS_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Operator::Limit(op) = graph.operator(node_id) {\r\n            if let Some(child_id) = graph.eldest_child_at(node_id) {\r\n                if let Operator::Limit(child_op) = graph.operator(child_id) {\r\n                    let offset = Self::binary_options(op.offset, child_op.offset, |a, b| a + b);\r\n                    let limit = Self::binary_options(op.limit, child_op.limit, cmp::min);\r\n\r\n                    let new_limit_op = LimitOperator { offset, limit };\r\n\r\n                    graph.remove_node(child_id, false);\r\n                    graph.replace_node(node_id, Operator::Limit(new_limit_op));\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl EliminateLimits {\r\n    fn binary_options\u003cF: Fn(usize, usize) -\u003e usize\u003e(\r\n        a: Option\u003cusize\u003e,\r\n        b: Option\u003cusize\u003e,\r\n        _fn: F,\r\n    ) -\u003e Option\u003cusize\u003e {\r\n        match (a, b) {\r\n            (Some(a), Some(b)) =\u003e Some(_fn(a, b)),\r\n            (Some(a), None) =\u003e Some(a),\r\n            (None, Some(b)) =\u003e Some(b),\r\n            (None, None) =\u003e None,\r\n        }\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::binder::test::select_sql_run;\r\n    use crate::errors::DatabaseError;\r\n    use crate::optimizer::heuristic::batch::HepBatchStrategy;\r\n    use crate::optimizer::heuristic::optimizer::HepOptimizer;\r\n    use crate::optimizer::rule::RuleImpl;\r\n    use crate::planner::operator::limit::LimitOperator;\r\n    use crate::planner::operator::Operator;\r\n\r\n    #[tokio::test]\r\n    async fn test_limit_project_transpose() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan = select_sql_run(\"select c1, c2 from t1 limit 1\").await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan.clone())\r\n            .batch(\r\n                \"test_limit_project_transpose\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::LimitProjectTranspose],\r\n            )\r\n            .find_best()?;\r\n\r\n        if let Operator::Project(_) = \u0026best_plan.operator {\r\n        } else {\r\n            unreachable!(\"Should be a project operator\")\r\n        }\r\n\r\n        if let Operator::Limit(_) = \u0026best_plan.childrens[0].operator {\r\n        } else {\r\n            unreachable!(\"Should be a limit operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_eliminate_limits() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan = select_sql_run(\"select c1, c2 from t1 limit 1 offset 1\").await?;\r\n\r\n        let mut optimizer = HepOptimizer::new(plan.clone()).batch(\r\n            \"test_eliminate_limits\".to_string(),\r\n            HepBatchStrategy::once_topdown(),\r\n            vec![RuleImpl::EliminateLimits],\r\n        );\r\n\r\n        let new_limit_op = LimitOperator {\r\n            offset: Some(2),\r\n            limit: Some(1),\r\n        };\r\n\r\n        optimizer.graph.add_root(Operator::Limit(new_limit_op));\r\n\r\n        let best_plan = optimizer.find_best()?;\r\n\r\n        if let Operator::Limit(op) = \u0026best_plan.operator {\r\n            assert_eq!(op.limit, Some(1));\r\n            assert_eq!(op.offset, Some(3));\r\n        } else {\r\n            unreachable!(\"Should be a project operator\")\r\n        }\r\n\r\n        if let Operator::Limit(_) = \u0026best_plan.childrens[0].operator {\r\n            unreachable!(\"Should not be a limit operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_push_limit_through_join() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan = select_sql_run(\"select * from t1 left join t2 on c1 = c3 limit 1\").await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan.clone())\r\n            .batch(\r\n                \"test_push_limit_through_join\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![\r\n                    RuleImpl::LimitProjectTranspose,\r\n                    RuleImpl::PushLimitThroughJoin,\r\n                ],\r\n            )\r\n            .find_best()?;\r\n\r\n        if let Operator::Join(_) = \u0026best_plan.childrens[0].childrens[0].operator {\r\n        } else {\r\n            unreachable!(\"Should be a join operator\")\r\n        }\r\n\r\n        if let Operator::Limit(op) = \u0026best_plan.childrens[0].childrens[0].childrens[0].operator {\r\n            assert_eq!(op.limit, Some(1));\r\n        } else {\r\n            unreachable!(\"Should be a limit operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_push_limit_into_table_scan() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan = select_sql_run(\"select * from t1 limit 1 offset 1\").await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan.clone())\r\n            .batch(\r\n                \"test_push_limit_into_table_scan\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![\r\n                    RuleImpl::LimitProjectTranspose,\r\n                    RuleImpl::PushLimitIntoTableScan,\r\n                ],\r\n            )\r\n            .find_best()?;\r\n\r\n        if let Operator::Scan(op) = \u0026best_plan.childrens[0].operator {\r\n            assert_eq!(op.limit, (Some(1), Some(1)))\r\n        } else {\r\n            unreachable!(\"Should be a project operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":17293822569102704640},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":17293822569102704640},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":17149707381026848768},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":17437937757178560512},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":8574853690513424384},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":8574853690513424384},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":49,"coverable":55},{"path":["E:","\\","sql-layer","src","optimizer","rule","pushdown_predicates.rs"],"content":"use crate::catalog::ColumnRef;\r\nuse crate::errors::*;\r\nuse crate::expression::{BinaryOperator, ScalarExpression};\r\nuse crate::optimizer::core::pattern::Pattern;\r\nuse crate::optimizer::core::pattern::PatternChildrenPredicate;\r\nuse crate::optimizer::core::rule::Rule;\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\nuse crate::planner::operator::filter::FilterOperator;\r\nuse crate::planner::operator::join::JoinType;\r\nuse crate::planner::operator::Operator;\r\nuse crate::types::LogicalType;\r\nuse itertools::Itertools;\r\nuse lazy_static::lazy_static;\r\n\r\nlazy_static! {\r\n    static ref PUSH_PREDICATE_THROUGH_JOIN: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Filter(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Join(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n    static ref PUSH_PREDICATE_INTO_SCAN: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Filter(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| matches!(op, Operator::Scan(_)),\r\n                children: PatternChildrenPredicate::None,\r\n            }]),\r\n        }\r\n    };\r\n}\r\n\r\nfn split_conjunctive_predicates(expr: \u0026ScalarExpression) -\u003e Vec\u003cScalarExpression\u003e {\r\n    match expr {\r\n        ScalarExpression::Binary {\r\n            op: BinaryOperator::And,\r\n            left_expr,\r\n            right_expr,\r\n            ..\r\n        } =\u003e split_conjunctive_predicates(left_expr)\r\n            .into_iter()\r\n            .chain(split_conjunctive_predicates(right_expr))\r\n            .collect_vec(),\r\n        _ =\u003e vec![expr.clone()],\r\n    }\r\n}\r\n\r\n/// reduce filters into a filter, and then build a new LogicalFilter node with input child.\r\n/// if filters is empty, return the input child.\r\nfn reduce_filters(filters: Vec\u003cScalarExpression\u003e, having: bool) -\u003e Option\u003cFilterOperator\u003e {\r\n    filters\r\n        .into_iter()\r\n        .reduce(|a, b| ScalarExpression::Binary {\r\n            op: BinaryOperator::And,\r\n            left_expr: Box::new(a),\r\n            right_expr: Box::new(b),\r\n            ty: LogicalType::Boolean,\r\n        })\r\n        .map(|f| FilterOperator {\r\n            predicate: f,\r\n            having,\r\n        })\r\n}\r\n\r\n/// Return true when left is subset of right, only compare table_id and column_id, so it's safe to\r\n/// used for join output cols with nullable columns.\r\n/// If left equals right, return true.\r\npub fn is_subset_cols(left: \u0026[ColumnRef], right: \u0026[ColumnRef]) -\u003e bool {\r\n    left.iter().all(|l| right.contains(l))\r\n}\r\n\r\npub struct PushPredicateIntoScan;\r\n\r\nimpl Rule for PushPredicateIntoScan {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026PUSH_PREDICATE_INTO_SCAN\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Operator::Filter(op) = graph.operator(node_id) {\r\n            let child_id = graph.children_at(node_id)[0];\r\n            if let Operator::Scan(child_op) = graph.operator(child_id) {\r\n                if child_op.index_by.is_some() {\r\n                    return Ok(());\r\n                }\r\n\r\n                //FIXME: now only support unique\r\n                for meta in \u0026child_op.index_metas {\r\n                    let mut option = op.predicate.convert_binary(\u0026meta.column_ids[0])?;\r\n\r\n                    if let Some(mut binary) = option.take() {\r\n                        binary.scope_aggregation()?;\r\n                        let rearrange_binaries = binary.rearrange()?;\r\n\r\n                        if rearrange_binaries.is_empty() {\r\n                            continue;\r\n                        }\r\n                        let mut scan_by_index = child_op.clone();\r\n                        scan_by_index.index_by = Some((meta.clone(), rearrange_binaries));\r\n\r\n                        // The constant expression extracted in prewhere is used to\r\n                        // reduce the data scanning range and cannot replace the role of Filter.\r\n                        graph.replace_node(child_id, Operator::Scan(scan_by_index));\r\n\r\n                        return Ok(());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\npub struct PushPredicateThroughJoin;\r\n\r\nimpl Rule for PushPredicateThroughJoin {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026PUSH_PREDICATE_THROUGH_JOIN\r\n    }\r\n\r\n    // TODO: pushdown_predicates need to consider output columns\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        let child_id = graph.children_at(node_id)[0];\r\n        //\r\n        if let Operator::Join(child_op) = graph.operator(child_id) {\r\n            //\r\n            if !matches!(\r\n                child_op.join_type,\r\n                JoinType::Inner | JoinType::Left | JoinType::Right\r\n            ) {\r\n                return Ok(());\r\n            }\r\n\r\n            let join_childs = graph.children_at(child_id);\r\n            let left_columns = graph.operator(join_childs[0]).referenced_columns(true);\r\n            let right_columns = graph.operator(join_childs[1]).referenced_columns(true);\r\n\r\n            let mut new_ops = (None, None, None);\r\n            //\r\n            if let Operator::Filter(op) = graph.operator(node_id) {\r\n                //\r\n                let filter_exprs = split_conjunctive_predicates(\u0026op.predicate);\r\n\r\n                let (left_filters, rest): (Vec\u003c_\u003e, Vec\u003c_\u003e) = filter_exprs\r\n                    .into_iter()\r\n                    .partition(|f| is_subset_cols(\u0026f.referenced_columns(true), \u0026left_columns));\r\n                let (right_filters, common_filters): (Vec\u003c_\u003e, Vec\u003c_\u003e) = rest\r\n                    .into_iter()\r\n                    .partition(|f| is_subset_cols(\u0026f.referenced_columns(true), \u0026right_columns));\r\n\r\n                let replace_filters = match child_op.join_type {\r\n                    JoinType::Inner =\u003e {\r\n                        if !left_filters.is_empty() {\r\n                            if let Some(left_filter_op) = reduce_filters(left_filters, op.having) {\r\n                                new_ops.0 = Some(Operator::Filter(left_filter_op));\r\n                            }\r\n                        }\r\n\r\n                        if !right_filters.is_empty() {\r\n                            if let Some(right_filter_op) = reduce_filters(right_filters, op.having)\r\n                            {\r\n                                new_ops.1 = Some(Operator::Filter(right_filter_op));\r\n                            }\r\n                        }\r\n\r\n                        common_filters\r\n                    }\r\n                    JoinType::Left =\u003e {\r\n                        if !left_filters.is_empty() {\r\n                            if let Some(left_filter_op) = reduce_filters(left_filters, op.having) {\r\n                                new_ops.0 = Some(Operator::Filter(left_filter_op));\r\n                            }\r\n                        }\r\n\r\n                        common_filters\r\n                            .into_iter()\r\n                            .chain(right_filters)\r\n                            .collect_vec()\r\n                    }\r\n                    JoinType::Right =\u003e {\r\n                        if !right_filters.is_empty() {\r\n                            if let Some(right_filter_op) = reduce_filters(right_filters, op.having)\r\n                            {\r\n                                new_ops.1 = Some(Operator::Filter(right_filter_op));\r\n                            }\r\n                        }\r\n\r\n                        common_filters.into_iter().chain(left_filters).collect_vec()\r\n                    }\r\n                    _ =\u003e vec![],\r\n                };\r\n\r\n                if !replace_filters.is_empty() {\r\n                    if let Some(replace_filter_op) = reduce_filters(replace_filters, op.having) {\r\n                        new_ops.2 = Some(Operator::Filter(replace_filter_op));\r\n                    }\r\n                }\r\n            }\r\n\r\n            if let Some(left_op) = new_ops.0 {\r\n                graph.add_node(child_id, Some(join_childs[0]), left_op);\r\n            }\r\n\r\n            if let Some(right_op) = new_ops.1 {\r\n                graph.add_node(child_id, Some(join_childs[1]), right_op);\r\n            }\r\n\r\n            if let Some(common_op) = new_ops.2 {\r\n                graph.replace_node(node_id, common_op);\r\n            } else {\r\n                graph.remove_node(node_id, false);\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::binder::test::select_sql_run;\r\n    use crate::errors::DatabaseError;\r\n    use crate::expression::simplify::ConstantBinary::Scope;\r\n    use crate::expression::{BinaryOperator, ScalarExpression};\r\n    use crate::optimizer::heuristic::batch::HepBatchStrategy;\r\n    use crate::optimizer::heuristic::optimizer::HepOptimizer;\r\n    use crate::optimizer::rule::RuleImpl;\r\n    use crate::planner::operator::Operator;\r\n    use crate::types::value::DataValue;\r\n    use crate::types::LogicalType;\r\n    use std::collections::Bound;\r\n    use std::sync::Arc;\r\n\r\n    #[tokio::test]\r\n    async fn test_push_predicate_into_scan() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        // 1 - c2 \u003c 0 =\u003e c2 \u003e 1\r\n        let plan = select_sql_run(\"select * from t1 where -(1 - c2) \u003e 0\").await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan)\r\n            .batch(\r\n                \"simplify_filter\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::SimplifyFilter],\r\n            )\r\n            .batch(\r\n                \"test_push_predicate_into_scan\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::PushPredicateIntoScan],\r\n            )\r\n            .find_best()?;\r\n\r\n        if let Operator::Scan(op) = \u0026best_plan.childrens[0].childrens[0].operator {\r\n            let mock_binaries = vec![Scope {\r\n                min: Bound::Excluded(Arc::new(DataValue::Int32(Some(1)))),\r\n                max: Bound::Unbounded,\r\n            }];\r\n\r\n            assert_eq!(op.index_by.clone().unwrap().1, mock_binaries);\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_push_predicate_through_join_in_left_join() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan =\r\n            select_sql_run(\"select * from t1 left join t2 on c1 = c3 where c1 \u003e 1 and c3 \u003c 2\")\r\n                .await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan)\r\n            .batch(\r\n                \"test_push_predicate_through_join\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::PushPredicateThroughJoin],\r\n            )\r\n            .find_best()?;\r\n\r\n        if let Operator::Filter(op) = \u0026best_plan.childrens[0].operator {\r\n            match op.predicate {\r\n                ScalarExpression::Binary {\r\n                    op: BinaryOperator::Lt,\r\n                    ty: LogicalType::Boolean,\r\n                    ..\r\n                } =\u003e (),\r\n                _ =\u003e unreachable!(),\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        if let Operator::Filter(op) = \u0026best_plan.childrens[0].childrens[0].childrens[0].operator {\r\n            match op.predicate {\r\n                ScalarExpression::Binary {\r\n                    op: BinaryOperator::Gt,\r\n                    ty: LogicalType::Boolean,\r\n                    ..\r\n                } =\u003e (),\r\n                _ =\u003e unreachable!(),\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_push_predicate_through_join_in_right_join() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan =\r\n            select_sql_run(\"select * from t1 right join t2 on c1 = c3 where c1 \u003e 1 and c3 \u003c 2\")\r\n                .await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan)\r\n            .batch(\r\n                \"test_push_predicate_through_join\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::PushPredicateThroughJoin],\r\n            )\r\n            .find_best()?;\r\n\r\n        if let Operator::Filter(op) = \u0026best_plan.childrens[0].operator {\r\n            match op.predicate {\r\n                ScalarExpression::Binary {\r\n                    op: BinaryOperator::Gt,\r\n                    ty: LogicalType::Boolean,\r\n                    ..\r\n                } =\u003e (),\r\n                _ =\u003e unreachable!(),\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        if let Operator::Filter(op) = \u0026best_plan.childrens[0].childrens[0].childrens[1].operator {\r\n            match op.predicate {\r\n                ScalarExpression::Binary {\r\n                    op: BinaryOperator::Lt,\r\n                    ty: LogicalType::Boolean,\r\n                    ..\r\n                } =\u003e (),\r\n                _ =\u003e unreachable!(),\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_push_predicate_through_join_in_inner_join() -\u003e Result\u003c(), DatabaseError\u003e {\r\n        let plan =\r\n            select_sql_run(\"select * from t1 inner join t2 on c1 = c3 where c1 \u003e 1 and c3 \u003c 2\")\r\n                .await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan)\r\n            .batch(\r\n                \"test_push_predicate_through_join\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::PushPredicateThroughJoin],\r\n            )\r\n            .find_best()?;\r\n\r\n        if let Operator::Join(_) = \u0026best_plan.childrens[0].operator {\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        if let Operator::Filter(op) = \u0026best_plan.childrens[0].childrens[0].operator {\r\n            match op.predicate {\r\n                ScalarExpression::Binary {\r\n                    op: BinaryOperator::Gt,\r\n                    ty: LogicalType::Boolean,\r\n                    ..\r\n                } =\u003e (),\r\n                _ =\u003e unreachable!(),\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        if let Operator::Filter(op) = \u0026best_plan.childrens[0].childrens[1].operator {\r\n            match op.predicate {\r\n                ScalarExpression::Binary {\r\n                    op: BinaryOperator::Lt,\r\n                    ty: LogicalType::Boolean,\r\n                    ..\r\n                } =\u003e (),\r\n                _ =\u003e unreachable!(),\r\n            }\r\n        } else {\r\n            unreachable!(\"Should be a filter operator\")\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":18014398509481984000},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":9007199254740992000},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":9007199254740992000},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":4107282860161892352},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1801439850948198400},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null}],"covered":72,"coverable":80},{"path":["E:","\\","sql-layer","src","optimizer","rule","simplification.rs"],"content":"use crate::errors::*;\r\nuse crate::optimizer::core::pattern::{Pattern, PatternChildrenPredicate};\r\nuse crate::optimizer::core::rule::Rule;\r\nuse crate::optimizer::heuristic::graph::{HepGraph, HepNodeId};\r\n\r\nuse crate::planner::operator::Operator;\r\nuse lazy_static::lazy_static;\r\nlazy_static! {\r\n    static ref SIMPLIFY_FILTER_RULE: Pattern = {\r\n        Pattern {\r\n            predicate: |op| matches!(op, Operator::Filter(_)),\r\n            children: PatternChildrenPredicate::Predicate(vec![Pattern {\r\n                predicate: |op| !matches!(op, Operator::Aggregate(_)),\r\n                children: PatternChildrenPredicate::Recursive,\r\n            }]),\r\n        }\r\n    };\r\n}\r\n#[derive(Copy, Clone)]\r\npub struct SimplifyFilter;\r\n\r\nimpl Rule for SimplifyFilter {\r\n    fn pattern(\u0026self) -\u003e \u0026Pattern {\r\n        \u0026SIMPLIFY_FILTER_RULE\r\n    }\r\n\r\n    fn apply(\u0026self, node_id: HepNodeId, graph: \u0026mut HepGraph) -\u003e Result\u003c()\u003e {\r\n        if let Operator::Filter(mut filter_op) = graph.operator(node_id).clone() {\r\n            filter_op.predicate.simplify()?;\r\n            filter_op.predicate.constant_calculation()?;\r\n\r\n            graph.replace_node(node_id, Operator::Filter(filter_op))\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::binder::test::select_sql_run;\r\n    use crate::catalog::{ColumnCatalog, ColumnDesc, ColumnSummary};\r\n\r\n    use crate::expression::simplify::ConstantBinary;\r\n    use crate::expression::{BinaryOperator, ScalarExpression, UnaryOperator};\r\n    use crate::optimizer::heuristic::batch::HepBatchStrategy;\r\n    use crate::optimizer::heuristic::optimizer::HepOptimizer;\r\n    use crate::optimizer::rule::{simplification::*, RuleImpl};\r\n    use crate::planner::operator::filter::FilterOperator;\r\n    use crate::planner::operator::Operator;\r\n    use crate::planner::LogicalPlan;\r\n    use crate::types::value::DataValue;\r\n    use crate::types::LogicalType;\r\n    use std::collections::Bound;\r\n    use std::sync::Arc;\r\n\r\n    #[tokio::test]\r\n    async fn test_constant_calculation_omitted() -\u003e Result\u003c()\u003e {\r\n        // (2 + (-1)) \u003c -(c1 + 1)\r\n        let plan =\r\n            select_sql_run(\"select c1 + (2 + 1), 2 + 1 from t1 where (2 + (-1)) \u003c -(c1 + 1)\")\r\n                .await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan)\r\n            .batch(\r\n                \"test_simplification\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::SimplifyFilter, RuleImpl::ConstantFolder],\r\n            )\r\n            .find_best()?;\r\n        if let Operator::Project(project_op) = best_plan.clone().operator {\r\n            let constant_expr = ScalarExpression::Constant(Arc::new(DataValue::Int32(Some(3))));\r\n            if let ScalarExpression::Binary { right_expr, .. } = \u0026project_op.exprs[0] {\r\n                assert_eq!(right_expr.as_ref(), \u0026constant_expr);\r\n            } else {\r\n                unreachable!();\r\n            }\r\n            assert_eq!(\u0026project_op.exprs[1], \u0026constant_expr);\r\n        } else {\r\n            unreachable!();\r\n        }\r\n        if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n            let column_binary = filter_op.predicate.convert_binary(\u00260).unwrap();\r\n            let final_binary = ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(Arc::new(DataValue::Int32(Some(-2)))),\r\n            };\r\n            assert_eq!(column_binary, Some(final_binary));\r\n        } else {\r\n            unreachable!();\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_single_column() -\u003e Result\u003c()\u003e {\r\n        // c1 + 1 \u003c -1 =\u003e c1 \u003c -2\r\n        let plan_1 = select_sql_run(\"select * from t1 where -(c1 + 1) \u003e 1\").await?;\r\n        // 1 - c1 \u003c -1 =\u003e c1 \u003e 2\r\n        let plan_2 = select_sql_run(\"select * from t1 where -(1 - c1) \u003e 1\").await?;\r\n        // c1 \u003c -1\r\n        let plan_3 = select_sql_run(\"select * from t1 where -c1 \u003e 1\").await?;\r\n        // c1 \u003e 0\r\n        let plan_4 = select_sql_run(\"select * from t1 where c1 + 1 \u003e 1\").await?;\r\n\r\n        // c1 + 1 \u003c -1 =\u003e c1 \u003c -2\r\n        let plan_5 = select_sql_run(\"select * from t1 where 1 \u003c -(c1 + 1)\").await?;\r\n        // 1 - c1 \u003c -1 =\u003e c1 \u003e 2\r\n        let plan_6 = select_sql_run(\"select * from t1 where 1 \u003c -(1 - c1)\").await?;\r\n        // c1 \u003c -1\r\n        let plan_7 = select_sql_run(\"select * from t1 where 1 \u003c -c1\").await?;\r\n        // c1 \u003e 0\r\n        let plan_8 = select_sql_run(\"select * from t1 where 1 \u003c c1 + 1\").await?;\r\n\r\n        // c1 \u003c 24\r\n        let plan_9 = select_sql_run(\"select * from t1 where (-1 - c1) + 1 \u003e 24\").await?;\r\n\r\n        // c1 \u003c 24\r\n        let plan_10 = select_sql_run(\"select * from t1 where 24 \u003c (-1 - c1) + 1\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cConstantBinary\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\r\n                    \"{expr}: {:#?}\",\r\n                    filter_op.predicate.convert_binary(\u00260).unwrap()\r\n                );\r\n\r\n                Ok(filter_op.predicate.convert_binary(\u00260).unwrap())\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"-(c1 + 1) \u003e 1\")?;\r\n        let op_2 = op(plan_2, \"-(1 - c1) \u003e 1\")?;\r\n        let op_3 = op(plan_3, \"-c1 \u003e 1\")?;\r\n        let op_4 = op(plan_4, \"c1 + 1 \u003e 1\")?;\r\n        let op_5 = op(plan_9, \"(-1 - c1) + 1 \u003e 24\")?;\r\n\r\n        assert!(op_1.is_some());\r\n        assert!(op_2.is_some());\r\n        assert!(op_3.is_some());\r\n        assert!(op_4.is_some());\r\n        assert!(op_5.is_some());\r\n\r\n        assert_eq!(op_1, op(plan_5, \"1 \u003c -(c1 + 1)\")?);\r\n        assert_eq!(op_2, op(plan_6, \"1 \u003c -(1 - c1)\")?);\r\n        assert_eq!(op_3, op(plan_7, \"1 \u003c -c1\")?);\r\n        assert_eq!(op_4, op(plan_8, \"1 \u003c c1 + 1\")?);\r\n        assert_eq!(op_5, op(plan_10, \"24 \u003c (-1 - c1) + 1\")?);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_repeating_column() -\u003e Result\u003c()\u003e {\r\n        let plan = select_sql_run(\"select * from t1 where -(c1 + 1) \u003e c2\").await?;\r\n\r\n        let best_plan = HepOptimizer::new(plan.clone())\r\n            .batch(\r\n                \"test_simplify_filter\".to_string(),\r\n                HepBatchStrategy::once_topdown(),\r\n                vec![RuleImpl::SimplifyFilter],\r\n            )\r\n            .find_best()?;\r\n        if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n            let c1_col = ColumnCatalog {\r\n                summary: ColumnSummary {\r\n                    id: Some(0),\r\n                    name: \"c1\".to_string(),\r\n                    table_name: Some(Arc::new(\"t1\".to_string())),\r\n                },\r\n                nullable: false,\r\n                desc: ColumnDesc {\r\n                    column_datatype: LogicalType::Integer,\r\n                    is_primary: true,\r\n                    is_unique: false,\r\n                    default: None,\r\n                },\r\n                // ref_expr: None,\r\n            };\r\n            let c2_col = ColumnCatalog {\r\n                summary: ColumnSummary {\r\n                    id: Some(1),\r\n                    name: \"c2\".to_string(),\r\n                    table_name: Some(Arc::new(\"t1\".to_string())),\r\n                },\r\n                nullable: false,\r\n                desc: ColumnDesc {\r\n                    column_datatype: LogicalType::Integer,\r\n                    is_primary: false,\r\n                    is_unique: true,\r\n                    default: None,\r\n                },\r\n                // ref_expr: None,\r\n            };\r\n\r\n            // -(c1 + 1) \u003e c2 =\u003e c1 \u003c -c2 - 1\r\n            assert_eq!(\r\n                filter_op.predicate,\r\n                ScalarExpression::Binary {\r\n                    op: BinaryOperator::Gt,\r\n                    left_expr: Box::new(ScalarExpression::Unary {\r\n                        op: UnaryOperator::Minus,\r\n                        expr: Box::new(ScalarExpression::Binary {\r\n                            op: BinaryOperator::Plus,\r\n                            left_expr: Box::new(ScalarExpression::ColumnRef(Arc::new(c1_col))),\r\n                            right_expr: Box::new(ScalarExpression::Constant(Arc::new(\r\n                                DataValue::Int32(Some(1))\r\n                            ))),\r\n                            ty: LogicalType::Integer,\r\n                        }),\r\n                        ty: LogicalType::Integer,\r\n                    }),\r\n                    right_expr: Box::new(ScalarExpression::ColumnRef(Arc::new(c2_col))),\r\n                    ty: LogicalType::Boolean,\r\n                }\r\n            )\r\n        } else {\r\n            unreachable!()\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_multiple_column() -\u003e Result\u003c()\u003e {\r\n        // c1 + 1 \u003c -1 =\u003e c1 \u003c -2\r\n        let plan_1 =\r\n            select_sql_run(\"select * from t1 where -(c1 + 1) \u003e 1 and -(1 - c2) \u003e 1\").await?;\r\n        // 1 - c1 \u003c -1 =\u003e c1 \u003e 2\r\n        let plan_2 =\r\n            select_sql_run(\"select * from t1 where -(1 - c1) \u003e 1 and -(c2 + 1) \u003e 1\").await?;\r\n        // c1 \u003c -1\r\n        let plan_3 = select_sql_run(\"select * from t1 where -c1 \u003e 1 and c2 + 1 \u003e 1\").await?;\r\n        // c1 \u003e 0\r\n        let plan_4 = select_sql_run(\"select * from t1 where c1 + 1 \u003e 1 and -c2 \u003e 1\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cFilterOperator\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\"{expr}: {:#?}\", filter_op);\r\n\r\n                Ok(Some(filter_op))\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"-(c1 + 1) \u003e 1 and -(1 - c2) \u003e 1\")?.unwrap();\r\n        let op_2 = op(plan_2, \"-(1 - c1) \u003e 1 and -(c2 + 1) \u003e 1\")?.unwrap();\r\n        let op_3 = op(plan_3, \"-c1 \u003e 1 and c2 + 1 \u003e 1\")?.unwrap();\r\n        let op_4 = op(plan_4, \"c1 + 1 \u003e 1 and -c2 \u003e 1\")?.unwrap();\r\n\r\n        let cb_1_c1 = op_1.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_1 =\u003e c1: {:#?}\", cb_1_c1);\r\n        assert_eq!(\r\n            cb_1_c1,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(Arc::new(DataValue::Int32(Some(-2))))\r\n            })\r\n        );\r\n\r\n        let cb_1_c2 = op_1.predicate.convert_binary(\u00261).unwrap();\r\n        println!(\"op_1 =\u003e c2: {:#?}\", cb_1_c2);\r\n        assert_eq!(\r\n            cb_1_c2,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Excluded(Arc::new(DataValue::Int32(Some(2)))),\r\n                max: Bound::Unbounded\r\n            })\r\n        );\r\n\r\n        let cb_2_c1 = op_2.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_2 =\u003e c1: {:#?}\", cb_2_c1);\r\n        assert_eq!(\r\n            cb_2_c1,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Excluded(Arc::new(DataValue::Int32(Some(2)))),\r\n                max: Bound::Unbounded\r\n            })\r\n        );\r\n\r\n        let cb_2_c2 = op_2.predicate.convert_binary(\u00261).unwrap();\r\n        println!(\"op_2 =\u003e c2: {:#?}\", cb_2_c2);\r\n        assert_eq!(\r\n            cb_1_c1,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(Arc::new(DataValue::Int32(Some(-2))))\r\n            })\r\n        );\r\n\r\n        let cb_3_c1 = op_3.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_3 =\u003e c1: {:#?}\", cb_3_c1);\r\n        assert_eq!(\r\n            cb_3_c1,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(Arc::new(DataValue::Int32(Some(-1))))\r\n            })\r\n        );\r\n\r\n        let cb_3_c2 = op_3.predicate.convert_binary(\u00261).unwrap();\r\n        println!(\"op_3 =\u003e c2: {:#?}\", cb_3_c2);\r\n        assert_eq!(\r\n            cb_3_c2,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Excluded(Arc::new(DataValue::Int32(Some(0)))),\r\n                max: Bound::Unbounded\r\n            })\r\n        );\r\n\r\n        let cb_4_c1 = op_4.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_4 =\u003e c1: {:#?}\", cb_4_c1);\r\n        assert_eq!(\r\n            cb_4_c1,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Excluded(Arc::new(DataValue::Int32(Some(0)))),\r\n                max: Bound::Unbounded\r\n            })\r\n        );\r\n\r\n        let cb_4_c2 = op_4.predicate.convert_binary(\u00261).unwrap();\r\n        println!(\"op_4 =\u003e c2: {:#?}\", cb_4_c2);\r\n        assert_eq!(\r\n            cb_4_c2,\r\n            Some(ConstantBinary::Scope {\r\n                min: Bound::Unbounded,\r\n                max: Bound::Excluded(Arc::new(DataValue::Int32(Some(-1))))\r\n            })\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_multiple_column_in_or() -\u003e Result\u003c()\u003e {\r\n        // c1 + 1 \u003c -1 =\u003e c1 \u003c -2\r\n        let plan_1 = select_sql_run(\"select * from t1 where c1 \u003e c2 or c1 \u003e 1\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cFilterOperator\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\"{expr}: {:#?}\", filter_op);\r\n\r\n                Ok(Some(filter_op))\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"c1 \u003e c2 or c1 \u003e 1\")?.unwrap();\r\n\r\n        let cb_1_c1 = op_1.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_1 =\u003e c1: {:#?}\", cb_1_c1);\r\n        assert_eq!(cb_1_c1, None);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_multiple_dispersed_same_column_in_or() -\u003e Result\u003c()\u003e {\r\n        let plan_1 = select_sql_run(\"select * from t1 where c1 = 4 and c1 \u003e c2 or c1 \u003e 1\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cFilterOperator\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\"{expr}: {:#?}\", filter_op);\r\n\r\n                Ok(Some(filter_op))\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"c1 = 4 and c2 \u003e c1 or c1 \u003e 1\")?.unwrap();\r\n\r\n        let cb_1_c1 = op_1.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_1 =\u003e c1: {:#?}\", cb_1_c1);\r\n        assert_eq!(\r\n            cb_1_c1,\r\n            Some(ConstantBinary::Or(vec![\r\n                ConstantBinary::Eq(Arc::new(DataValue::Int32(Some(4)))),\r\n                ConstantBinary::Scope {\r\n                    min: Bound::Excluded(Arc::new(DataValue::Int32(Some(1)))),\r\n                    max: Bound::Unbounded\r\n                }\r\n            ]))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_column_is_null() -\u003e Result\u003c()\u003e {\r\n        let plan_1 = select_sql_run(\"select * from t1 where c1 is null\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cFilterOperator\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\"{expr}: {:#?}\", filter_op);\r\n\r\n                Ok(Some(filter_op))\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"c1 is null\")?.unwrap();\r\n\r\n        let cb_1_c1 = op_1.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_1 =\u003e c1: {:#?}\", cb_1_c1);\r\n        assert_eq!(cb_1_c1, Some(ConstantBinary::Eq(Arc::new(DataValue::Null))));\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_column_is_not_null() -\u003e Result\u003c()\u003e {\r\n        let plan_1 = select_sql_run(\"select * from t1 where c1 is not null\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cFilterOperator\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\"{expr}: {:#?}\", filter_op);\r\n\r\n                Ok(Some(filter_op))\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"c1 is not null\")?.unwrap();\r\n\r\n        let cb_1_c1 = op_1.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_1 =\u003e c1: {:#?}\", cb_1_c1);\r\n        assert_eq!(\r\n            cb_1_c1,\r\n            Some(ConstantBinary::NotEq(Arc::new(DataValue::Null)))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_column_in() -\u003e Result\u003c()\u003e {\r\n        let plan_1 = select_sql_run(\"select * from t1 where c1 in (1, 2, 3)\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cFilterOperator\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\"{expr}: {:#?}\", filter_op);\r\n\r\n                Ok(Some(filter_op))\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"c1 in (1, 2, 3)\")?.unwrap();\r\n\r\n        let cb_1_c1 = op_1.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_1 =\u003e c1: {:#?}\", cb_1_c1);\r\n        assert_eq!(\r\n            cb_1_c1,\r\n            Some(ConstantBinary::Or(vec![\r\n                ConstantBinary::Eq(Arc::new(DataValue::Int32(Some(2)))),\r\n                ConstantBinary::Eq(Arc::new(DataValue::Int32(Some(1)))),\r\n                ConstantBinary::Eq(Arc::new(DataValue::Int32(Some(3)))),\r\n            ]))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn test_simplify_filter_column_not_in() -\u003e Result\u003c()\u003e {\r\n        let plan_1 = select_sql_run(\"select * from t1 where c1 not in (1, 2, 3)\").await?;\r\n\r\n        let op = |plan: LogicalPlan, expr: \u0026str| -\u003e Result\u003cOption\u003cFilterOperator\u003e\u003e {\r\n            let best_plan = HepOptimizer::new(plan.clone())\r\n                .batch(\r\n                    \"test_simplify_filter\".to_string(),\r\n                    HepBatchStrategy::once_topdown(),\r\n                    vec![RuleImpl::SimplifyFilter],\r\n                )\r\n                .find_best()?;\r\n            if let Operator::Filter(filter_op) = best_plan.childrens[0].clone().operator {\r\n                println!(\"{expr}: {:#?}\", filter_op);\r\n\r\n                Ok(Some(filter_op))\r\n            } else {\r\n                Ok(None)\r\n            }\r\n        };\r\n\r\n        let op_1 = op(plan_1, \"c1 not in (1, 2, 3)\")?.unwrap();\r\n\r\n        let cb_1_c1 = op_1.predicate.convert_binary(\u00260).unwrap();\r\n        println!(\"op_1 =\u003e c1: {:#?}\", cb_1_c1);\r\n        assert_eq!(\r\n            cb_1_c1,\r\n            Some(ConstantBinary::And(vec![\r\n                ConstantBinary::NotEq(Arc::new(DataValue::Int32(Some(2)))),\r\n                ConstantBinary::NotEq(Arc::new(DataValue::Int32(Some(1)))),\r\n                ConstantBinary::NotEq(Arc::new(DataValue::Int32(Some(3)))),\r\n            ]))\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":13258597302978740228},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":1441151880758558730},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":6629298651489370112},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":6629298651489370112},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":8863084066665136132},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":17726168133330272264},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":8863084066665136132},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null}],"covered":9,"coverable":10},{"path":["E:","\\","sql-layer","src","parser.rs"],"content":"use sqlparser::dialect::PostgreSqlDialect;\r\nuse sqlparser::parser::ParserError;\r\nuse sqlparser::{ast::Statement as SqlStatement, parser::Parser};\r\nconst DIALECT: PostgreSqlDialect = PostgreSqlDialect {};\r\n\r\npub fn parse(sql: \u0026str) -\u003e Result\u003cVec\u003cSqlStatement\u003e, ParserError\u003e {\r\n    Parser::parse_sql(\u0026DIALECT, sql)\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n    #[test]\r\n    fn test_parser() {\r\n        let sql = \"select a, b, c, d from x join y on a = c;        \";\r\n        let ast = parse(sql);\r\n        println!(\"{:#?}\", ast);\r\n    }\r\n}\r\n","traces":[{"line":6,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":7,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null}],"covered":2,"coverable":2},{"path":["E:","\\","sql-layer","src","planner","mod.rs"],"content":"use std::sync::Arc;\r\n\r\nuse itertools::Itertools;\r\n\r\nuse crate::catalog::{ColumnCatalog, SchemaRef, TableName};\r\n\r\nuse self::operator::{values::ValuesOperator, Operator};\r\n\r\npub mod operator;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct LogicalPlan {\r\n    pub operator: Operator,\r\n    pub childrens: Vec\u003cLogicalPlan\u003e,\r\n    pub(crate) _output_schema_ref: Option\u003cSchemaRef\u003e,\r\n}\r\n\r\nimpl LogicalPlan {\r\n    pub fn new(operator: Operator, childrens: Vec\u003cLogicalPlan\u003e) -\u003e Self {\r\n        LogicalPlan {\r\n            operator,\r\n            childrens,\r\n            _output_schema_ref: None,\r\n        }\r\n    }\r\n    pub fn child(\u0026self, index: usize) -\u003e Option\u003c\u0026LogicalPlan\u003e {\r\n        self.childrens.get(index)\r\n    }\r\n\r\n    pub fn referenced_table(\u0026self) -\u003e Vec\u003cTableName\u003e {\r\n        fn collect_table(plan: \u0026LogicalPlan, results: \u0026mut Vec\u003cTableName\u003e) {\r\n            if let Operator::Scan(op) = \u0026plan.operator {\r\n                results.push(op.table_name.clone());\r\n            }\r\n            for child in \u0026plan.childrens {\r\n                collect_table(child, results);\r\n            }\r\n        }\r\n\r\n        let mut tables = Vec::new();\r\n        collect_table(self, \u0026mut tables);\r\n        tables\r\n    }\r\n    pub fn explain(\u0026self, indentation: usize) -\u003e String {\r\n        let mut result = format!(\"{:indent$}{}\", \"\", self.operator, indent = indentation);\r\n\r\n        for child in \u0026self.childrens {\r\n            result.push('\\n');\r\n            result.push_str(\u0026child.explain(indentation + 2));\r\n        }\r\n\r\n        result\r\n    }\r\n    pub fn output_schema(\u0026mut self) -\u003e \u0026SchemaRef {\r\n        self._output_schema_ref\r\n            .get_or_insert_with(|| match \u0026self.operator {\r\n                Operator::Filter(_) | Operator::Sort(_) | Operator::Limit(_) =\u003e {\r\n                    self.childrens[0].output_schema().clone()\r\n                }\r\n                Operator::Aggregate(op) =\u003e {\r\n                    let out_columns = op\r\n                        .agg_calls\r\n                        .iter()\r\n                        .chain(op.groupby_exprs.iter())\r\n                        .map(|expr| expr.output_columns())\r\n                        .collect_vec();\r\n                    Arc::new(out_columns)\r\n                }\r\n                Operator::Join(_op) =\u003e {\r\n                    // if matches!(op.join_type, JoinType::Left) {\r\n                    //     return self.childrens[0].output_schema().clone();\r\n                    // }\r\n                    let out_columns = self\r\n                        .childrens\r\n                        .iter_mut()\r\n                        .flat_map(|children| Vec::clone(children.output_schema()))\r\n                        .collect_vec();\r\n                    // for iter in out_columns.iter(){\r\n                    //     println!(\"out_columns: {}\", iter);\r\n                    // }\r\n                    Arc::new(out_columns)\r\n                }\r\n                Operator::Project(op) =\u003e {\r\n                    let out_columns = op\r\n                        .exprs\r\n                        .iter()\r\n                        .map(|expr| expr.output_columns())\r\n                        .collect_vec();\r\n                    Arc::new(out_columns)\r\n                }\r\n                Operator::Scan(op) =\u003e {\r\n                    let out_columns = op\r\n                        .columns\r\n                        .iter()\r\n                        .map(|column| column.output_columns())\r\n                        .collect_vec();\r\n                    Arc::new(out_columns)\r\n                }\r\n                Operator::Values(ValuesOperator { columns, .. }) =\u003e Arc::new(columns.clone()),\r\n                Operator::Dummy =\u003e Arc::new(vec![]),\r\n                Operator::Show =\u003e Arc::new(vec![\r\n                    Arc::new(ColumnCatalog::new_dummy(\"TABLE\".to_string())),\r\n                    // Arc::new(ColumnCatalog::new_dummy(\"COLUMN_METAS_LEN\".to_string())),\r\n                ]),\r\n                Operator::Explain =\u003e {\r\n                    Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\"PLAN\".to_string()))])\r\n                }\r\n                Operator::Describe(_) =\u003e Arc::new(vec![\r\n                    Arc::new(ColumnCatalog::new_dummy(\"FIELD\".to_string())),\r\n                    Arc::new(ColumnCatalog::new_dummy(\"TYPE\".to_string())),\r\n                    Arc::new(ColumnCatalog::new_dummy(\"NULL\".to_string())),\r\n                    Arc::new(ColumnCatalog::new_dummy(\"Key\".to_string())),\r\n                    Arc::new(ColumnCatalog::new_dummy(\"DEFAULT\".to_string())),\r\n                ]),\r\n                Operator::Insert(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"INSERTED\".to_string(),\r\n                ))]),\r\n                Operator::Update(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"UPDATED\".to_string(),\r\n                ))]),\r\n                Operator::Delete(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"DELETED\".to_string(),\r\n                ))]),\r\n                Operator::AddColumn(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"ADD COLUMN SUCCESS\".to_string(),\r\n                ))]),\r\n                Operator::DropColumn(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"DROP COLUMN SUCCESS\".to_string(),\r\n                ))]),\r\n                Operator::CreateTable(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"CREATE TABLE SUCCESS\".to_string(),\r\n                ))]),\r\n                Operator::DropTable(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"DROP TABLE SUCCESS\".to_string(),\r\n                ))]),\r\n                // Operator::Truncate(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                //     \"TRUNCATE TABLE SUCCESS\".to_string(),\r\n                // ))]),\r\n                Operator::CopyFromFile(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"COPY FROM SOURCE\".to_string(),\r\n                ))]),\r\n                Operator::SetVar(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"SET SUCCESS\".to_string(),\r\n                ))]),\r\n                Operator::CreateIndex(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"CREATE INDEX SUCCESS\".to_string(),\r\n                ))]),\r\n                Operator::DropIndex(_) =\u003e Arc::new(vec![Arc::new(ColumnCatalog::new_dummy(\r\n                    \"DROP INDEX SUCCESS\".to_string(),\r\n                ))]),\r\n            })\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":18302628885633695744},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":9727775195120271360},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":9727775195120271360},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":18014398509481984000},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":2666130979403333632},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":11240984669916758016},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2233785415175766016},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":12970366926827028480},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":47,"coverable":84},{"path":["E:","\\","sql-layer","src","planner","operator","aggregate.rs"],"content":"use std::fmt::{self, Formatter};\r\n\r\nuse itertools::Itertools;\r\nuse serde::{Deserialize, Serialize};\r\n\r\nuse crate::planner::LogicalPlan;\r\nuse crate::{expression::ScalarExpression, planner::operator::Operator};\r\n\r\n#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]\r\npub struct AggregateOperator {\r\n    pub groupby_exprs: Vec\u003cScalarExpression\u003e,\r\n    pub agg_calls: Vec\u003cScalarExpression\u003e,\r\n    pub is_distinct: bool,\r\n}\r\n\r\nimpl AggregateOperator {\r\n    pub fn build(\r\n        children: LogicalPlan,\r\n        agg_calls: Vec\u003cScalarExpression\u003e,\r\n        groupby_exprs: Vec\u003cScalarExpression\u003e,\r\n        is_distinct: bool,\r\n    ) -\u003e LogicalPlan {\r\n        LogicalPlan::new(\r\n            Operator::Aggregate(Self {\r\n                groupby_exprs,\r\n                agg_calls,\r\n                is_distinct,\r\n            }),\r\n            vec![children],\r\n        )\r\n    }\r\n}\r\n\r\nimpl fmt::Display for AggregateOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        let calls = self\r\n            .agg_calls\r\n            .iter()\r\n            .map(|call| format!(\"{}\", call))\r\n            .join(\", \");\r\n        write!(f, \"Aggregate [{}]\", calls)?;\r\n\r\n        if !self.groupby_exprs.is_empty() {\r\n            let groupbys = self\r\n                .groupby_exprs\r\n                .iter()\r\n                .map(|groupby| format!(\"{}\", groupby))\r\n                .join(\", \");\r\n            write!(f, \" -\u003e Group By [{}]\", groupbys)?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":6,"coverable":17},{"path":["E:","\\","sql-layer","src","planner","operator","alter_table.rs"],"content":"use std::fmt::{self, Formatter};\r\n\r\nuse crate::catalog::{ColumnCatalog, TableName};\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct AddColumnOperator {\r\n    pub table_name: TableName,\r\n    pub if_not_exists: bool,\r\n    pub column: ColumnCatalog,\r\n}\r\nimpl fmt::Display for AddColumnOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(\r\n            f,\r\n            \"Add {} -\u003e {}, If Not Exists: {}\",\r\n            self.column.name(),\r\n            self.table_name,\r\n            self.if_not_exists\r\n        )?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct DropColumnOperator {\r\n    pub table_name: TableName,\r\n    pub column_name: String,\r\n    pub if_exists: bool,\r\n}\r\n\r\nimpl fmt::Display for DropColumnOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(\r\n            f,\r\n            \"Drop {} -\u003e {}, If Exists: {}\",\r\n            self.column_name, self.table_name, self.if_exists\r\n        )?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":12},{"path":["E:","\\","sql-layer","src","planner","operator","copy_from_file.rs"],"content":"use crate::binder::copy::ExtSource;\r\nuse crate::catalog::ColumnRef;\r\nuse itertools::Itertools;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Eq, Clone, Hash)]\r\npub struct CopyFromFileOperator {\r\n    pub table: String,\r\n    pub source: ExtSource,\r\n    pub schema_ref: Vec\u003cColumnRef\u003e,\r\n}\r\n\r\nimpl fmt::Display for CopyFromFileOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        let columns = self\r\n            .schema_ref\r\n            .iter()\r\n            .map(|column| column.name().to_string())\r\n            .join(\", \");\r\n        write!(\r\n            f,\r\n            \"Copy {} -\u003e {} [{}]\",\r\n            self.source.path.display(),\r\n            self.table,\r\n            columns\r\n        )?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["E:","\\","sql-layer","src","planner","operator","create_index.rs"],"content":"use std::fmt::{self, Formatter};\r\n\r\nuse crate::catalog::{IndexName, TableName};\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct CreateIndexOperator {\r\n    pub table_name: TableName,\r\n    pub index_name: IndexName,\r\n    pub col_name: String,\r\n}\r\n\r\nimpl fmt::Display for CreateIndexOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(\r\n            f,\r\n            \"Create Index {} on {}.{}\",\r\n            self.index_name, self.table_name, self.col_name\r\n        )?;\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":609},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":609},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":609},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":609},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":609},"fn_name":null}],"covered":5,"coverable":5},{"path":["E:","\\","sql-layer","src","planner","operator","create_table.rs"],"content":"use crate::catalog::{ColumnCatalog, TableName};\r\nuse itertools::Itertools;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct CreateTableOperator {\r\n    /// Table name to insert to\r\n    pub table_name: TableName,\r\n    /// List of columns of the table\r\n    pub columns: Vec\u003cColumnCatalog\u003e,\r\n    pub if_not_exists: bool,\r\n}\r\nimpl fmt::Display for CreateTableOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        let columns = self\r\n            .columns\r\n            .iter()\r\n            .map(|column| column.name().to_string())\r\n            .join(\", \");\r\n        write!(\r\n            f,\r\n            \"Create {} -\u003e [{}], If Not Exists: {}\",\r\n            self.table_name, columns, self.if_not_exists\r\n        )?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["E:","\\","sql-layer","src","planner","operator","delete.rs"],"content":"use crate::catalog::TableName;\r\n\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct DeleteOperator {\r\n    pub table_name: TableName,\r\n}\r\nimpl fmt::Display for DeleteOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"Delete {}\", self.table_name)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["E:","\\","sql-layer","src","planner","operator","describe.rs"],"content":"use crate::catalog::TableName;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Eq, Clone, Hash)]\r\npub struct DescribeOperator {\r\n    pub table_name: TableName,\r\n}\r\n\r\nimpl fmt::Display for DescribeOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"Describe {}\", self.table_name)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["E:","\\","sql-layer","src","planner","operator","drop_index.rs"],"content":"use core::fmt;\r\nuse std::fmt::Formatter;\r\n\r\nuse crate::catalog::{IndexName, TableName};\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct DropIndexOperator {\r\n    pub table_name: TableName,\r\n    pub index_name: IndexName,\r\n    pub if_exists: bool,\r\n}\r\n\r\nimpl fmt::Display for DropIndexOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(\r\n            f,\r\n            \"Drop Index {} of {} If Not Exists: {}\",\r\n            self.index_name, self.table_name, self.if_exists\r\n        )?;\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["E:","\\","sql-layer","src","planner","operator","drop_table.rs"],"content":"use crate::catalog::TableName;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct DropTableOperator {\r\n    /// Table name to insert to\r\n    pub table_name: TableName,\r\n    pub if_exists: bool,\r\n}\r\nimpl fmt::Display for DropTableOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"Drop {}, If Exists: {}\", self.table_name, self.if_exists)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["E:","\\","sql-layer","src","planner","operator","filter.rs"],"content":"use super::Operator;\r\nuse crate::{expression::ScalarExpression, planner::LogicalPlan};\r\nuse std::fmt::Formatter;\r\nuse std::{fmt, vec};\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct FilterOperator {\r\n    pub predicate: ScalarExpression,\r\n    pub having: bool,\r\n}\r\n\r\nimpl FilterOperator {\r\n    pub fn build(predicate: ScalarExpression, children: LogicalPlan, having: bool) -\u003e LogicalPlan {\r\n        LogicalPlan::new(\r\n            Operator::Filter(FilterOperator { predicate, having }),\r\n            vec![children],\r\n        )\r\n    }\r\n}\r\n\r\nimpl fmt::Display for FilterOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"Filter {}, Is Having: {}\", self.predicate, self.having)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":2810246167479189507},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":2810246167479189507},"fn_name":null},{"line":16,"address":[],"length":0,"stats":{"Line":2810246167479189507},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":6},{"path":["E:","\\","sql-layer","src","planner","operator","insert.rs"],"content":"use crate::catalog::TableName;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct InsertOperator {\r\n    pub table_name: TableName,\r\n    pub is_overwrite: bool,\r\n}\r\nimpl fmt::Display for InsertOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(\r\n            f,\r\n            \"Insert {}, Is Overwrite: {}\",\r\n            self.table_name, self.is_overwrite\r\n        )?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":5},{"path":["E:","\\","sql-layer","src","planner","operator","join.rs"],"content":"use crate::{expression::ScalarExpression, planner::LogicalPlan};\r\nuse itertools::Itertools;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\nuse strum_macros::Display;\r\n\r\nuse super::Operator;\r\n\r\n#[derive(Debug, PartialEq, Display, Clone, Copy)]\r\npub enum JoinType {\r\n    Inner,\r\n    Left,\r\n    Right,\r\n    Full,\r\n    Cross,\r\n}\r\n#[derive(Debug, Clone, PartialEq)]\r\npub enum JoinCondition {\r\n    On {\r\n        /// Equijoin clause expressed as pairs of (left, right) join columns\r\n        on: Vec\u003c(ScalarExpression, ScalarExpression)\u003e,\r\n        /// Filters applied during join (non-equi conditions)\r\n        filter: Option\u003cScalarExpression\u003e,\r\n    },\r\n    None,\r\n}\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct JoinOperator {\r\n    pub on: JoinCondition,\r\n    pub join_type: JoinType,\r\n}\r\n\r\nimpl JoinOperator {\r\n    pub fn build(\r\n        left: LogicalPlan,\r\n        right: LogicalPlan,\r\n        on: JoinCondition,\r\n        join_type: JoinType,\r\n    ) -\u003e LogicalPlan {\r\n        LogicalPlan::new(\r\n            Operator::Join(JoinOperator { on, join_type }),\r\n            vec![left, right],\r\n        )\r\n    }\r\n}\r\n\r\nimpl fmt::Display for JoinOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"{} Join On {}\", self.join_type, self.on)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl fmt::Display for JoinCondition {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        match self {\r\n            JoinCondition::On { on, filter } =\u003e {\r\n                let on = on\r\n                    .iter()\r\n                    .map(|(v1, v2)| format!(\"{} = {}\", v1, v2))\r\n                    .join(\" AND \");\r\n\r\n                write!(f, \"{}\", on)?;\r\n                if let Some(filter) = filter {\r\n                    write!(f, \"Where {}\", filter)?;\r\n                }\r\n            }\r\n            JoinCondition::None =\u003e {\r\n                write!(f, \"Nothing\")?;\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":35,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":16},{"path":["E:","\\","sql-layer","src","planner","operator","limit.rs"],"content":"use crate::planner::LogicalPlan;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\nuse super::Operator;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct LimitOperator {\r\n    pub offset: Option\u003cusize\u003e,\r\n    pub limit: Option\u003cusize\u003e,\r\n}\r\n\r\nimpl LimitOperator {\r\n    pub fn build(\r\n        offset: Option\u003cusize\u003e,\r\n        limit: Option\u003cusize\u003e,\r\n        children: LogicalPlan,\r\n    ) -\u003e LogicalPlan {\r\n        LogicalPlan::new(\r\n            Operator::Limit(LimitOperator { offset, limit }),\r\n            vec![children],\r\n        )\r\n    }\r\n}\r\nimpl fmt::Display for LimitOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        if let Some(limit) = self.limit {\r\n            write!(f, \"Limit {}\", limit)?;\r\n        }\r\n        if self.limit.is_some() \u0026\u0026 self.offset.is_some() {\r\n            write!(f, \", \")?;\r\n        }\r\n        if let Some(offset) = self.offset {\r\n            write!(f, \"Offset {}\", offset)?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":360287970189639690},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":360287970189639690},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":360287970189639690},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":3,"coverable":11},{"path":["E:","\\","sql-layer","src","planner","operator","mod.rs"],"content":"use itertools::Itertools;\r\n\r\nuse self::{\r\n    aggregate::AggregateOperator,\r\n    alter_table::{AddColumnOperator, DropColumnOperator},\r\n    copy_from_file::CopyFromFileOperator,\r\n    create_index::CreateIndexOperator,\r\n    create_table::CreateTableOperator,\r\n    delete::DeleteOperator,\r\n    describe::DescribeOperator,\r\n    drop_index::DropIndexOperator,\r\n    drop_table::DropTableOperator,\r\n    filter::FilterOperator,\r\n    insert::InsertOperator,\r\n    join::{JoinCondition, JoinOperator},\r\n    limit::LimitOperator,\r\n    project::ProjectOperator,\r\n    scan::ScanOperator,\r\n    set_var::SetVarOperator,\r\n    sort::SortOperator,\r\n    update::UpdateOperator,\r\n    values::ValuesOperator,\r\n};\r\nuse crate::catalog::ColumnRef;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\npub mod aggregate;\r\npub mod alter_table;\r\npub mod copy_from_file;\r\npub mod create_index;\r\npub mod create_table;\r\npub mod delete;\r\npub mod describe;\r\npub mod drop_index;\r\npub mod drop_table;\r\npub mod filter;\r\npub mod insert;\r\npub mod join;\r\npub mod limit;\r\npub mod project;\r\npub mod scan;\r\npub mod set_var;\r\npub mod sort;\r\npub mod update;\r\npub mod values;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub enum Operator {\r\n    // DQL\r\n    Dummy,\r\n    Aggregate(AggregateOperator),\r\n    Filter(FilterOperator),\r\n    Join(JoinOperator),\r\n    Project(ProjectOperator),\r\n    Scan(ScanOperator),\r\n    Sort(SortOperator),\r\n    Limit(LimitOperator),\r\n    Values(ValuesOperator),\r\n    Explain,\r\n    Show,\r\n    SetVar(SetVarOperator),\r\n    Describe(DescribeOperator),\r\n    // DML\r\n    Insert(InsertOperator),\r\n    Update(UpdateOperator),\r\n    Delete(DeleteOperator),\r\n    // DDL\r\n    AddColumn(AddColumnOperator),\r\n    DropColumn(DropColumnOperator),\r\n    CreateTable(CreateTableOperator),\r\n    DropTable(DropTableOperator),\r\n    CreateIndex(CreateIndexOperator),\r\n    DropIndex(DropIndexOperator),\r\n    CopyFromFile(CopyFromFileOperator),\r\n}\r\nimpl Operator {\r\n    pub fn referenced_columns(\u0026self, only_column_ref: bool) -\u003e Vec\u003cColumnRef\u003e {\r\n        match self {\r\n            Operator::Aggregate(op) =\u003e op\r\n                .agg_calls\r\n                .iter()\r\n                .chain(op.groupby_exprs.iter())\r\n                .flat_map(|expr| expr.referenced_columns(only_column_ref))\r\n                .collect_vec(),\r\n            Operator::Filter(op) =\u003e op.predicate.referenced_columns(only_column_ref),\r\n            Operator::Join(op) =\u003e {\r\n                let mut exprs = Vec::new();\r\n\r\n                if let JoinCondition::On { on, filter } = \u0026op.on {\r\n                    for (left_expr, right_expr) in on {\r\n                        exprs.append(\u0026mut left_expr.referenced_columns(only_column_ref));\r\n                        exprs.append(\u0026mut right_expr.referenced_columns(only_column_ref));\r\n                    }\r\n\r\n                    if let Some(filter_expr) = filter {\r\n                        exprs.append(\u0026mut filter_expr.referenced_columns(only_column_ref));\r\n                    }\r\n                }\r\n                exprs\r\n            }\r\n            Operator::Project(op) =\u003e op\r\n                .exprs\r\n                .iter()\r\n                .flat_map(|expr| expr.referenced_columns(only_column_ref))\r\n                .collect_vec(),\r\n            Operator::Scan(op) =\u003e op\r\n                .columns\r\n                .iter()\r\n                .flat_map(|expr| expr.referenced_columns(only_column_ref))\r\n                .collect_vec(),\r\n            Operator::Sort(op) =\u003e op\r\n                .sort_fields\r\n                .iter()\r\n                .map(|field| \u0026field.expr)\r\n                .flat_map(|expr| expr.referenced_columns(only_column_ref))\r\n                .collect_vec(),\r\n            Operator::Values(op) =\u003e op.columns.clone(),\r\n            _ =\u003e vec![],\r\n        }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for Operator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        match self {\r\n            Operator::Dummy =\u003e write!(f, \"Dummy\"),\r\n            Operator::Aggregate(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Filter(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Join(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Project(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Scan(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Sort(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Limit(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Values(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Explain =\u003e unreachable!(),\r\n            Operator::Insert(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Update(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::AddColumn(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::DropColumn(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::CreateTable(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::DropTable(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Delete(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::CreateIndex(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::DropIndex(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Show =\u003e write!(f, \"Show Tables\"),\r\n            Operator::SetVar(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::CopyFromFile(op) =\u003e write!(f, \"{}\", op),\r\n            Operator::Describe(op) =\u003e write!(f, \"{}\", op),\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":78,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":26,"coverable":52},{"path":["E:","\\","sql-layer","src","planner","operator","project.rs"],"content":"use crate::catalog::ColumnRef;\r\nuse crate::expression::ScalarExpression;\r\nuse itertools::Itertools;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct ProjectOperator {\r\n    pub exprs: Vec\u003cScalarExpression\u003e,\r\n}\r\n\r\nimpl ProjectOperator {\r\n    pub fn ouput_schema(\u0026self) -\u003e Vec\u003cColumnRef\u003e {\r\n        self.exprs\r\n            .iter()\r\n            .map(|expr| expr.output_columns())\r\n            .collect()\r\n    }\r\n}\r\n\r\nimpl fmt::Display for ProjectOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        let exprs = self.exprs.iter().map(|expr| format!(\"{}\", expr)).join(\", \");\r\n\r\n        write!(f, \"Projection [{}]\", exprs)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["E:","\\","sql-layer","src","planner","operator","scan.rs"],"content":"use super::Operator;\r\nuse crate::catalog::{TableCatalog, TableName};\r\nuse crate::expression::simplify::ConstantBinary;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::planner::LogicalPlan;\r\nuse crate::storage::Bounds;\r\nuse crate::types::index::IndexMetaRef;\r\nuse itertools::Itertools;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct ScanOperator {\r\n    pub index_metas: Vec\u003cIndexMetaRef\u003e,\r\n\r\n    pub table_name: TableName,\r\n    pub columns: Vec\u003cScalarExpression\u003e,\r\n    // Support push down limit.\r\n    pub limit: Bounds,\r\n\r\n    // IndexScan only\r\n    // Support push down predicate.\r\n    // If pre_where is simple predicate, for example:  a \u003e 1 then can calculate directly when read data.\r\n    pub index_by: Option\u003c(IndexMetaRef, Vec\u003cConstantBinary\u003e)\u003e,\r\n}\r\nimpl ScanOperator {\r\n    pub fn build(table_name: TableName, table_catalog: \u0026TableCatalog) -\u003e LogicalPlan {\r\n        // Fill all Columns in TableCatalog by default\r\n        let columns = table_catalog\r\n            .all_columns()\r\n            .into_iter()\r\n            .map(ScalarExpression::ColumnRef)\r\n            .collect_vec();\r\n        LogicalPlan::new(\r\n            Operator::Scan(ScanOperator {\r\n                index_metas: table_catalog.indexes.clone(),\r\n                table_name,\r\n                columns,\r\n\r\n                limit: (None, None),\r\n                index_by: None,\r\n            }),\r\n            vec![],\r\n        )\r\n    }\r\n}\r\nimpl fmt::Display for ScanOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        let projection_columns = self\r\n            .columns\r\n            .iter()\r\n            .map(|column| format!(\"{}\", column))\r\n            .join(\", \");\r\n        let (offset, limit) = self.limit;\r\n        if let Some(index) = \u0026self.index_by {\r\n            write!(\r\n                f,\r\n                \"IndexScan {} by {} -\u003e [{}]\",\r\n                self.table_name, index.0.name, projection_columns\r\n            )?;\r\n        } else {\r\n            write!(f, \"Scan {} -\u003e [{}]\", self.table_name, projection_columns)?;\r\n        }\r\n        if let Some(limit) = limit {\r\n            write!(f, \", Limit: {}\", limit)?;\r\n        }\r\n        if let Some(offset) = offset {\r\n            write!(f, \", Offset: {}\", offset)?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":10,"coverable":22},{"path":["E:","\\","sql-layer","src","planner","operator","set_var.rs"],"content":"use std::fmt;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct SetVarOperator {\r\n    pub variable: String,\r\n    pub value: String,\r\n}\r\nimpl fmt::Display for SetVarOperator {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        write!(f, \"Set {} = {}\", self.variable, self.value)?;\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["E:","\\","sql-layer","src","planner","operator","sort.rs"],"content":"use crate::expression::ScalarExpression;\r\nuse itertools::Itertools;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct SortField {\r\n    pub expr: ScalarExpression,\r\n    pub asc: bool,\r\n    pub nulls_first: bool,\r\n}\r\n\r\nimpl SortField {\r\n    pub fn new(expr: ScalarExpression, asc: bool, nulls_first: bool) -\u003e Self {\r\n        SortField {\r\n            expr,\r\n            asc,\r\n            nulls_first,\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct SortOperator {\r\n    pub sort_fields: Vec\u003cSortField\u003e,\r\n    /// Support push down limit to sort plan.\r\n    pub limit: Option\u003cusize\u003e,\r\n}\r\n\r\nimpl fmt::Display for SortOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        let sort_fields = self\r\n            .sort_fields\r\n            .iter()\r\n            .map(|sort_field| format!(\"{}\", sort_field))\r\n            .join(\", \");\r\n        write!(f, \"Sort By {}\", sort_fields)?;\r\n\r\n        if let Some(limit) = self.limit {\r\n            write!(f, \", Limit {}\", limit)?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl fmt::Display for SortField {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"{}\", self.expr)?;\r\n        if self.asc {\r\n            write!(f, \" Asc\")?;\r\n        } else {\r\n            write!(f, \" Desc\")?;\r\n        }\r\n        if self.nulls_first {\r\n            write!(f, \" Nulls First\")?;\r\n        } else {\r\n            write!(f, \" Nulls Last\")?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":18},{"path":["E:","\\","sql-layer","src","planner","operator","update.rs"],"content":"use std::fmt;\r\nuse std::fmt::Formatter;\r\nuse std::sync::Arc;\r\n\r\nuse crate::{\r\n    catalog::{ColumnCatalog, TableName},\r\n    expression::ScalarExpression,\r\n};\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct UpdateOperator {\r\n    pub columns: Vec\u003cArc\u003cColumnCatalog\u003e\u003e,\r\n    pub set_expr: Vec\u003cScalarExpression\u003e,\r\n    pub table_name: TableName,\r\n}\r\nimpl fmt::Display for UpdateOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"Update {}\", self.table_name)?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3},{"path":["E:","\\","sql-layer","src","planner","operator","values.rs"],"content":"use crate::catalog::ColumnRef;\r\nuse crate::types::value::ValueRef;\r\nuse itertools::Itertools;\r\nuse std::fmt;\r\nuse std::fmt::Formatter;\r\n\r\n#[derive(Debug, PartialEq, Clone)]\r\npub struct ValuesOperator {\r\n    pub rows: Vec\u003cVec\u003cValueRef\u003e\u003e,\r\n    pub columns: Vec\u003cColumnRef\u003e,\r\n}\r\nimpl fmt::Display for ValuesOperator {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        let columns = self\r\n            .columns\r\n            .iter()\r\n            .map(|column| column.name().to_string())\r\n            .join(\", \");\r\n\r\n        write!(f, \"Values [{}], RowsLen: {}\", columns, self.rows.len())?;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":13,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["E:","\\","sql-layer","src","server.rs"],"content":"use std::{io, sync::Arc};\r\n\r\nuse async_trait::async_trait;\r\nuse futures::stream;\r\nuse rust_decimal::prelude::ToPrimitive;\r\n\r\nuse pgwire::{\r\n    api::{\r\n        auth::{noop::NoopStartupHandler, StartupHandler},\r\n        portal::{Format, Portal},\r\n        query::{ExtendedQueryHandler, SimpleQueryHandler, StatementOrPortal},\r\n        results::{DataRowEncoder, DescribeResponse, FieldInfo, QueryResponse, Response, Tag},\r\n        stmt::NoopQueryParser,\r\n        ClientInfo, MakeHandler, StatelessMakeHandler, Type,\r\n    },\r\n    error::{ErrorInfo, PgWireError, PgWireResult},\r\n    tokio::process_socket,\r\n};\r\nuse tokio::{net::TcpListener, sync::Mutex};\r\nuse tracing::debug;\r\n\r\nuse crate::{\r\n    catalog::SchemaRef,\r\n    db::{DBTransaction, Database},\r\n    errors::*,\r\n    planner::operator::Operator,\r\n    storage::{piggy_stroage::PiggyKVStroage},\r\n    types::{tuple::Tuple, LogicalType},\r\n};\r\n\r\npub struct Session {\r\n    inner: Arc\u003cDatabase\u003cPiggyKVStroage\u003e\u003e,\r\n    tx: Mutex\u003cOption\u003cDBTransaction\u003cPiggyKVStroage\u003e\u003e\u003e,\r\n}\r\npub struct Server {\r\n    pub(crate) inner: Arc\u003cDatabase\u003cPiggyKVStroage\u003e\u003e,\r\n}\r\n\r\nimpl MakeHandler for Server {\r\n    type Handler = Arc\u003cSession\u003e;\r\n\r\n    fn make(\u0026self) -\u003e Self::Handler {\r\n        Arc::new(Session {\r\n            inner: Arc::clone(\u0026self.inner),\r\n            tx: Mutex::new(None),\r\n        })\r\n    }\r\n}\r\n\r\n#[async_trait]\r\nimpl ExtendedQueryHandler for Session {\r\n    type Statement = String;\r\n\r\n    type QueryParser = NoopQueryParser;\r\n\r\n    fn query_parser(\u0026self) -\u003e Arc\u003cSelf::QueryParser\u003e {\r\n        Arc::new(NoopQueryParser::new())\r\n    }\r\n    async fn do_describe\u003cC\u003e(\r\n        \u0026self,\r\n        _client: \u0026mut C,\r\n        target: StatementOrPortal\u003c'_, Self::Statement\u003e,\r\n    ) -\u003e PgWireResult\u003cDescribeResponse\u003e\r\n    where\r\n        C: ClientInfo + Unpin + Send + Sync,\r\n    {\r\n        match target {\r\n            StatementOrPortal::Statement(stmt) =\u003e {\r\n                let plan = self.inner.prepare_sql(\u0026stmt.statement).await.unwrap();\r\n                // debug!(\"plan: {:?}\", plan);\r\n                if let Operator::Project(op) = plan.operator {\r\n                    let filed = op\r\n                        .ouput_schema()\r\n                        .iter()\r\n                        .enumerate()\r\n                        .map(|(idx, col)| {\r\n                            let name = col.name();\r\n                            let data_type = col.datatype();\r\n                            FieldInfo::new(\r\n                                name.to_string(),\r\n                                None,\r\n                                None,\r\n                                into_pg_type(data_type).unwrap(),\r\n                                Format::UnifiedText.format_for(idx),\r\n                            )\r\n                        })\r\n                        .collect::\u003cVec\u003c_\u003e\u003e();\r\n                    // debug!(\"filed: {:?}\", filed);\r\n                    Ok(DescribeResponse::new(None, filed))\r\n                } else {\r\n                    Ok(DescribeResponse::new(None, vec![]))\r\n                }\r\n            }\r\n            StatementOrPortal::Portal(portal) =\u003e {\r\n                let plan = self\r\n                    .inner\r\n                    .prepare_sql(\u0026portal.statement.statement)\r\n                    .await\r\n                    .unwrap();\r\n                // debug!(\"plan: {:?}\", plan);\r\n                if let Operator::Project(op) = plan.operator {\r\n                    let filed = op\r\n                        .ouput_schema()\r\n                        .iter()\r\n                        .enumerate()\r\n                        .map(|(idx, col)| {\r\n                            let name = col.name();\r\n                            let data_type = col.datatype();\r\n                            FieldInfo::new(\r\n                                name.to_string(),\r\n                                None,\r\n                                None,\r\n                                into_pg_type(data_type).unwrap(),\r\n                                Format::UnifiedText.format_for(idx),\r\n                            )\r\n                        })\r\n                        .collect::\u003cVec\u003c_\u003e\u003e();\r\n                    // debug!(\"filed: {:?}\", filed);\r\n                    Ok(DescribeResponse::new(None, filed))\r\n                } else {\r\n                    Ok(DescribeResponse::new(None, vec![]))\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    async fn do_query\u003c'a, C\u003e(\r\n        \u0026self,\r\n        _client: \u0026mut C,\r\n        portal: \u0026'a Portal\u003cSelf::Statement\u003e,\r\n        _max_rows: usize,\r\n    ) -\u003e PgWireResult\u003cResponse\u003c'a\u003e\u003e\r\n    where\r\n        C: ClientInfo + Unpin + Send + Sync,\r\n    {\r\n        let query = \u0026portal.statement.statement;\r\n        //  debug!(\"query: {}\", query);\r\n        match query.to_uppercase().as_str() {\r\n            \"BEGIN;\" | \"BEGIN\" | \"START TRANSACTION;\" | \"START TRANSACTION\" =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                if guard.is_some() {\r\n                    return Err(PgWireError::ApiError(Box::new(\r\n                        DatabaseError::TransactionAlreadyExists,\r\n                    )));\r\n                }\r\n                let transaction = self\r\n                    .inner\r\n                    .new_transaction()\r\n                    .await\r\n                    .map_err(|e| PgWireError::ApiError(Box::new(e)))?;\r\n                guard.replace(transaction);\r\n\r\n                Ok(Response::Execution(Tag::new(\"BEGIN\")))\r\n            }\r\n            \"COMMIT;\" | \"COMMIT\" =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                if let Some(transaction) = guard.take() {\r\n                    transaction\r\n                        .commit()\r\n                        .await\r\n                        .map_err(|e| PgWireError::ApiError(Box::new(e)))?;\r\n\r\n                    Ok(Response::Execution(Tag::new(\"COMMIT\")))\r\n                } else {\r\n                    Err(PgWireError::ApiError(Box::new(\r\n                        DatabaseError::NoTransactionBegin,\r\n                    )))\r\n                }\r\n            }\r\n            \"ROLLBACK;\" | \"ROLLBACK\" =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                if guard.is_none() {\r\n                    return Err(PgWireError::ApiError(Box::new(\r\n                        DatabaseError::NoTransactionBegin,\r\n                    )));\r\n                }\r\n                drop(guard.take());\r\n\r\n                Ok(Response::Execution(Tag::new(\"ROLLBACK\")))\r\n            }\r\n            _ =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                let (schema, tuples) = if let Some(transaction) = guard.as_mut() {\r\n                    transaction.run(query).await\r\n                } else {\r\n                    self.inner.run(query).await\r\n                }\r\n                .map_err(|e| PgWireError::ApiError(Box::new(e)))?;\r\n                // debug!(\"tuples: {:?}\", tuples);\r\n                Ok(Response::Query(encode_tuples(schema, tuples)?))\r\n            }\r\n        }\r\n    }\r\n}\r\nfn row_desc_from_stmt(schema: SchemaRef, format: \u0026Format) -\u003e PgWireResult\u003cVec\u003cFieldInfo\u003e\u003e {\r\n    return schema\r\n        .iter()\r\n        .enumerate()\r\n        .map(|(idx, col)| {\r\n            let datatype = col.datatype();\r\n            let name = col.name();\r\n\r\n            Ok(FieldInfo::new(\r\n                name.to_string(),\r\n                None,\r\n                None,\r\n                into_pg_type(datatype).unwrap(),\r\n                format.format_for(idx),\r\n            ))\r\n        })\r\n        .collect();\r\n}\r\n\r\n#[async_trait]\r\nimpl SimpleQueryHandler for Session {\r\n    async fn do_query\u003c'a, 'b: 'a, C\u003e(\r\n        \u0026'b self,\r\n        _client: \u0026mut C,\r\n        query: \u0026'a str,\r\n    ) -\u003e PgWireResult\u003cVec\u003cResponse\u003c'a\u003e\u003e\u003e\r\n    where\r\n        C: ClientInfo + Unpin + Send + Sync,\r\n    {\r\n        match query.to_uppercase().as_str() {\r\n            \"BEGIN;\" | \"BEGIN\" =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                if guard.is_some() {\r\n                    return Err(PgWireError::ApiError(Box::new(\r\n                        DatabaseError::TransactionAlreadyExists,\r\n                    )));\r\n                }\r\n                let transaction = self\r\n                    .inner\r\n                    .new_transaction()\r\n                    .await\r\n                    .map_err(|e| PgWireError::ApiError(Box::new(e)))?;\r\n                guard.replace(transaction);\r\n\r\n                Ok(vec![Response::Execution(Tag::new(\"BEGIN\"))])\r\n            }\r\n            \"COMMIT;\" | \"COMMIT\" =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                if let Some(transaction) = guard.take() {\r\n                    transaction\r\n                        .commit()\r\n                        .await\r\n                        .map_err(|e| PgWireError::ApiError(Box::new(e)))?;\r\n\r\n                    Ok(vec![Response::Execution(Tag::new(\"COMMIT\"))])\r\n                } else {\r\n                    Err(PgWireError::ApiError(Box::new(\r\n                        DatabaseError::NoTransactionBegin,\r\n                    )))\r\n                }\r\n            }\r\n            \"ROLLBACK;\" | \"ROLLBACK\" =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                if guard.is_none() {\r\n                    return Err(PgWireError::ApiError(Box::new(\r\n                        DatabaseError::NoTransactionBegin,\r\n                    )));\r\n                }\r\n                drop(guard.take());\r\n\r\n                Ok(vec![Response::Execution(Tag::new(\"ROLLBACK\"))])\r\n            }\r\n            _ =\u003e {\r\n                let mut guard = self.tx.lock().await;\r\n\r\n                let (schema, tuples) = if let Some(transaction) = guard.as_mut() {\r\n                    transaction.run(query).await\r\n                } else {\r\n                    self.inner.run(query).await\r\n                }\r\n                .map_err(|e| PgWireError::ApiError(Box::new(e)))?;\r\n\r\n                Ok(vec![Response::Query(encode_tuples(schema, tuples)?)])\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl Server {\r\n    pub async fn new(kv: PiggyKVStroage) -\u003e Result\u003cArc\u003cServer\u003e\u003e {\r\n        Ok(Arc::new(Server {\r\n            inner: Arc::new(Database::new(kv)?),\r\n        }))\r\n    }\r\n\r\n    pub async fn run(server: Arc\u003cSelf\u003e) {\r\n        // let backend = Server::new().await.unwrap();\r\n        let processor = server;\r\n\r\n\r\n        let authenticator = Arc::new(StatelessMakeHandler::new(Arc::new(NoopStartupHandler)));\r\n        let server_addr = format!(\"{}:{}\", \"127.0.0.1\", \"5432\");\r\n        let listener = TcpListener::bind(server_addr).await.unwrap();\r\n\r\n        tokio::select! {\r\n            res = server_run(processor.clone(), processor.clone(), authenticator, listener) =\u003e {\r\n                if let Err(err) = res {\r\n                    debug!(\"server run error: {}\", err);\r\n                }\r\n            }\r\n            _ = quit() =\u003e {\r\n                debug!(\"quit server\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npub(crate) async fn server_run\u003c\r\n    A: MakeHandler\u003cHandler = Arc\u003cimpl StartupHandler + 'static\u003e\u003e,\r\n    Q: MakeHandler\u003cHandler = Arc\u003cimpl SimpleQueryHandler + 'static\u003e\u003e,\r\n    EQ: MakeHandler\u003cHandler = Arc\u003cimpl ExtendedQueryHandler + 'static\u003e\u003e,\r\n\u003e(\r\n    processor: Arc\u003cQ\u003e,\r\n    placeholder: Arc\u003cEQ\u003e,\r\n    authenticator: Arc\u003cA\u003e,\r\n    listener: TcpListener,\r\n) -\u003e io::Result\u003c()\u003e {\r\n    loop {\r\n        let incoming_socket = listener.accept().await?;\r\n        let authenticator_ref = authenticator.make();\r\n        let processor_ref = processor.make();\r\n        let placeholder_ref = placeholder.make();\r\n\r\n        tokio::spawn(async move {\r\n            if let Err(err) = process_socket(\r\n                incoming_socket.0,\r\n                None,\r\n                authenticator_ref,\r\n                processor_ref,\r\n                placeholder_ref,\r\n            )\r\n            .await\r\n            {\r\n                debug!(\"process_socket error: {}\", err);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nasync fn quit() -\u003e io::Result\u003c()\u003e {\r\n    #[cfg(unix)]\r\n    {\r\n        let mut interrupt =\r\n            tokio::signal::unix::signal(tokio::signal::unix::SignalKind::interrupt())?;\r\n        let mut terminate =\r\n            tokio::signal::unix::signal(tokio::signal::unix::SignalKind::terminate())?;\r\n        tokio::select! {\r\n            _ = interrupt.recv() =\u003e (),\r\n            _ = terminate.recv() =\u003e (),\r\n        }\r\n        Ok(())\r\n    }\r\n    #[cfg(windows)]\r\n    {\r\n        let mut signal = tokio::signal::windows::ctrl_c()?;\r\n        let _ = signal.recv().await;\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\nfn encode_tuples\u003c'a\u003e(schema: SchemaRef, tuples: Vec\u003cTuple\u003e) -\u003e PgWireResult\u003cQueryResponse\u003c'a\u003e\u003e {\r\n    // if tuples.is_empty() {\r\n    //     return Ok(QueryResponse::new(Arc::new(vec![]), stream::empty()));\r\n    // }\r\n    let schema = Arc::new(row_desc_from_stmt(schema, \u0026Format::UnifiedText)?);\r\n    let mut results = Vec::with_capacity(tuples.len());\r\n\r\n    for tuple in tuples {\r\n        let mut encoder = DataRowEncoder::new(schema.clone());\r\n        for value in tuple.values {\r\n            match value.logical_type() {\r\n                LogicalType::SqlNull =\u003e encoder.encode_field(\u0026None::\u003ci8\u003e),\r\n                LogicalType::Boolean =\u003e encoder.encode_field(\u0026value.bool()),\r\n                LogicalType::Tinyint =\u003e encoder.encode_field(\u0026value.i8()),\r\n                LogicalType::UTinyint =\u003e encoder.encode_field(\u0026value.u8().map(|v| v as i8)),\r\n                LogicalType::Smallint =\u003e encoder.encode_field(\u0026value.i16()),\r\n                LogicalType::USmallint =\u003e encoder.encode_field(\u0026value.u16().map(|v| v as i16)),\r\n                LogicalType::Integer =\u003e encoder.encode_field(\u0026value.i32()),\r\n                LogicalType::UInteger =\u003e encoder.encode_field(\u0026value.u32()),\r\n                LogicalType::Bigint =\u003e encoder.encode_field(\u0026value.i64()),\r\n                LogicalType::UBigint =\u003e encoder.encode_field(\u0026value.u64().map(|v| v as i64)),\r\n                LogicalType::Float =\u003e encoder.encode_field(\u0026value.float()),\r\n                LogicalType::Double =\u003e encoder.encode_field(\u0026value.double()),\r\n                LogicalType::Varchar(_) =\u003e encoder.encode_field(\u0026value.utf8()),\r\n                LogicalType::Date =\u003e encoder.encode_field(\u0026value.date()),\r\n                LogicalType::DateTime =\u003e encoder.encode_field(\u0026value.datetime()),\r\n                LogicalType::Decimal(_, _) =\u003e {\r\n                    encoder.encode_field(\u0026value.decimal().map(|v| v.to_f64()))\r\n                } //todo\r\n                _ =\u003e unreachable!(),\r\n            }?;\r\n        }\r\n\r\n        results.push(encoder.finish());\r\n    }\r\n    let iter = stream::iter(results);\r\n    Ok(QueryResponse::new(schema, iter))\r\n}\r\nfn into_pg_type(data_type: \u0026LogicalType) -\u003e PgWireResult\u003cType\u003e {\r\n    Ok(match data_type {\r\n        LogicalType::SqlNull =\u003e Type::UNKNOWN,\r\n        LogicalType::Boolean =\u003e Type::BOOL,\r\n        LogicalType::Tinyint | LogicalType::UTinyint =\u003e Type::CHAR,\r\n        LogicalType::Smallint | LogicalType::USmallint =\u003e Type::INT2,\r\n        LogicalType::Integer | LogicalType::UInteger =\u003e Type::INT4,\r\n        LogicalType::Bigint | LogicalType::UBigint =\u003e Type::INT8,\r\n        LogicalType::Float =\u003e Type::FLOAT4,\r\n        LogicalType::Double =\u003e Type::FLOAT8,\r\n        LogicalType::Varchar(_) =\u003e Type::VARCHAR,\r\n        LogicalType::Date | LogicalType::DateTime =\u003e Type::DATE,\r\n        LogicalType::Decimal(_, _) =\u003e Type::NUMERIC,\r\n        _ =\u003e {\r\n            return Err(PgWireError::UserError(Box::new(ErrorInfo::new(\r\n                \"ERROR\".to_owned(),\r\n                \"XX000\".to_owned(),\r\n                format!(\"Unsupported Datatype {data_type}\"),\r\n            ))));\r\n        }\r\n    })\r\n}\r\n","traces":[{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":199},{"path":["E:","\\","sql-layer","src","storage","engine","mod.rs"],"content":"pub mod piggykv;\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","block","builder.rs"],"content":"use bytes::BufMut;\r\n\r\nuse crate::storage::engine::piggykv::key::{KeySlice, KeyVec};\r\n\r\nuse super::{Block, SIZEOF_U16};\r\n\r\n/// Builds a block.\r\npub struct BlockBuilder {\r\n    /// Offsets of each key-value entries.\r\n    offsets: Vec\u003cu16\u003e,\r\n    /// All serialized key-value pairs in the block.\r\n    data: Vec\u003cu8\u003e,\r\n    /// The expected block size.\r\n    block_size: usize,\r\n    /// The first key in the block\r\n    first_key: KeyVec,\r\n}\r\n\r\nfn compute_overlap(first_key: KeySlice, key: KeySlice) -\u003e usize {\r\n    let mut i = 0;\r\n    loop {\r\n        if i \u003e= first_key.key_len() || i \u003e= key.key_len() {\r\n            break;\r\n        }\r\n        if first_key.key_ref()[i] != key.key_ref()[i] {\r\n            break;\r\n        }\r\n        i += 1;\r\n    }\r\n    i\r\n}\r\n\r\nimpl BlockBuilder {\r\n    /// Creates a new block builder.\r\n    pub fn new(block_size: usize) -\u003e Self {\r\n        Self {\r\n            offsets: Vec::new(),\r\n            data: Vec::new(),\r\n            block_size,\r\n            first_key: KeyVec::new(),\r\n        }\r\n    }\r\n\r\n    fn estimated_size(\u0026self) -\u003e usize {\r\n        SIZEOF_U16 /* number of key-value pairs in the block */ +  self.offsets.len() * SIZEOF_U16 /* offsets */ + self.data.len()\r\n        // key-value pairs\r\n    }\r\n\r\n    /// Adds a key-value pair to the block. Returns false when the block is full.\r\n    #[must_use]\r\n    pub fn add(\u0026mut self, key: KeySlice, value: \u0026[u8]) -\u003e bool {\r\n        assert!(!key.is_empty(), \"key must not be empty\");\r\n        if self.estimated_size() + key.raw_len() + value.len() + SIZEOF_U16 * 3 /* key_len, value_len and offset */ \u003e self.block_size\r\n            \u0026\u0026 !self.is_empty()\r\n        {\r\n            return false;\r\n        }\r\n        // Add the offset of the data into the offset array.\r\n        self.offsets.push(self.data.len() as u16);\r\n        let overlap = compute_overlap(self.first_key.as_key_slice(), key);\r\n        // Encode key overlap.\r\n        self.data.put_u16(overlap as u16);\r\n        // Encode key length.\r\n        self.data.put_u16((key.key_len() - overlap) as u16);\r\n        // Encode key content.\r\n        self.data.put(\u0026key.key_ref()[overlap..]);\r\n        // Encode key ts\r\n        self.data.put_u64(key.ts());\r\n        // Encode value length.\r\n        self.data.put_u16(value.len() as u16);\r\n        // Encode value content.\r\n        self.data.put(value);\r\n\r\n        if self.first_key.is_empty() {\r\n            self.first_key = key.to_key_vec();\r\n        }\r\n\r\n        true\r\n    }\r\n\r\n    /// Check if there are no key-value pairs in the block.\r\n    pub fn is_empty(\u0026self) -\u003e bool {\r\n        self.offsets.is_empty()\r\n    }\r\n\r\n    /// Finalize the block.\r\n    pub fn build(self) -\u003e Block {\r\n        if self.is_empty() {\r\n            panic!(\"block should not be empty\");\r\n        }\r\n        Block {\r\n            data: self.data,\r\n            offsets: self.offsets,\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":9943947977234055168},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":9943947977234055168},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":9799832789158191154},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":144115188075866936},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":14051230837395937884},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":9799832789158199296},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":4251398048237749652},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":9943947977234066232},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":14699749183737300306},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":14699749183737300306},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":14699749183737300306},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":14699749183737300306},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":8286623314361712688},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":8286623314361712688},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":8286623314361714116},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":8286623314361715592},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":8286623314361712640},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":18158513697557839872},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":16789419410837209041},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":9943947977234055215},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":9943947977234055215},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":9943947977234055215},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":9943947977234055215},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":9943947977234055215},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":9943947977234055215},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":9943947977234055215},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":9943947977234055215},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":16717361816799281199},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":6773413839565225984},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":9943947977234055216},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":4611686018427389284},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":4611686018427389284},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":6701356245527298192},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":6701356245527298192},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":48},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":6701356245527298144},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":6701356245527298144},"fn_name":null}],"covered":37,"coverable":37},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","block","iterator.rs"],"content":"use std::sync::Arc;\r\n\r\nuse bytes::Buf;\r\n\r\nuse crate::storage::engine::piggykv::key::{KeySlice, KeyVec};\r\n\r\nuse super::{Block, SIZEOF_U16};\r\n\r\n/// Iterates on a block.\r\npub struct BlockIterator {\r\n    /// reference to the block\r\n    block: Arc\u003cBlock\u003e,\r\n    /// the current key at the iterator position\r\n    key: KeyVec,\r\n    /// the value range from the block\r\n    value_range: (usize, usize),\r\n    /// the current index at the iterator position\r\n    idx: usize,\r\n    /// the first key in the block\r\n    first_key: KeyVec,\r\n}\r\n\r\nimpl Block {\r\n    fn get_first_key(\u0026self) -\u003e KeyVec {\r\n        let mut buf = \u0026self.data[..];\r\n        buf.get_u16();\r\n        let key_len = buf.get_u16() as usize;\r\n        let key = \u0026buf[..key_len];\r\n        buf.advance(key_len);\r\n        KeyVec::from_vec_with_ts(key.to_vec(), buf.get_u64())\r\n    }\r\n}\r\n\r\nimpl BlockIterator {\r\n    fn new(block: Arc\u003cBlock\u003e) -\u003e Self {\r\n        Self {\r\n            first_key: block.get_first_key(),\r\n            block,\r\n            key: KeyVec::new(),\r\n            value_range: (0, 0),\r\n            idx: 0,\r\n        }\r\n    }\r\n\r\n    /// Creates a block iterator and seek to the first entry.\r\n    pub fn create_and_seek_to_first(block: Arc\u003cBlock\u003e) -\u003e Self {\r\n        let mut iter = Self::new(block);\r\n        iter.seek_to_first();\r\n        iter\r\n    }\r\n\r\n    /// Creates a block iterator and seek to the first key that \u003e= `key`.\r\n    pub fn create_and_seek_to_key(block: Arc\u003cBlock\u003e, key: KeySlice) -\u003e Self {\r\n        let mut iter = Self::new(block);\r\n        iter.seek_to_key(key);\r\n        iter\r\n    }\r\n\r\n    /// Returns the key of the current entry.\r\n    pub fn key(\u0026self) -\u003e KeySlice {\r\n        debug_assert!(!self.key.is_empty(), \"invalid iterator\");\r\n        self.key.as_key_slice()\r\n    }\r\n\r\n    /// Returns the value of the current entry.\r\n    pub fn value(\u0026self) -\u003e \u0026[u8] {\r\n        debug_assert!(!self.key.is_empty(), \"invalid iterator\");\r\n        \u0026self.block.data[self.value_range.0..self.value_range.1]\r\n    }\r\n\r\n    /// Returns true if the iterator is valid.\r\n    pub fn is_valid(\u0026self) -\u003e bool {\r\n        !self.key.is_empty()\r\n    }\r\n\r\n    /// Seeks to the first key in the block.\r\n    pub fn seek_to_first(\u0026mut self) {\r\n        self.seek_to(0);\r\n    }\r\n\r\n    /// Seeks to the idx-th key in the block.\r\n    fn seek_to(\u0026mut self, idx: usize) {\r\n        if idx \u003e= self.block.offsets.len() {\r\n            self.key.clear();\r\n            self.value_range = (0, 0);\r\n            return;\r\n        }\r\n        let offset = self.block.offsets[idx] as usize;\r\n        self.seek_to_offset(offset);\r\n        self.idx = idx;\r\n    }\r\n\r\n    /// Move to the next key in the block.\r\n    pub fn next(\u0026mut self) {\r\n        self.idx += 1;\r\n        self.seek_to(self.idx);\r\n    }\r\n\r\n    /// Seek to the specified position and update the current `key` and `value`\r\n    /// Index update will be handled by caller\r\n    fn seek_to_offset(\u0026mut self, offset: usize) {\r\n        let mut entry = \u0026self.block.data[offset..];\r\n        // Since `get_u16()` will automatically move the ptr 2 bytes ahead here,\r\n        // we don't need to manually advance it\r\n        let overlap_len = entry.get_u16() as usize;\r\n        let key_len = entry.get_u16() as usize;\r\n        let key = \u0026entry[..key_len];\r\n        self.key.clear();\r\n        self.key.append(\u0026self.first_key.key_ref()[..overlap_len]);\r\n        self.key.append(key);\r\n        entry.advance(key_len);\r\n        let ts = entry.get_u64();\r\n        self.key.set_ts(ts);\r\n        let value_len = entry.get_u16() as usize;\r\n        // REMEMBER TO CHANGE THIS every time you change the encoding!\r\n        let value_offset_begin =\r\n            offset + SIZEOF_U16 + SIZEOF_U16 + std::mem::size_of::\u003cu64\u003e() + key_len + SIZEOF_U16;\r\n        let value_offset_end = value_offset_begin + value_len;\r\n        self.value_range = (value_offset_begin, value_offset_end);\r\n        entry.advance(value_len);\r\n    }\r\n\r\n    /// Seek to the first key that is \u003e= `key`.\r\n    pub fn seek_to_key(\u0026mut self, key: KeySlice) {\r\n        let mut low = 0;\r\n        let mut high = self.block.offsets.len();\r\n        while low \u003c high {\r\n            let mid = low + (high - low) / 2;\r\n            self.seek_to(mid);\r\n            assert!(self.is_valid());\r\n            match self.key().cmp(\u0026key) {\r\n                std::cmp::Ordering::Less =\u003e low = mid + 1,\r\n                std::cmp::Ordering::Greater =\u003e high = mid,\r\n                std::cmp::Ordering::Equal =\u003e return,\r\n            }\r\n        }\r\n        self.seek_to(low);\r\n    }\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":9295429630892704007},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":9295429630892704007},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":9295429630892704007},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":9295429630892704007},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":17365880163140632628},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":17365880163140632628},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":17365880163140632628},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":17365880163140632628},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":10016005571271983314},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1585267068834427163},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":10016005571271983314},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":3674937295934337097},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":7349874591868664240},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3674937295934337097},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":12538021362599463271},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":12538021362599463271},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":9655717601082354973},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":9655717601082354973},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":10160120759347839028},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":10160120759347839028},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":10952754293765048978},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":10952754293765048978},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":10952754293765048978},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":17654110539292341666},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":17654110539292341666},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":17654110539292341666},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":6773413839565226036},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":6773413839565226036},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":6773413839565226036},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":17654110539292345701},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":16861477004875139677},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":16861477004875139677},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":16861477004875139677},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":12177733392409824564},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":16933534598913067796},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":16933534598913067796},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":16933534598913067796},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":16933534598913067795},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":432345564227568131},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":13330654897016668372},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":3170534137668829395},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":13690942867206308384},"fn_name":null}],"covered":69,"coverable":69},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","block.rs"],"content":"mod builder;\r\nmod iterator;\r\n\r\npub use builder::BlockBuilder;\r\nuse bytes::{Buf, BufMut, Bytes};\r\npub use iterator::BlockIterator;\r\n\r\npub(crate) const SIZEOF_U16: usize = std::mem::size_of::\u003cu16\u003e();\r\n\r\n/// A block is the smallest unit of read and caching in LSM tree. It is a collection of sorted\r\n/// key-value pairs.\r\npub struct Block {\r\n    pub(crate) data: Vec\u003cu8\u003e,\r\n    pub(crate) offsets: Vec\u003cu16\u003e,\r\n}\r\n\r\nimpl Block {\r\n    pub fn encode(\u0026self) -\u003e Bytes {\r\n        let mut buf = self.data.clone();\r\n        let offsets_len = self.offsets.len();\r\n        for offset in \u0026self.offsets {\r\n            buf.put_u16(*offset);\r\n        }\r\n        // Adds number of elements at the end of the block\r\n        buf.put_u16(offsets_len as u16);\r\n        buf.into()\r\n    }\r\n\r\n    pub fn decode(data: \u0026[u8]) -\u003e Self {\r\n        // get number of elements in the block\r\n        let entry_offsets_len = (\u0026data[data.len() - SIZEOF_U16..]).get_u16() as usize;\r\n        let data_end = data.len() - SIZEOF_U16 - entry_offsets_len * SIZEOF_U16;\r\n        let offsets_raw = \u0026data[data_end..data.len() - SIZEOF_U16];\r\n        // get offset array\r\n        let offsets = offsets_raw\r\n            .chunks(SIZEOF_U16)\r\n            .map(|mut x| x.get_u16())\r\n            .collect();\r\n        // retrieve data\r\n        let data = data[0..data_end].to_vec();\r\n        Self { data, offsets }\r\n    }\r\n}\r\n\r\n\r\n#[cfg(test)]\r\nmod test{\r\n    use std::sync::Arc;\r\n\r\nuse bytes::Bytes;\r\n\r\nuse crate::storage::engine::piggykv::key::{KeySlice, KeyVec};\r\n\r\nuse super::{Block, BlockBuilder, BlockIterator};\r\n\r\n\r\n#[test]\r\nfn test_block_build_single_key() {\r\n    let mut builder = BlockBuilder::new(16);\r\n    assert!(builder.add(KeySlice::for_testing_from_slice_no_ts(b\"233\"), b\"233333\"));\r\n    builder.build();\r\n}\r\n\r\n#[test]\r\nfn test_block_build_full() {\r\n    let mut builder = BlockBuilder::new(16);\r\n    assert!(builder.add(KeySlice::for_testing_from_slice_no_ts(b\"11\"), b\"11\"));\r\n    assert!(!builder.add(KeySlice::for_testing_from_slice_no_ts(b\"22\"), b\"22\"));\r\n    builder.build();\r\n}\r\n\r\n#[test]\r\nfn test_block_build_large_1() {\r\n    let mut builder = BlockBuilder::new(16);\r\n    assert!(builder.add(\r\n        KeySlice::for_testing_from_slice_no_ts(b\"11\"),\r\n        \u0026b\"1\".repeat(100)\r\n    ));\r\n    builder.build();\r\n}\r\n\r\n#[test]\r\nfn test_block_build_large_2() {\r\n    let mut builder = BlockBuilder::new(16);\r\n    assert!(builder.add(KeySlice::for_testing_from_slice_no_ts(b\"11\"), b\"1\"));\r\n    assert!(!builder.add(\r\n        KeySlice::for_testing_from_slice_no_ts(b\"11\"),\r\n        \u0026b\"1\".repeat(100)\r\n    ));\r\n}\r\n\r\nfn key_of(idx: usize) -\u003e KeyVec {\r\n    KeyVec::for_testing_from_vec_no_ts(format!(\"key_{:03}\", idx * 5).into_bytes())\r\n}\r\n\r\nfn value_of(idx: usize) -\u003e Vec\u003cu8\u003e {\r\n    format!(\"value_{:010}\", idx).into_bytes()\r\n}\r\n\r\nfn num_of_keys() -\u003e usize {\r\n    100\r\n}\r\n\r\nfn generate_block() -\u003e Block {\r\n    let mut builder = BlockBuilder::new(10000);\r\n    for idx in 0..num_of_keys() {\r\n        let key = key_of(idx);\r\n        let value = value_of(idx);\r\n        assert!(builder.add(key.as_key_slice(), \u0026value[..]));\r\n    }\r\n    builder.build()\r\n}\r\n\r\n#[test]\r\nfn test_block_build_all() {\r\n    generate_block();\r\n}\r\n\r\n#[test]\r\nfn test_block_encode() {\r\n    let block = generate_block();\r\n    block.encode();\r\n}\r\n\r\n#[test]\r\nfn test_block_decode() {\r\n    let block = generate_block();\r\n    let encoded = block.encode();\r\n    let decoded_block = Block::decode(\u0026encoded);\r\n    assert_eq!(block.offsets, decoded_block.offsets);\r\n    assert_eq!(block.data, decoded_block.data);\r\n}\r\n\r\nfn as_bytes(x: \u0026[u8]) -\u003e Bytes {\r\n    Bytes::copy_from_slice(x)\r\n}\r\n\r\n#[test]\r\nfn test_block_iterator() {\r\n    let block = Arc::new(generate_block());\r\n    let mut iter = BlockIterator::create_and_seek_to_first(block);\r\n    for _ in 0..5 {\r\n        for i in 0..num_of_keys() {\r\n            let key = iter.key();\r\n            let value = iter.value();\r\n            assert_eq!(\r\n                key.for_testing_key_ref(),\r\n                key_of(i).for_testing_key_ref(),\r\n                \"expected key: {:?}, actual key: {:?}\",\r\n                as_bytes(key_of(i).for_testing_key_ref()),\r\n                as_bytes(key.for_testing_key_ref())\r\n            );\r\n            assert_eq!(\r\n                value,\r\n                value_of(i),\r\n                \"expected value: {:?}, actual value: {:?}\",\r\n                as_bytes(\u0026value_of(i)),\r\n                as_bytes(value)\r\n            );\r\n            iter.next();\r\n        }\r\n        iter.seek_to_first();\r\n    }\r\n}\r\n\r\n#[test]\r\nfn test_block_seek_key() {\r\n    let block = Arc::new(generate_block());\r\n    let mut iter = BlockIterator::create_and_seek_to_key(block, key_of(0).as_key_slice());\r\n    for offset in 1..=5 {\r\n        for i in 0..num_of_keys() {\r\n            let key = iter.key();\r\n            let value = iter.value();\r\n            assert_eq!(\r\n                key.for_testing_key_ref(),\r\n                key_of(i).for_testing_key_ref(),\r\n                \"expected key: {:?}, actual key: {:?}\",\r\n                as_bytes(key_of(i).for_testing_key_ref()),\r\n                as_bytes(key.for_testing_key_ref())\r\n            );\r\n            assert_eq!(\r\n                value,\r\n                value_of(i),\r\n                \"expected value: {:?}, actual value: {:?}\",\r\n                as_bytes(\u0026value_of(i)),\r\n                as_bytes(value)\r\n            );\r\n            iter.seek_to_key(KeySlice::for_testing_from_slice_no_ts(\r\n                \u0026format!(\"key_{:03}\", i * 5 + offset).into_bytes(),\r\n            ));\r\n        }\r\n        iter.seek_to_key(KeySlice::for_testing_from_slice_no_ts(b\"k\"));\r\n    }\r\n}\r\n\r\n}","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":6269010681299730695},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":6269010681299730695},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":6269010681299730695},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":7277816997830721943},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":6485183463413514288},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":6269010681299730695},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":6269010681299730695},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":2954361355555046803},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2954361355555046803},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":2954361355555046803},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":2954361355555046803},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":2954361355555046803},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":2954361355555046803},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":9799832789158202150},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":2954361355555046803},"fn_name":null}],"covered":15,"coverable":15},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","compact","leveled.rs"],"content":"use std::collections::HashSet;\r\n\r\nuse serde::{Deserialize, Serialize};\r\nuse tracing::debug;\r\n\r\nuse crate::storage::engine::piggykv::lsm_storage::LsmStorageState;\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub struct LeveledCompactionTask {\r\n    // if upper_level is `None`, then it is L0 compaction\r\n    pub upper_level: Option\u003cusize\u003e,\r\n    pub upper_level_sst_ids: Vec\u003cusize\u003e,\r\n    pub lower_level: usize,\r\n    pub lower_level_sst_ids: Vec\u003cusize\u003e,\r\n    pub is_lower_level_bottom_level: bool,\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\npub struct LeveledCompactionOptions {\r\n    pub level_size_multiplier: usize,\r\n    pub level0_file_num_compaction_trigger: usize,\r\n    pub max_levels: usize,\r\n    pub base_level_size_mb: usize,\r\n}\r\n\r\npub struct LeveledCompactionController {\r\n    options: LeveledCompactionOptions,\r\n}\r\n\r\nimpl LeveledCompactionController {\r\n    pub fn new(options: LeveledCompactionOptions) -\u003e Self {\r\n        Self { options }\r\n    }\r\n\r\n    fn find_overlapping_ssts(\r\n        \u0026self,\r\n        snapshot: \u0026LsmStorageState,\r\n        sst_ids: \u0026[usize],\r\n        in_level: usize,\r\n    ) -\u003e Vec\u003cusize\u003e {\r\n        let begin_key = sst_ids\r\n            .iter()\r\n            .map(|id| snapshot.sstables[id].first_key())\r\n            .min()\r\n            .cloned()\r\n            .unwrap();\r\n        let end_key = sst_ids\r\n            .iter()\r\n            .map(|id| snapshot.sstables[id].last_key())\r\n            .max()\r\n            .cloned()\r\n            .unwrap();\r\n        let mut overlap_ssts = Vec::new();\r\n        for sst_id in \u0026snapshot.levels[in_level - 1].1 {\r\n            let sst = \u0026snapshot.sstables[sst_id];\r\n            let first_key = sst.first_key();\r\n            let last_key = sst.last_key();\r\n            if !(last_key \u003c \u0026begin_key || first_key \u003e \u0026end_key) {\r\n                overlap_ssts.push(*sst_id);\r\n            }\r\n        }\r\n        overlap_ssts\r\n    }\r\n\r\n    pub fn generate_compaction_task(\r\n        \u0026self,\r\n        snapshot: \u0026LsmStorageState,\r\n    ) -\u003e Option\u003cLeveledCompactionTask\u003e {\r\n        // step 1: compute target level size\r\n        let mut target_level_size = (0..self.options.max_levels).map(|_| 0).collect::\u003cVec\u003c_\u003e\u003e(); // exclude level 0\r\n        let mut real_level_size = Vec::with_capacity(self.options.max_levels);\r\n        let mut base_level = self.options.max_levels;\r\n        for i in 0..self.options.max_levels {\r\n            real_level_size.push(\r\n                snapshot.levels[i]\r\n                    .1\r\n                    .iter()\r\n                    .map(|x| snapshot.sstables.get(x).unwrap().table_size())\r\n                    .sum::\u003cu64\u003e() as usize,\r\n            );\r\n        }\r\n        let base_level_size_bytes = self.options.base_level_size_mb * 1024 * 1024;\r\n\r\n        // select base level and compute target level size\r\n        target_level_size[self.options.max_levels - 1] =\r\n            real_level_size[self.options.max_levels - 1].max(base_level_size_bytes);\r\n        for i in (0..(self.options.max_levels - 1)).rev() {\r\n            let next_level_size = target_level_size[i + 1];\r\n            let this_level_size = next_level_size / self.options.level_size_multiplier;\r\n            if next_level_size \u003e base_level_size_bytes {\r\n                target_level_size[i] = this_level_size;\r\n            }\r\n            if target_level_size[i] \u003e 0 {\r\n                base_level = i + 1;\r\n            }\r\n        }\r\n\r\n        // Flush L0 SST is the top priority\r\n        if snapshot.l0_sstables.len() \u003e= self.options.level0_file_num_compaction_trigger {\r\n            debug!(\"flush L0 SST to base level {}\", base_level);\r\n            return Some(LeveledCompactionTask {\r\n                upper_level: None,\r\n                upper_level_sst_ids: snapshot.l0_sstables.clone(),\r\n                lower_level: base_level,\r\n                lower_level_sst_ids: self.find_overlapping_ssts(\r\n                    snapshot,\r\n                    \u0026snapshot.l0_sstables,\r\n                    base_level,\r\n                ),\r\n                is_lower_level_bottom_level: base_level == self.options.max_levels,\r\n            });\r\n        }\r\n        //\r\n        //\r\n        let mut priorities = Vec::with_capacity(self.options.max_levels);\r\n        for level in 0..self.options.max_levels {\r\n            let prio = real_level_size[level] as f64 / target_level_size[level] as f64;\r\n            //\r\n            if prio \u003e 1.0 {\r\n                //,\r\n                priorities.push((prio, level + 1));\r\n            }\r\n        }\r\n        priorities.sort_by(|a, b| a.partial_cmp(b).unwrap().reverse());\r\n        let priority = priorities.first(); //\r\n        if let Some((_, level)) = priority {\r\n            println!(\r\n                \"target level sizes: {:?}, real level sizes: {:?}, base_level: {}\",\r\n                target_level_size\r\n                    .iter()\r\n                    .map(|x| format!(\"{:.3}MB\", *x as f64 / 1024.0 / 1024.0))\r\n                    .collect::\u003cVec\u003c_\u003e\u003e(),\r\n                real_level_size\r\n                    .iter()\r\n                    .map(|x| format!(\"{:.3}MB\", *x as f64 / 1024.0 / 1024.0))\r\n                    .collect::\u003cVec\u003c_\u003e\u003e(),\r\n                base_level,\r\n            );\r\n            //\r\n            let level = *level;\r\n            // sst\r\n            let selected_sst = snapshot.levels[level - 1].1.iter().min().copied().unwrap();\r\n            println!(\r\n                \"compaction triggered by priority: {level} out of {:?}, select {selected_sst} for compaction\",\r\n                priorities\r\n            );\r\n            return Some(LeveledCompactionTask {\r\n                upper_level: Some(level),\r\n                upper_level_sst_ids: vec![selected_sst],\r\n                lower_level: level + 1,\r\n                lower_level_sst_ids: self.find_overlapping_ssts(\r\n                    snapshot,\r\n                    \u0026[selected_sst],\r\n                    level + 1,\r\n                ),\r\n                is_lower_level_bottom_level: level + 1 == self.options.max_levels,\r\n            });\r\n        }\r\n        None\r\n    }\r\n\r\n    pub fn apply_compaction_result(\r\n        \u0026self,\r\n        snapshot: \u0026LsmStorageState,\r\n        task: \u0026LeveledCompactionTask,\r\n        output: \u0026[usize],\r\n        in_recovery: bool,\r\n    ) -\u003e (LsmStorageState, Vec\u003cusize\u003e) {\r\n        let mut snapshot = snapshot.clone();\r\n        let mut files_to_remove = Vec::new();\r\n        let mut upper_level_sst_ids_set = task\r\n            .upper_level_sst_ids\r\n            .iter()\r\n            .copied()\r\n            .collect::\u003cHashSet\u003c_\u003e\u003e();\r\n        let mut lower_level_sst_ids_set = task\r\n            .lower_level_sst_ids\r\n            .iter()\r\n            .copied()\r\n            .collect::\u003cHashSet\u003c_\u003e\u003e();\r\n        if let Some(upper_level) = task.upper_level {\r\n            let new_upper_level_ssts = snapshot.levels[upper_level - 1]\r\n                .1\r\n                .iter()\r\n                .filter_map(|x| {\r\n                    if upper_level_sst_ids_set.remove(x) {\r\n                        return None;\r\n                    }\r\n                    Some(*x)\r\n                })\r\n                .collect::\u003cVec\u003c_\u003e\u003e();\r\n            assert!(upper_level_sst_ids_set.is_empty());\r\n            snapshot.levels[upper_level - 1].1 = new_upper_level_ssts;\r\n        } else {\r\n            let new_l0_ssts = snapshot\r\n                .l0_sstables\r\n                .iter()\r\n                .filter_map(|x| {\r\n                    if upper_level_sst_ids_set.remove(x) {\r\n                        return None;\r\n                    }\r\n                    Some(*x)\r\n                })\r\n                .collect::\u003cVec\u003c_\u003e\u003e();\r\n            assert!(upper_level_sst_ids_set.is_empty());\r\n            snapshot.l0_sstables = new_l0_ssts;\r\n        }\r\n\r\n        files_to_remove.extend(\u0026task.upper_level_sst_ids);\r\n        files_to_remove.extend(\u0026task.lower_level_sst_ids);\r\n\r\n        let mut new_lower_level_ssts = snapshot.levels[task.lower_level - 1]\r\n            .1\r\n            .iter()\r\n            .filter_map(|x| {\r\n                if lower_level_sst_ids_set.remove(x) {\r\n                    return None;\r\n                }\r\n                Some(*x)\r\n            })\r\n            .collect::\u003cVec\u003c_\u003e\u003e();\r\n        assert!(lower_level_sst_ids_set.is_empty());\r\n        new_lower_level_ssts.extend(output);\r\n        if !in_recovery {\r\n            new_lower_level_ssts.sort_by(|x, y| {\r\n                snapshot\r\n                    .sstables\r\n                    .get(x)\r\n                    .unwrap()\r\n                    .first_key()\r\n                    .cmp(snapshot.sstables.get(y).unwrap().first_key())\r\n            });\r\n        }\r\n        snapshot.levels[task.lower_level - 1].1 = new_lower_level_ssts;\r\n        (snapshot, files_to_remove)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n\r\n    use tempfile::tempdir;\r\n\r\n    use crate::storage::engine::piggykv::{compact::CompactionOptions, debug::{check_compaction_ratio, compaction_bench}, lsm_storage::LsmStorageOptions, PiggyKV};\r\n\r\n    use super::LeveledCompactionOptions;\r\n\r\n\r\n    #[test]\r\n    fn test_integration() {\r\n        let dir = tempdir().unwrap();\r\n        let storage = PiggyKV::open(\r\n            \u0026dir,\r\n            LsmStorageOptions::compaction_test(CompactionOptions::Leveled(\r\n                LeveledCompactionOptions {\r\n                    level0_file_num_compaction_trigger: 2,\r\n                    level_size_multiplier: 2,\r\n                    base_level_size_mb: 1,\r\n                    max_levels: 4,\r\n                },\r\n            )),\r\n        )\r\n        .unwrap();\r\n\r\n        compaction_bench(storage.clone());\r\n        check_compaction_ratio(storage.clone());\r\n    }\r\n}\r\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4827858800541171712},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":4827858800541171712},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":5764607523034234880},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":5764607523034234880},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":5764607523034234880},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":6917529027641081856},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":10952754293765046272},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":16429131440647569408},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":15852670688344145923},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":14123288431433875459},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":14123288431433875459},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":14123288431433875459},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1152921504606846979},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":5476377146882523136},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":5476377146882523136},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":6485183463413514242},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":1008806316530991106},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":13763000461244235776},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":18158513697557839872},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":18158513697557839872},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1585267068834414594},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":1873497444986126338},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":9871890383196127241},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":13763000461244235776},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":14843864371813154816},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":4323455642275676160},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":4323455642275676160},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":12682136550675316736},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":1441151880758558722},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":1441151880758558722},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":1441151880758558722},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1441151880758558722},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1441151880758558722},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":1441151880758558722},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":1441151880758558722},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":2522015791327477764},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":5908722711110090752},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":5764607523034234880},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":5188146770730811392},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":7854277750134145024},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":6413125869375586304},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":6413125869375586304},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":6413125869375586304},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":6413125869375586304},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":6413125869375586304},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":6413125869375586304},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null}],"covered":97,"coverable":97},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","compact.rs"],"content":"mod leveled;\r\nuse std::collections::HashSet;\r\nuse std::sync::Arc;\r\nuse std::time::Duration;\r\n\r\nuse crate::errors::Result;\r\npub use leveled::{LeveledCompactionController, LeveledCompactionOptions, LeveledCompactionTask};\r\nuse serde::{Deserialize, Serialize};\r\nuse tracing::debug;\r\n\r\nuse super::iterators::concat_iterator::SstConcatIterator;\r\nuse super::iterators::merge_iterator::MergeIterator;\r\nuse super::iterators::two_merge_iterator::TwoMergeIterator;\r\nuse super::iterators::StorageIterator;\r\nuse super::key::KeySlice;\r\nuse super::lsm_storage::{LsmStorageInner, LsmStorageState};\r\nuse super::manifest::ManifestRecord;\r\nuse super::table::{SsTable, SsTableBuilder, SsTableIterator};\r\n\r\n#[derive(Debug, Serialize, Deserialize)]\r\npub enum CompactionTask {\r\n    Leveled(LeveledCompactionTask),\r\n    ForceFullCompaction {\r\n        l0_sstables: Vec\u003cusize\u003e,\r\n        l1_sstables: Vec\u003cusize\u003e,\r\n    },\r\n}\r\n\r\nimpl CompactionTask {\r\n    fn compact_to_bottom_level(\u0026self) -\u003e bool {\r\n        match self {\r\n            CompactionTask::ForceFullCompaction { .. } =\u003e true,\r\n            CompactionTask::Leveled(task) =\u003e task.is_lower_level_bottom_level,\r\n        }\r\n    }\r\n}\r\n\r\npub(crate) enum CompactionController {\r\n    Leveled(LeveledCompactionController),\r\n    NoCompaction,\r\n}\r\n\r\nimpl CompactionController {\r\n    pub fn generate_compaction_task(\u0026self, snapshot: \u0026LsmStorageState) -\u003e Option\u003cCompactionTask\u003e {\r\n        match self {\r\n            CompactionController::Leveled(ctrl) =\u003e ctrl\r\n                .generate_compaction_task(snapshot)\r\n                .map(CompactionTask::Leveled),\r\n            CompactionController::NoCompaction =\u003e unreachable!(),\r\n        }\r\n    }\r\n\r\n    pub fn apply_compaction_result(\r\n        \u0026self,\r\n        snapshot: \u0026LsmStorageState,\r\n        task: \u0026CompactionTask,\r\n        output: \u0026[usize],\r\n        in_recovery: bool,\r\n    ) -\u003e (LsmStorageState, Vec\u003cusize\u003e) {\r\n        match (self, task) {\r\n            (CompactionController::Leveled(ctrl), CompactionTask::Leveled(task)) =\u003e {\r\n                ctrl.apply_compaction_result(snapshot, task, output, in_recovery)\r\n            }\r\n            _ =\u003e unreachable!(),\r\n        }\r\n    }\r\n}\r\n\r\nimpl CompactionController {\r\n    pub fn flush_to_l0(\u0026self) -\u003e bool {\r\n        matches!(self, Self::Leveled(_) | Self::NoCompaction)\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone)]\r\npub enum CompactionOptions {\r\n    /// Leveled compaction with partial compaction + dynamic level support (= RocksDB's Leveled\r\n    /// Compaction)\r\n    Leveled(LeveledCompactionOptions),\r\n    /// In no compaction mode (week 1), always flush to L0\r\n    NoCompaction,\r\n}\r\n\r\nimpl LsmStorageInner {\r\n    fn compact_generate_sst_from_iter(\r\n        \u0026self,\r\n        mut iter: impl for\u003c'a\u003e StorageIterator\u003cKeyType\u003c'a\u003e = KeySlice\u003c'a\u003e\u003e,\r\n        compact_to_bottom_level: bool,\r\n    ) -\u003e Result\u003cVec\u003cArc\u003cSsTable\u003e\u003e\u003e {\r\n        let mut builder = None;\r\n        let mut new_sst = Vec::new();\r\n        let mut last_key = Vec::\u003cu8\u003e::new();\r\n        let watermark = self.mvcc().watermark();\r\n        let mut first_key_below_watermark = false;\r\n\r\n        while iter.is_valid() {\r\n            if builder.is_none() {\r\n                builder = Some(SsTableBuilder::new(self.options.block_size));\r\n            }\r\n            let same_as_last_key = iter.key().key_ref() == last_key;\r\n            if !same_as_last_key {\r\n                first_key_below_watermark = true;\r\n            }\r\n\r\n            if compact_to_bottom_level\r\n                \u0026\u0026 !same_as_last_key\r\n                \u0026\u0026 iter.key().ts() \u003c= watermark\r\n                \u0026\u0026 iter.value().is_empty()\r\n            {\r\n                last_key.clear();\r\n                last_key.extend(iter.key().key_ref());\r\n                iter._next()?;\r\n                first_key_below_watermark = false;\r\n                continue;\r\n            }\r\n\r\n            if same_as_last_key \u0026\u0026 iter.key().ts() \u003c= watermark {\r\n                if !first_key_below_watermark {\r\n                    iter._next()?;\r\n                    continue;\r\n                }\r\n                first_key_below_watermark = false;\r\n            }\r\n\r\n            let builder_inner = builder.as_mut().unwrap();\r\n            if builder_inner.estimated_size() \u003e= self.options.target_sst_size {\r\n                let sst_id = self.next_sst_id();\r\n                let old_builder = builder.take().unwrap();\r\n                let sst = Arc::new(old_builder.build(\r\n                    sst_id,\r\n                    Some(self.block_cache.clone()),\r\n                    self.options.bloom_false_positive_rate,\r\n                    self.path_of_sst(sst_id),\r\n                )?);\r\n                new_sst.push(sst);\r\n                builder = Some(SsTableBuilder::new(self.options.block_size));\r\n            }\r\n            let builder_inner = builder.as_mut().unwrap();\r\n            builder_inner.add(iter.key(), iter.value());\r\n\r\n            if !same_as_last_key {\r\n                last_key.clear();\r\n                last_key.extend(iter.key().key_ref());\r\n            }\r\n\r\n            iter._next()?;\r\n        }\r\n        if let Some(builder) = builder {\r\n            let sst_id = self.next_sst_id(); // lock dropped here\r\n            let sst = Arc::new(builder.build(\r\n                sst_id,\r\n                Some(self.block_cache.clone()),\r\n                self.options.bloom_false_positive_rate,\r\n                self.path_of_sst(sst_id),\r\n            )?);\r\n            new_sst.push(sst);\r\n        }\r\n        Ok(new_sst)\r\n    }\r\n\r\n    fn compact(\u0026self, task: \u0026CompactionTask) -\u003e Result\u003cVec\u003cArc\u003cSsTable\u003e\u003e\u003e {\r\n        let snapshot = {\r\n            let state = self.state.read();\r\n            state.clone()\r\n        };\r\n        match task {\r\n            CompactionTask::ForceFullCompaction {\r\n                l0_sstables,\r\n                l1_sstables,\r\n            } =\u003e {\r\n                let mut l0_iters = Vec::with_capacity(l0_sstables.len());\r\n                for id in l0_sstables.iter() {\r\n                    l0_iters.push(Box::new(SsTableIterator::create_and_seek_to_first(\r\n                        snapshot.sstables.get(id).unwrap().clone(),\r\n                    )?));\r\n                }\r\n                let mut l1_iters = Vec::with_capacity(l1_sstables.len());\r\n                for id in l1_sstables.iter() {\r\n                    l1_iters.push(snapshot.sstables.get(id).unwrap().clone());\r\n                }\r\n                let iter = TwoMergeIterator::create(\r\n                    MergeIterator::create(l0_iters),\r\n                    SstConcatIterator::create_and_seek_to_first(l1_iters)?,\r\n                )?;\r\n                self.compact_generate_sst_from_iter(iter, task.compact_to_bottom_level())\r\n            }\r\n            CompactionTask::Leveled(LeveledCompactionTask {\r\n                upper_level,\r\n                upper_level_sst_ids,\r\n                lower_level: _,\r\n                lower_level_sst_ids,\r\n                ..\r\n            }) =\u003e match upper_level {\r\n                Some(_) =\u003e {\r\n                    let mut upper_ssts = Vec::with_capacity(upper_level_sst_ids.len());\r\n                    for id in upper_level_sst_ids.iter() {\r\n                        upper_ssts.push(snapshot.sstables.get(id).unwrap().clone());\r\n                    }\r\n                    let upper_iter = SstConcatIterator::create_and_seek_to_first(upper_ssts)?;\r\n                    let mut lower_ssts = Vec::with_capacity(lower_level_sst_ids.len());\r\n                    for id in lower_level_sst_ids.iter() {\r\n                        lower_ssts.push(snapshot.sstables.get(id).unwrap().clone());\r\n                    }\r\n                    let lower_iter = SstConcatIterator::create_and_seek_to_first(lower_ssts)?;\r\n                    self.compact_generate_sst_from_iter(\r\n                        TwoMergeIterator::create(upper_iter, lower_iter)?,\r\n                        task.compact_to_bottom_level(),\r\n                    )\r\n                }\r\n                None =\u003e {\r\n                    let mut upper_iters = Vec::with_capacity(upper_level_sst_ids.len());\r\n                    for id in upper_level_sst_ids.iter() {\r\n                        upper_iters.push(Box::new(SsTableIterator::create_and_seek_to_first(\r\n                            snapshot.sstables.get(id).unwrap().clone(),\r\n                        )?));\r\n                    }\r\n                    let upper_iter = MergeIterator::create(upper_iters);\r\n                    let mut lower_ssts = Vec::with_capacity(lower_level_sst_ids.len());\r\n                    for id in lower_level_sst_ids.iter() {\r\n                        lower_ssts.push(snapshot.sstables.get(id).unwrap().clone());\r\n                    }\r\n                    let lower_iter = SstConcatIterator::create_and_seek_to_first(lower_ssts)?;\r\n                    self.compact_generate_sst_from_iter(\r\n                        TwoMergeIterator::create(upper_iter, lower_iter)?,\r\n                        task.compact_to_bottom_level(),\r\n                    )\r\n                }\r\n            },\r\n        }\r\n    }\r\n\r\n    pub fn force_full_compaction(\u0026self) -\u003e Result\u003c()\u003e {\r\n        let CompactionOptions::NoCompaction = self.options.compaction_options else {\r\n            panic!(\"full compaction can only be called with compaction is not enabled\")\r\n        };\r\n\r\n        let snapshot = {\r\n            let state = self.state.read();\r\n            state.clone()\r\n        };\r\n\r\n        let l0_sstables = snapshot.l0_sstables.clone();\r\n        let l1_sstables = snapshot.levels[0].1.clone();\r\n        let compaction_task = CompactionTask::ForceFullCompaction {\r\n            l0_sstables: l0_sstables.clone(),\r\n            l1_sstables: l1_sstables.clone(),\r\n        };\r\n\r\n        println!(\"force full compaction: {:?}\", compaction_task);\r\n\r\n        let sstables = self.compact(\u0026compaction_task)?;\r\n        let mut ids = Vec::with_capacity(sstables.len());\r\n\r\n        {\r\n            let state_lock = self.state_lock.lock();\r\n            let mut state = self.state.read().as_ref().clone();\r\n            for sst in l0_sstables.iter().chain(l1_sstables.iter()) {\r\n                let result = state.sstables.remove(sst);\r\n                assert!(result.is_some());\r\n            }\r\n            for new_sst in sstables {\r\n                ids.push(new_sst.sst_id());\r\n                let result = state.sstables.insert(new_sst.sst_id(), new_sst);\r\n                assert!(result.is_none());\r\n            }\r\n            assert_eq!(l1_sstables, state.levels[0].1);\r\n            state.levels[0].1 = ids.clone();\r\n            let mut l0_sstables_map = l0_sstables.iter().copied().collect::\u003cHashSet\u003c_\u003e\u003e();\r\n            state.l0_sstables = state\r\n                .l0_sstables\r\n                .iter()\r\n                .filter(|x| !l0_sstables_map.remove(x))\r\n                .copied()\r\n                .collect::\u003cVec\u003c_\u003e\u003e();\r\n            assert!(l0_sstables_map.is_empty());\r\n            *self.state.write() = Arc::new(state);\r\n            self.sync_dir()?;\r\n            self.manifest.as_ref().unwrap().add_record(\r\n                \u0026state_lock,\r\n                ManifestRecord::Compaction(compaction_task, ids.clone()),\r\n            )?;\r\n        }\r\n        for sst in l0_sstables.iter().chain(l1_sstables.iter()) {\r\n            std::fs::remove_file(self.path_of_sst(*sst))?;\r\n        }\r\n\r\n        println!(\"force full compaction done, new SSTs: {:?}\", ids);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn trigger_compaction(\u0026self) -\u003e Result\u003c()\u003e {\r\n        let snapshot = {\r\n            let state = self.state.read();\r\n            state.clone()\r\n        };\r\n        let task = self\r\n            .compaction_controller\r\n            .generate_compaction_task(\u0026snapshot);\r\n        let Some(task) = task else {\r\n            return Ok(());\r\n        };\r\n        // self.dump_structure();\r\n        debug!(\"running compaction task: {:?}\", task);\r\n        let sstables = self.compact(\u0026task)?;\r\n        let output = sstables.iter().map(|x| x.sst_id()).collect::\u003cVec\u003c_\u003e\u003e();\r\n        let ssts_to_remove = {\r\n            let state_lock = self.state_lock.lock();\r\n            let mut snapshot = self.state.read().as_ref().clone();\r\n            let mut new_sst_ids = Vec::new();\r\n            for file_to_add in sstables {\r\n                new_sst_ids.push(file_to_add.sst_id());\r\n                let result = snapshot.sstables.insert(file_to_add.sst_id(), file_to_add);\r\n                assert!(result.is_none());\r\n            }\r\n            let (mut snapshot, files_to_remove) = self\r\n                .compaction_controller\r\n                .apply_compaction_result(\u0026snapshot, \u0026task, \u0026output, false);\r\n            let mut ssts_to_remove = Vec::with_capacity(files_to_remove.len());\r\n            for file_to_remove in \u0026files_to_remove {\r\n                let result = snapshot.sstables.remove(file_to_remove);\r\n                assert!(result.is_some(), \"cannot remove {}.sst\", file_to_remove);\r\n                ssts_to_remove.push(result.unwrap());\r\n            }\r\n            let mut state = self.state.write();\r\n            *state = Arc::new(snapshot);\r\n            drop(state);\r\n            self.sync_dir()?;\r\n            self.manifest()\r\n                .add_record(\u0026state_lock, ManifestRecord::Compaction(task, new_sst_ids))?;\r\n            ssts_to_remove\r\n        };\r\n        debug!(\r\n            \"compaction finished: {} files removed, {} files added, output={:?}\",\r\n            ssts_to_remove.len(),\r\n            output.len(),\r\n            output\r\n        );\r\n        for sst in ssts_to_remove {\r\n            std::fs::remove_file(self.path_of_sst(sst.sst_id()))?;\r\n        }\r\n        self.sync_dir()?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub(crate) fn spawn_compaction_thread(\r\n        self: \u0026Arc\u003cSelf\u003e,\r\n        rx: crossbeam_channel::Receiver\u003c()\u003e,\r\n    ) -\u003e Result\u003cOption\u003cstd::thread::JoinHandle\u003c()\u003e\u003e\u003e {\r\n        if let CompactionOptions::Leveled(_) = self.options.compaction_options {\r\n            let this = self.clone();\r\n            let handle = std::thread::spawn(move || {\r\n                let ticker = crossbeam_channel::tick(Duration::from_millis(50));\r\n                loop {\r\n                    crossbeam_channel::select! {\r\n                        recv(ticker) -\u003e _ =\u003e if let Err(e) = this.trigger_compaction() {\r\n                            eprintln!(\"compaction failed: {}\", e);\r\n                        },\r\n                        recv(rx) -\u003e _ =\u003e return\r\n                    }\r\n                }\r\n            });\r\n            return Ok(Some(handle));\r\n        }\r\n        Ok(None)\r\n    }\r\n\r\n    fn trigger_flush(\u0026self) -\u003e Result\u003c()\u003e {\r\n        let res = {\r\n            let state = self.state.read();\r\n            state.imm_memtables.len() \u003e= self.options.num_memtable_limit\r\n        };\r\n        if res {\r\n            self.force_flush_next_imm_memtable()?;\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub(crate) fn spawn_flush_thread(\r\n        self: \u0026Arc\u003cSelf\u003e,\r\n        rx: crossbeam_channel::Receiver\u003c()\u003e,\r\n    ) -\u003e Result\u003cOption\u003cstd::thread::JoinHandle\u003c()\u003e\u003e\u003e {\r\n        let this = self.clone();\r\n        let handle = std::thread::spawn(move || {\r\n            let ticker = crossbeam_channel::tick(Duration::from_millis(50));\r\n            loop {\r\n                crossbeam_channel::select! {\r\n                    recv(ticker) -\u003e _ =\u003e if let Err(e) = this.trigger_flush() {\r\n                        eprintln!(\"flush failed: {}\", e);\r\n                    },\r\n                    recv(rx) -\u003e _ =\u003e return\r\n                }\r\n            }\r\n        });\r\n        Ok(Some(handle))\r\n    }\r\n}\r\n\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use std::{ops::Bound, path::Path, sync::Arc};\r\n\r\n    use bytes::Bytes;\r\n    use tempfile::tempdir;\r\n    use crate::storage::engine::piggykv::{debug::{check_iter_result_by_key, check_lsm_iter_result_by_key, construct_merge_iterator_over_storage, sync}, iterators::{concat_iterator::SstConcatIterator, StorageIterator}, key::{KeySlice, TS_ENABLED}, lsm_storage::{LsmStorageInner, LsmStorageOptions}, table::{bloom::Bloom, FileObject, SsTable, SsTableBuilder}};\r\n    #[test]\r\n    fn test_task1_full_compaction() {\r\n        // We do not use LSM iterator in this test because it's implemented as part of task 3\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(\u0026dir, LsmStorageOptions::default()).unwrap());\r\n        #[allow(clippy::let_unit_value)]\r\n        let _txn = storage.new_txn().unwrap();\r\n        storage.put(b\"0\", b\"v1\").unwrap();\r\n        sync(\u0026storage);\r\n        storage.put(b\"0\", b\"v2\").unwrap();\r\n        storage.put(b\"1\", b\"v2\").unwrap();\r\n        storage.put(b\"2\", b\"v2\").unwrap();\r\n        sync(\u0026storage);\r\n        storage.delete(b\"0\").unwrap();\r\n        storage.delete(b\"2\").unwrap();\r\n        sync(\u0026storage);\r\n        assert_eq!(storage.state.read().l0_sstables.len(), 3);\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.state.read());\r\n        if TS_ENABLED {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v1\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v2\")),\r\n                ],\r\n            );\r\n        } else {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"\")),\r\n                ],\r\n            );\r\n        }\r\n        storage.force_full_compaction().unwrap();\r\n        assert!(storage.state.read().l0_sstables.is_empty());\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.state.read());\r\n        if TS_ENABLED {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v1\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v2\")),\r\n                ],\r\n            );\r\n        } else {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![(Bytes::from_static(b\"1\"), Bytes::from_static(b\"v2\"))],\r\n            );\r\n        }\r\n        storage.put(b\"0\", b\"v3\").unwrap();\r\n        storage.put(b\"2\", b\"v3\").unwrap();\r\n        sync(\u0026storage);\r\n        storage.delete(b\"1\").unwrap();\r\n        sync(\u0026storage);\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.state.read());\r\n        if TS_ENABLED {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v3\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v1\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v3\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v2\")),\r\n                ],\r\n            );\r\n        } else {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v3\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v3\")),\r\n                ],\r\n            );\r\n        }\r\n        storage.force_full_compaction().unwrap();\r\n        assert!(storage.state.read().l0_sstables.is_empty());\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.state.read());\r\n        if TS_ENABLED {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v3\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v1\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"v2\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v3\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v2\")),\r\n                ],\r\n            );\r\n        } else {\r\n            check_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"0\"), Bytes::from_static(b\"v3\")),\r\n                    (Bytes::from_static(b\"2\"), Bytes::from_static(b\"v3\")),\r\n                ],\r\n            );\r\n        }\r\n    }\r\n    \r\n    fn generate_concat_sst(\r\n        start_key: usize,\r\n        end_key: usize,\r\n        dir: impl AsRef\u003cPath\u003e,\r\n        id: usize,\r\n    ) -\u003e SsTable {\r\n        let mut builder = SsTableBuilder::new(128);\r\n        for idx in start_key..end_key {\r\n            let key = format!(\"{:05}\", idx);\r\n            builder.add(\r\n                KeySlice::for_testing_from_slice_no_ts(key.as_bytes()),\r\n                b\"test\",\r\n            );\r\n        }\r\n        let path = dir.as_ref().join(format!(\"{id}.sst\"));\r\n        builder.build_for_test(path).unwrap()\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task2_concat_iterator() {\r\n        let dir = tempdir().unwrap();\r\n        let mut sstables = Vec::new();\r\n        for i in 1..=10 {\r\n            sstables.push(Arc::new(generate_concat_sst(\r\n                i * 10,\r\n                (i + 1) * 10,\r\n                dir.path(),\r\n                i,\r\n            )));\r\n        }\r\n        for key in 0..120 {\r\n            let iter = SstConcatIterator::create_and_seek_to_key(\r\n                sstables.clone(),\r\n                KeySlice::for_testing_from_slice_no_ts(format!(\"{:05}\", key).as_bytes()),\r\n            )\r\n            .unwrap();\r\n            if key \u003c 10 {\r\n                assert!(iter.is_valid());\r\n                assert_eq!(iter.key().for_testing_key_ref(), b\"00010\");\r\n            } else if key \u003e= 110 {\r\n                assert!(!iter.is_valid());\r\n            } else {\r\n                assert!(iter.is_valid());\r\n                assert_eq!(\r\n                    iter.key().for_testing_key_ref(),\r\n                    format!(\"{:05}\", key).as_bytes()\r\n                );\r\n            }\r\n        }\r\n        let iter = SstConcatIterator::create_and_seek_to_first(sstables.clone()).unwrap();\r\n        assert!(iter.is_valid());\r\n        assert_eq!(iter.key().for_testing_key_ref(), b\"00010\");\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task3_integration() {\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(\u0026dir, LsmStorageOptions::default()).unwrap());\r\n        storage.put(b\"0\", b\"2333333\").unwrap();\r\n        storage.put(b\"00\", b\"2333333\").unwrap();\r\n        storage.put(b\"4\", b\"23\").unwrap();\r\n        sync(\u0026storage);\r\n    \r\n        storage.delete(b\"4\").unwrap();\r\n        sync(\u0026storage);\r\n    \r\n        storage.force_full_compaction().unwrap();\r\n        assert!(storage.state.read().l0_sstables.is_empty());\r\n        assert!(!storage.state.read().levels[0].1.is_empty());\r\n    \r\n        storage.put(b\"1\", b\"233\").unwrap();\r\n        storage.put(b\"2\", b\"2333\").unwrap();\r\n        sync(\u0026storage);\r\n    \r\n        storage.put(b\"00\", b\"2333\").unwrap();\r\n        storage.put(b\"3\", b\"23333\").unwrap();\r\n        storage.delete(b\"1\").unwrap();\r\n        sync(\u0026storage);\r\n        storage.force_full_compaction().unwrap();\r\n    \r\n        assert!(storage.state.read().l0_sstables.is_empty());\r\n        assert!(!storage.state.read().levels[0].1.is_empty());\r\n    \r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut storage.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"0\"), Bytes::from(\"2333333\")),\r\n                (Bytes::from(\"00\"), Bytes::from(\"2333\")),\r\n                (Bytes::from(\"2\"), Bytes::from(\"2333\")),\r\n                (Bytes::from(\"3\"), Bytes::from(\"23333\")),\r\n            ],\r\n        );\r\n    \r\n        assert_eq!(\r\n            storage.get(b\"0\").unwrap(),\r\n            Some(Bytes::from_static(b\"2333333\"))\r\n        );\r\n        assert_eq!(\r\n            storage.get(b\"00\").unwrap(),\r\n            Some(Bytes::from_static(b\"2333\"))\r\n        );\r\n        assert_eq!(\r\n            storage.get(b\"2\").unwrap(),\r\n            Some(Bytes::from_static(b\"2333\"))\r\n        );\r\n        assert_eq!(\r\n            storage.get(b\"3\").unwrap(),\r\n            Some(Bytes::from_static(b\"23333\"))\r\n        );\r\n        assert_eq!(storage.get(b\"4\").unwrap(), None);\r\n        assert_eq!(storage.get(b\"--\").unwrap(), None);\r\n        assert_eq!(storage.get(b\"555\").unwrap(), None);\r\n    }\r\n    \r\n}\r\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":2089670227099910347},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2089670227099910347},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":2089670227099910347},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2089670227099910347},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":2089670227099910347},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":2089670227099910347},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":2089670227099910143},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":14483576401623515135},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":13258597302978739768},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":432345564227568607},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":12826251738751172608},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":1224979098644775368},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":1224979098644775368},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":2449958197289550736},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1224979098644775368},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":1224979098644775368},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":1224979098644775368},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1224979098644775368},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":4179340454199820288},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":268,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":1801439850948198400},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":15564440312192434176},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":12682136550675316736},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":2666130979403333632},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":6773413839565225984},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":17365880163140632576},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":17365880163140632576},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":13042424520864956416},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":864691128455135233},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":3026418949592973311},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":7061644215716937729},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":7061644215716937729},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":10088063165309911044},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null}],"covered":191,"coverable":200},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","debug.rs"],"content":"\r\nuse std::{collections::BTreeMap, ops::Bound, os::windows::fs::MetadataExt, path::Path, sync::Arc, time::Duration};\r\n\r\nuse bytes::Bytes;\r\nuse crate::{errors::{DatabaseError, Result}, storage::engine::piggykv::key::TS_ENABLED};\r\nuse super::{compact::{CompactionOptions, LeveledCompactionOptions}, iterators::{merge_iterator::MergeIterator, StorageIterator}, key::KeySlice, lsm_storage::{BlockCache, LsmStorageInner, LsmStorageState}, table::{SsTable, SsTableBuilder, SsTableIterator}, PiggyKV};\r\n\r\nimpl LsmStorageInner {\r\n    pub fn dump_structure(\u0026self) {\r\n        let snapshot = self.state.read();\r\n        if !snapshot.l0_sstables.is_empty() {\r\n            println!(\r\n                \"L0 ({}): {:?}\",\r\n                snapshot.l0_sstables.len(),\r\n                snapshot.l0_sstables,\r\n            );\r\n        }\r\n        for (level, files) in \u0026snapshot.levels {\r\n            println!(\"L{level} ({}): {:?}\", files.len(), files);\r\n        }\r\n    }\r\n}\r\n\r\nimpl PiggyKV {\r\n    pub fn dump_structure(\u0026self) {\r\n        self.inner.dump_structure()\r\n    }\r\n}\r\n\r\n#[derive(Clone)]\r\npub struct MockIterator {\r\n    pub data: Vec\u003c(Bytes, Bytes)\u003e,\r\n    pub error_when: Option\u003cusize\u003e,\r\n    pub index: usize,\r\n}\r\n\r\nimpl MockIterator {\r\n    pub fn new(data: Vec\u003c(Bytes, Bytes)\u003e) -\u003e Self {\r\n        Self {\r\n            data,\r\n            index: 0,\r\n            error_when: None,\r\n        }\r\n    }\r\n\r\n    pub fn new_with_error(data: Vec\u003c(Bytes, Bytes)\u003e, error_when: usize) -\u003e Self {\r\n        Self {\r\n            data,\r\n            index: 0,\r\n            error_when: Some(error_when),\r\n        }\r\n    }\r\n}\r\n\r\nimpl StorageIterator for MockIterator {\r\n    type KeyType\u003c'a\u003e = KeySlice\u003c'a\u003e;\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        if self.index \u003c self.data.len() {\r\n            self.index += 1;\r\n        }\r\n        if let Some(error_when) = self.error_when {\r\n            if self.index == error_when {\r\n                return Err(DatabaseError::InternalError(\"fake error!\".to_string()));\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn key(\u0026self) -\u003e KeySlice {\r\n        if let Some(error_when) = self.error_when {\r\n            if self.index \u003e= error_when {\r\n                panic!(\"invalid access after next returns an error!\");\r\n            }\r\n        }\r\n        KeySlice::for_testing_from_slice_no_ts(self.data[self.index].0.as_ref())\r\n    }\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        if let Some(error_when) = self.error_when {\r\n            if self.index \u003e= error_when {\r\n                panic!(\"invalid access after next returns an error!\");\r\n            }\r\n        }\r\n        self.data[self.index].1.as_ref()\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        if let Some(error_when) = self.error_when {\r\n            if self.index \u003e= error_when {\r\n                panic!(\"invalid access after next returns an error!\");\r\n            }\r\n        }\r\n        self.index \u003c self.data.len()\r\n    }\r\n}\r\n\r\npub fn as_bytes(x: \u0026[u8]) -\u003e Bytes {\r\n    Bytes::copy_from_slice(x)\r\n}\r\n\r\npub fn check_iter_result_by_key\u003cI\u003e(iter: \u0026mut I, expected: Vec\u003c(Bytes, Bytes)\u003e)\r\nwhere\r\n    I: for\u003c'a\u003e StorageIterator\u003cKeyType\u003c'a\u003e = KeySlice\u003c'a\u003e\u003e,\r\n{\r\n    for (k, v) in expected {\r\n        assert!(iter.is_valid());\r\n        assert_eq!(\r\n            k,\r\n            iter.key().for_testing_key_ref(),\r\n            \"expected key: {:?}, actual key: {:?}\",\r\n            k,\r\n            as_bytes(iter.key().for_testing_key_ref()),\r\n        );\r\n        assert_eq!(\r\n            v,\r\n            iter.value(),\r\n            \"expected value: {:?}, actual value: {:?}\",\r\n            v,\r\n            as_bytes(iter.value()),\r\n        );\r\n        iter._next().unwrap();\r\n    }\r\n    assert!(!iter.is_valid());\r\n}\r\n\r\n#[allow(dead_code)]\r\npub fn check_iter_result_by_key_and_ts\u003cI\u003e(iter: \u0026mut I, expected: Vec\u003c((Bytes, u64), Bytes)\u003e)\r\nwhere\r\n    I: for\u003c'a\u003e StorageIterator\u003cKeyType\u003c'a\u003e = KeySlice\u003c'a\u003e\u003e,\r\n{\r\n    for ((k, ts), v) in expected {\r\n        assert!(iter.is_valid());\r\n        assert_eq!(\r\n            (\u0026k[..], ts),\r\n            (\r\n                iter.key().for_testing_key_ref(),\r\n                iter.key().for_testing_ts()\r\n            ),\r\n            \"expected key: {:?}@{}, actual key: {:?}@{}\",\r\n            k,\r\n            ts,\r\n            as_bytes(iter.key().for_testing_key_ref()),\r\n            iter.key().for_testing_ts(),\r\n        );\r\n        assert_eq!(\r\n            v,\r\n            iter.value(),\r\n            \"expected value: {:?}, actual value: {:?}\",\r\n            v,\r\n            as_bytes(iter.value()),\r\n        );\r\n        iter._next().unwrap();\r\n    }\r\n    assert!(!iter.is_valid());\r\n}\r\n\r\npub fn check_lsm_iter_result_by_key\u003cI\u003e(iter: \u0026mut I, expected: Vec\u003c(Bytes, Bytes)\u003e)\r\nwhere\r\n    I: for\u003c'a\u003e StorageIterator\u003cKeyType\u003c'a\u003e = \u0026'a [u8]\u003e,\r\n{\r\n    for (k, v) in expected {\r\n        assert!(iter.is_valid());\r\n        assert_eq!(\r\n            k,\r\n            iter.key(),\r\n            \"expected key: {:?}, actual key: {:?}\",\r\n            k,\r\n            as_bytes(iter.key()),\r\n        );\r\n        assert_eq!(\r\n            v,\r\n            iter.value(),\r\n            \"expected value: {:?}, actual value: {:?}\",\r\n            v,\r\n            as_bytes(iter.value()),\r\n        );\r\n        iter._next().unwrap();\r\n    }\r\n    assert!(!iter.is_valid());\r\n}\r\n\r\npub fn expect_iter_error(mut iter: impl StorageIterator) {\r\n    loop {\r\n        match iter._next() {\r\n            Ok(_) if iter.is_valid() =\u003e continue,\r\n            Ok(_) =\u003e panic!(\"expect an error\"),\r\n            Err(_) =\u003e break,\r\n        }\r\n    }\r\n}\r\n\r\npub fn generate_sst(\r\n    id: usize,\r\n    path: impl AsRef\u003cPath\u003e,\r\n    data: Vec\u003c(Bytes, Bytes)\u003e,\r\n    block_cache: Option\u003cArc\u003cBlockCache\u003e\u003e,\r\n) -\u003e SsTable {\r\n    let mut builder = SsTableBuilder::new(128);\r\n    for (key, value) in data {\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(\u0026key[..]), \u0026value[..]);\r\n    }\r\n    builder.build(id, block_cache,0.01, path.as_ref()).unwrap()\r\n}\r\n\r\n#[allow(dead_code)]\r\npub fn generate_sst_with_ts(\r\n    id: usize,\r\n    path: impl AsRef\u003cPath\u003e,\r\n    data: Vec\u003c((Bytes, u64), Bytes)\u003e,\r\n    block_cache: Option\u003cArc\u003cBlockCache\u003e\u003e,\r\n) -\u003e SsTable {\r\n    let mut builder = SsTableBuilder::new(128);\r\n    for ((key, ts), value) in data {\r\n        builder.add(\r\n            KeySlice::for_testing_from_slice_with_ts(\u0026key[..], ts),\r\n            \u0026value[..],\r\n        );\r\n    }\r\n    builder.build(id, block_cache,0.01, path.as_ref()).unwrap()\r\n}\r\n\r\npub fn sync(storage: \u0026LsmStorageInner) {\r\n    storage\r\n        .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n        .unwrap();\r\n    storage.force_flush_next_imm_memtable().unwrap();\r\n}\r\n\r\npub fn compaction_bench(storage: Arc\u003cPiggyKV\u003e) {\r\n    let mut key_map = BTreeMap::\u003cusize, usize\u003e::new();\r\n    let gen_key = |i| format!(\"{:010}\", i); // 10B\r\n    let gen_value = |i| format!(\"{:0110}\", i); // 110B\r\n    let mut max_key = 0;\r\n    let overlaps = if TS_ENABLED { 10000 } else { 20000 };\r\n    for iter in 0..10 {\r\n        let range_begin = iter * 5000;\r\n        for i in range_begin..(range_begin + overlaps) {\r\n            // 120B per key, 4MB data populated\r\n            let key: String = gen_key(i);\r\n            let version = key_map.get(\u0026i).copied().unwrap_or_default() + 1;\r\n            let value = gen_value(version);\r\n            key_map.insert(i, version);\r\n            storage.put(key.as_bytes(), value.as_bytes()).unwrap();\r\n            max_key = max_key.max(i);\r\n        }\r\n    }\r\n\r\n    std::thread::sleep(Duration::from_secs(1)); // wait until all memtables flush\r\n    while {\r\n        let snapshot = storage.inner.state.read();\r\n        !snapshot.imm_memtables.is_empty()\r\n    } {\r\n        storage.inner.force_flush_next_imm_memtable().unwrap();\r\n    }\r\n\r\n    let mut prev_snapshot = storage.inner.state.read().clone();\r\n    while {\r\n        std::thread::sleep(Duration::from_secs(1));\r\n        let snapshot = storage.inner.state.read().clone();\r\n        let to_cont = prev_snapshot.levels != snapshot.levels\r\n            || prev_snapshot.l0_sstables != snapshot.l0_sstables;\r\n        prev_snapshot = snapshot;\r\n        to_cont\r\n    } {\r\n        println!(\"waiting for compaction to converge\");\r\n    }\r\n\r\n    let mut expected_key_value_pairs = Vec::new();\r\n    for i in 0..(max_key + 40000) {\r\n        let key = gen_key(i);\r\n        let value = storage.get(key.as_bytes()).unwrap();\r\n        if let Some(val) = key_map.get(\u0026i) {\r\n            let expected_value = gen_value(*val);\r\n            assert_eq!(value, Some(Bytes::from(expected_value.clone())));\r\n            expected_key_value_pairs.push((Bytes::from(key), Bytes::from(expected_value)));\r\n        } else {\r\n            assert!(value.is_none());\r\n        }\r\n    }\r\n\r\n    check_lsm_iter_result_by_key(\r\n        \u0026mut storage.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n        expected_key_value_pairs,\r\n    );\r\n\r\n    storage.dump_structure();\r\n\r\n    println!(\"This test case does not guarantee your compaction algorithm produces a LSM state as expected. It only does minimal checks on the size of the levels. Please use the compaction simulator to check if the compaction is correctly going on.\");\r\n}\r\n\r\npub fn check_compaction_ratio(storage: Arc\u003cPiggyKV\u003e) {\r\n    let state = storage.inner.state.read().clone();\r\n    let compaction_options = storage.inner.options.compaction_options.clone();\r\n    let mut level_size = Vec::new();\r\n    let l0_sst_num = state.l0_sstables.len();\r\n    for (_, files) in \u0026state.levels {\r\n        let size = match \u0026compaction_options {\r\n            CompactionOptions::Leveled(_) =\u003e files\r\n                .iter()\r\n                .map(|x| state.sstables.get(x).as_ref().unwrap().table_size())\r\n                .sum::\u003cu64\u003e(),\r\n            _ =\u003e unreachable!(),\r\n        };\r\n        level_size.push(size);\r\n    }\r\n    let extra_iterators = if TS_ENABLED {\r\n        1 /* txn local iterator for OCC */\r\n    } else {\r\n        0\r\n    };\r\n    let num_iters = storage\r\n        .scan(Bound::Unbounded, Bound::Unbounded)\r\n        .unwrap()\r\n        .num_active_iterators();\r\n    let num_memtables = storage.inner.state.read().imm_memtables.len() + 1;\r\n    match compaction_options {\r\n        CompactionOptions::NoCompaction =\u003e unreachable!(),\r\n        CompactionOptions::Leveled(LeveledCompactionOptions {\r\n            level_size_multiplier,\r\n            level0_file_num_compaction_trigger,\r\n            max_levels,\r\n            ..\r\n        }) =\u003e {\r\n            assert!(l0_sst_num \u003c level0_file_num_compaction_trigger);\r\n            assert!(level_size.len() \u003c= max_levels);\r\n            let last_level_size = *level_size.last().unwrap();\r\n            let mut multiplier = 1.0;\r\n            for idx in (1..level_size.len()).rev() {\r\n                multiplier *= level_size_multiplier as f64;\r\n                let this_size = level_size[idx - 1];\r\n                assert!(\r\n                    // do not add hard requirement on level size multiplier considering bloom filters...\r\n                    this_size as f64 / last_level_size as f64 \u003c= 1.0 / multiplier + 0.5,\r\n                    \"L{}/L_max, {}/{}\u003e\u003e1.0/{}\",\r\n                    state.levels[idx - 1].0,\r\n                    this_size,\r\n                    last_level_size,\r\n                    multiplier\r\n                );\r\n            }\r\n            assert!(\r\n                num_iters \u003c= l0_sst_num + num_memtables + max_levels + extra_iterators,\r\n                \"we found {num_iters} iterators in your implementation, (l0_sst_num={l0_sst_num}, num_memtables={num_memtables}, max_levels={max_levels}) did you use concat iterators?\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\npub fn dump_files_in_dir(path: impl AsRef\u003cPath\u003e) {\r\n    println!(\"--- DIR DUMP ---\");\r\n    for f in path.as_ref().read_dir().unwrap() {\r\n        let f = f.unwrap();\r\n        print!(\"{}\", f.path().display());\r\n        println!(\r\n            \", size={:.3}KB\",\r\n            f.metadata().unwrap().file_size() as f64 / 1024.0\r\n        );\r\n    }\r\n}\r\n\r\npub fn construct_merge_iterator_over_storage(\r\n    state: \u0026LsmStorageState,\r\n) -\u003e MergeIterator\u003cSsTableIterator\u003e {\r\n    let mut iters = Vec::new();\r\n    for t in \u0026state.l0_sstables {\r\n        iters.push(Box::new(\r\n            SsTableIterator::create_and_seek_to_first(state.sstables.get(t).cloned().unwrap())\r\n                .unwrap(),\r\n        ));\r\n    }\r\n    for (_, files) in \u0026state.levels {\r\n        for f in files {\r\n            iters.push(Box::new(\r\n                SsTableIterator::create_and_seek_to_first(state.sstables.get(f).cloned().unwrap())\r\n                    .unwrap(),\r\n            ));\r\n        }\r\n    }\r\n    MergeIterator::create(iters)\r\n}\r\n","traces":[{"line":9,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":10,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":11,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":12,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":6269010681299730432},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":12538021362599460864},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6269010681299730432},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6413125869375586304},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":8718968878589280255},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":8358680908399640578},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":17942340915444056064},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":18158513697557839872},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":17942340915444056064},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":14483576401623515136},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":7638104968020361001},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":2377900603251621673},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":2377900603251621673},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":2377900603251621673},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":2377900603251621673},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":2377900603251621673},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":2377900603251621673},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":18446744073709551401},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":18446744073709551401},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":2377900603251621888},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":2882303761517117655},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":13258597302978740224},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":8718968878589281017},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":144115188075856262},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":144115188075856262},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":72057594037928326},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":17221764975064776333},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":15564440312192434332},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":4539628424389460339},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":72057594037928092},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":72057594037928092},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":72057594037928092},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":72057594037928092},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":72057594037928092},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":648518346341351580},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":1008806316530991709},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":330,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":2377900603251621888},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":376,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null}],"covered":151,"coverable":184},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","iterators","concat_iterator.rs"],"content":"use std::sync::Arc;\r\nuse crate::errors::Result;\r\n\r\n\r\nuse crate::storage::engine::piggykv::{key::KeySlice, table::{SsTable, SsTableIterator}};\r\n\r\nuse super::StorageIterator;\r\n\r\n/// Concat multiple iterators ordered in key order and their key ranges do not overlap. We do not want to create the\r\n/// iterators when initializing this iterator to reduce the overhead of seeking.\r\npub struct SstConcatIterator {\r\n    current: Option\u003cSsTableIterator\u003e,\r\n    next_sst_idx: usize,\r\n    sstables: Vec\u003cArc\u003cSsTable\u003e\u003e,\r\n}\r\n\r\nimpl SstConcatIterator {\r\n    fn check_sst_valid(sstables: \u0026[Arc\u003cSsTable\u003e]) {\r\n        for sst in sstables {\r\n            assert!(sst.first_key() \u003c= sst.last_key());\r\n        }\r\n        if !sstables.is_empty() {\r\n            for i in 0..(sstables.len() - 1) {\r\n                assert!(sstables[i].last_key() \u003c sstables[i + 1].first_key());\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn create_and_seek_to_first(sstables: Vec\u003cArc\u003cSsTable\u003e\u003e) -\u003e Result\u003cSelf\u003e {\r\n        Self::check_sst_valid(\u0026sstables);\r\n        if sstables.is_empty() {\r\n            return Ok(Self {\r\n                current: None,\r\n                next_sst_idx: 0,\r\n                sstables,\r\n            });\r\n        }\r\n        let mut iter = Self {\r\n            current: Some(SsTableIterator::create_and_seek_to_first(\r\n                sstables[0].clone(),\r\n            )?),\r\n            next_sst_idx: 1,\r\n            sstables,\r\n        };\r\n        iter.move_until_valid()?;\r\n        Ok(iter)\r\n    }\r\n\r\n    pub fn create_and_seek_to_key(sstables: Vec\u003cArc\u003cSsTable\u003e\u003e, key: KeySlice) -\u003e Result\u003cSelf\u003e {\r\n        Self::check_sst_valid(\u0026sstables);\r\n        let idx: usize = sstables\r\n            .partition_point(|table| table.first_key().as_key_slice() \u003c= key)\r\n            .saturating_sub(1);\r\n        if idx \u003e= sstables.len() {\r\n            return Ok(Self {\r\n                current: None,\r\n                next_sst_idx: sstables.len(),\r\n                sstables,\r\n            });\r\n        }\r\n        let mut iter = Self {\r\n            current: Some(SsTableIterator::create_and_seek_to_key(\r\n                sstables[idx].clone(),\r\n                key,\r\n            )?),\r\n            next_sst_idx: idx + 1,\r\n            sstables,\r\n        };\r\n        iter.move_until_valid()?;\r\n        Ok(iter)\r\n    }\r\n\r\n    fn move_until_valid(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        while let Some(iter) = self.current.as_mut() {\r\n            if iter.is_valid() {\r\n                break;\r\n            }\r\n            if self.next_sst_idx \u003e= self.sstables.len() {\r\n                self.current = None;\r\n            } else {\r\n                self.current = Some(SsTableIterator::create_and_seek_to_first(\r\n                    self.sstables[self.next_sst_idx].clone(),\r\n                )?);\r\n                self.next_sst_idx += 1;\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl StorageIterator for SstConcatIterator {\r\n    type KeyType\u003c'a\u003e = KeySlice\u003c'a\u003e;\r\n\r\n    fn key(\u0026self) -\u003e KeySlice {\r\n        self.current.as_ref().unwrap().key()\r\n    }\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        self.current.as_ref().unwrap().value()\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        if let Some(current) = \u0026self.current {\r\n            assert!(current.is_valid());\r\n            true\r\n        } else {\r\n            false\r\n        }\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        self.current.as_mut().unwrap()._next()?;\r\n        self.move_until_valid()?;\r\n        Ok(())\r\n    }\r\n\r\n    fn num_active_iterators(\u0026self) -\u003e usize {\r\n        1\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":1801439850948198400},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":10016005571271985867},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":1801439850948198613},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":4107282860161891285},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":7061644215716937936},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":6341068275337658368},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":6341068275337658368},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":6341068275337658368},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":3963167672086036480},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":2377900603251621888},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":13907115649320091648},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":13907115649320091648},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":13907115649320091648},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":13907115649320091648},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":792633534417208783},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":792633534417208783},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":792633534417208783},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":792633534417208783},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":144115188075856080},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":5260204364768742146},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":15780613094306217984},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6701356245527300658},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":2810246167479190705},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":2161727821137838288},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1080863910568919248},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":17726168133330272256},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":17726168133330272256},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":10088063165309919140},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":10088063165309919140},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":15564440312192436145},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":13618885273168373911},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":16501189034685501313},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":17509995351216498379},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":3098476543630907209},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":3098476543630908201},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":3098476543630906217},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":3098476543630901248},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":864691128455136224},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":864691128455136224},"fn_name":null}],"covered":46,"coverable":48},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","iterators","merge_iterator.rs"],"content":"use std::cmp::{self};\r\nuse std::collections::binary_heap::PeekMut;\r\nuse std::collections::BinaryHeap;\r\n\r\nuse crate::errors::Result;\r\nuse crate::storage::engine::piggykv::key::KeySlice;\r\n\r\n\r\nuse super::StorageIterator;\r\n\r\nstruct HeapWrapper\u003cI: StorageIterator\u003e(pub usize, pub Box\u003cI\u003e);\r\n\r\nimpl\u003cI: StorageIterator\u003e PartialEq for HeapWrapper\u003cI\u003e {\r\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n        self.partial_cmp(other).unwrap() == cmp::Ordering::Equal\r\n    }\r\n}\r\n\r\nimpl\u003cI: StorageIterator\u003e Eq for HeapWrapper\u003cI\u003e {}\r\n\r\nimpl\u003cI: StorageIterator\u003e PartialOrd for HeapWrapper\u003cI\u003e {\r\n    #[allow(clippy::non_canonical_partial_ord_impl)]\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003ccmp::Ordering\u003e {\r\n        match self.1.key().cmp(\u0026other.1.key()) {\r\n            cmp::Ordering::Greater =\u003e Some(cmp::Ordering::Greater),\r\n            cmp::Ordering::Less =\u003e Some(cmp::Ordering::Less),\r\n            cmp::Ordering::Equal =\u003e self.0.partial_cmp(\u0026other.0),\r\n        }\r\n        .map(|x| x.reverse())\r\n    }\r\n}\r\n\r\nimpl\u003cI: StorageIterator\u003e Ord for HeapWrapper\u003cI\u003e {\r\n    fn cmp(\u0026self, other: \u0026Self) -\u003e cmp::Ordering {\r\n        self.partial_cmp(other).unwrap()\r\n    }\r\n}\r\n\r\n/// Merge multiple iterators of the same type. If the same key occurs multiple times in some\r\n/// iterators, perfer the one with smaller index.\r\npub struct MergeIterator\u003cI: StorageIterator\u003e {\r\n    iters: BinaryHeap\u003cHeapWrapper\u003cI\u003e\u003e,\r\n    current: Option\u003cHeapWrapper\u003cI\u003e\u003e,\r\n}\r\n\r\nimpl\u003cI: StorageIterator\u003e MergeIterator\u003cI\u003e {\r\n    pub fn create(iters: Vec\u003cBox\u003cI\u003e\u003e) -\u003e Self {\r\n        if iters.is_empty() {\r\n            return Self {\r\n                iters: BinaryHeap::new(),\r\n                current: None,\r\n            };\r\n        }\r\n\r\n        let mut heap = BinaryHeap::new();\r\n\r\n        if iters.iter().all(|x| !x.is_valid()) {\r\n            // All invalid, select the last one as the current.\r\n            let mut iters = iters;\r\n            return Self {\r\n                iters: heap,\r\n                current: Some(HeapWrapper(0, iters.pop().unwrap())),\r\n            };\r\n        }\r\n\r\n        for (idx, iter) in iters.into_iter().enumerate() {\r\n            if iter.is_valid() {\r\n                heap.push(HeapWrapper(idx, iter));\r\n            }\r\n        }\r\n\r\n        let current = heap.pop().unwrap();\r\n        Self {\r\n            iters: heap,\r\n            current: Some(current),\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cI: 'static + for\u003c'a\u003e StorageIterator\u003cKeyType\u003c'a\u003e = KeySlice\u003c'a\u003e\u003e\u003e StorageIterator\r\n    for MergeIterator\u003cI\u003e\r\n{\r\n    type KeyType\u003c'a\u003e = KeySlice\u003c'a\u003e;\r\n\r\n    fn key(\u0026self) -\u003e KeySlice {\r\n        self.current.as_ref().unwrap().1.key()\r\n    }\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        self.current.as_ref().unwrap().1.value()\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        self.current\r\n            .as_ref()\r\n            .map(|x| x.1.is_valid())\r\n            .unwrap_or(false)\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        let current = self.current.as_mut().unwrap();\r\n        // Pop the item out of the heap if they have the same value.\r\n        while let Some(mut inner_iter) = self.iters.peek_mut() {\r\n            debug_assert!(\r\n                inner_iter.1.key() \u003e= current.1.key(),\r\n                \"heap invariant violated\"\r\n            );\r\n            if inner_iter.1.key() == current.1.key() {\r\n                // Case 1: an error occurred when calling `next`.\r\n                if let e @ Err(_) = inner_iter.1._next() {\r\n                    PeekMut::pop(inner_iter);\r\n                    return e;\r\n                }\r\n\r\n                // Case 2: iter is no longer valid.\r\n                if !inner_iter.1.is_valid() {\r\n                    PeekMut::pop(inner_iter);\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        current.1._next()?;\r\n\r\n        // If the current iterator is invalid, pop it out of the heap and select the next one.\r\n        if !current.1.is_valid() {\r\n            if let Some(iter) = self.iters.pop() {\r\n                *current = iter;\r\n            }\r\n            return Ok(());\r\n        }\r\n\r\n        // Otherwise, compare with heap top and swap if necessary.\r\n        if let Some(mut inner_iter) = self.iters.peek_mut() {\r\n            if *current \u003c *inner_iter {\r\n                std::mem::swap(\u0026mut *inner_iter, current);\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn num_active_iterators(\u0026self) -\u003e usize {\r\n        self.iters\r\n            .iter()\r\n            .map(|x| x.1.num_active_iterators())\r\n            .sum::\u003cusize\u003e()\r\n            + self\r\n                .current\r\n                .as_ref()\r\n                .map(|x| x.1.num_active_iterators())\r\n                .unwrap_or(0)\r\n    }\r\n}\r\n\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use std::{ops::Bound, sync::Arc, time::Duration};\r\n\r\n    use bytes::Bytes;\r\n\r\n    use crate::storage::engine::piggykv::{debug::{check_iter_result_by_key, check_lsm_iter_result_by_key, generate_sst, sync, MockIterator}, iterators::{two_merge_iterator::TwoMergeIterator, StorageIterator}, key::{KeySlice, KeyVec}, lsm_storage::{LsmStorageInner, LsmStorageOptions}, PiggyKV};\r\n    use tempfile::{tempdir, TempDir};\r\n    use super::*;\r\n\r\n    #[test]\r\n    fn test_task1_merge_1() {\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n        ]);\r\n        let i2 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.2\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n        ]);\r\n        let mut iter = TwoMergeIterator::create(i1, i2).unwrap();\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n                (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n            ],\r\n        )\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task1_merge_2() {\r\n        let i2 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n        ]);\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.2\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n        ]);\r\n        let mut iter = TwoMergeIterator::create(i1, i2).unwrap();\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.2\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n                (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n            ],\r\n        )\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task1_merge_3() {\r\n        let i2 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n        ]);\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n        ]);\r\n        let mut iter = TwoMergeIterator::create(i1, i2).unwrap();\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n                (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n            ],\r\n        )\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task1_merge_4() {\r\n        let i2 = MockIterator::new(vec![]);\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n        ]);\r\n        let mut iter = TwoMergeIterator::create(i1, i2).unwrap();\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n                (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n            ],\r\n        );\r\n        let i1 = MockIterator::new(vec![]);\r\n        let i2 = MockIterator::new(vec![\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n        ]);\r\n        let mut iter = TwoMergeIterator::create(i1, i2).unwrap();\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n                (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n            ],\r\n        );\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task1_merge_5() {\r\n        let i2 = MockIterator::new(vec![]);\r\n        let i1 = MockIterator::new(vec![]);\r\n        let mut iter = TwoMergeIterator::create(i1, i2).unwrap();\r\n        check_iter_result_by_key(\u0026mut iter, vec![])\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task2_storage_scan() {\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(\u0026dir, LsmStorageOptions::default()).unwrap());\r\n        storage.put(b\"1\", b\"233\").unwrap();\r\n        storage.put(b\"2\", b\"2333\").unwrap();\r\n        storage.put(b\"00\", b\"2333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        storage.put(b\"3\", b\"23333\").unwrap();\r\n        storage.delete(b\"1\").unwrap();\r\n        let sst1 = generate_sst(\r\n            10,\r\n            dir.path().join(\"10.sst\"),\r\n            vec![\r\n                (Bytes::from_static(b\"0\"), Bytes::from_static(b\"2333333\")),\r\n                (Bytes::from_static(b\"00\"), Bytes::from_static(b\"2333333\")),\r\n                (Bytes::from_static(b\"4\"), Bytes::from_static(b\"23\")),\r\n            ],\r\n            Some(storage.block_cache.clone()),\r\n        );\r\n        let sst2 = generate_sst(\r\n            11,\r\n            dir.path().join(\"11.sst\"),\r\n            vec![(Bytes::from_static(b\"4\"), Bytes::from_static(b\"\"))],\r\n            Some(storage.block_cache.clone()),\r\n        );\r\n        {\r\n            let mut state = storage.state.write();\r\n            let mut snapshot = state.as_ref().clone();\r\n            snapshot.l0_sstables.push(sst2.sst_id()); // this is the latest SST\r\n            snapshot.l0_sstables.push(sst1.sst_id());\r\n            snapshot.sstables.insert(sst2.sst_id(), sst2.into());\r\n            snapshot.sstables.insert(sst1.sst_id(), sst1.into());\r\n            *state = snapshot.into();\r\n        }\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut storage.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"0\"), Bytes::from(\"2333333\")),\r\n                (Bytes::from(\"00\"), Bytes::from(\"2333\")),\r\n                (Bytes::from(\"2\"), Bytes::from(\"2333\")),\r\n                (Bytes::from(\"3\"), Bytes::from(\"23333\")),\r\n            ],\r\n        );\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut storage\r\n                .scan(Bound::Included(b\"1\"), Bound::Included(b\"2\"))\r\n                .unwrap(),\r\n            vec![(Bytes::from(\"2\"), Bytes::from(\"2333\"))],\r\n        );\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut storage\r\n                .scan(Bound::Excluded(b\"1\"), Bound::Excluded(b\"3\"))\r\n                .unwrap(),\r\n            vec![(Bytes::from(\"2\"), Bytes::from(\"2333\"))],\r\n        );\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut storage\r\n                .scan(Bound::Included(b\"0\"), Bound::Included(b\"1\"))\r\n                .unwrap(),\r\n            vec![\r\n                (Bytes::from_static(b\"0\"), Bytes::from_static(b\"2333333\")),\r\n                (Bytes::from(\"00\"), Bytes::from(\"2333\")),\r\n            ],\r\n        );\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut storage\r\n                .scan(Bound::Excluded(b\"0\"), Bound::Included(b\"1\"))\r\n                .unwrap(),\r\n            vec![(Bytes::from(\"00\"), Bytes::from(\"2333\"))],\r\n        );\r\n    }\r\n    \r\n    #[test]\r\n    fn test_task3_storage_get() {\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(\u0026dir, LsmStorageOptions::default()).unwrap());\r\n        storage.put(b\"1\", b\"233\").unwrap();\r\n        storage.put(b\"2\", b\"2333\").unwrap();\r\n        storage.put(b\"00\", b\"2333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        storage.put(b\"3\", b\"23333\").unwrap();\r\n        storage.delete(b\"1\").unwrap();\r\n        let sst1 = generate_sst(\r\n            10,\r\n            dir.path().join(\"10.sst\"),\r\n            vec![\r\n                (Bytes::from_static(b\"0\"), Bytes::from_static(b\"2333333\")),\r\n                (Bytes::from_static(b\"00\"), Bytes::from_static(b\"2333333\")),\r\n                (Bytes::from_static(b\"4\"), Bytes::from_static(b\"23\")),\r\n            ],\r\n            Some(storage.block_cache.clone()),\r\n        );\r\n        let sst2 = generate_sst(\r\n            11,\r\n            dir.path().join(\"11.sst\"),\r\n            vec![(Bytes::from_static(b\"4\"), Bytes::from_static(b\"\"))],\r\n            Some(storage.block_cache.clone()),\r\n        );\r\n        {\r\n            let mut state = storage.state.write();\r\n            let mut snapshot = state.as_ref().clone();\r\n            snapshot.l0_sstables.push(sst2.sst_id()); // this is the latest SST\r\n            snapshot.l0_sstables.push(sst1.sst_id());\r\n            snapshot.sstables.insert(sst2.sst_id(), sst2.into());\r\n            snapshot.sstables.insert(sst1.sst_id(), sst1.into());\r\n            *state = snapshot.into();\r\n        }\r\n        assert_eq!(\r\n            storage.get(b\"0\").unwrap(),\r\n            Some(Bytes::from_static(b\"2333333\"))\r\n        );\r\n        assert_eq!(\r\n            storage.get(b\"00\").unwrap(),\r\n            Some(Bytes::from_static(b\"2333\"))\r\n        );\r\n        assert_eq!(\r\n            storage.get(b\"2\").unwrap(),\r\n            Some(Bytes::from_static(b\"2333\"))\r\n        );\r\n        assert_eq!(\r\n            storage.get(b\"3\").unwrap(),\r\n            Some(Bytes::from_static(b\"23333\"))\r\n        );\r\n        assert_eq!(storage.get(b\"4\").unwrap(), None);\r\n        assert_eq!(storage.get(b\"--\").unwrap(), None);\r\n        assert_eq!(storage.get(b\"555\").unwrap(), None);\r\n    }\r\n    #[test]\r\nfn test_task1_storage_scan() {\r\n    let dir = tempdir().unwrap();\r\n    let storage =\r\n        Arc::new(LsmStorageInner::open(\u0026dir, LsmStorageOptions::default()).unwrap());\r\n    storage.put(b\"0\", b\"2333333\").unwrap();\r\n    storage.put(b\"00\", b\"2333333\").unwrap();\r\n    storage.put(b\"4\", b\"23\").unwrap();\r\n    sync(\u0026storage);\r\n\r\n    storage.delete(b\"4\").unwrap();\r\n    sync(\u0026storage);\r\n\r\n    storage.put(b\"1\", b\"233\").unwrap();\r\n    storage.put(b\"2\", b\"2333\").unwrap();\r\n    storage\r\n        .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n        .unwrap();\r\n    storage.put(b\"00\", b\"2333\").unwrap();\r\n    storage\r\n        .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n        .unwrap();\r\n    storage.put(b\"3\", b\"23333\").unwrap();\r\n    storage.delete(b\"1\").unwrap();\r\n\r\n    {\r\n        let state = storage.state.read();\r\n        assert_eq!(state.l0_sstables.len(), 2);\r\n        assert_eq!(state.imm_memtables.len(), 2);\r\n    }\r\n\r\n    check_lsm_iter_result_by_key(\r\n        \u0026mut storage.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n        vec![\r\n            (Bytes::from(\"0\"), Bytes::from(\"2333333\")),\r\n            (Bytes::from(\"00\"), Bytes::from(\"2333\")),\r\n            (Bytes::from(\"2\"), Bytes::from(\"2333\")),\r\n            (Bytes::from(\"3\"), Bytes::from(\"23333\")),\r\n        ],\r\n    );\r\n    check_lsm_iter_result_by_key(\r\n        \u0026mut storage\r\n            .scan(Bound::Included(b\"1\"), Bound::Included(b\"2\"))\r\n            .unwrap(),\r\n        vec![(Bytes::from(\"2\"), Bytes::from(\"2333\"))],\r\n    );\r\n    check_lsm_iter_result_by_key(\r\n        \u0026mut storage\r\n            .scan(Bound::Excluded(b\"1\"), Bound::Excluded(b\"3\"))\r\n            .unwrap(),\r\n        vec![(Bytes::from(\"2\"), Bytes::from(\"2333\"))],\r\n    );\r\n}\r\n\r\n#[test]\r\nfn test_task1_storage_get() {\r\n    let dir = tempdir().unwrap();\r\n    let storage =\r\n        Arc::new(LsmStorageInner::open(\u0026dir, LsmStorageOptions::default()).unwrap());\r\n    storage.put(b\"0\", b\"2333333\").unwrap();\r\n    storage.put(b\"00\", b\"2333333\").unwrap();\r\n    storage.put(b\"4\", b\"23\").unwrap();\r\n    sync(\u0026storage);\r\n\r\n    storage.delete(b\"4\").unwrap();\r\n    sync(\u0026storage);\r\n\r\n    storage.put(b\"1\", b\"233\").unwrap();\r\n    storage.put(b\"2\", b\"2333\").unwrap();\r\n    storage\r\n        .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n        .unwrap();\r\n    storage.put(b\"00\", b\"2333\").unwrap();\r\n    storage\r\n        .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n        .unwrap();\r\n    storage.put(b\"3\", b\"23333\").unwrap();\r\n    storage.delete(b\"1\").unwrap();\r\n\r\n    {\r\n        let state = storage.state.read();\r\n        assert_eq!(state.l0_sstables.len(), 2);\r\n        assert_eq!(state.imm_memtables.len(), 2);\r\n    }\r\n\r\n    assert_eq!(\r\n        storage.get(b\"0\").unwrap(),\r\n        Some(Bytes::from_static(b\"2333333\"))\r\n    );\r\n    assert_eq!(\r\n        storage.get(b\"00\").unwrap(),\r\n        Some(Bytes::from_static(b\"2333\"))\r\n    );\r\n    assert_eq!(\r\n        storage.get(b\"2\").unwrap(),\r\n        Some(Bytes::from_static(b\"2333\"))\r\n    );\r\n    assert_eq!(\r\n        storage.get(b\"3\").unwrap(),\r\n        Some(Bytes::from_static(b\"23333\"))\r\n    );\r\n    assert_eq!(storage.get(b\"4\").unwrap(), None);\r\n    assert_eq!(storage.get(b\"--\").unwrap(), None);\r\n    assert_eq!(storage.get(b\"555\").unwrap(), None);\r\n}\r\n\r\n#[test]\r\nfn test_task2_auto_flush() {\r\n    let dir = tempdir().unwrap();\r\n    let storage = PiggyKV::open(\u0026dir, LsmStorageOptions::default()).unwrap();\r\n\r\n    let value = \"1\".repeat(1024); // 1KB\r\n\r\n    // approximately 6MB\r\n    for i in 0..6000 {\r\n        storage\r\n            .put(format!(\"{i}\").as_bytes(), value.as_bytes())\r\n            .unwrap();\r\n    }\r\n\r\n    std::thread::sleep(Duration::from_millis(500));\r\n\r\n    assert!(!storage.inner.state.read().l0_sstables.is_empty());\r\n}\r\n\r\n#[test]\r\nfn test_task3_sst_filter() {\r\n    let dir = tempdir().unwrap();\r\n    let storage =\r\n        Arc::new(LsmStorageInner::open(\u0026dir, LsmStorageOptions::default()).unwrap());\r\n\r\n    for i in 1..=10000 {\r\n        if i % 1000 == 0 {\r\n            sync(\u0026storage);\r\n        }\r\n        storage\r\n            .put(format!(\"{:05}\", i).as_bytes(), b\"2333333\")\r\n            .unwrap();\r\n    }\r\n\r\n    let iter = storage.scan(Bound::Unbounded, Bound::Unbounded).unwrap();\r\n    assert!(\r\n        iter.num_active_iterators() \u003e= 10,\r\n        \"did you implement num_active_iterators? current active iterators = {}\",\r\n        iter.num_active_iterators()\r\n    );\r\n    let max_num = iter.num_active_iterators();\r\n    let iter = storage\r\n        .scan(\r\n            Bound::Excluded(format!(\"{:05}\", 10000).as_bytes()),\r\n            Bound::Unbounded,\r\n        )\r\n        .unwrap();\r\n    assert!(iter.num_active_iterators() \u003c max_num);\r\n    let min_num = iter.num_active_iterators();\r\n    let iter = storage\r\n        .scan(\r\n            Bound::Unbounded,\r\n            Bound::Excluded(format!(\"{:05}\", 1).as_bytes()),\r\n        )\r\n        .unwrap();\r\n    assert_eq!(iter.num_active_iterators(), min_num);\r\n    let iter = storage\r\n        .scan(\r\n            Bound::Unbounded,\r\n            Bound::Included(format!(\"{:05}\", 0).as_bytes()),\r\n        )\r\n        .unwrap();\r\n    assert_eq!(iter.num_active_iterators(), min_num);\r\n    let iter = storage\r\n        .scan(\r\n            Bound::Included(format!(\"{:05}\", 10001).as_bytes()),\r\n            Bound::Unbounded,\r\n        )\r\n        .unwrap();\r\n    assert_eq!(iter.num_active_iterators(), min_num);\r\n    let iter = storage\r\n        .scan(\r\n            Bound::Included(format!(\"{:05}\", 5000).as_bytes()),\r\n            Bound::Excluded(format!(\"{:05}\", 6000).as_bytes()),\r\n        )\r\n        .unwrap();\r\n    assert!(min_num \u003c= iter.num_active_iterators() \u0026\u0026 iter.num_active_iterators() \u003c max_num);\r\n}\r\n\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":15,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":1297036692682703517},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":2233785415175767132},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":2233785415175767132},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":2233785415175767132},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":17149707381026847860},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":17149707381026847859},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3530822107858469236},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":3530822107858469236},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":3530822107858469236},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3530822107858469236},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":13618885273168380433},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":13618885273168380433},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":18446744073709551613},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":1224979098644777793},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":1369094286720633665},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":625},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":5620492334958378382},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":5188146770730811392},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":13690942867206307840},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":17149707381026848916},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":17149707381026848916},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":5764607523034234894},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":6052837899185946638},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":2161727821137838087},"fn_name":null}],"covered":59,"coverable":64},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","iterators","two_merge_iterator.rs"],"content":"use crate::errors::Result;\r\n\r\nuse super::StorageIterator;\r\n\r\n/// Merges two iterators of different types into one. If the two iterators have the same key, only\r\n/// produce the key once and prefer the entry from A.\r\npub struct TwoMergeIterator\u003cA: StorageIterator, B: StorageIterator\u003e {\r\n    a: A,\r\n    b: B,\r\n    choose_a: bool,\r\n}\r\n\r\nimpl\u003c\r\n        A: 'static + StorageIterator,\r\n        B: 'static + for\u003c'a\u003e StorageIterator\u003cKeyType\u003c'a\u003e = A::KeyType\u003c'a\u003e\u003e,\r\n    \u003e TwoMergeIterator\u003cA, B\u003e\r\n{\r\n    fn choose_a(a: \u0026A, b: \u0026B) -\u003e bool {\r\n        if !a.is_valid() {\r\n            return false;\r\n        }\r\n        if !b.is_valid() {\r\n            return true;\r\n        }\r\n        a.key() \u003c b.key()\r\n    }\r\n\r\n    fn skip_b(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        if self.a.is_valid() \u0026\u0026 self.b.is_valid() \u0026\u0026 self.b.key() == self.a.key() {\r\n            self.b._next()?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub fn create(a: A, b: B) -\u003e Result\u003cSelf\u003e {\r\n        let mut iter = Self {\r\n            choose_a: false,\r\n            a,\r\n            b,\r\n        };\r\n        iter.skip_b()?;\r\n        iter.choose_a = Self::choose_a(\u0026iter.a, \u0026iter.b);\r\n        Ok(iter)\r\n    }\r\n}\r\n\r\nimpl\u003c\r\n        A: 'static + StorageIterator,\r\n        B: 'static + for\u003c'a\u003e StorageIterator\u003cKeyType\u003c'a\u003e = A::KeyType\u003c'a\u003e\u003e,\r\n    \u003e StorageIterator for TwoMergeIterator\u003cA, B\u003e\r\n{\r\n    type KeyType\u003c'a\u003e = A::KeyType\u003c'a\u003e;\r\n\r\n    fn key(\u0026self) -\u003e A::KeyType\u003c'_\u003e {\r\n        if self.choose_a {\r\n            self.a.key()\r\n        } else {\r\n            self.b.key()\r\n        }\r\n    }\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        if self.choose_a {\r\n            self.a.value()\r\n        } else {\r\n            self.b.value()\r\n        }\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        if self.choose_a {\r\n            self.a.is_valid()\r\n        } else {\r\n            self.b.is_valid()\r\n        }\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        if self.choose_a {\r\n            self.a._next()?;\r\n        } else {\r\n            self.b._next()?;\r\n        }\r\n        self.skip_b()?;\r\n        self.choose_a = Self::choose_a(\u0026self.a, \u0026self.b);\r\n        Ok(())\r\n    }\r\n\r\n    fn num_active_iterators(\u0026self) -\u003e usize {\r\n        self.a.num_active_iterators() + self.b.num_active_iterators()\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":16645304222761354620},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":16933534598913066762},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":743},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":877},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":2161727821137838295},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":2161727821137838295},"fn_name":null}],"covered":35,"coverable":35},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","iterators.rs"],"content":"pub mod concat_iterator;\r\npub mod merge_iterator;\r\npub mod two_merge_iterator;\r\nuse crate::errors::Result;\r\n\r\npub trait StorageIterator {\r\n    type KeyType\u003c'a\u003e: PartialEq + Eq + PartialOrd + Ord\r\n    where\r\n        Self: 'a;\r\n\r\n    /// Get the current value.\r\n    fn value(\u0026self) -\u003e \u0026[u8];\r\n\r\n    /// Get the current key.\r\n    fn key(\u0026self) -\u003e Self::KeyType\u003c'_\u003e;\r\n\r\n    /// Check if the current iterator is valid.\r\n    fn is_valid(\u0026self) -\u003e bool;\r\n\r\n    /// Move to the next position.\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e;\r\n\r\n    /// Number of underlying active iterators for this iterator.\r\n    fn num_active_iterators(\u0026self) -\u003e usize {\r\n        1\r\n    }\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null}],"covered":2,"coverable":2},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","key.rs"],"content":"use std::{cmp::Reverse, fmt::Debug};\r\n\r\nuse bytes::Bytes;\r\n\r\npub struct Key\u003cT: AsRef\u003c[u8]\u003e\u003e(T, u64);\r\n\r\npub type KeySlice\u003c'a\u003e = Key\u003c\u0026'a [u8]\u003e;\r\npub type KeyVec = Key\u003cVec\u003cu8\u003e\u003e;\r\npub type KeyBytes = Key\u003cBytes\u003e;\r\n\r\n/// For testing purpose, should not use anywhere in your implementation.\r\npub const TS_ENABLED: bool = true;\r\n\r\n/// Temporary, should remove after implementing full week 3 day 1 + 2.\r\npub const TS_DEFAULT: u64 = 0;\r\n\r\npub const TS_MAX: u64 = std::u64::MAX;\r\npub const TS_MIN: u64 = std::u64::MIN;\r\npub const TS_RANGE_BEGIN: u64 = std::u64::MAX;\r\npub const TS_RANGE_END: u64 = std::u64::MIN;\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e\u003e Key\u003cT\u003e {\r\n    pub fn into_inner(self) -\u003e T {\r\n        self.0\r\n    }\r\n\r\n    pub fn key_len(\u0026self) -\u003e usize {\r\n        self.0.as_ref().len()\r\n    }\r\n\r\n    pub fn raw_len(\u0026self) -\u003e usize {\r\n        self.0.as_ref().len() + std::mem::size_of::\u003cu64\u003e()\r\n    }\r\n\r\n    pub fn is_empty(\u0026self) -\u003e bool {\r\n        self.0.as_ref().is_empty()\r\n    }\r\n    pub fn for_testing_ts(self) -\u003e u64 {\r\n        self.1\r\n    }\r\n\r\n}\r\n\r\nimpl Key\u003cVec\u003cu8\u003e\u003e {\r\n    pub fn new() -\u003e Self {\r\n        Self(Vec::new(), TS_DEFAULT)\r\n    }\r\n\r\n    /// Create a `KeyVec` from a `Vec\u003cu8\u003e` and a ts. Will be removed in week 3.\r\n    pub fn from_vec_with_ts(key: Vec\u003cu8\u003e, ts: u64) -\u003e Self {\r\n        Self(key, ts)\r\n    }\r\n\r\n    /// Clears the key and set ts to 0.\r\n    pub fn clear(\u0026mut self) {\r\n        self.0.clear()\r\n    }\r\n\r\n    /// Append a slice to the end of the key\r\n    pub fn append(\u0026mut self, data: \u0026[u8]) {\r\n        self.0.extend(data)\r\n    }\r\n\r\n    pub fn set_ts(\u0026mut self, ts: u64) {\r\n        self.1 = ts;\r\n    }\r\n\r\n    /// Set the key from a slice without re-allocating.\r\n    pub fn set_from_slice(\u0026mut self, key_slice: KeySlice) {\r\n        self.0.clear();\r\n        self.0.extend(key_slice.0);\r\n        self.1 = key_slice.1;\r\n    }\r\n\r\n    pub fn as_key_slice(\u0026self) -\u003e KeySlice {\r\n        Key(self.0.as_slice(), self.1)\r\n    }\r\n\r\n    pub fn into_key_bytes(self) -\u003e KeyBytes {\r\n        Key(self.0.into(), self.1)\r\n    }\r\n\r\n    pub fn key_ref(\u0026self) -\u003e \u0026[u8] {\r\n        self.0.as_ref()\r\n    }\r\n\r\n    pub fn ts(\u0026self) -\u003e u64 {\r\n        self.1\r\n    }\r\n\r\n    pub fn for_testing_key_ref(\u0026self) -\u003e \u0026[u8] {\r\n        self.0.as_ref()\r\n    }\r\n\r\n    pub fn for_testing_from_vec_no_ts(key: Vec\u003cu8\u003e) -\u003e Self {\r\n        Self(key, TS_DEFAULT)\r\n    }\r\n}\r\n\r\nimpl Key\u003cBytes\u003e {\r\n    pub fn new() -\u003e Self {\r\n        Self(Bytes::new(), TS_DEFAULT)\r\n    }\r\n\r\n    pub fn as_key_slice(\u0026self) -\u003e KeySlice {\r\n        Key(\u0026self.0, self.1)\r\n    }\r\n\r\n    /// Create a `KeyBytes` from a `Bytes` and a ts.\r\n    pub fn from_bytes_with_ts(bytes: Bytes, ts: u64) -\u003e KeyBytes {\r\n        Key(bytes, ts)\r\n    }\r\n\r\n    pub fn key_ref(\u0026self) -\u003e \u0026[u8] {\r\n        self.0.as_ref()\r\n    }\r\n\r\n    pub fn ts(\u0026self) -\u003e u64 {\r\n        self.1\r\n    }\r\n\r\n    pub fn for_testing_from_bytes_no_ts(bytes: Bytes) -\u003e KeyBytes {\r\n        Key(bytes, TS_DEFAULT)\r\n    }\r\n\r\n    pub fn for_testing_key_ref(\u0026self) -\u003e \u0026[u8] {\r\n        self.0.as_ref()\r\n    }\r\n    \r\n}\r\n\r\nimpl\u003c'a\u003e Key\u003c\u0026'a [u8]\u003e {\r\n    pub fn to_key_vec(self) -\u003e KeyVec {\r\n        Key(self.0.to_vec(), self.1)\r\n    }\r\n\r\n    /// Create a key slice from a slice. Will be removed in week 3.\r\n    pub fn from_slice(slice: \u0026'a [u8], ts: u64) -\u003e Self {\r\n        Self(slice, ts)\r\n    }\r\n\r\n    pub fn key_ref(self) -\u003e \u0026'a [u8] {\r\n        self.0\r\n    }\r\n\r\n    pub fn ts(\u0026self) -\u003e u64 {\r\n        self.1\r\n    }\r\n\r\n    pub fn for_testing_key_ref(self) -\u003e \u0026'a [u8] {\r\n        self.0\r\n    }\r\n\r\n    pub fn for_testing_from_slice_no_ts(slice: \u0026'a [u8]) -\u003e Self {\r\n        Self(slice, TS_DEFAULT)\r\n    }\r\n    pub fn for_testing_from_slice_with_ts(slice: \u0026'a [u8], ts: u64) -\u003e Self {\r\n        Self(slice, ts)\r\n    }\r\n\r\n\r\n}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + Debug\u003e Debug for Key\u003cT\u003e {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        self.0.fmt(f)\r\n    }\r\n}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + Default\u003e Default for Key\u003cT\u003e {\r\n    fn default() -\u003e Self {\r\n        Self(T::default(), TS_DEFAULT)\r\n    }\r\n}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + PartialEq\u003e PartialEq for Key\u003cT\u003e {\r\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n        (self.0.as_ref(), self.1).eq(\u0026(other.0.as_ref(), other.1))\r\n    }\r\n}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + Eq\u003e Eq for Key\u003cT\u003e {}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + Clone\u003e Clone for Key\u003cT\u003e {\r\n    fn clone(\u0026self) -\u003e Self {\r\n        Self(self.0.clone(), self.1)\r\n    }\r\n}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + Copy\u003e Copy for Key\u003cT\u003e {}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + PartialOrd\u003e PartialOrd for Key\u003cT\u003e {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cstd::cmp::Ordering\u003e {\r\n        (self.0.as_ref(), Reverse(self.1)).partial_cmp(\u0026(other.0.as_ref(), Reverse(other.1)))\r\n    }\r\n}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e + Ord\u003e Ord for Key\u003cT\u003e {\r\n    fn cmp(\u0026self, other: \u0026Self) -\u003e std::cmp::Ordering {\r\n        (self.0.as_ref(), Reverse(self.1)).cmp(\u0026(other.0.as_ref(), Reverse(other.1)))\r\n    }\r\n}\r\n","traces":[{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":7205759403792795076},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":7205759403792795076},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":8214565720323785017},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":8214565720323785017},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":10160120759347839239},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":10160120759347839239},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":16861477004875139730},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":16861477004875139730},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":17654110539292349627},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":17654110539292349627},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":16645304222761355869},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":16645304222761355869},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":16645304222761355869},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":16645304222761355869},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":11168927075878831554},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":11168927075878831554},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":14555633995661456865},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":14555633995661456865},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":17654110539292344879},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":17654110539292344879},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":15132094747964869213},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":15132094747964869213},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":6341068275337658375},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":6341068275337658375},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":4899916394579099659},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":4899916394579099659},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":7277816997830722274},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":7277816997830722274},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":10232178353385780498},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":10232178353385780498},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":12249790986447749865},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":12249790986447749865},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":12249790986447749216},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":12249790986447749216},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855968},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":144115188075855968},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":9079256848778919936},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":9079256848778919936},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":9007199254740992511},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":9007199254740992511},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":17654110539292347015},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":17654110539292347015},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":4899916394579141152},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":4899916394579141152},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":2594073385365411304},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":2594073385365411304},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2233785415175766025},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":2233785415175766025},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":7782220156096217095},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":7782220156096217095},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":12249790986447749120},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":12249790986447749120},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":2161727821137839255},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":2161727821137839255},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":200,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null}],"covered":68,"coverable":76},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","lsm_iterator.rs"],"content":"use std::ops::Bound;\r\n\r\nuse crate::errors::{DatabaseError, Result};\r\nuse bytes::Bytes;\r\n\r\n\r\nuse super::iterators::concat_iterator::SstConcatIterator;\r\nuse super::iterators::merge_iterator::MergeIterator;\r\nuse super::iterators::two_merge_iterator::TwoMergeIterator;\r\nuse super::iterators::StorageIterator;\r\nuse super::mem_table::MemTableIterator;\r\nuse super::table::SsTableIterator;\r\n\r\n/// Represents the internal type for an LSM iterator. This type will be changed across the tutorial for multiple times.\r\ntype LsmIteratorInner = TwoMergeIterator\u003c\r\n    TwoMergeIterator\u003cMergeIterator\u003cMemTableIterator\u003e, MergeIterator\u003cSsTableIterator\u003e\u003e,\r\n    MergeIterator\u003cSstConcatIterator\u003e,\r\n\u003e;\r\n\r\npub struct LsmIterator {\r\n    inner: LsmIteratorInner,\r\n    end_bound: Bound\u003cBytes\u003e,\r\n    is_valid: bool,\r\n    read_ts: u64,\r\n    prev_key: Vec\u003cu8\u003e,\r\n}\r\n\r\nimpl LsmIterator {\r\n    pub(crate) fn new(\r\n        iter: LsmIteratorInner,\r\n        end_bound: Bound\u003cBytes\u003e,\r\n        read_ts: u64,\r\n    ) -\u003e Result\u003cSelf\u003e {\r\n        let mut iter = Self {\r\n            is_valid: iter.is_valid(),\r\n            inner: iter,\r\n            end_bound,\r\n            read_ts,\r\n            prev_key: Vec::new(),\r\n        };\r\n        iter.move_to_key()?;\r\n        Ok(iter)\r\n    }\r\n\r\n    fn next_inner(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        self.inner._next()?;\r\n        if !self.inner.is_valid() {\r\n            self.is_valid = false;\r\n            return Ok(());\r\n        }\r\n\r\n        match self.end_bound.as_ref() {\r\n            Bound::Unbounded =\u003e {}\r\n            Bound::Included(key) =\u003e self.is_valid = self.inner.key().key_ref() \u003c= key.as_ref(),\r\n            Bound::Excluded(key) =\u003e self.is_valid = self.inner.key().key_ref() \u003c key.as_ref(),\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn move_to_key(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        loop {\r\n            while self.inner.is_valid() \u0026\u0026 self.inner.key().key_ref() == self.prev_key {\r\n                self.next_inner()?;\r\n            }\r\n            if !self.inner.is_valid() {\r\n                break;\r\n            }\r\n            self.prev_key.clear();\r\n            self.prev_key.extend(self.inner.key().key_ref());\r\n            while self.inner.is_valid()\r\n                \u0026\u0026 self.inner.key().key_ref() == self.prev_key\r\n                \u0026\u0026 self.inner.key().ts() \u003e self.read_ts\r\n            {\r\n                self.next_inner()?;\r\n            }\r\n            if !self.inner.is_valid() {\r\n                break;\r\n            }\r\n            if self.inner.key().key_ref() != self.prev_key {\r\n                continue;\r\n            }\r\n            if !self.inner.value().is_empty() {\r\n                break;\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl StorageIterator for LsmIterator {\r\n    type KeyType\u003c'a\u003e = \u0026'a [u8];\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        self.is_valid\r\n    }\r\n\r\n    fn key(\u0026self) -\u003e \u0026[u8] {\r\n        self.inner.key().key_ref()\r\n    }\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        self.inner.value()\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        self.next_inner()?;\r\n        self.move_to_key()?;\r\n        Ok(())\r\n    }\r\n\r\n    fn num_active_iterators(\u0026self) -\u003e usize {\r\n        self.inner.num_active_iterators()\r\n    }\r\n}\r\n\r\n/// A wrapper around existing iterator, will prevent users from calling `next` when the iterator is\r\n/// invalid. If an iterator is already invalid, `next` does not do anything. If `next` returns an error,\r\n/// `is_valid` should return false, and `next` should always return an error.\r\npub struct FusedIterator\u003cI: StorageIterator\u003e {\r\n    iter: I,\r\n    has_errored: bool,\r\n}\r\n\r\nimpl\u003cI: StorageIterator\u003e FusedIterator\u003cI\u003e {\r\n    pub fn new(iter: I) -\u003e Self {\r\n        Self {\r\n            iter,\r\n            has_errored: false,\r\n        }\r\n    }\r\n}\r\n\r\nimpl\u003cI: StorageIterator\u003e StorageIterator for FusedIterator\u003cI\u003e {\r\n    type KeyType\u003c'a\u003e = I::KeyType\u003c'a\u003e where Self: 'a;\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        !self.has_errored \u0026\u0026 self.iter.is_valid()\r\n    }\r\n\r\n    fn key(\u0026self) -\u003e Self::KeyType\u003c'_\u003e {\r\n        if !self.is_valid() {\r\n            panic!(\"invalid access to the underlying iterator\");\r\n        }\r\n        self.iter.key()\r\n    }\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        if !self.is_valid() {\r\n            panic!(\"invalid access to the underlying iterator\");\r\n        }\r\n        self.iter.value()\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        // only move when the iterator is valid and not errored\r\n        if self.has_errored {\r\n            return Err(DatabaseError::InternalError(\"the iterator is tainted\".to_string()));\r\n        }\r\n        if self.iter.is_valid() {\r\n            if let Err(e) = self.iter._next() {\r\n                self.has_errored = true;\r\n                return Err(e);\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn num_active_iterators(\u0026self) -\u003e usize {\r\n        self.iter.num_active_iterators()\r\n    }\r\n}\r\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":5692549928996306949},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":5692549928996306949},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":5692549928996306949},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":5692549928996307321},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":5692549928996306577},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":7782220156096217088},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":7782220156096217480},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":7782220156096216696},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":1585267068834414200},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":9223372036854775808},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":720575940379279751},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":1585267068834414983},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":17582052945254416384},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":13835058055282164710},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":5404319552844595455},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":1441151880758559052},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":18302628885633696175},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":1585267068834414493},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1585267068834414493},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":10520408729537478557},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":9295429630892703645},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":9223372036854775709},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":8935141660703063965},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":1224979098644775342},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":360287970189639250},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":72057594037928523},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":288230376151710727},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":16501189034685497500},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":17582052945254417401},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":8430738502437568943},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":8430738502437568943},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":10952754293765048370},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":10952754293765048370},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":12321848580485677702},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":12321848580485677702},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":11889503016258110301},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":11889503016258110516},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":11889503016258110086},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":11889503016258109440},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":720575940379279575},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":720575940379279575},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":15708555500268290048},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":12898309332789099034},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":7277816997830721536},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":7277816997830721536},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":18446744073709551185},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":7277816997830721967},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":5404319552844595631},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":5404319552844595631},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":5404319552844595631},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":12754194144713245103},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":12754194144713245103},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":144115188075856087},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":12610078956637389016},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":12033618204333965313},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":12538021362599461079},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null}],"covered":65,"coverable":66},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","lsm_storage.rs"],"content":"use std::collections::{BTreeSet, HashMap};\r\n\r\nuse std::ops::Bound;\r\nuse std::path::{Path, PathBuf};\r\nuse std::sync::atomic::AtomicUsize;\r\nuse std::sync::Arc;\r\n\r\nuse crate::errors::Result;\r\nuse bytes::Bytes;\r\nuse derive_with::With;\r\nuse parking_lot::{Mutex, MutexGuard, RwLock};\r\nuse tracing::debug;\r\n\r\nuse super::block::Block;\r\nuse super::compact::{\r\n    CompactionController, CompactionOptions, LeveledCompactionController, LeveledCompactionOptions,\r\n};\r\nuse super::iterators::concat_iterator::SstConcatIterator;\r\nuse super::iterators::merge_iterator::MergeIterator;\r\nuse super::iterators::two_merge_iterator::TwoMergeIterator;\r\nuse super::iterators::StorageIterator;\r\nuse super::key::{self, KeySlice};\r\nuse super::lsm_iterator::{FusedIterator, LsmIterator};\r\nuse super::manifest::{Manifest, ManifestRecord};\r\nuse super::mem_table::{map_bound, map_key_bound_plus_ts, MemTable};\r\nuse super::mvcc::txn::{Transaction, TxnIterator};\r\nuse super::mvcc::LsmMvccInner;\r\nuse super::table::{FileObject, SsTable, SsTableBuilder, SsTableIterator};\r\n\r\npub type BlockCache = moka::sync::Cache\u003c(usize, usize), Arc\u003cBlock\u003e\u003e;\r\n/// Represents the state of the storage engine.\r\n#[derive(Clone)]\r\npub struct LsmStorageState {\r\n    /// The current memtable.\r\n    pub memtable: Arc\u003cMemTable\u003e,\r\n    /// Immutable memtables, from latest to earliest.\r\n    pub imm_memtables: Vec\u003cArc\u003cMemTable\u003e\u003e,\r\n    /// L0 SSTs, from latest to earliest.\r\n    /// l0 is unsorted,each l0 sst created by imm_memtables,but imm_memtables is not sorted by key  \r\n    pub l0_sstables: Vec\u003cusize\u003e,\r\n    /// SsTables sorted by key range; L1 - L_max for leveled compaction, or tiers for tiered\r\n    /// compaction.  \r\n    /// each element is (level, a vec of sst_id of current level)  \r\n    pub levels: Vec\u003c(usize, Vec\u003cusize\u003e)\u003e,\r\n    /// SST objects.\r\n    pub sstables: HashMap\u003cusize, Arc\u003cSsTable\u003e\u003e,\r\n}\r\n\r\npub enum WriteBatchRecord\u003cT: AsRef\u003c[u8]\u003e\u003e {\r\n    Put(T, T),\r\n    Del(T),\r\n}\r\n\r\nimpl LsmStorageState {\r\n    fn create(options: \u0026LsmStorageOptions) -\u003e Self {\r\n        let levels = match \u0026options.compaction_options {\r\n            CompactionOptions::Leveled(LeveledCompactionOptions { max_levels, .. }) =\u003e (1\r\n                ..=*max_levels)\r\n                .map(|level| (level, Vec::new()))\r\n                .collect::\u003cVec\u003c_\u003e\u003e(),\r\n            CompactionOptions::NoCompaction =\u003e vec![(1, Vec::new())],\r\n        };\r\n        Self {\r\n            memtable: Arc::new(MemTable::create(0)),\r\n            imm_memtables: Vec::new(),\r\n            l0_sstables: Vec::new(),\r\n            levels,\r\n            sstables: Default::default(),\r\n        }\r\n    }\r\n}\r\n\r\n#[derive(Debug, Clone, With)]\r\npub struct LsmStorageOptions {\r\n    // Block size in bytes\r\n    pub block_size: usize,\r\n    // SST size in bytes, also the approximate memtable capacity limit\r\n    pub target_sst_size: usize,\r\n    // Maximum number of memtables in memory, flush to L0 when exceeding this limit\r\n    pub num_memtable_limit: usize,\r\n    pub compaction_options: CompactionOptions,\r\n    pub enable_wal: bool,\r\n    pub bloom_false_positive_rate: f64,\r\n    pub serializable: bool,\r\n}\r\nimpl Default for LsmStorageOptions {\r\n    fn default() -\u003e Self {\r\n        Self {\r\n            block_size: 4096,\r\n            target_sst_size: 2 \u003c\u003c 20, // 2MB\r\n            num_memtable_limit: 2,\r\n            compaction_options: CompactionOptions::NoCompaction,\r\n            enable_wal: true,\r\n            bloom_false_positive_rate: 0.01,\r\n            serializable: true,\r\n        }\r\n    }\r\n}\r\nimpl LsmStorageOptions {\r\n    pub fn default_for_mvcc_test(compaction_options: CompactionOptions) -\u003e Self {\r\n        Self {\r\n            block_size: 4096,\r\n            target_sst_size: 1 \u003c\u003c 20, // 1MB\r\n            compaction_options,\r\n            enable_wal: false,\r\n            num_memtable_limit: 2,\r\n            serializable: false,\r\n            bloom_false_positive_rate: 0.01,\r\n        }\r\n    }\r\n\r\n    pub fn compaction_test(compaction_options: CompactionOptions) -\u003e Self {\r\n        Self {\r\n            block_size: 4096,\r\n            target_sst_size: 1 \u003c\u003c 20, // 1MB\r\n            compaction_options,\r\n            enable_wal: false,\r\n            num_memtable_limit: 2,\r\n            serializable: false,\r\n            bloom_false_positive_rate: 0.01,\r\n        }\r\n    }\r\n\r\n\r\n    pub fn no_compaction() -\u003e Self {\r\n        Self {\r\n            block_size: 4096,\r\n            target_sst_size: 2 \u003c\u003c 20, // 2MB\r\n            num_memtable_limit: 3,\r\n            compaction_options: CompactionOptions::NoCompaction,\r\n            enable_wal: true,\r\n            bloom_false_positive_rate: 0.01,\r\n            serializable: false,\r\n        }\r\n    }\r\n    pub fn leveled_compaction() -\u003e Self {\r\n        Self {\r\n            block_size: 4096,\r\n            target_sst_size: 2 \u003c\u003c 20, // 2MB\r\n            num_memtable_limit: 3,\r\n            compaction_options: CompactionOptions::Leveled(LeveledCompactionOptions {\r\n                level0_file_num_compaction_trigger: 2,\r\n                max_levels: 4,\r\n                base_level_size_mb: 128,\r\n                level_size_multiplier: 2,\r\n            }),\r\n            enable_wal: true,\r\n            bloom_false_positive_rate: 0.01,\r\n            serializable: true,\r\n        }\r\n    }\r\n}\r\nfn range_overlap(\r\n    user_begin: Bound\u003c\u0026[u8]\u003e,\r\n    user_end: Bound\u003c\u0026[u8]\u003e,\r\n    table_begin: KeySlice,\r\n    table_end: KeySlice,\r\n) -\u003e bool {\r\n    match user_end {\r\n        Bound::Excluded(key) if key \u003c= table_begin.key_ref() =\u003e {\r\n            return false;\r\n        }\r\n        Bound::Included(key) if key \u003c table_begin.key_ref() =\u003e {\r\n            return false;\r\n        }\r\n        _ =\u003e {}\r\n    }\r\n    match user_begin {\r\n        Bound::Excluded(key) if key \u003e= table_end.key_ref() =\u003e {\r\n            return false;\r\n        }\r\n        Bound::Included(key) if key \u003e table_end.key_ref() =\u003e {\r\n            return false;\r\n        }\r\n        _ =\u003e {}\r\n    }\r\n    true\r\n}\r\n\r\nfn key_within(user_key: \u0026[u8], table_begin: KeySlice, table_end: KeySlice) -\u003e bool {\r\n    table_begin.key_ref() \u003c= user_key \u0026\u0026 user_key \u003c= table_end.key_ref()\r\n}\r\n\r\n/// The storage interface of the LSM tree.\r\npub(crate) struct LsmStorageInner {\r\n    pub(crate) state: Arc\u003cRwLock\u003cArc\u003cLsmStorageState\u003e\u003e\u003e,\r\n    pub(crate) state_lock: Mutex\u003c()\u003e,\r\n    path: PathBuf,\r\n    pub(crate) block_cache: Arc\u003cBlockCache\u003e,\r\n    next_sst_id: AtomicUsize,\r\n    pub(crate) options: Arc\u003cLsmStorageOptions\u003e,\r\n    pub(crate) compaction_controller: CompactionController,\r\n    pub(crate) manifest: Option\u003cManifest\u003e,\r\n    pub(crate) mvcc: Option\u003cLsmMvccInner\u003e,\r\n}\r\n\r\nimpl LsmStorageInner {\r\n    pub(crate) fn mvcc(\u0026self) -\u003e \u0026LsmMvccInner {\r\n        self.mvcc.as_ref().unwrap()\r\n    }\r\n\r\n    pub(crate) fn manifest(\u0026self) -\u003e \u0026Manifest {\r\n        self.manifest.as_ref().unwrap()\r\n    }\r\n    pub(crate) fn next_sst_id(\u0026self) -\u003e usize {\r\n        self.next_sst_id\r\n            .fetch_add(1, std::sync::atomic::Ordering::SeqCst)\r\n    }\r\n\r\n    /// Start the storage engine by either loading an existing directory or creating a new one if the directory does\r\n    /// not exist.\r\n    pub(crate) fn open(path: impl AsRef\u003cPath\u003e, options: LsmStorageOptions) -\u003e Result\u003cSelf\u003e {\r\n        let mut state = LsmStorageState::create(\u0026options);\r\n        let path = path.as_ref();\r\n        let mut next_sst_id = 1;\r\n        let block_cache = Arc::new(BlockCache::new(1 \u003c\u003c 20)); // 4GB block cache,\r\n        let manifest;\r\n\r\n        let compaction_controller = match \u0026options.compaction_options {\r\n            CompactionOptions::Leveled(options) =\u003e {\r\n                CompactionController::Leveled(LeveledCompactionController::new(options.clone()))\r\n            }\r\n            CompactionOptions::NoCompaction =\u003e CompactionController::NoCompaction,\r\n        };\r\n\r\n        if !path.exists() {\r\n            std::fs::create_dir_all(path).expect(\"failed to create DB dir\");\r\n        }\r\n        let mut last_commit_ts = 0;\r\n        let manifest_path = path.join(\"MANIFEST\");\r\n        if !manifest_path.exists() {\r\n            if options.enable_wal {\r\n                state.memtable = Arc::new(MemTable::create_with_wal(\r\n                    state.memtable.id(),\r\n                    Self::path_of_wal_static(path, state.memtable.id()),\r\n                )?);\r\n            }\r\n            manifest = Manifest::create(\u0026manifest_path).expect(\"failed to create manifest\");\r\n            manifest.add_record_when_init(ManifestRecord::NewMemtable(state.memtable.id()))?;\r\n        } else {\r\n            let (m, records) = Manifest::recover(\u0026manifest_path)?;\r\n            let mut memtables = BTreeSet::new();\r\n            for record in records {\r\n                match record {\r\n                    ManifestRecord::Flush(sst_id) =\u003e {\r\n                        let res = memtables.remove(\u0026sst_id);\r\n                        assert!(res, \"memtable not exist?\");\r\n                        if compaction_controller.flush_to_l0() {\r\n                            state.l0_sstables.insert(0, sst_id);\r\n                        } else {\r\n                            state.levels.insert(0, (sst_id, vec![sst_id]));\r\n                        }\r\n                        next_sst_id = next_sst_id.max(sst_id);\r\n                    }\r\n                    ManifestRecord::NewMemtable(x) =\u003e {\r\n                        next_sst_id = next_sst_id.max(x);\r\n                        memtables.insert(x);\r\n                    }\r\n                    ManifestRecord::Compaction(task, output) =\u003e {\r\n                        let (new_state, _) = compaction_controller\r\n                            .apply_compaction_result(\u0026state, \u0026task, \u0026output, true);\r\n                        // TODO: apply remove again\r\n                        state = new_state;\r\n                        next_sst_id =\r\n                            next_sst_id.max(output.iter().max().copied().unwrap_or_default());\r\n                    }\r\n                }\r\n            }\r\n\r\n            let mut sst_cnt = 0;\r\n            // recover SSTs\r\n            for table_id in state\r\n                .l0_sstables\r\n                .iter()\r\n                .chain(state.levels.iter().flat_map(|(_, files)| files))\r\n            {\r\n                let table_id = *table_id;\r\n                let sst = SsTable::open(\r\n                    table_id,\r\n                    Some(block_cache.clone()),\r\n                    FileObject::open(\u0026Self::path_of_sst_static(path, table_id))?,\r\n                )?;\r\n                last_commit_ts = last_commit_ts.max(sst.max_ts());\r\n\r\n                state.sstables.insert(table_id, Arc::new(sst));\r\n                sst_cnt += 1;\r\n            }\r\n            println!(\"{} SSTs opened\", sst_cnt);\r\n\r\n            next_sst_id += 1;\r\n\r\n            // recover memtables\r\n            if options.enable_wal {\r\n                let mut wal_cnt = 0;\r\n                for id in memtables.iter() {\r\n                    let memtable =\r\n                        MemTable::recover_from_wal(*id, Self::path_of_wal_static(path, *id))?;\r\n                    let max_ts = memtable\r\n                        .map\r\n                        .iter()\r\n                        .map(|x| x.key().ts())\r\n                        .max()\r\n                        .unwrap_or_default();\r\n                    last_commit_ts = last_commit_ts.max(max_ts);\r\n\r\n                    if !memtable.is_empty() {\r\n                        state.imm_memtables.insert(0, Arc::new(memtable));\r\n                        wal_cnt += 1;\r\n                    }\r\n                }\r\n                println!(\"{} WALs recovered\", wal_cnt);\r\n                state.memtable = Arc::new(MemTable::create_with_wal(\r\n                    next_sst_id,\r\n                    Self::path_of_wal_static(path, next_sst_id),\r\n                )?);\r\n            } else {\r\n                state.memtable = Arc::new(MemTable::create(next_sst_id));\r\n            }\r\n            m.add_record_when_init(ManifestRecord::NewMemtable(state.memtable.id()))?;\r\n            next_sst_id += 1;\r\n            manifest = m;\r\n            for (_id, ssts) in \u0026mut state.levels {\r\n                ssts.sort_by(|x, y| {\r\n                    state\r\n                        .sstables\r\n                        .get(x)\r\n                        .unwrap()\r\n                        .first_key()\r\n                        .cmp(state.sstables.get(y).unwrap().first_key())\r\n                })\r\n            }\r\n        };\r\n\r\n        let storage = Self {\r\n            state: Arc::new(RwLock::new(Arc::new(state))),\r\n            state_lock: Mutex::new(()),\r\n            path: path.to_path_buf(),\r\n            block_cache,\r\n            next_sst_id: AtomicUsize::new(next_sst_id),\r\n            compaction_controller,\r\n            manifest: Some(manifest),\r\n            options: options.into(),\r\n            mvcc: Some(LsmMvccInner::new(last_commit_ts)),\r\n        };\r\n        storage.sync_dir()?;\r\n        Ok(storage)\r\n    }\r\n\r\n    pub fn sync(\u0026self) -\u003e Result\u003c()\u003e {\r\n        self.state.read().memtable.sync_wal()\r\n    }\r\n\r\n    /// Get a key from the storage. In day 7, this can be further optimized by using a bloom filter.\r\n    pub fn get(self: \u0026Arc\u003cSelf\u003e, key: \u0026[u8]) -\u003e Result\u003cOption\u003cBytes\u003e\u003e {\r\n        let txn = self.mvcc().new_txn(self.clone(), self.options.serializable);\r\n        txn.get(key)\r\n    }\r\n    pub(crate) fn get_with_ts(\u0026self, key: \u0026[u8], read_ts: u64) -\u003e Result\u003cOption\u003cBytes\u003e\u003e {\r\n        let snapshot = {\r\n            let guard = self.state.read();\r\n            Arc::clone(\u0026guard)\r\n        }; // drop global lock here\r\n\r\n        let mut memtable_iters = Vec::with_capacity(snapshot.imm_memtables.len() + 1);\r\n        memtable_iters.push(Box::new(snapshot.memtable.scan(\r\n            Bound::Included(KeySlice::from_slice(key, key::TS_RANGE_BEGIN)),\r\n            Bound::Included(KeySlice::from_slice(key, key::TS_RANGE_END)),\r\n        )));\r\n        for memtable in snapshot.imm_memtables.iter() {\r\n            memtable_iters.push(Box::new(memtable.scan(\r\n                Bound::Included(KeySlice::from_slice(key, key::TS_RANGE_BEGIN)),\r\n                Bound::Included(KeySlice::from_slice(key, key::TS_RANGE_END)),\r\n            )));\r\n        }\r\n        let memtable_iter = MergeIterator::create(memtable_iters);\r\n\r\n        let mut l0_iters = Vec::with_capacity(snapshot.l0_sstables.len());\r\n\r\n        let keep_table = |key: \u0026[u8], table: \u0026SsTable| {\r\n            if key_within(\r\n                key,\r\n                table.first_key().as_key_slice(),\r\n                table.last_key().as_key_slice(),\r\n            ) {\r\n                if let Some(bloom) = \u0026table.bloom {\r\n                    if bloom.may_contain(farmhash::fingerprint32(key)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    return true;\r\n                }\r\n            }\r\n            false\r\n        };\r\n\r\n        for table in snapshot.l0_sstables.iter() {\r\n            let table = snapshot.sstables[table].clone();\r\n            if keep_table(key, \u0026table) {\r\n                l0_iters.push(Box::new(SsTableIterator::create_and_seek_to_key(\r\n                    table,\r\n                    KeySlice::from_slice(key, key::TS_RANGE_BEGIN),\r\n                )?));\r\n            }\r\n        }\r\n        let l0_iter = MergeIterator::create(l0_iters);\r\n        let mut level_iters = Vec::with_capacity(snapshot.levels.len());\r\n        for (_, level_sst_ids) in \u0026snapshot.levels {\r\n            let mut level_ssts = Vec::with_capacity(level_sst_ids.len());\r\n            for table in level_sst_ids {\r\n                let table = snapshot.sstables[table].clone();\r\n                if keep_table(key, \u0026table) {\r\n                    level_ssts.push(table);\r\n                }\r\n            }\r\n            let level_iter = SstConcatIterator::create_and_seek_to_key(\r\n                level_ssts,\r\n                KeySlice::from_slice(key, key::TS_RANGE_BEGIN),\r\n            )?;\r\n            level_iters.push(Box::new(level_iter));\r\n        }\r\n\r\n        let iter = LsmIterator::new(\r\n            TwoMergeIterator::create(\r\n                TwoMergeIterator::create(memtable_iter, l0_iter)?,\r\n                MergeIterator::create(level_iters),\r\n            )?,\r\n            Bound::Unbounded,\r\n            read_ts,\r\n        )?;\r\n\r\n        if iter.is_valid() \u0026\u0026 iter.key() == key \u0026\u0026 !iter.value().is_empty() {\r\n            return Ok(Some(Bytes::copy_from_slice(iter.value())));\r\n        }\r\n        Ok(None)\r\n    }\r\n\r\n    pub fn write_batch_inner\u003cT: AsRef\u003c[u8]\u003e\u003e(\u0026self, batch: \u0026[WriteBatchRecord\u003cT\u003e]) -\u003e Result\u003cu64\u003e {\r\n        let _lck = self.mvcc().write_lock.lock();\r\n        let ts = self.mvcc().latest_commit_ts() + 1;\r\n        for record in batch {\r\n            match record {\r\n                WriteBatchRecord::Del(key) =\u003e {\r\n                    let key = key.as_ref();\r\n                    assert!(!key.is_empty(), \"key cannot be empty\");\r\n                    let size;\r\n                    {\r\n                        let guard = self.state.read();\r\n                        guard.memtable.put(KeySlice::from_slice(key, ts), b\"\")?;\r\n                        size = guard.memtable.approximate_size();\r\n                    }\r\n                    self.try_freeze(size)?;\r\n                }\r\n                WriteBatchRecord::Put(key, value) =\u003e {\r\n                    let key = key.as_ref();\r\n                    let value = value.as_ref();\r\n                    assert!(!key.is_empty(), \"key cannot be empty\");\r\n                    assert!(!value.is_empty(), \"value cannot be empty\");\r\n                    let size;\r\n                    {\r\n                        let guard = self.state.read();\r\n                        guard.memtable.put(KeySlice::from_slice(key, ts), value)?;\r\n                        size = guard.memtable.approximate_size();\r\n                    }\r\n                    self.try_freeze(size)?;\r\n                }\r\n            }\r\n        }\r\n        self.mvcc().update_commit_ts(ts);\r\n        Ok(ts)\r\n    }\r\n\r\n    pub fn write_batch\u003cT: AsRef\u003c[u8]\u003e\u003e(\r\n        self: \u0026Arc\u003cSelf\u003e,\r\n        batch: \u0026[WriteBatchRecord\u003cT\u003e],\r\n    ) -\u003e Result\u003c()\u003e {\r\n        if !self.options.serializable {\r\n            self.write_batch_inner(batch)?;\r\n        } else {\r\n            let txn = self.mvcc().new_txn(self.clone(), self.options.serializable);\r\n            for record in batch {\r\n                match record {\r\n                    WriteBatchRecord::Del(key) =\u003e {\r\n                        txn.delete(key.as_ref());\r\n                    }\r\n                    WriteBatchRecord::Put(key, value) =\u003e {\r\n                        txn.put(key.as_ref(), value.as_ref());\r\n                    }\r\n                }\r\n            }\r\n            txn.commit()?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    /// Put a key-value pair into the storage by writing into the current memtable.\r\n    pub fn put(self: \u0026Arc\u003cSelf\u003e, key: \u0026[u8], value: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        if !self.options.serializable {\r\n            self.write_batch_inner(\u0026[WriteBatchRecord::Put(key, value)])?;\r\n        } else {\r\n            let txn = self.mvcc().new_txn(self.clone(), self.options.serializable);\r\n            txn.put(key, value);\r\n            txn.commit()?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    /// Remove a key from the storage by writing an empty value.\r\n    pub fn delete(self: \u0026Arc\u003cSelf\u003e, key: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        if !self.options.serializable {\r\n            self.write_batch_inner(\u0026[WriteBatchRecord::Del(key)])?;\r\n        } else {\r\n            let txn = self.mvcc().new_txn(self.clone(), self.options.serializable);\r\n            txn.delete(key);\r\n            txn.commit()?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn try_freeze(\u0026self, estimated_size: usize) -\u003e Result\u003c()\u003e {\r\n        if estimated_size \u003e= self.options.target_sst_size {\r\n            let state_lock = self.state_lock.lock();\r\n            let guard = self.state.read();\r\n            // the memtable could have already been frozen, check again to ensure we really need to freeze\r\n            if guard.memtable.approximate_size() \u003e= self.options.target_sst_size {\r\n                drop(guard);\r\n                self.force_freeze_memtable(\u0026state_lock)?;\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub(crate) fn path_of_sst_static(path: impl AsRef\u003cPath\u003e, id: usize) -\u003e PathBuf {\r\n        path.as_ref().join(format!(\"{:05}.sst\", id))\r\n    }\r\n\r\n    pub(crate) fn path_of_sst(\u0026self, id: usize) -\u003e PathBuf {\r\n        Self::path_of_sst_static(\u0026self.path, id)\r\n    }\r\n\r\n    pub(crate) fn path_of_wal_static(path: impl AsRef\u003cPath\u003e, id: usize) -\u003e PathBuf {\r\n        path.as_ref().join(format!(\"{:05}.wal\", id))\r\n    }\r\n\r\n    pub(crate) fn path_of_wal(\u0026self, id: usize) -\u003e PathBuf {\r\n        Self::path_of_wal_static(\u0026self.path, id)\r\n    }\r\n\r\n    pub(super) fn sync_dir(\u0026self) -\u003e Result\u003c()\u003e {\r\n        if let Some(manifest) = \u0026self.manifest {\r\n            manifest.sync()?;\r\n        }\r\n        self.state\r\n            .write()\r\n            .sstables\r\n            .values()\r\n            .for_each(|sstable| sstable.sync().ok().unwrap());\r\n        Ok(())\r\n    }\r\n\r\n    pub(super) fn freeze_memtable_with_memtable(\u0026self, memtable: Arc\u003cMemTable\u003e) -\u003e Result\u003c()\u003e {\r\n        let mut guard = self.state.write();\r\n        // Swap the current memtable with a new one.\r\n        let mut snapshot = guard.as_ref().clone();\r\n        let old_memtable = std::mem::replace(\u0026mut snapshot.memtable, memtable);\r\n        // Add the memtable to the immutable memtables.\r\n        snapshot.imm_memtables.insert(0, old_memtable.clone());\r\n        // Update the snapshot.\r\n        *guard = Arc::new(snapshot);\r\n\r\n        drop(guard);\r\n        old_memtable.sync_wal()?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// Force freeze the current memtable to an immutable memtable\r\n    pub fn force_freeze_memtable(\u0026self, state_lock_observer: \u0026MutexGuard\u003c'_, ()\u003e) -\u003e Result\u003c()\u003e {\r\n        let memtable_id = self.next_sst_id();\r\n        let memtable = if self.options.enable_wal {\r\n            Arc::new(MemTable::create_with_wal(\r\n                memtable_id,\r\n                self.path_of_wal(memtable_id),\r\n            )?)\r\n        } else {\r\n            Arc::new(MemTable::create(memtable_id))\r\n        };\r\n\r\n        self.freeze_memtable_with_memtable(memtable)?;\r\n\r\n        self.manifest.as_ref().unwrap().add_record(\r\n            state_lock_observer,\r\n            ManifestRecord::NewMemtable(memtable_id),\r\n        )?;\r\n        self.sync_dir()?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// Force flush the earliest-created immutable memtable to disk\r\n    pub fn force_flush_next_imm_memtable(\u0026self) -\u003e Result\u003c()\u003e {\r\n        let state_lock = self.state_lock.lock();\r\n\r\n        let flush_memtable;\r\n\r\n        {\r\n            let guard = self.state.read();\r\n            flush_memtable = guard\r\n                .imm_memtables\r\n                .last()\r\n                .expect(\"no imm memtables!\")\r\n                .clone();\r\n        }\r\n\r\n        let mut builder = SsTableBuilder::new(self.options.block_size);\r\n        flush_memtable.flush(\u0026mut builder)?;\r\n        let sst_id = flush_memtable.id();\r\n        let sst = Arc::new(builder.build(\r\n            sst_id,\r\n            Some(self.block_cache.clone()),\r\n            self.options.bloom_false_positive_rate,\r\n            self.path_of_sst(sst_id),\r\n        )?);\r\n\r\n        // Add the flushed L0 table to the list.\r\n        {\r\n            let mut guard = self.state.write();\r\n            let mut snapshot = guard.as_ref().clone();\r\n            // Remove the memtable from the immutable memtables.\r\n            let mem = snapshot.imm_memtables.pop().unwrap();\r\n            assert_eq!(mem.id(), sst_id);\r\n            // Add L0 table\r\n            if self.compaction_controller.flush_to_l0() {\r\n                // In leveled compaction or no compaction, simply flush to L0\r\n                snapshot.l0_sstables.insert(0, sst_id);\r\n            } else {\r\n                // In tiered compaction, create a new tier\r\n                snapshot.levels.insert(0, (sst_id, vec![sst_id]));\r\n            }\r\n            debug!(\"flushed {}.sst with size={}\", sst_id, sst.table_size());\r\n            snapshot.sstables.insert(sst_id, sst);\r\n            // Update the snapshot.\r\n            *guard = Arc::new(snapshot);\r\n        }\r\n\r\n        if self.options.enable_wal {\r\n            std::fs::remove_file(self.path_of_wal(sst_id))?;\r\n        }\r\n\r\n        self.manifest()\r\n            .add_record(\u0026state_lock, ManifestRecord::Flush(sst_id))?;\r\n\r\n        self.sync_dir()?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub fn new_txn(self: \u0026Arc\u003cSelf\u003e) -\u003e Result\u003cArc\u003cTransaction\u003e\u003e {\r\n        Ok(self.mvcc().new_txn(self.clone(), self.options.serializable))\r\n    }\r\n\r\n    pub fn scan\u003c'a\u003e(\r\n        self: \u0026'a Arc\u003cSelf\u003e,\r\n        lower: Bound\u003c\u0026[u8]\u003e,\r\n        upper: Bound\u003c\u0026[u8]\u003e,\r\n    ) -\u003e Result\u003cTxnIterator\u003e {\r\n        let txn = self.mvcc().new_txn(self.clone(), self.options.serializable);\r\n        txn.scan(lower, upper)\r\n    }\r\n\r\n    /// Create an iterator over a range of keys.\r\n    pub(crate) fn scan_with_ts(\r\n        \u0026self,\r\n        lower: Bound\u003c\u0026[u8]\u003e,\r\n        upper: Bound\u003c\u0026[u8]\u003e,\r\n        read_ts: u64,\r\n    ) -\u003e Result\u003cFusedIterator\u003cLsmIterator\u003e\u003e {\r\n        // println!(\r\n        //     \"scan_with_ts: {:?}\",\r\n        //     (\r\n        //         map_key_bound(map_key_bound_plus_ts(lower, key::TS_RANGE_BEGIN)),\r\n        //         map_key_bound(map_key_bound_plus_ts(upper, key::TS_RANGE_END)),\r\n        //         read_ts\r\n        //     )\r\n        // );\r\n        let snapshot = {\r\n            let guard = self.state.read();\r\n            Arc::clone(\u0026guard)\r\n        }; // drop global lock here\r\n\r\n        let mut memtable_iters = Vec::with_capacity(snapshot.imm_memtables.len() + 1);\r\n        memtable_iters.push(Box::new(snapshot.memtable.scan(\r\n            map_key_bound_plus_ts(lower, key::TS_RANGE_BEGIN),\r\n            map_key_bound_plus_ts(upper, key::TS_RANGE_END),\r\n        )));\r\n        for memtable in snapshot.imm_memtables.iter() {\r\n            memtable_iters.push(Box::new(memtable.scan(\r\n                map_key_bound_plus_ts(lower, key::TS_RANGE_BEGIN),\r\n                map_key_bound_plus_ts(upper, key::TS_RANGE_END),\r\n            )));\r\n        }\r\n        let memtable_iter = MergeIterator::create(memtable_iters);\r\n        let mut table_iters = Vec::with_capacity(snapshot.l0_sstables.len());\r\n        for table_id in snapshot.l0_sstables.iter() {\r\n            let table = snapshot.sstables[table_id].clone();\r\n            if range_overlap(\r\n                lower,\r\n                upper,\r\n                table.first_key().as_key_slice(),\r\n                table.last_key().as_key_slice(),\r\n            ) {\r\n                // println!(\"hit sst:{}\", table_id);\r\n                let iter = match lower {\r\n                    Bound::Included(key) =\u003e SsTableIterator::create_and_seek_to_key(\r\n                        table,\r\n                        KeySlice::from_slice(key, key::TS_RANGE_BEGIN),\r\n                    )?,\r\n                    Bound::Excluded(key) =\u003e {\r\n                        let mut iter = SsTableIterator::create_and_seek_to_key(\r\n                            table,\r\n                            KeySlice::from_slice(key, key::TS_RANGE_BEGIN),\r\n                        )?;\r\n                        while iter.is_valid() \u0026\u0026 iter.key().key_ref() == key {\r\n                            iter._next()?;\r\n                        }\r\n                        iter\r\n                    }\r\n\r\n                    Bound::Unbounded =\u003e SsTableIterator::create_and_seek_to_first(table)?,\r\n                };\r\n                table_iters.push(Box::new(iter));\r\n            }\r\n        }\r\n\r\n        let l0_iter = MergeIterator::create(table_iters);\r\n        let mut level_iters = Vec::with_capacity(snapshot.levels.len());\r\n        for (_, level_sst_ids) in \u0026snapshot.levels {\r\n            let mut level_ssts = Vec::with_capacity(level_sst_ids.len());\r\n            for table in level_sst_ids {\r\n                let table = snapshot.sstables[table].clone();\r\n                if range_overlap(\r\n                    lower,\r\n                    upper,\r\n                    table.first_key().as_key_slice(),\r\n                    table.last_key().as_key_slice(),\r\n                ) {\r\n                    level_ssts.push(table);\r\n                }\r\n            }\r\n\r\n            let level_iter = match lower {\r\n                Bound::Included(key) =\u003e SstConcatIterator::create_and_seek_to_key(\r\n                    level_ssts,\r\n                    KeySlice::from_slice(key, key::TS_RANGE_BEGIN),\r\n                )?,\r\n                Bound::Excluded(key) =\u003e {\r\n                    let mut iter = SstConcatIterator::create_and_seek_to_key(\r\n                        level_ssts,\r\n                        KeySlice::from_slice(key, key::TS_RANGE_BEGIN),\r\n                    )?;\r\n                    while iter.is_valid() \u0026\u0026 iter.key().key_ref() == key {\r\n                        iter._next()?;\r\n                    }\r\n                    iter\r\n                }\r\n                Bound::Unbounded =\u003e SstConcatIterator::create_and_seek_to_first(level_ssts)?,\r\n            };\r\n            level_iters.push(Box::new(level_iter));\r\n        }\r\n\r\n        let iter = TwoMergeIterator::create(memtable_iter, l0_iter)?;\r\n\r\n        let iter = TwoMergeIterator::create(iter, MergeIterator::create(level_iters))?;\r\n\r\n        let lsm_iter = LsmIterator::new(iter, map_bound(upper), read_ts)?;\r\n        Ok(FusedIterator::new(lsm_iter))\r\n    }\r\n}\r\n","traces":[{"line":55,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":9799832789158199296},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":16212958658533785853},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":8935141660703064064},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":4179340454199820288},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1152921504606846976},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":2017612633061982208},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":6773413839565225984},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":1080863910568919040},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":10520408729537478656},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":11024811887802979403},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":15780613094306221751},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":15780613094306221751},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":4251398048237750778},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":4251398048237750778},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":9799832789158199296},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":9151314442816847872},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":4251398048237748224},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":4251398048237748224},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":354,"address":[],"length":0,"stats":{"Line":4539628424389459968},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":4539628424389459968},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":4539628424389459968},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":5908722711110091865},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":3386706919782613363},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":3386706919782613363},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":3386706919782613363},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":17582052945254416384},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":17582052945254416384},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":9655717601082343424},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":10520408729537478656},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":10520408729537478656},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":10520408729537478656},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":18158513697557850262},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":8791026472627208192},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":1729382256910265477},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":4395513236313604467},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":5260204364768739699},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":5260204364768739699},"fn_name":null},{"line":399,"address":[],"length":0,"stats":{"Line":3819052484010180608},"fn_name":null},{"line":400,"address":[],"length":0,"stats":{"Line":3819052484010180608},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":3819052484010180608},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":406,"address":[],"length":0,"stats":{"Line":17582052945254416755},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":9871890383196127603},"fn_name":null},{"line":408,"address":[],"length":0,"stats":{"Line":10736581511651262464},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":2810246167479184933},"fn_name":null},{"line":411,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":10736581511651267451},"fn_name":null},{"line":417,"address":[],"length":0,"stats":{"Line":10736581511651267451},"fn_name":null},{"line":424,"address":[],"length":0,"stats":{"Line":17582052945254418241},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":17582052945254417499},"fn_name":null},{"line":427,"address":[],"length":0,"stats":{"Line":17582052945254417499},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":17582052945254417499},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":7133701809754865664},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":3458764513820540713},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":14123288431433876786},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":13474770085092524240},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":13474770085092524240},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":13474770085092524240},"fn_name":null},{"line":440,"address":[],"length":0,"stats":{"Line":14915921965851083424},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":443,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":1513209474796487117},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":18374686479671623895},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":18374686479671623895},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":18374686479671623895},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":18374686479671623899},"fn_name":null},{"line":457,"address":[],"length":0,"stats":{"Line":18374686479671623891},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":18374686479671623891},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":18374686479671623891},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":18374686479671623891},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":18374686479671623891},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":13474770085092524490},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":13474770085092524490},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":479,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":481,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":482,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":483,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":492,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":11601272640106397305},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":13402712491054596553},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":13402712491054596553},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":13402712491054596553},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":6557241057451441653},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":18230571291595767874},"fn_name":null},{"line":509,"address":[],"length":0,"stats":{"Line":18230571291595767874},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":66},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":18230571291595767811},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":18230571291595767811},"fn_name":null},{"line":514,"address":[],"length":0,"stats":{"Line":18230571291595767811},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":18230571291595767868},"fn_name":null},{"line":519,"address":[],"length":0,"stats":{"Line":1441151880758558723},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":1441151880758558723},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":2522015791327478223},"fn_name":null},{"line":522,"address":[],"length":0,"stats":{"Line":2522015791327478223},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":2522015791327478223},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":2522015791327478223},"fn_name":null},{"line":526,"address":[],"length":0,"stats":{"Line":2522015791327478223},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":1441151880758558260},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":9799832789158199296},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":9799832789158199296},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":9799832789158199296},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":9799832789158199296},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":10520408729537478656},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":10520408729537478656},"fn_name":null},{"line":544,"address":[],"length":0,"stats":{"Line":6269010681299730432},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":6269010681299730432},"fn_name":null},{"line":548,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":549,"address":[],"length":0,"stats":{"Line":8935141660703064063},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":4467570830351532033},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":4467570830351532033},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":4467570830351532033},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":9727775195120271361},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":571,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":10664523917613334528},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":4395513236313604096},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":4395513236313604096},"fn_name":null},{"line":582,"address":[],"length":0,"stats":{"Line":4395513236313604096},"fn_name":null},{"line":585,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":590,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":596,"address":[],"length":0,"stats":{"Line":5332261958806667264},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":601,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":607,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":608,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":5620492334958379008},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":11529215046068469760},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":691,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":692,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":695,"address":[],"length":0,"stats":{"Line":9583660007044415488},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":13402712491054596096},"fn_name":null},{"line":704,"address":[],"length":0,"stats":{"Line":6845471433603153920},"fn_name":null},{"line":706,"address":[],"length":0,"stats":{"Line":6845471433603153920},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":6845471433603153920},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":6845471433603153920},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":6845471433603153920},"fn_name":null},{"line":712,"address":[],"length":0,"stats":{"Line":5764607523034234880},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":715,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":735,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":736,"address":[],"length":0,"stats":{"Line":4179340454199820288},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":16068843470457929728},"fn_name":null},{"line":738,"address":[],"length":0,"stats":{"Line":1801439850948198400},"fn_name":null},{"line":746,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":13690942867206307840},"fn_name":null},{"line":752,"address":[],"length":0,"stats":{"Line":12321848580485677056},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":12321848580485677056},"fn_name":null},{"line":755,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":757,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":3098476543630901248},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":772,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null}],"covered":278,"coverable":352},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","manifest.rs"],"content":"use std::fs::{File, OpenOptions};\r\nuse std::io::{Read, Write};\r\nuse std::path::Path;\r\nuse std::sync::Arc;\r\n\r\nuse bytes::{Buf, BufMut};\r\nuse parking_lot::{Mutex, MutexGuard};\r\nuse serde::{Deserialize, Serialize};\r\nuse tracing::{error};\r\nuse crate::errors::Result;\r\n\r\nuse super::compact::CompactionTask;\r\n\r\n\r\npub struct Manifest {\r\n    file: Arc\u003cMutex\u003cFile\u003e\u003e,\r\n}\r\n\r\n#[derive(Serialize, Deserialize)]\r\npub enum ManifestRecord {\r\n    Flush(usize),\r\n    NewMemtable(usize),\r\n    Compaction(CompactionTask, Vec\u003cusize\u003e),\r\n}\r\n\r\nimpl Manifest {\r\n    pub fn create(path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cSelf\u003e {\r\n        Ok(Self {\r\n            file: Arc::new(Mutex::new(\r\n                OpenOptions::new()\r\n                    .read(true)\r\n                    .create_new(true)\r\n                    .write(true)\r\n                    .open(path)\r\n                    .expect(\"failed to create manifest\"),\r\n            )),\r\n        })\r\n    }\r\n    pub fn sync(\u0026self) -\u003e Result\u003c()\u003e {\r\n        self.file.lock().sync_all()?;\r\n        Ok(())\r\n    }\r\n    pub fn recover(path: impl AsRef\u003cPath\u003e) -\u003e Result\u003c(Self, Vec\u003cManifestRecord\u003e)\u003e {\r\n        let mut file = OpenOptions::new()\r\n            .read(true)\r\n            .append(true)\r\n            .open(path)\r\n            .expect(\"failed to recover manifest\");\r\n        let mut buf = Vec::new();\r\n        file.read_to_end(\u0026mut buf)?;\r\n        let mut buf_ptr = buf.as_slice();\r\n        let mut records = Vec::new();\r\n        while buf_ptr.has_remaining() {\r\n            let len = buf_ptr.get_u64();\r\n            let slice = \u0026buf_ptr[..len as usize];\r\n            let json = serde_json::from_slice::\u003cManifestRecord\u003e(slice).unwrap();\r\n            buf_ptr.advance(len as usize);\r\n            let checksum = buf_ptr.get_u32();\r\n            if checksum != crc32fast::hash(slice) {\r\n                error!(\"checksum mismatched!\");\r\n                panic!(\"checksum mismatched!\");\r\n            }\r\n            records.push(json);\r\n        }\r\n        Ok((\r\n            Self {\r\n                file: Arc::new(Mutex::new(file)),\r\n            },\r\n            records,\r\n        ))\r\n    }\r\n\r\n    pub fn add_record(\r\n        \u0026self,\r\n        _state_lock_observer: \u0026MutexGuard\u003c()\u003e,\r\n        record: ManifestRecord,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        self.add_record_when_init(record)\r\n    }\r\n\r\n    pub fn add_record_when_init(\u0026self, record: ManifestRecord) -\u003e Result\u003c()\u003e {\r\n        let mut file = self.file.lock();\r\n        let mut buf = serde_json::to_vec(\u0026record).unwrap();\r\n        let hash = crc32fast::hash(\u0026buf);\r\n        file.write_all(\u0026(buf.len() as u64).to_be_bytes())?;\r\n        buf.put_u32(hash);\r\n        file.write_all(\u0026buf)?;\r\n        file.sync_all()?;\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":27,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":4467570830351532033},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":4467570830351532031},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":10232178353385766912},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":10232178353385766912},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":15132094747964866560},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":15132094747964866560},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":15132094747964866560},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":15132094747964866560},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":15132094747964866560},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":15132094747964866560},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":15132094747964866560},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":15132094747964866560},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":15132094747964866560},"fn_name":null}],"covered":23,"coverable":44},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","mem_table.rs"],"content":"use std::ops::Bound;\r\nuse std::path::Path;\r\nuse std::sync::atomic::AtomicUsize;\r\nuse std::sync::Arc;\r\n\r\nuse crate::errors::Result;\r\nuse bytes::Bytes;\r\nuse crossbeam_skiplist::map::Entry;\r\nuse crossbeam_skiplist::SkipMap;\r\nuse ouroboros::self_referencing;\r\n\r\nuse super::iterators::StorageIterator;\r\nuse super::key::{KeyBytes, KeySlice, TS_DEFAULT};\r\nuse super::table::SsTableBuilder;\r\nuse super::wal::Wal;\r\n\r\n/// A basic mem-table based on crossbeam-skiplist.\r\n///\r\n/// An initial implementation of memtable is part of week 1, day 1. It will be incrementally implemented in other\r\n/// chapters of week 1 and week 2.\r\npub struct MemTable {\r\n    pub(super) map: Arc\u003cSkipMap\u003cKeyBytes, Bytes\u003e\u003e,\r\n    wal: Option\u003cWal\u003e,\r\n    id: usize,\r\n    approximate_size: Arc\u003cAtomicUsize\u003e,\r\n}\r\n\r\n/// Create a bound of `Bytes` from a bound of `\u0026[u8]`.\r\npub(crate) fn map_bound(bound: Bound\u003c\u0026[u8]\u003e) -\u003e Bound\u003cBytes\u003e {\r\n    match bound {\r\n        Bound::Included(x) =\u003e Bound::Included(Bytes::copy_from_slice(x)),\r\n        Bound::Excluded(x) =\u003e Bound::Excluded(Bytes::copy_from_slice(x)),\r\n        Bound::Unbounded =\u003e Bound::Unbounded,\r\n    }\r\n}\r\n\r\n/// Create a bound of `Bytes` from a bound of `KeySlice`.\r\npub(crate) fn map_key_bound(bound: Bound\u003cKeySlice\u003e) -\u003e Bound\u003cKeyBytes\u003e {\r\n    match bound {\r\n        Bound::Included(x) =\u003e Bound::Included(KeyBytes::from_bytes_with_ts(\r\n            Bytes::copy_from_slice(x.key_ref()),\r\n            x.ts(),\r\n        )),\r\n        Bound::Excluded(x) =\u003e Bound::Excluded(KeyBytes::from_bytes_with_ts(\r\n            Bytes::copy_from_slice(x.key_ref()),\r\n            x.ts(),\r\n        )),\r\n        Bound::Unbounded =\u003e Bound::Unbounded,\r\n    }\r\n}\r\n\r\n/// Create a bound of `Bytes` from a bound of `KeySlice`.\r\npub(crate) fn map_key_bound_plus_ts(bound: Bound\u003c\u0026[u8]\u003e, ts: u64) -\u003e Bound\u003cKeySlice\u003e {\r\n    match bound {\r\n        Bound::Included(x) =\u003e Bound::Included(KeySlice::from_slice(x, ts)),\r\n        Bound::Excluded(x) =\u003e Bound::Excluded(KeySlice::from_slice(x, ts)),\r\n        Bound::Unbounded =\u003e Bound::Unbounded,\r\n    }\r\n}\r\n\r\nimpl MemTable {\r\n    /// Create a new mem-table.\r\n    pub fn create(id: usize) -\u003e Self {\r\n        Self {\r\n            id,\r\n            map: Arc::new(SkipMap::new()),\r\n            wal: None,\r\n            approximate_size: Arc::new(AtomicUsize::new(0)),\r\n        }\r\n    }\r\n\r\n    /// Create a new mem-table with WAL\r\n    pub fn create_with_wal(id: usize, path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cSelf\u003e {\r\n        Ok(Self {\r\n            id,\r\n            map: Arc::new(SkipMap::new()),\r\n            wal: Some(Wal::create(path.as_ref())?),\r\n            approximate_size: Arc::new(AtomicUsize::new(0)),\r\n        })\r\n    }\r\n\r\n    /// Create a memtable from WAL\r\n    pub fn recover_from_wal(id: usize, path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cSelf\u003e {\r\n        let map = Arc::new(SkipMap::new());\r\n        Ok(Self {\r\n            id,\r\n            wal: Some(Wal::recover(path.as_ref(), \u0026map)?),\r\n            map,\r\n            approximate_size: Arc::new(AtomicUsize::new(0)),\r\n        })\r\n    }\r\n\r\n    /// Get a value by key.\r\n    pub fn get(\u0026self, key: KeySlice) -\u003e Option\u003cBytes\u003e {\r\n        let key_bytes = KeyBytes::from_bytes_with_ts(\r\n            Bytes::from_static(unsafe { std::mem::transmute(key.key_ref()) }),\r\n            key.ts(),\r\n        );\r\n\r\n        self.map.get(\u0026key_bytes).map(|e| e.value().clone())\r\n    }\r\n\r\n    /// Put a key-value pair into the mem-table.\r\n    pub fn put(\u0026self, key: KeySlice, value: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        let estimated_size = key.raw_len() + value.len();\r\n        self.map.insert(\r\n            key.to_key_vec().into_key_bytes(),\r\n            Bytes::copy_from_slice(value),\r\n        );\r\n        self.approximate_size\r\n            .fetch_add(estimated_size, std::sync::atomic::Ordering::Relaxed);\r\n        if let Some(ref wal) = self.wal {\r\n            wal.put(key, value)?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub fn sync_wal(\u0026self) -\u003e Result\u003c()\u003e {\r\n        if let Some(ref wal) = self.wal {\r\n            wal.sync()?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    /// Get an iterator over a range of keys.\r\n    pub fn scan(\u0026self, lower: Bound\u003cKeySlice\u003e, upper: Bound\u003cKeySlice\u003e) -\u003e MemTableIterator {\r\n        let (lower, upper) = (map_key_bound(lower), map_key_bound(upper));\r\n        let mut iter = MemTableIteratorBuilder {\r\n            map: self.map.clone(),\r\n            iter_builder: |map| map.range((lower, upper)),\r\n            item: (KeyBytes::new(), Bytes::new()),\r\n        }\r\n        .build();\r\n        let entry = iter.with_iter_mut(|iter| MemTableIterator::entry_to_item(iter.next()));\r\n        iter.with_mut(|x| *x.item = entry);\r\n        iter\r\n    }\r\n\r\n    /// Flush the mem-table to SSTable. Implement in week 1 day 6.\r\n    pub fn flush(\u0026self, builder: \u0026mut SsTableBuilder) -\u003e Result\u003c()\u003e {\r\n        for entry in self.map.iter() {\r\n            builder.add(entry.key().as_key_slice(), \u0026entry.value()[..]);\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub fn id(\u0026self) -\u003e usize {\r\n        self.id\r\n    }\r\n\r\n    pub fn approximate_size(\u0026self) -\u003e usize {\r\n        self.approximate_size\r\n            .load(std::sync::atomic::Ordering::Relaxed)\r\n    }\r\n\r\n    /// Only use this function when closing the database\r\n    pub fn is_empty(\u0026self) -\u003e bool {\r\n        self.map.is_empty()\r\n    }\r\n    pub fn for_testing_put_slice(\u0026self, key: \u0026[u8], value: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        self.put(KeySlice::from_slice(key, TS_DEFAULT), value)\r\n    }\r\n\r\n    pub fn for_testing_get_slice(\u0026self, key: \u0026[u8]) -\u003e Option\u003cBytes\u003e {\r\n        self.get(KeySlice::from_slice(key, TS_DEFAULT))\r\n    }\r\n\r\n    pub fn for_testing_scan_slice(\r\n        \u0026self,\r\n        lower: Bound\u003c\u0026[u8]\u003e,\r\n        upper: Bound\u003c\u0026[u8]\u003e,\r\n    ) -\u003e MemTableIterator {\r\n        self.scan(\r\n            map_key_bound_plus_ts(lower, TS_DEFAULT),\r\n            map_key_bound_plus_ts(upper, TS_DEFAULT),\r\n        )\r\n    }\r\n}\r\n\r\ntype SkipMapRangeIter\u003c'a\u003e = crossbeam_skiplist::map::Range\u003c\r\n    'a,\r\n    KeyBytes,\r\n    (Bound\u003cKeyBytes\u003e, Bound\u003cKeyBytes\u003e),\r\n    KeyBytes,\r\n    Bytes,\r\n\u003e;\r\n\r\n/// An iterator over a range of `SkipMap`. This is a self-referential structure and please refer to week 1, day 2\r\n/// chapter for more information.\r\n///\r\n/// This is part of week 1, day 2.\r\n#[self_referencing]\r\npub struct MemTableIterator {\r\n    /// Stores a reference to the skipmap.\r\n    map: Arc\u003cSkipMap\u003cKeyBytes, Bytes\u003e\u003e,\r\n    /// Stores a skipmap iterator that refers to the lifetime of `MemTableIterator` itself.\r\n    #[borrows(map)]\r\n    #[not_covariant]\r\n    iter: SkipMapRangeIter\u003c'this\u003e,\r\n    /// Stores the current key-value pair.\r\n    item: (KeyBytes, Bytes),\r\n}\r\n\r\nimpl MemTableIterator {\r\n    fn entry_to_item(entry: Option\u003cEntry\u003c'_, KeyBytes, Bytes\u003e\u003e) -\u003e (KeyBytes, Bytes) {\r\n        entry\r\n            .map(|x| (x.key().clone(), x.value().clone()))\r\n            .unwrap_or_else(|| (KeyBytes::new(), Bytes::new()))\r\n    }\r\n}\r\n\r\nimpl StorageIterator for MemTableIterator {\r\n    type KeyType\u003c'a\u003e = KeySlice\u003c'a\u003e;\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        \u0026self.borrow_item().1[..]\r\n    }\r\n\r\n    fn key(\u0026self) -\u003e KeySlice {\r\n        self.borrow_item().0.as_key_slice()\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        !self.borrow_item().0.is_empty()\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        let entry = self.with_iter_mut(|iter| MemTableIterator::entry_to_item(iter.next()));\r\n        self.with_mut(|x| *x.item = entry);\r\n        Ok(())\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod test {\r\n    use std::{ops::Bound, sync::Arc};\r\n    use bytes::Bytes;\r\n    use tempfile::tempdir;\r\n\r\n    use crate::storage::engine::piggykv::{\r\n        debug::{check_iter_result_by_key, check_lsm_iter_result_by_key, expect_iter_error, MockIterator}, iterators::{merge_iterator::MergeIterator, StorageIterator}, lsm_iterator::FusedIterator, lsm_storage::{LsmStorageInner, LsmStorageOptions}, mem_table::MemTable\r\n    };\r\n\r\n    #[test]\r\n    fn test_task1_memtable_get() {\r\n        let memtable = MemTable::create(0);\r\n        memtable.for_testing_put_slice(b\"key1\", b\"value1\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key2\", b\"value2\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key3\", b\"value3\").unwrap();\r\n        assert_eq!(\r\n            \u0026memtable.for_testing_get_slice(b\"key1\").unwrap()[..],\r\n            b\"value1\"\r\n        );\r\n        assert_eq!(\r\n            \u0026memtable.for_testing_get_slice(b\"key2\").unwrap()[..],\r\n            b\"value2\"\r\n        );\r\n        assert_eq!(\r\n            \u0026memtable.for_testing_get_slice(b\"key3\").unwrap()[..],\r\n            b\"value3\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task1_memtable_overwrite() {\r\n        let memtable = MemTable::create(0);\r\n        memtable.for_testing_put_slice(b\"key1\", b\"value1\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key2\", b\"value2\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key3\", b\"value3\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key1\", b\"value11\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key2\", b\"value22\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key3\", b\"value33\").unwrap();\r\n        assert_eq!(\r\n            \u0026memtable.for_testing_get_slice(b\"key1\").unwrap()[..],\r\n            b\"value11\"\r\n        );\r\n        assert_eq!(\r\n            \u0026memtable.for_testing_get_slice(b\"key2\").unwrap()[..],\r\n            b\"value22\"\r\n        );\r\n        assert_eq!(\r\n            \u0026memtable.for_testing_get_slice(b\"key3\").unwrap()[..],\r\n            b\"value33\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_storage_integration() {\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(dir.path(), LsmStorageOptions::default()).unwrap());\r\n        assert_eq!(\u0026storage.get(b\"0\").unwrap(), \u0026None);\r\n        storage.put(b\"1\", b\"233\").unwrap();\r\n        storage.put(b\"2\", b\"2333\").unwrap();\r\n        storage.put(b\"3\", b\"23333\").unwrap();\r\n        assert_eq!(\u0026storage.get(b\"1\").unwrap().unwrap()[..], b\"233\");\r\n        assert_eq!(\u0026storage.get(b\"2\").unwrap().unwrap()[..], b\"2333\");\r\n        assert_eq!(\u0026storage.get(b\"3\").unwrap().unwrap()[..], b\"23333\");\r\n        storage.delete(b\"2\").unwrap();\r\n        assert!(storage.get(b\"2\").unwrap().is_none());\r\n        storage.delete(b\"0\").unwrap(); // should NOT report any error\r\n    }\r\n\r\n    #[test]\r\n    fn test_task3_storage_integration() {\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(dir.path(), LsmStorageOptions::default()).unwrap());\r\n        storage.put(b\"1\", b\"233\").unwrap();\r\n        storage.put(b\"2\", b\"2333\").unwrap();\r\n        storage.put(b\"3\", b\"23333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        assert_eq!(storage.state.read().imm_memtables.len(), 1);\r\n        let previous_approximate_size = storage.state.read().imm_memtables[0].approximate_size();\r\n        assert!(previous_approximate_size \u003e= 15);\r\n        storage.put(b\"1\", b\"2333\").unwrap();\r\n        storage.put(b\"2\", b\"23333\").unwrap();\r\n        storage.put(b\"3\", b\"233333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        assert_eq!(storage.state.read().imm_memtables.len(), 2);\r\n        assert!(\r\n            storage.state.read().imm_memtables[1].approximate_size() == previous_approximate_size,\r\n            \"wrong order of memtables?\"\r\n        );\r\n        assert!(\r\n            storage.state.read().imm_memtables[0].approximate_size() \u003e previous_approximate_size\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task3_freeze_on_capacity() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default();\r\n        options.target_sst_size = 1024;\r\n        options.num_memtable_limit = 1000;\r\n        let storage = Arc::new(LsmStorageInner::open(dir.path(), options).unwrap());\r\n        for _ in 0..1000 {\r\n            storage.put(b\"1\", b\"2333\").unwrap();\r\n        }\r\n        let num_imm_memtables = storage.state.read().imm_memtables.len();\r\n        assert!(num_imm_memtables \u003e= 1, \"no memtable frozen?\");\r\n        for _ in 0..1000 {\r\n            storage.delete(b\"1\").unwrap();\r\n        }\r\n        assert!(\r\n            storage.state.read().imm_memtables.len() \u003e num_imm_memtables,\r\n            \"no more memtable frozen?\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task4_storage_integration() {\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(dir.path(), LsmStorageOptions::default()).unwrap());\r\n        assert_eq!(\u0026storage.get(b\"0\").unwrap(), \u0026None);\r\n        storage.put(b\"1\", b\"233\").unwrap();\r\n        storage.put(b\"2\", b\"2333\").unwrap();\r\n        storage.put(b\"3\", b\"23333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        storage.delete(b\"1\").unwrap();\r\n        storage.delete(b\"2\").unwrap();\r\n        storage.put(b\"3\", b\"2333\").unwrap();\r\n        storage.put(b\"4\", b\"23333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        storage.put(b\"1\", b\"233333\").unwrap();\r\n        storage.put(b\"3\", b\"233333\").unwrap();\r\n        assert_eq!(storage.state.read().imm_memtables.len(), 2);\r\n        assert_eq!(\u0026storage.get(b\"1\").unwrap().unwrap()[..], b\"233333\");\r\n        assert_eq!(\u0026storage.get(b\"2\").unwrap(), \u0026None);\r\n        assert_eq!(\u0026storage.get(b\"3\").unwrap().unwrap()[..], b\"233333\");\r\n        assert_eq!(\u0026storage.get(b\"4\").unwrap().unwrap()[..], b\"23333\");\r\n    }\r\n    #[test]\r\n    fn test_task1_memtable_iter() {\r\n        use std::ops::Bound;\r\n        let memtable = MemTable::create(0);\r\n        memtable.for_testing_put_slice(b\"key1\", b\"value1\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key2\", b\"value2\").unwrap();\r\n        memtable.for_testing_put_slice(b\"key3\", b\"value3\").unwrap();\r\n\r\n        {\r\n            let mut iter = memtable.for_testing_scan_slice(Bound::Unbounded, Bound::Unbounded);\r\n            assert_eq!(iter.key().for_testing_key_ref(), b\"key1\");\r\n            assert_eq!(iter.value(), b\"value1\");\r\n            assert!(iter.is_valid());\r\n            iter._next().unwrap();\r\n            assert_eq!(iter.key().for_testing_key_ref(), b\"key2\");\r\n            assert_eq!(iter.value(), b\"value2\");\r\n            assert!(iter.is_valid());\r\n            iter._next().unwrap();\r\n            assert_eq!(iter.key().for_testing_key_ref(), b\"key3\");\r\n            assert_eq!(iter.value(), b\"value3\");\r\n            assert!(iter.is_valid());\r\n            iter._next().unwrap();\r\n            assert!(!iter.is_valid());\r\n        }\r\n\r\n        {\r\n            let mut iter =\r\n                memtable.for_testing_scan_slice(Bound::Included(b\"key1\"), Bound::Included(b\"key2\"));\r\n            assert_eq!(iter.key().for_testing_key_ref(), b\"key1\");\r\n            assert_eq!(iter.value(), b\"value1\");\r\n            assert!(iter.is_valid());\r\n            iter._next().unwrap();\r\n            assert_eq!(iter.key().for_testing_key_ref(), b\"key2\");\r\n            assert_eq!(iter.value(), b\"value2\");\r\n            assert!(iter.is_valid());\r\n            iter._next().unwrap();\r\n            assert!(!iter.is_valid());\r\n        }\r\n\r\n        {\r\n            let mut iter =\r\n                memtable.for_testing_scan_slice(Bound::Excluded(b\"key1\"), Bound::Excluded(b\"key3\"));\r\n            assert_eq!(iter.key().for_testing_key_ref(), b\"key2\");\r\n            assert_eq!(iter.value(), b\"value2\");\r\n            assert!(iter.is_valid());\r\n            iter._next().unwrap();\r\n            assert!(!iter.is_valid());\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_task1_empty_memtable_iter() {\r\n        use std::ops::Bound;\r\n        let memtable = MemTable::create(0);\r\n        {\r\n            let iter =\r\n                memtable.for_testing_scan_slice(Bound::Excluded(b\"key1\"), Bound::Excluded(b\"key3\"));\r\n            assert!(!iter.is_valid());\r\n        }\r\n        {\r\n            let iter =\r\n                memtable.for_testing_scan_slice(Bound::Included(b\"key1\"), Bound::Included(b\"key2\"));\r\n            assert!(!iter.is_valid());\r\n        }\r\n        {\r\n            let iter = memtable.for_testing_scan_slice(Bound::Unbounded, Bound::Unbounded);\r\n            assert!(!iter.is_valid());\r\n        }\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_merge_1() {\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n            (Bytes::from(\"e\"), Bytes::new()),\r\n        ]);\r\n        let i2 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.2\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n        ]);\r\n        let i3 = MockIterator::new(vec![\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.3\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.3\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"4.3\")),\r\n        ]);\r\n\r\n        let mut iter = MergeIterator::create(vec![\r\n            Box::new(i1.clone()),\r\n            Box::new(i2.clone()),\r\n            Box::new(i3.clone()),\r\n        ]);\r\n\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n                (Bytes::from(\"d\"), Bytes::from(\"4.2\")),\r\n                (Bytes::from(\"e\"), Bytes::new()),\r\n            ],\r\n        );\r\n\r\n        let mut iter = MergeIterator::create(vec![Box::new(i3), Box::new(i1), Box::new(i2)]);\r\n\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.3\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.3\")),\r\n                (Bytes::from(\"d\"), Bytes::from(\"4.3\")),\r\n                (Bytes::from(\"e\"), Bytes::new()),\r\n            ],\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_merge_2() {\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n        ]);\r\n        let i2 = MockIterator::new(vec![\r\n            (Bytes::from(\"d\"), Bytes::from(\"1.2\")),\r\n            (Bytes::from(\"e\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"f\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"g\"), Bytes::from(\"4.2\")),\r\n        ]);\r\n        let i3 = MockIterator::new(vec![\r\n            (Bytes::from(\"h\"), Bytes::from(\"1.3\")),\r\n            (Bytes::from(\"i\"), Bytes::from(\"2.3\")),\r\n            (Bytes::from(\"j\"), Bytes::from(\"3.3\")),\r\n            (Bytes::from(\"k\"), Bytes::from(\"4.3\")),\r\n        ]);\r\n        let i4 = MockIterator::new(vec![]);\r\n        let result = vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n            (Bytes::from(\"d\"), Bytes::from(\"1.2\")),\r\n            (Bytes::from(\"e\"), Bytes::from(\"2.2\")),\r\n            (Bytes::from(\"f\"), Bytes::from(\"3.2\")),\r\n            (Bytes::from(\"g\"), Bytes::from(\"4.2\")),\r\n            (Bytes::from(\"h\"), Bytes::from(\"1.3\")),\r\n            (Bytes::from(\"i\"), Bytes::from(\"2.3\")),\r\n            (Bytes::from(\"j\"), Bytes::from(\"3.3\")),\r\n            (Bytes::from(\"k\"), Bytes::from(\"4.3\")),\r\n        ];\r\n\r\n        let mut iter = MergeIterator::create(vec![\r\n            Box::new(i1.clone()),\r\n            Box::new(i2.clone()),\r\n            Box::new(i3.clone()),\r\n            Box::new(i4.clone()),\r\n        ]);\r\n        check_iter_result_by_key(\u0026mut iter, result.clone());\r\n\r\n        let mut iter = MergeIterator::create(vec![\r\n            Box::new(i2.clone()),\r\n            Box::new(i4.clone()),\r\n            Box::new(i3.clone()),\r\n            Box::new(i1.clone()),\r\n        ]);\r\n        check_iter_result_by_key(\u0026mut iter, result.clone());\r\n\r\n        let mut iter =\r\n            MergeIterator::create(vec![Box::new(i4), Box::new(i3), Box::new(i2), Box::new(i1)]);\r\n        check_iter_result_by_key(\u0026mut iter, result);\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_merge_empty() {\r\n        let mut iter = MergeIterator::\u003cMockIterator\u003e::create(vec![]);\r\n        check_iter_result_by_key(\u0026mut iter, vec![]);\r\n\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n        ]);\r\n        let i2 = MockIterator::new(vec![]);\r\n        let mut iter = MergeIterator::\u003cMockIterator\u003e::create(vec![Box::new(i1), Box::new(i2)]);\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n            ],\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_merge_error() {\r\n        let mut iter = MergeIterator::\u003cMockIterator\u003e::create(vec![]);\r\n        check_iter_result_by_key(\u0026mut iter, vec![]);\r\n\r\n        let i1 = MockIterator::new(vec![\r\n            (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n            (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n        ]);\r\n        let i2 = MockIterator::new_with_error(\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"2.1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"3.1\")),\r\n            ],\r\n            1,\r\n        );\r\n        let iter = MergeIterator::\u003cMockIterator\u003e::create(vec![\r\n            Box::new(i1.clone()),\r\n            Box::new(i1),\r\n            Box::new(i2),\r\n        ]);\r\n        // your implementation should correctly throw an error instead of panic\r\n        expect_iter_error(iter);\r\n    }\r\n\r\n    #[test]\r\n    fn test_task3_fused_iterator() {\r\n        let iter = MockIterator::new(vec![]);\r\n        let mut fused_iter = FusedIterator::new(iter);\r\n        assert!(!fused_iter.is_valid());\r\n        fused_iter._next().unwrap();\r\n        fused_iter._next().unwrap();\r\n        fused_iter._next().unwrap();\r\n        assert!(!fused_iter.is_valid());\r\n\r\n        let iter = MockIterator::new_with_error(\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n                (Bytes::from(\"a\"), Bytes::from(\"1.1\")),\r\n            ],\r\n            1,\r\n        );\r\n        let mut fused_iter = FusedIterator::new(iter);\r\n        assert!(fused_iter.is_valid());\r\n        assert!(fused_iter._next().is_err());\r\n        assert!(!fused_iter.is_valid());\r\n        assert!(fused_iter._next().is_err());\r\n        assert!(fused_iter._next().is_err());\r\n    }\r\n\r\n    #[test]\r\n    fn test_task4_integration() {\r\n        let dir = tempdir().unwrap();\r\n        let storage =\r\n            Arc::new(LsmStorageInner::open(dir.path(), LsmStorageOptions::default()).unwrap());\r\n        storage.put(b\"1\", b\"233\").unwrap();\r\n        storage.put(b\"2\", b\"2333\").unwrap();\r\n        storage.put(b\"3\", b\"23333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        storage.delete(b\"1\").unwrap();\r\n        storage.delete(b\"2\").unwrap();\r\n        storage.put(b\"3\", b\"2333\").unwrap();\r\n        storage.put(b\"4\", b\"23333\").unwrap();\r\n        storage\r\n            .force_freeze_memtable(\u0026storage.state_lock.lock())\r\n            .unwrap();\r\n        storage.put(b\"1\", b\"233333\").unwrap();\r\n        storage.put(b\"3\", b\"233333\").unwrap();\r\n        {\r\n            let mut iter = storage.scan(Bound::Unbounded, Bound::Unbounded).unwrap();\r\n            check_lsm_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![\r\n                    (Bytes::from_static(b\"1\"), Bytes::from_static(b\"233333\")),\r\n                    (Bytes::from_static(b\"3\"), Bytes::from_static(b\"233333\")),\r\n                    (Bytes::from_static(b\"4\"), Bytes::from_static(b\"23333\")),\r\n                ],\r\n            );\r\n            assert!(!iter.is_valid());\r\n            iter._next().unwrap();\r\n            iter._next().unwrap();\r\n            iter._next().unwrap();\r\n            assert!(!iter.is_valid());\r\n        }\r\n        {\r\n            let mut iter = storage\r\n                .scan(Bound::Included(b\"2\"), Bound::Included(b\"3\"))\r\n                .unwrap();\r\n            check_lsm_iter_result_by_key(\r\n                \u0026mut iter,\r\n                vec![(Bytes::from_static(b\"3\"), Bytes::from_static(b\"233333\"))],\r\n            );\r\n            assert!(!iter.is_valid());\r\n            iter._next().unwrap();\r\n            iter._next().unwrap();\r\n            iter._next().unwrap();\r\n            assert!(!iter.is_valid());\r\n        }\r\n    }\r\n}\r\n","traces":[{"line":29,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":10520408729537478655},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":1152921504606846977},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":3602879701896396800},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":3602879701896396800},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":13258597302978739479},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":13258597302978739479},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":13258597302978739479},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":1585267068834415337},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":1585267068834415337},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1585267068834415337},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":17005592192950992896},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":17005592192950992896},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":7205759403792793600},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":8791026472627207729},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":72},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":2305843009213694805},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":16068843470457929728},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":11024811887802974208},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":11024811887802974208},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":11024811887802974208},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":14627691589699371008},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":11024811887802974208},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":14627691589699371380},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":14627691589699371380},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":11024811887802974208},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":2810246167479189876},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":8142508126285857140},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":2666130979403333632},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":2810246167479189935},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":4179340454199820289},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":4179340454199820289},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":4179340454199820289},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":216172782113784271},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":216172782113784271},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":8863084066665136128},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":14267403619509731700},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":11601272640106397710},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":12105675798371893628},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":12105675798371893628},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":6917529027641081898},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":6917529027641081898},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":1224979098644775777},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":1224979098644775777},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":16285016252571715555},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":11961560610296041779},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":11961560610296041421},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":16285016252571715555},"fn_name":null}],"covered":86,"coverable":94},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","mod.rs"],"content":"pub mod block;\r\npub mod compact;\r\nmod debug;\r\npub mod iterators;\r\npub mod key;\r\npub mod lsm_iterator;\r\npub mod lsm_storage;\r\npub mod manifest;\r\npub mod mem_table;\r\npub mod mvcc;\r\npub mod table;\r\npub mod wal;\r\n\r\nuse std::{ops::Bound, path::Path, sync::Arc};\r\n\r\nuse bytes::Bytes;\r\nuse parking_lot::Mutex;\r\n\r\nuse self::{\r\n    lsm_storage::{LsmStorageInner, LsmStorageOptions, WriteBatchRecord},\r\n    mem_table::MemTable,\r\n    mvcc::txn::{Transaction, TxnIterator},\r\n};\r\n\r\nuse crate::errors::Result;\r\n\r\n/// A thin wrapper for `LsmStorageInner` and the user interface .\r\npub struct PiggyKV {\r\n    pub(crate) inner: Arc\u003cLsmStorageInner\u003e,\r\n    /// Notifies the L0 flush thread to stop working. (In week 1 day 6)\r\n    flush_notifier: crossbeam_channel::Sender\u003c()\u003e,\r\n    /// The handle for the compaction thread. (In week 1 day 6)\r\n    flush_thread: Mutex\u003cOption\u003cstd::thread::JoinHandle\u003c()\u003e\u003e\u003e,\r\n    /// Notifies the compaction thread to stop working. (In week 2)\r\n    compaction_notifier: crossbeam_channel::Sender\u003c()\u003e,\r\n    /// The handle for the compaction thread. (In week 2)\r\n    compaction_thread: Mutex\u003cOption\u003cstd::thread::JoinHandle\u003c()\u003e\u003e\u003e,\r\n}\r\n\r\nimpl Drop for PiggyKV {\r\n    fn drop(\u0026mut self) {\r\n        // println!(\"drop\");\r\n        self.compaction_notifier.send(()).ok();\r\n        self.flush_notifier.send(()).ok();\r\n    }\r\n}\r\n\r\nimpl PiggyKV {\r\n    pub fn close(\u0026self) -\u003e Result\u003c()\u003e {\r\n        self.inner.sync_dir()?;\r\n        self.compaction_notifier.send(()).ok();\r\n        self.flush_notifier.send(()).ok();\r\n\r\n        let mut compaction_thread = self.compaction_thread.lock();\r\n        if let Some(compaction_thread) = compaction_thread.take() {\r\n            compaction_thread.join().unwrap();\r\n        }\r\n        let mut flush_thread = self.flush_thread.lock();\r\n        if let Some(flush_thread) = flush_thread.take() {\r\n            flush_thread.join().unwrap();\r\n        }\r\n        if self.inner.options.enable_wal {\r\n            self.inner.sync()?;\r\n            self.inner.sync_dir()?;\r\n            return Ok(());\r\n        }\r\n\r\n        // create memtable and skip updating manifest\r\n        if !self.inner.state.read().memtable.is_empty() {\r\n            self.inner\r\n                .freeze_memtable_with_memtable(Arc::new(MemTable::create(\r\n                    self.inner.next_sst_id(),\r\n                )))?;\r\n        }\r\n\r\n        while {\r\n            let snapshot = self.inner.state.read();\r\n            !snapshot.imm_memtables.is_empty()\r\n        } {\r\n            self.inner.force_flush_next_imm_memtable()?;\r\n        }\r\n        self.inner.sync_dir()?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    /// Start the storage engine by either loading an existing directory or creating a new one if the directory does\r\n    /// not exist.\r\n    pub fn open(path: impl AsRef\u003cPath\u003e, options: LsmStorageOptions) -\u003e Result\u003cArc\u003cSelf\u003e\u003e {\r\n        let inner = Arc::new(LsmStorageInner::open(path, options)?);\r\n        let (tx1, rx) = crossbeam_channel::unbounded();\r\n        let compaction_thread = inner.spawn_compaction_thread(rx)?;\r\n        let (tx2, rx) = crossbeam_channel::unbounded();\r\n        let flush_thread = inner.spawn_flush_thread(rx)?;\r\n        Ok(Arc::new(Self {\r\n            inner,\r\n            flush_notifier: tx2,\r\n            flush_thread: Mutex::new(flush_thread),\r\n            compaction_notifier: tx1,\r\n            compaction_thread: Mutex::new(compaction_thread),\r\n        }))\r\n    }\r\n\r\n    pub fn get(\u0026self, key: \u0026[u8]) -\u003e Result\u003cOption\u003cBytes\u003e\u003e {\r\n        self.inner.get(key)\r\n    }\r\n\r\n    pub fn write_batch\u003cT: AsRef\u003c[u8]\u003e\u003e(\u0026self, batch: \u0026[WriteBatchRecord\u003cT\u003e]) -\u003e Result\u003c()\u003e {\r\n        self.inner.write_batch(batch)\r\n    }\r\n\r\n    pub fn put(self: \u0026Arc\u003cSelf\u003e, key: \u0026[u8], value: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        self.inner.put(key, value)\r\n    }\r\n    pub fn delete(self: \u0026Arc\u003cSelf\u003e, key: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        self.inner.delete(key)\r\n    }\r\n    pub fn sync(\u0026self) -\u003e Result\u003c()\u003e {\r\n        self.inner.sync()\r\n    }\r\n\r\n    pub fn new_txn(self: \u0026Arc\u003cSelf\u003e) -\u003e Result\u003cArc\u003cTransaction\u003e\u003e {\r\n        self.inner.new_txn()\r\n    }\r\n\r\n    pub fn scan(\u0026self, lower: Bound\u003c\u0026[u8]\u003e, upper: Bound\u003c\u0026[u8]\u003e) -\u003e Result\u003cTxnIterator\u003e {\r\n        self.inner.scan(lower, upper)\r\n    }\r\n\r\n    /// Only call this in test cases due to race conditions\r\n    pub fn force_flush(\u0026self) -\u003e Result\u003c()\u003e {\r\n        if !self.inner.state.read().memtable.is_empty() {\r\n            self.inner\r\n                .force_freeze_memtable(\u0026self.inner.state_lock.lock())?;\r\n        }\r\n        if !self.inner.state.read().imm_memtables.is_empty() {\r\n            self.inner.force_flush_next_imm_memtable()?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    pub fn force_full_compaction(\u0026self) -\u003e Result\u003c()\u003e {\r\n        self.inner.force_full_compaction()\r\n    }\r\n}\r\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":4035225266123964858},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":4035225266123964858},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":4035225266123964858},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4035225266123964416},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":2954361355555045747},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2954361355555045747},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":288230376151712158},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":288230376151712158},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":11457157452030541824},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":11457157452030541824},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null}],"covered":46,"coverable":57},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","mvcc","txn.rs"],"content":"#![allow(unused_variables)] // TODO(you): remove this lint after implementing this mod\r\n#![allow(dead_code)] // TODO(you): remove this lint after implementing this mod\r\n\r\nuse std::{\r\n    collections::HashSet,\r\n    ops::Bound,\r\n    sync::{\r\n        atomic::{AtomicBool, Ordering},\r\n        Arc,\r\n    },\r\n};\r\n\r\nuse bytes::Bytes;\r\nuse crossbeam_skiplist::{map::Entry, SkipMap};\r\nuse itertools::Itertools;\r\nuse ouroboros::self_referencing;\r\nuse parking_lot::Mutex;\r\nuse tracing::error;\r\n\r\nuse super::CommittedTxnData;\r\nuse crate::errors::{DatabaseError, Result};\r\nuse crate::storage::engine::piggykv::{\r\n    iterators::{two_merge_iterator::TwoMergeIterator, StorageIterator},\r\n    lsm_iterator::{FusedIterator, LsmIterator},\r\n    lsm_storage::{LsmStorageInner, WriteBatchRecord},\r\n    mem_table::map_bound,\r\n};\r\n\r\npub struct Transaction {\r\n    pub(crate) read_ts: u64,\r\n    pub(crate) inner: Arc\u003cLsmStorageInner\u003e,\r\n    pub(crate) local_storage: Arc\u003cSkipMap\u003cBytes, Bytes\u003e\u003e,\r\n    pub(crate) committed: Arc\u003cAtomicBool\u003e,\r\n    /// Write set and read set\r\n    pub(crate) key_hashes: Option\u003cMutex\u003c(HashSet\u003cu32\u003e, HashSet\u003cu32\u003e)\u003e\u003e,\r\n}\r\n\r\nimpl Transaction {\r\n    pub fn get(\u0026self, key: \u0026[u8]) -\u003e Result\u003cOption\u003cBytes\u003e\u003e {\r\n        if self.committed.load(Ordering::SeqCst) {\r\n            error!(\"cannot operate on committed txn!\");\r\n            return Err(DatabaseError::InternalError(\r\n                \"cannot operate on committed txn!\".to_string(),\r\n            ));\r\n        }\r\n        if let Some(guard) = \u0026self.key_hashes {\r\n            let mut guard = guard.lock();\r\n            let (_, read_set) = \u0026mut *guard;\r\n            read_set.insert(farmhash::hash32(key));\r\n        }\r\n        if let Some(entry) = self.local_storage.get(key) {\r\n            if entry.value().is_empty() {\r\n                return Ok(None);\r\n            } else {\r\n                return Ok(Some(entry.value().clone()));\r\n            }\r\n        }\r\n        self.inner.get_with_ts(key, self.read_ts)\r\n    }\r\n\r\n    pub fn scan(self: \u0026Arc\u003cSelf\u003e, lower: Bound\u003c\u0026[u8]\u003e, upper: Bound\u003c\u0026[u8]\u003e) -\u003e Result\u003cTxnIterator\u003e {\r\n        if self.committed.load(Ordering::SeqCst) {\r\n            panic!(\"cannot operate on committed txn!\");\r\n        }\r\n        let mut local_iter = TxnLocalIteratorBuilder {\r\n            map: self.local_storage.clone(),\r\n            iter_builder: |map| map.range((map_bound(lower), map_bound(upper))),\r\n            item: (Bytes::new(), Bytes::new()),\r\n        }\r\n        .build();\r\n        let entry = local_iter.with_iter_mut(|iter| TxnLocalIterator::entry_to_item(iter.next()));\r\n        local_iter.with_mut(|x| *x.item = entry);\r\n        let inner_scan = self.inner.scan_with_ts(lower, upper, self.read_ts)?;\r\n\r\n        let iter = TwoMergeIterator::create(local_iter, inner_scan)?;\r\n        TxnIterator::create(self.clone(), iter)\r\n    }\r\n\r\n    pub fn put(\u0026self, key: \u0026[u8], value: \u0026[u8]) {\r\n        if self.committed.load(Ordering::SeqCst) {\r\n            panic!(\"cannot operate on committed txn!\");\r\n        }\r\n        self.local_storage\r\n            .insert(Bytes::copy_from_slice(key), Bytes::copy_from_slice(value));\r\n        if let Some(key_hashes) = \u0026self.key_hashes {\r\n            let mut key_hashes = key_hashes.lock();\r\n            let (write_hashes, _) = \u0026mut *key_hashes;\r\n            write_hashes.insert(farmhash::hash32(key));\r\n        }\r\n    }\r\n\r\n    pub fn delete(\u0026self, key: \u0026[u8]) {\r\n        if self.committed.load(Ordering::SeqCst) {\r\n            panic!(\"cannot operate on committed txn!\");\r\n        }\r\n        self.local_storage\r\n            .insert(Bytes::copy_from_slice(key), Bytes::new());\r\n        if let Some(key_hashes) = \u0026self.key_hashes {\r\n            let mut key_hashes = key_hashes.lock();\r\n            let (write_hashes, _) = \u0026mut *key_hashes;\r\n            write_hashes.insert(farmhash::hash32(key));\r\n        }\r\n    }\r\n\r\n    pub fn commit(\u0026self) -\u003e Result\u003c()\u003e {\r\n        self.committed\r\n            .compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)\r\n            .expect(\"cannot operate on committed txn!\");\r\n        let _commit_lock = self.inner.mvcc().commit_lock.lock();\r\n        let serializability_check;\r\n        if let Some(guard) = \u0026self.key_hashes {\r\n            let guard = guard.lock();\r\n            let (write_set, read_set) = \u0026*guard;\r\n            // println!(\r\n            //     \"commit txn {}: write_set: {:?}, read_set: {:?}\",\r\n            //     self.read_ts,write_set, read_set\r\n            // );\r\n            if !write_set.is_empty() {\r\n                let committed_txns = self.inner.mvcc().committed_txns.lock();\r\n                for (_, txn_data) in committed_txns.range((self.read_ts + 1)..) {\r\n\r\n                    for key_hash in read_set {\r\n                        if txn_data.key_hashes.contains(key_hash) {\r\n                            return Err(DatabaseError::Serialization);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            serializability_check = true;\r\n        } else {\r\n            serializability_check = false;\r\n        }\r\n        let batch = self\r\n            .local_storage\r\n            .iter()\r\n            .map(|entry| {\r\n                if entry.value().is_empty() {\r\n                    WriteBatchRecord::Del(entry.key().clone())\r\n                } else {\r\n                    WriteBatchRecord::Put(entry.key().clone(), entry.value().clone())\r\n                }\r\n            })\r\n            .collect::\u003cVec\u003c_\u003e\u003e();\r\n        let ts = self.inner.write_batch_inner(\u0026batch)?;\r\n        if serializability_check {\r\n            let mut committed_txns = self.inner.mvcc().committed_txns.lock();\r\n            let mut key_hashes = self.key_hashes.as_ref().unwrap().lock();\r\n            let (write_set, _) = \u0026mut *key_hashes;\r\n\r\n            let old_data = committed_txns.insert(\r\n                ts,\r\n                CommittedTxnData {\r\n                    key_hashes: std::mem::take(write_set),\r\n                    read_ts: self.read_ts,\r\n                    commit_ts: ts,\r\n                },\r\n            );\r\n            assert!(old_data.is_none());\r\n\r\n            // remove unneeded txn data\r\n            let watermark = self.inner.mvcc().watermark();\r\n            while let Some(entry) = committed_txns.first_entry() {\r\n                if *entry.key() \u003c watermark {\r\n                    entry.remove();\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n    pub fn debug(\u0026self) {\r\n        let snapshot = {\r\n            let guard = self.inner.state.write();\r\n            guard\r\n        };\r\n        for sst in snapshot.l0_sstables.iter() {\r\n            println!(\r\n                \"l0 sst: {:?},first_key:{:?},last_key:{:?}\",\r\n                sst,\r\n                snapshot.sstables[sst].first_key(),\r\n                snapshot.sstables[sst].last_key()\r\n            );\r\n        }\r\n        for level in snapshot.levels.iter() {\r\n            for sst in level.1.iter() {\r\n                println!(\r\n                    \"l{} sst: {:?},first_key:{:?},last_key:{:?}\",\r\n                    level.0,\r\n                    sst,\r\n                    snapshot.sstables[sst].first_key(),\r\n                    snapshot.sstables[sst].last_key()\r\n                );\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nimpl Drop for Transaction {\r\n    fn drop(\u0026mut self) {\r\n        self.inner.mvcc().ts.lock().1.remove_reader(self.read_ts)\r\n    }\r\n}\r\n\r\ntype SkipMapRangeIter\u003c'a\u003e =\r\n    crossbeam_skiplist::map::Range\u003c'a, Bytes, (Bound\u003cBytes\u003e, Bound\u003cBytes\u003e), Bytes, Bytes\u003e;\r\n\r\nimpl TxnLocalIterator {\r\n    fn entry_to_item(entry: Option\u003cEntry\u003c'_, Bytes, Bytes\u003e\u003e) -\u003e (Bytes, Bytes) {\r\n        entry\r\n            .map(|x| (x.key().clone(), x.value().clone()))\r\n            .unwrap_or_else(|| (Bytes::new(), Bytes::new()))\r\n    }\r\n}\r\n#[self_referencing]\r\npub struct TxnLocalIterator {\r\n    /// Stores a reference to the skipmap.\r\n    map: Arc\u003cSkipMap\u003cBytes, Bytes\u003e\u003e,\r\n    /// Stores a skipmap iterator that refers to the lifetime of `MemTableIterator` itself.\r\n    #[borrows(map)]\r\n    #[not_covariant]\r\n    iter: SkipMapRangeIter\u003c'this\u003e,\r\n    /// Stores the current key-value pair.\r\n    item: (Bytes, Bytes),\r\n}\r\n\r\nimpl StorageIterator for TxnLocalIterator {\r\n    type KeyType\u003c'a\u003e = \u0026'a [u8];\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        \u0026self.borrow_item().1[..]\r\n    }\r\n\r\n    fn key(\u0026self) -\u003e \u0026[u8] {\r\n        \u0026self.borrow_item().0[..]\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        !self.borrow_item().0.is_empty()\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        let entry = self.with_iter_mut(|iter| TxnLocalIterator::entry_to_item(iter.next()));\r\n        self.with_mut(|x| *x.item = entry);\r\n        Ok(())\r\n    }\r\n}\r\n\r\npub struct TxnIterator {\r\n    txn: Arc\u003cTransaction\u003e,\r\n    iter: TwoMergeIterator\u003cTxnLocalIterator, FusedIterator\u003cLsmIterator\u003e\u003e,\r\n}\r\n\r\nimpl TxnIterator {\r\n    pub fn create(\r\n        txn: Arc\u003cTransaction\u003e,\r\n        iter: TwoMergeIterator\u003cTxnLocalIterator, FusedIterator\u003cLsmIterator\u003e\u003e,\r\n    ) -\u003e Result\u003cSelf\u003e {\r\n        let mut iter = Self { txn, iter };\r\n\r\n        iter.skip_deletes()?;\r\n        if iter.is_valid() {\r\n            iter.add_to_read_set(iter.key());\r\n        }\r\n        Ok(iter)\r\n    }\r\n\r\n    fn skip_deletes(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        while self.iter.is_valid() \u0026\u0026 self.iter.value().is_empty() {\r\n            println!(\"skip key={}\", String::from_utf8(self.iter.key().to_vec())?);\r\n            if !self.iter.value().is_empty() {\r\n                println!(\"val={}\", String::from_utf8(self.iter.value().to_vec())?);\r\n            }\r\n            self.iter._next()?;\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn add_to_read_set(\u0026self, key: \u0026[u8]) {\r\n        if let Some(guard) = \u0026self.txn.key_hashes {\r\n            let mut guard = guard.lock();\r\n            let (_, read_set) = \u0026mut *guard;\r\n            read_set.insert(farmhash::hash32(key));\r\n        }\r\n    }\r\n}\r\n\r\nimpl StorageIterator for TxnIterator {\r\n    type KeyType\u003c'a\u003e = \u0026'a [u8] where Self: 'a;\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        self.iter.value()\r\n    }\r\n\r\n    fn key(\u0026self) -\u003e Self::KeyType\u003c'_\u003e {\r\n        self.iter.key()\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        self.iter.is_valid()\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        self.iter._next()?;\r\n        self.skip_deletes()?;\r\n        if self.is_valid() {\r\n            self.add_to_read_set(self.key());\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn num_active_iterators(\u0026self) -\u003e usize {\r\n        self.iter.num_active_iterators()\r\n    }\r\n}\r\n\r\nimpl Iterator for TxnIterator {\r\n    type Item = (Bytes, Bytes);\r\n\r\n    fn next(\u0026mut self) -\u003e Option\u003cSelf::Item\u003e {\r\n        if self.is_valid() {\r\n            let key = Bytes::copy_from_slice(self.key());\r\n            let val = Bytes::copy_from_slice(self.value());\r\n            self._next().ok();\r\n            Some((key, val))\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use std::ops::Bound;\r\n\r\n    use bytes::Bytes;\r\n    use tempfile::tempdir;\r\n\r\n    use crate::storage::engine::piggykv::{\r\n        compact::CompactionOptions, debug::check_lsm_iter_result_by_key,\r\n        iterators::StorageIterator, lsm_storage::LsmStorageOptions, PiggyKV,\r\n    };\r\n\r\n    #[test]\r\n    fn test_txn_integration() {\r\n        let dir = tempdir().unwrap();\r\n        let options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        let txn1 = storage.new_txn().unwrap();\r\n        let txn2 = storage.new_txn().unwrap();\r\n        txn1.put(b\"test1\", b\"233\");\r\n        txn2.put(b\"test2\", b\"233\");\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut txn1.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![(Bytes::from(\"test1\"), Bytes::from(\"233\"))],\r\n        );\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut txn2.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![(Bytes::from(\"test2\"), Bytes::from(\"233\"))],\r\n        );\r\n        let txn3 = storage.new_txn().unwrap();\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut txn3.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![],\r\n        );\r\n        txn1.commit().unwrap();\r\n        txn2.commit().unwrap();\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut txn3.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![],\r\n        );\r\n        drop(txn3);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut storage.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"test1\"), Bytes::from(\"233\")),\r\n                (Bytes::from(\"test2\"), Bytes::from(\"233\")),\r\n            ],\r\n        );\r\n        let txn4 = storage.new_txn().unwrap();\r\n        assert_eq!(txn4.get(b\"test1\").unwrap(), Some(Bytes::from(\"233\")));\r\n        assert_eq!(txn4.get(b\"test2\").unwrap(), Some(Bytes::from(\"233\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut txn4.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"test1\"), Bytes::from(\"233\")),\r\n                (Bytes::from(\"test2\"), Bytes::from(\"233\")),\r\n            ],\r\n        );\r\n        txn4.put(b\"test2\", b\"2333\");\r\n        assert_eq!(txn4.get(b\"test1\").unwrap(), Some(Bytes::from(\"233\")));\r\n        assert_eq!(txn4.get(b\"test2\").unwrap(), Some(Bytes::from(\"2333\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut txn4.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"test1\"), Bytes::from(\"233\")),\r\n                (Bytes::from(\"test2\"), Bytes::from(\"2333\")),\r\n            ],\r\n        );\r\n        txn4.delete(b\"test2\");\r\n        assert_eq!(txn4.get(b\"test1\").unwrap(), Some(Bytes::from(\"233\")));\r\n        assert_eq!(txn4.get(b\"test2\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut txn4.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![(Bytes::from(\"test1\"), Bytes::from(\"233\"))],\r\n        );\r\n    }\r\n    #[test]\r\n    fn test_serializable_1() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        options.serializable = true;\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        storage.put(b\"key1\", b\"1\").unwrap();\r\n        storage.put(b\"key2\", b\"2\").unwrap();\r\n        let txn1 = storage.new_txn().unwrap();\r\n        let txn2 = storage.new_txn().unwrap();\r\n        txn1.put(b\"key1\", \u0026txn1.get(b\"key2\").unwrap().unwrap());\r\n        txn2.put(b\"key2\", \u0026txn2.get(b\"key1\").unwrap().unwrap());\r\n        txn1.commit().unwrap();\r\n        assert!(txn2.commit().is_err());\r\n        drop(txn2);\r\n        assert_eq!(storage.get(b\"key1\").unwrap(), Some(Bytes::from(\"2\")));\r\n        assert_eq!(storage.get(b\"key2\").unwrap(), Some(Bytes::from(\"2\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_serializable_2() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        options.serializable = true;\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        let txn1 = storage.new_txn().unwrap();\r\n        let txn2 = storage.new_txn().unwrap();\r\n        txn1.put(b\"key1\", b\"1\");\r\n        txn2.put(b\"key1\", b\"2\");\r\n        txn1.commit().unwrap();\r\n        txn2.commit().unwrap();\r\n        assert_eq!(storage.get(b\"key1\").unwrap(), Some(Bytes::from(\"2\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_serializable_3_ts_range() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        options.serializable = true;\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        storage.put(b\"key1\", b\"1\").unwrap();\r\n        storage.put(b\"key2\", b\"2\").unwrap();\r\n        let txn1 = storage.new_txn().unwrap();\r\n        txn1.put(b\"key1\", \u0026txn1.get(b\"key2\").unwrap().unwrap());\r\n        txn1.commit().unwrap();\r\n        let txn2 = storage.new_txn().unwrap();\r\n        txn2.put(b\"key2\", \u0026txn2.get(b\"key1\").unwrap().unwrap());\r\n        txn2.commit().unwrap();\r\n        drop(txn2);\r\n        assert_eq!(storage.get(b\"key1\").unwrap(), Some(Bytes::from(\"2\")));\r\n        assert_eq!(storage.get(b\"key2\").unwrap(), Some(Bytes::from(\"2\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_serializable_4_scan() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        options.serializable = true;\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        storage.put(b\"key1\", b\"1\").unwrap();\r\n        storage.put(b\"key2\", b\"2\").unwrap();\r\n        let txn1 = storage.new_txn().unwrap();\r\n        let txn2 = storage.new_txn().unwrap();\r\n        txn1.put(b\"key1\", \u0026txn1.get(b\"key2\").unwrap().unwrap());\r\n        txn1.commit().unwrap();\r\n        let iter = txn2.scan(Bound::Unbounded, Bound::Unbounded).unwrap();\r\n        let consume = iter.count();\r\n\r\n        assert_eq!(consume, 2);\r\n        txn2.put(b\"key2\", b\"1\");\r\n        assert!(txn2.commit().is_err());\r\n        drop(txn2);\r\n        assert_eq!(storage.get(b\"key1\").unwrap(), Some(Bytes::from(\"2\")));\r\n        assert_eq!(storage.get(b\"key2\").unwrap(), Some(Bytes::from(\"2\")));\r\n    }\r\n\r\n    #[test]\r\n    fn test_serializable_5_read_only() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        options.serializable = true;\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        storage.put(b\"key1\", b\"1\").unwrap();\r\n        storage.put(b\"key2\", b\"2\").unwrap();\r\n        let txn1 = storage.new_txn().unwrap();\r\n        txn1.put(b\"key1\", \u0026txn1.get(b\"key2\").unwrap().unwrap());\r\n        txn1.commit().unwrap();\r\n        let txn2 = storage.new_txn().unwrap();\r\n        txn2.get(b\"key1\").unwrap().unwrap();\r\n        let iter = txn2.scan(Bound::Unbounded, Bound::Unbounded).unwrap();\r\n        let _ = iter.count();\r\n        txn2.commit().unwrap();\r\n        assert_eq!(storage.get(b\"key1\").unwrap(), Some(Bytes::from(\"2\")));\r\n        assert_eq!(storage.get(b\"key2\").unwrap(), Some(Bytes::from(\"2\")));\r\n    }\r\n}\r\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":17726168133330272256},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":17726168133330272256},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":742},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":371},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":371},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":15636497906230361741},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":17870283321406127386},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":17582052945254416384},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":13114482114902884352},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":68},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":6989586621679009724},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":6989586621679009724},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6773413839565225916},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":4},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":1441151880758558716},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1441151880758558716},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":1369094286720630780},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":3314649325744684985},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":17582052945254416313},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":144115188075855943},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":1585267068834414663},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1585267068834414663},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":9295429630892703815},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":7710162562058289152},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":1369094286720630856},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":6341068275337658296},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":1585267068834414663},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":1441151880758558650},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":8502796096475496590},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":12033618204333965383},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":12033618204333965383},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1585267068834414663},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":12249790986447749120},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":12249790986447749120},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":6989586621679009792},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":14411518807585587204},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":432345564227568048},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":1297036692682703712},"fn_name":null},{"line":245,"address":[],"length":0,"stats":{"Line":1297036692682703712},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":432345564227568048},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":6557241057451442246},"fn_name":null},{"line":260,"address":[],"length":0,"stats":{"Line":6557241057451442246},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":6557241057451442246},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":12682136550675316806},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":6557241057451442176},"fn_name":null},{"line":269,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":13258597302978740656},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":144115188075856304},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":2},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":72057594037927937},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":12465963768561532928},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":8646911284551352105},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":12105675798371893462},"fn_name":null},{"line":293,"address":[],"length":0,"stats":{"Line":12105675798371893462},"fn_name":null},{"line":296,"address":[],"length":0,"stats":{"Line":7566047373982433495},"fn_name":null},{"line":297,"address":[],"length":0,"stats":{"Line":7566047373982433495},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":2017612633061982639},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":2017612633061982639},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":12538021362599461296},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":12538021362599461511},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":12538021362599461081},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":432345564227567833},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":6341068275337658368},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":12538021362599461079},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":12538021362599460864},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":12538021362599460864},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":9727775195120271360},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":9727775195120271360},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":9727775195120271360},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":9727775195120271360},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null}],"covered":117,"coverable":134},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","mvcc","watermark.rs"],"content":"#![allow(unused_variables)] // TODO(you): remove this lint after implementing this mod\r\n#![allow(dead_code)] // TODO(you): remove this lint after implementing this mod\r\n\r\nuse std::collections::BTreeMap;\r\n\r\npub struct Watermark {\r\n    readers: BTreeMap\u003cu64, usize\u003e,\r\n}\r\n\r\nimpl Watermark {\r\n    pub fn new() -\u003e Self {\r\n        Self {\r\n            readers: BTreeMap::new(),\r\n        }\r\n    }\r\n\r\n    pub fn add_reader(\u0026mut self, ts: u64) {\r\n        *self.readers.entry(ts).or_default() += 1;\r\n    }\r\n\r\n    pub fn remove_reader(\u0026mut self, ts: u64) {\r\n        let cnt = self.readers.get_mut(\u0026ts).unwrap();\r\n        *cnt -= 1;\r\n        if *cnt == 0 {\r\n            self.readers.remove(\u0026ts);\r\n        }\r\n    }\r\n    pub fn num_retained_snapshots(\u0026self) -\u003e usize {\r\n        self.readers.len()\r\n    }\r\n\r\n    pub fn watermark(\u0026self) -\u003e Option\u003cu64\u003e {\r\n        self.readers.first_key_value().map(|(ts, _)| *ts)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use crate::storage::engine::piggykv::{compact::CompactionOptions, debug::{check_iter_result_by_key, construct_merge_iterator_over_storage}, lsm_storage::{LsmStorageOptions, WriteBatchRecord}, mvcc::watermark::Watermark, PiggyKV};\r\n    use bytes::Bytes;\r\n    use tempfile::tempdir;\r\n\r\n    #[test]\r\n    fn test_task1_watermark() {\r\n        let mut watermark = Watermark::new();\r\n        watermark.add_reader(0);\r\n        for i in 1..=1000 {\r\n            watermark.add_reader(i);\r\n            assert_eq!(watermark.watermark(), Some(0));\r\n            assert_eq!(watermark.num_retained_snapshots(), i as usize + 1);\r\n        }\r\n        let mut cnt = 1001;\r\n        for i in 0..500 {\r\n            watermark.remove_reader(i);\r\n            assert_eq!(watermark.watermark(), Some(i + 1));\r\n            cnt -= 1;\r\n            assert_eq!(watermark.num_retained_snapshots(), cnt);\r\n        }\r\n        for i in (501..=1000).rev() {\r\n            watermark.remove_reader(i);\r\n            assert_eq!(watermark.watermark(), Some(500));\r\n            cnt -= 1;\r\n            assert_eq!(watermark.num_retained_snapshots(), cnt);\r\n        }\r\n        watermark.remove_reader(500);\r\n        assert_eq!(watermark.watermark(), None);\r\n        assert_eq!(watermark.num_retained_snapshots(), 0);\r\n        watermark.add_reader(2000);\r\n        watermark.add_reader(2000);\r\n        watermark.add_reader(2001);\r\n        assert_eq!(watermark.num_retained_snapshots(), 2);\r\n        assert_eq!(watermark.watermark(), Some(2000));\r\n        watermark.remove_reader(2000);\r\n        assert_eq!(watermark.num_retained_snapshots(), 2);\r\n        assert_eq!(watermark.watermark(), Some(2000));\r\n        watermark.remove_reader(2000);\r\n        assert_eq!(watermark.num_retained_snapshots(), 1);\r\n        assert_eq!(watermark.watermark(), Some(2001));\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_snapshot_watermark() {\r\n        let dir = tempdir().unwrap();\r\n        let options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        let txn1 = storage.new_txn().unwrap();\r\n        let txn2 = storage.new_txn().unwrap();\r\n        storage.put(b\"233\", b\"23333\").unwrap();\r\n        let txn3 = storage.new_txn().unwrap();\r\n        assert_eq!(storage.inner.mvcc().watermark(), txn1.read_ts);\r\n        drop(txn1);\r\n        assert_eq!(storage.inner.mvcc().watermark(), txn2.read_ts);\r\n        drop(txn2);\r\n        assert_eq!(storage.inner.mvcc().watermark(), txn3.read_ts);\r\n        drop(txn3);\r\n        assert_eq!(\r\n            storage.inner.mvcc().watermark(),\r\n            storage.inner.mvcc().latest_commit_ts()\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task3_mvcc_compaction() {\r\n        let dir = tempdir().unwrap();\r\n        let options = LsmStorageOptions::default_for_mvcc_test(CompactionOptions::NoCompaction);\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        let snapshot0 = storage.new_txn().unwrap();\r\n        storage\r\n            .write_batch(\u0026[\r\n                WriteBatchRecord::Put(b\"a\", b\"1\"),\r\n                WriteBatchRecord::Put(b\"b\", b\"1\"),\r\n            ])\r\n            .unwrap();\r\n        let snapshot1 = storage.new_txn().unwrap();\r\n        storage\r\n            .write_batch(\u0026[\r\n                WriteBatchRecord::Put(b\"a\", b\"2\"),\r\n                WriteBatchRecord::Put(b\"d\", b\"2\"),\r\n            ])\r\n            .unwrap();\r\n        let snapshot2 = storage.new_txn().unwrap();\r\n        storage\r\n            .write_batch(\u0026[\r\n                WriteBatchRecord::Put(b\"a\", b\"3\"),\r\n                WriteBatchRecord::Del(b\"d\"),\r\n            ])\r\n            .unwrap();\r\n        let snapshot3 = storage.new_txn().unwrap();\r\n        storage\r\n            .write_batch(\u0026[\r\n                WriteBatchRecord::Put(b\"c\", b\"4\"),\r\n                WriteBatchRecord::Del(b\"a\"),\r\n            ])\r\n            .unwrap();\r\n\r\n        storage.force_flush().unwrap();\r\n        storage.force_full_compaction().unwrap();\r\n\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.inner.state.read());\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::new()),\r\n                (Bytes::from(\"a\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"a\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"4\")),\r\n                (Bytes::from(\"d\"), Bytes::new()),\r\n                (Bytes::from(\"d\"), Bytes::from(\"2\")),\r\n            ],\r\n        );\r\n\r\n        drop(snapshot0);\r\n        storage.force_full_compaction().unwrap();\r\n\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.inner.state.read());\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::new()),\r\n                (Bytes::from(\"a\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"a\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"4\")),\r\n                (Bytes::from(\"d\"), Bytes::new()),\r\n                (Bytes::from(\"d\"), Bytes::from(\"2\")),\r\n            ],\r\n        );\r\n\r\n        drop(snapshot1);\r\n        storage.force_full_compaction().unwrap();\r\n\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.inner.state.read());\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::new()),\r\n                (Bytes::from(\"a\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"4\")),\r\n                (Bytes::from(\"d\"), Bytes::new()),\r\n                (Bytes::from(\"d\"), Bytes::from(\"2\")),\r\n            ],\r\n        );\r\n\r\n        drop(snapshot2);\r\n        storage.force_full_compaction().unwrap();\r\n\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.inner.state.read());\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::new()),\r\n                (Bytes::from(\"a\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"4\")),\r\n            ],\r\n        );\r\n\r\n        drop(snapshot3);\r\n        storage.force_full_compaction().unwrap();\r\n\r\n        let mut iter = construct_merge_iterator_over_storage(\u0026storage.inner.state.read());\r\n        check_iter_result_by_key(\r\n            \u0026mut iter,\r\n            vec![\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"4\")),\r\n            ],\r\n        );\r\n    }\r\n}\r\n","traces":[{"line":11,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":13,"address":[],"length":0,"stats":{"Line":4971973988617027584},"fn_name":null},{"line":17,"address":[],"length":0,"stats":{"Line":10808639105689190400},"fn_name":null},{"line":18,"address":[],"length":0,"stats":{"Line":10808639105689190400},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":10736581511651262910},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":10736581511651262910},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":10736581511651262910},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":1369094286720631676},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":9079256848778920382},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":15276209936040722878},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":15276209936040722878},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":648518346341351431},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":144115188075855886},"fn_name":null}],"covered":13,"coverable":13},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","mvcc.rs"],"content":"pub mod txn;\r\nmod watermark;\r\n\r\nuse std::{\r\n    collections::{BTreeMap, HashSet},\r\n    sync::{atomic::AtomicBool, Arc},\r\n};\r\n\r\nuse crossbeam_skiplist::SkipMap;\r\nuse parking_lot::Mutex;\r\n\r\nuse self::{txn::Transaction, watermark::Watermark};\r\n\r\nuse super::lsm_storage::LsmStorageInner;\r\n\r\npub(crate) struct CommittedTxnData {\r\n    pub(crate) key_hashes: HashSet\u003cu32\u003e,\r\n    #[allow(dead_code)]\r\n    pub(crate) read_ts: u64,\r\n    #[allow(dead_code)]\r\n    pub(crate) commit_ts: u64,\r\n}\r\n\r\npub(crate) struct LsmMvccInner {\r\n    pub(crate) write_lock: Mutex\u003c()\u003e,\r\n    pub(crate) commit_lock: Mutex\u003c()\u003e,\r\n\r\n    pub(crate) ts: Arc\u003cMutex\u003c(u64, Watermark)\u003e\u003e,\r\n    pub(crate) committed_txns: Arc\u003cMutex\u003cBTreeMap\u003cu64, CommittedTxnData\u003e\u003e\u003e,\r\n}\r\n\r\nimpl LsmMvccInner {\r\n    pub fn new(initial_ts: u64) -\u003e Self {\r\n        Self {\r\n            write_lock: Mutex::new(()),\r\n            commit_lock: Mutex::new(()),\r\n\r\n            ts: Arc::new(Mutex::new((initial_ts, Watermark::new()))),\r\n            committed_txns: Arc::new(Mutex::new(BTreeMap::new())),\r\n        }\r\n    }\r\n\r\n    pub fn latest_commit_ts(\u0026self) -\u003e u64 {\r\n        self.ts.lock().0\r\n    }\r\n\r\n    pub fn update_commit_ts(\u0026self, ts: u64) {\r\n        self.ts.lock().0 = ts;\r\n    }\r\n\r\n    /// All ts (strictly) below this ts can be garbage collected.\r\n    pub fn watermark(\u0026self) -\u003e u64 {\r\n        let ts = self.ts.lock();\r\n        ts.1.watermark().unwrap_or(ts.0)\r\n    }\r\n\r\n    pub fn new_txn(\u0026self, inner: Arc\u003cLsmStorageInner\u003e, serializable: bool) -\u003e Arc\u003cTransaction\u003e {\r\n        let mut ts = self.ts.lock();\r\n        let read_ts = ts.0;\r\n        ts.1.add_reader(read_ts);\r\n\r\n        Arc::new(Transaction {\r\n            inner,\r\n            read_ts,\r\n            local_storage: Arc::new(SkipMap::new()),\r\n            committed: Arc::new(AtomicBool::new(false)),\r\n            key_hashes: if serializable {\r\n                Some(Mutex::new((HashSet::new(), HashSet::new())))\r\n            } else {\r\n                None\r\n            },\r\n        })\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n\r\n    use std::{ops::Bound, sync::Arc, time::Duration};\r\n\r\n    use bytes::Bytes;\r\n    use tempfile::tempdir;\r\n\r\n    use crate::storage::engine::piggykv::{\r\n        compact::CompactionOptions,\r\n        debug::{\r\n            check_iter_result_by_key_and_ts, check_lsm_iter_result_by_key, dump_files_in_dir,\r\n            generate_sst_with_ts,\r\n        },\r\n        key::KeySlice,\r\n        lsm_storage::LsmStorageOptions,\r\n        table::{FileObject, SsTable, SsTableBuilder, SsTableIterator},\r\n        PiggyKV,\r\n    };\r\n\r\n    #[test]\r\n    fn test_sst_build_multi_version_simple() {\r\n        let mut builder = SsTableBuilder::new(16);\r\n        builder.add(\r\n            KeySlice::for_testing_from_slice_with_ts(b\"233\", 233),\r\n            b\"233333\",\r\n        );\r\n        builder.add(\r\n            KeySlice::for_testing_from_slice_with_ts(b\"233\", 0),\r\n            b\"2333333\",\r\n        );\r\n        let dir = tempdir().unwrap();\r\n        builder.build_for_test(dir.path().join(\"1.sst\")).unwrap();\r\n    }\r\n\r\n    fn generate_test_data() -\u003e Vec\u003c((Bytes, u64), Bytes)\u003e {\r\n        (0..100)\r\n            .map(|id| {\r\n                (\r\n                    (Bytes::from(format!(\"key{:05}\", id / 5)), 5 - (id % 5)),\r\n                    Bytes::from(format!(\"value{:05}\", id)),\r\n                )\r\n            })\r\n            .collect()\r\n    }\r\n\r\n    #[test]\r\n    fn test_sst_build_multi_version_hard() {\r\n        let dir = tempdir().unwrap();\r\n        let data = generate_test_data();\r\n        generate_sst_with_ts(1, dir.path().join(\"1.sst\"), data.clone(), None);\r\n        let sst = Arc::new(\r\n            SsTable::open(\r\n                1,\r\n                None,\r\n                FileObject::open(\u0026dir.path().join(\"1.sst\")).unwrap(),\r\n            )\r\n            .unwrap(),\r\n        );\r\n        check_iter_result_by_key_and_ts(\r\n            \u0026mut SsTableIterator::create_and_seek_to_first(sst).unwrap(),\r\n            data,\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_memtable_mvcc() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default();\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        storage.put(b\"a\", b\"1\").unwrap();\r\n        storage.put(b\"b\", b\"1\").unwrap();\r\n        let snapshot1 = storage.new_txn().unwrap();\r\n        storage.put(b\"a\", b\"2\").unwrap();\r\n        let snapshot2 = storage.new_txn().unwrap();\r\n        storage.delete(b\"b\").unwrap();\r\n        storage.put(b\"c\", b\"1\").unwrap();\r\n        let snapshot3 = storage.new_txn().unwrap();\r\n        assert_eq!(snapshot1.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot1.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot2.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot2.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot2.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot2.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot3.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot3.get(b\"b\").unwrap(), None);\r\n        assert_eq!(snapshot3.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot3.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        storage\r\n            .inner\r\n            .force_freeze_memtable(\u0026storage.inner.state_lock.lock())\r\n            .unwrap();\r\n        storage.put(b\"a\", b\"3\").unwrap();\r\n        storage.put(b\"b\", b\"3\").unwrap();\r\n        let snapshot4 = storage.new_txn().unwrap();\r\n        storage.put(b\"a\", b\"4\").unwrap();\r\n        let snapshot5 = storage.new_txn().unwrap();\r\n        storage.delete(b\"b\").unwrap();\r\n        storage.put(b\"c\", b\"5\").unwrap();\r\n        let snapshot6 = storage.new_txn().unwrap();\r\n        assert_eq!(snapshot1.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot1.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot2.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot2.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot2.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot2.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot3.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot3.get(b\"b\").unwrap(), None);\r\n        assert_eq!(snapshot3.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot3.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot4.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"3\")));\r\n        assert_eq!(snapshot4.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"3\")));\r\n        assert_eq!(snapshot4.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot4.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot5.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"4\")));\r\n        assert_eq!(snapshot5.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"3\")));\r\n        assert_eq!(snapshot5.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot5.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"4\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot6.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"4\")));\r\n        assert_eq!(snapshot6.get(b\"b\").unwrap(), None);\r\n        assert_eq!(snapshot6.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"5\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot6.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"4\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"5\")),\r\n            ],\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task2_lsm_iterator_mvcc() {\r\n        let dir = tempdir().unwrap();\r\n        let mut options = LsmStorageOptions::default();\r\n        let storage = PiggyKV::open(\u0026dir, options.clone()).unwrap();\r\n        storage.put(b\"a\", b\"1\").unwrap();\r\n        storage.put(b\"b\", b\"1\").unwrap();\r\n        let snapshot1 = storage.new_txn().unwrap();\r\n        storage.put(b\"a\", b\"2\").unwrap();\r\n        let snapshot2 = storage.new_txn().unwrap();\r\n        storage.delete(b\"b\").unwrap();\r\n        storage.put(b\"c\", b\"1\").unwrap();\r\n        let snapshot3 = storage.new_txn().unwrap();\r\n        storage.force_flush().unwrap();\r\n        assert_eq!(snapshot1.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot1.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot2.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot2.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot2.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot2.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot3.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot3.get(b\"b\").unwrap(), None);\r\n        assert_eq!(snapshot3.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot3.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        storage.put(b\"a\", b\"3\").unwrap();\r\n        storage.put(b\"b\", b\"3\").unwrap();\r\n        let snapshot4 = storage.new_txn().unwrap();\r\n        storage.put(b\"a\", b\"4\").unwrap();\r\n        let snapshot5 = storage.new_txn().unwrap();\r\n        storage.delete(b\"b\").unwrap();\r\n        storage.put(b\"c\", b\"5\").unwrap();\r\n        let snapshot6 = storage.new_txn().unwrap();\r\n        storage.force_flush().unwrap();\r\n        assert_eq!(snapshot1.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot1.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot1.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"1\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot2.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot2.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        assert_eq!(snapshot2.get(b\"c\").unwrap(), None);\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot2.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot3.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"2\")));\r\n        assert_eq!(snapshot3.get(b\"b\").unwrap(), None);\r\n        assert_eq!(snapshot3.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot3.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"2\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot4.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"3\")));\r\n        assert_eq!(snapshot4.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"3\")));\r\n        assert_eq!(snapshot4.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot4.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot5.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"4\")));\r\n        assert_eq!(snapshot5.get(b\"b\").unwrap(), Some(Bytes::from_static(b\"3\")));\r\n        assert_eq!(snapshot5.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"1\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot5.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"4\")),\r\n                (Bytes::from(\"b\"), Bytes::from(\"3\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"1\")),\r\n            ],\r\n        );\r\n        assert_eq!(snapshot6.get(b\"a\").unwrap(), Some(Bytes::from_static(b\"4\")));\r\n        assert_eq!(snapshot6.get(b\"b\").unwrap(), None);\r\n        assert_eq!(snapshot6.get(b\"c\").unwrap(), Some(Bytes::from_static(b\"5\")));\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot6.scan(Bound::Unbounded, Bound::Unbounded).unwrap(),\r\n            vec![\r\n                (Bytes::from(\"a\"), Bytes::from(\"4\")),\r\n                (Bytes::from(\"c\"), Bytes::from(\"5\")),\r\n            ],\r\n        );\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot6\r\n                .scan(Bound::Included(b\"a\"), Bound::Included(b\"a\"))\r\n                .unwrap(),\r\n            vec![(Bytes::from(\"a\"), Bytes::from(\"4\"))],\r\n        );\r\n        check_lsm_iter_result_by_key(\r\n            \u0026mut snapshot6\r\n                .scan(Bound::Excluded(b\"a\"), Bound::Excluded(b\"c\"))\r\n                .unwrap(),\r\n            vec![],\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_task3_sst_ts() {\r\n        let mut builder = SsTableBuilder::new(16);\r\n        builder.add(KeySlice::for_testing_from_slice_with_ts(b\"11\", 1), b\"11\");\r\n        builder.add(KeySlice::for_testing_from_slice_with_ts(b\"22\", 2), b\"22\");\r\n        builder.add(KeySlice::for_testing_from_slice_with_ts(b\"33\", 3), b\"11\");\r\n        builder.add(KeySlice::for_testing_from_slice_with_ts(b\"44\", 4), b\"22\");\r\n        builder.add(KeySlice::for_testing_from_slice_with_ts(b\"55\", 5), b\"11\");\r\n        builder.add(KeySlice::for_testing_from_slice_with_ts(b\"66\", 6), b\"22\");\r\n        let dir = tempdir().unwrap();\r\n        let sst = builder.build_for_test(dir.path().join(\"1.sst\")).unwrap();\r\n        assert_eq!(sst.max_ts(), 6);\r\n    }\r\n\r\n\r\n\r\n\r\n}\r\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":13546827679130451968},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":13546827679130451968},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":13474770085092524493},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":13474770085092524493},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3819052484010181069},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":3819052484010181069},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":3819052484010181069},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":12249790986447749191},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":9583660007044415930},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":2666130979403333261},"fn_name":null}],"covered":24,"coverable":24},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","table","bloom.rs"],"content":"// Copyright 2021 TiKV Project Authors. Licensed under Apache-2.0.\r\nuse crate::errors::Result;\r\n\r\nuse bytes::{Buf, BufMut, Bytes, BytesMut};\r\n\r\n/// Implements a bloom filter\r\npub struct Bloom {\r\n    /// data of filter in bits\r\n    pub(crate) filter: Bytes,\r\n    /// number of hash functions\r\n    pub(crate) k: u8,\r\n}\r\n\r\npub trait BitSlice {\r\n    fn get_bit(\u0026self, idx: usize) -\u003e bool;\r\n    fn bit_len(\u0026self) -\u003e usize;\r\n}\r\n\r\npub trait BitSliceMut {\r\n    fn set_bit(\u0026mut self, idx: usize, val: bool);\r\n}\r\n\r\nimpl\u003cT: AsRef\u003c[u8]\u003e\u003e BitSlice for T {\r\n    fn get_bit(\u0026self, idx: usize) -\u003e bool {\r\n        let pos = idx / 8;\r\n        let offset = idx % 8;\r\n        (self.as_ref()[pos] \u0026 (1 \u003c\u003c offset)) != 0\r\n    }\r\n\r\n    fn bit_len(\u0026self) -\u003e usize {\r\n        self.as_ref().len() * 8\r\n    }\r\n}\r\n\r\nimpl\u003cT: AsMut\u003c[u8]\u003e\u003e BitSliceMut for T {\r\n    fn set_bit(\u0026mut self, idx: usize, val: bool) {\r\n        let pos = idx / 8;\r\n        let offset = idx % 8;\r\n        if val {\r\n            self.as_mut()[pos] |= 1 \u003c\u003c offset;\r\n        } else {\r\n            self.as_mut()[pos] \u0026= !(1 \u003c\u003c offset);\r\n        }\r\n    }\r\n}\r\n\r\nimpl Bloom {\r\n    /// Decode a bloom filter\r\n    pub fn decode(buf: \u0026[u8]) -\u003e Result\u003cSelf\u003e {\r\n        let checksum = (\u0026buf[buf.len() - 4..buf.len()]).get_u32();\r\n        if checksum != crc32fast::hash(\u0026buf[..buf.len() - 4]) {\r\n            panic!(\"checksum mismatched for bloom filters\");\r\n        }\r\n        let filter = \u0026buf[..buf.len() - 5];\r\n        let k = buf[buf.len() - 5];\r\n        Ok(Self {\r\n            filter: filter.to_vec().into(),\r\n            k,\r\n        })\r\n    }\r\n\r\n    /// Encode a bloom filter\r\n    pub fn encode(\u0026self, buf: \u0026mut Vec\u003cu8\u003e) {\r\n        let offset = buf.len();\r\n        buf.extend(\u0026self.filter);\r\n        buf.put_u8(self.k);\r\n        let checksum = crc32fast::hash(\u0026buf[offset..]);\r\n        buf.put_u32(checksum);\r\n    }\r\n\r\n    /// Get bloom filter bits per key from entries count and FPR\r\n    pub fn bloom_bits_per_key(entries: usize, false_positive_rate: f64) -\u003e usize {\r\n        let size =\r\n            -1.0 * (entries as f64) * false_positive_rate.ln() / std::f64::consts::LN_2.powi(2);\r\n        let locs = (size / (entries as f64)).ceil();\r\n        locs as usize\r\n    }\r\n\r\n    /// Build bloom filter from key hashes\r\n    pub fn build_from_key_hashes(keys: \u0026[u32], bits_per_key: usize) -\u003e Self {\r\n        let k = (bits_per_key as f64 * 0.69) as u32;\r\n        let k = k.min(30).max(1);\r\n        let nbits = (keys.len() * bits_per_key).max(64);\r\n        let nbytes = (nbits + 7) / 8;\r\n        let nbits = nbytes * 8;\r\n        let mut filter = BytesMut::with_capacity(nbytes);\r\n        filter.resize(nbytes, 0);\r\n        for h in keys {\r\n            let mut h = *h;\r\n            let delta = (h \u003e\u003e 17) | (h \u003c\u003c 15);\r\n            for _ in 0..k {\r\n                let bit_pos = (h as usize) % nbits;\r\n                filter.set_bit(bit_pos, true);\r\n                h = h.wrapping_add(delta);\r\n            }\r\n        }\r\n        Self {\r\n            filter: filter.freeze(),\r\n            k: k as u8,\r\n        }\r\n    }\r\n\r\n    /// Check if a bloom filter may contain some data\r\n    pub fn may_contain(\u0026self, mut h: u32) -\u003e bool {\r\n        if self.k \u003e 30 {\r\n            // potential new encoding for short bloom filters\r\n            true\r\n        } else {\r\n            let nbits = self.filter.bit_len();\r\n            let delta = (h \u003e\u003e 17) | (h \u003c\u003c 15);\r\n            for _ in 0..self.k {\r\n                let bit_pos = h % (nbits as u32);\r\n                if !self.filter.get_bit(bit_pos as usize) {\r\n                    return false;\r\n                }\r\n                h = h.wrapping_add(delta);\r\n            }\r\n            true\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use tempfile::tempdir;\r\n    use crate::storage::engine::piggykv::{key::{KeySlice, TS_ENABLED}, table::{bloom::Bloom, FileObject, SsTable, SsTableBuilder}};\r\n    fn key_of(idx: usize) -\u003e Vec\u003cu8\u003e {\r\n        format!(\"key_{:010}\", idx * 5).into_bytes()\r\n    }\r\n\r\n    fn value_of(idx: usize) -\u003e Vec\u003cu8\u003e {\r\n        format!(\"value_{:010}\", idx).into_bytes()\r\n    }\r\n\r\n    fn num_of_keys() -\u003e usize {\r\n        100\r\n    }\r\n    #[test]\r\n    fn test_task1_bloom_filter() {\r\n        let mut key_hashes = Vec::new();\r\n        for idx in 0..num_of_keys() {\r\n            let key = key_of(idx);\r\n            key_hashes.push(farmhash::fingerprint32(\u0026key));\r\n        }\r\n        let bits_per_key = Bloom::bloom_bits_per_key(key_hashes.len(), 0.01);\r\n        println!(\"bits per key: {}\", bits_per_key);\r\n        let bloom = Bloom::build_from_key_hashes(\u0026key_hashes, bits_per_key);\r\n        println!(\"bloom size: {}, k={}\", bloom.filter.len(), bloom.k);\r\n        assert!(bloom.k \u003c 30);\r\n        for idx in 0..num_of_keys() {\r\n            let key = key_of(idx);\r\n            assert!(bloom.may_contain(farmhash::fingerprint32(\u0026key)));\r\n        }\r\n        let mut x = 0;\r\n        let mut cnt = 0;\r\n        for idx in num_of_keys()..(num_of_keys() * 10) {\r\n            let key = key_of(idx);\r\n            if bloom.may_contain(farmhash::fingerprint32(\u0026key)) {\r\n                x += 1;\r\n            }\r\n            cnt += 1;\r\n        }\r\n        assert_ne!(x, cnt, \"bloom filter not taking effect?\");\r\n        assert_ne!(x, 0, \"bloom filter not taking effect?\");\r\n    }\r\n    #[test]\r\n    fn test_task2_sst_decode() {\r\n        let mut builder = SsTableBuilder::new(128);\r\n        for idx in 0..num_of_keys() {\r\n            let key = key_of(idx);\r\n            let value = value_of(idx);\r\n            builder.add(KeySlice::for_testing_from_slice_no_ts(\u0026key[..]), \u0026value[..]);\r\n        }\r\n        let dir = tempdir().unwrap();\r\n        let path = dir.path().join(\"1.sst\");\r\n        let sst = builder.build_for_test(\u0026path).unwrap();\r\n        let sst2 = SsTable::open(0, None, FileObject::open(\u0026path).unwrap()).unwrap();\r\n        let bloom_1 = sst.bloom.as_ref().unwrap();\r\n        let bloom_2 = sst2.bloom.as_ref().unwrap();\r\n        assert_eq!(bloom_1.k, bloom_2.k);\r\n        assert_eq!(bloom_1.filter, bloom_2.filter);\r\n    }\r\n    #[test]\r\nfn test_task3_block_key_compression() {\r\n    let mut builder = SsTableBuilder::new(128);\r\n    for idx in 0..num_of_keys() {\r\n        let key = key_of(idx);\r\n        let value = value_of(idx);\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(\u0026key[..]), \u0026value[..]);\r\n    }\r\n    let dir = tempdir().unwrap();\r\n    let path = dir.path().join(\"1.sst\");\r\n    let sst = builder.build_for_test(path).unwrap();\r\n    if TS_ENABLED {\r\n        assert!(\r\n            sst.block_meta.len() \u003c= 34,\r\n            \"you have {} blocks, expect 34\",\r\n            sst.block_meta.len()\r\n        );\r\n    } else {\r\n        assert!(\r\n            sst.block_meta.len() \u003c= 25,\r\n            \"you have {} blocks, expect 25\",\r\n            sst.block_meta.len()\r\n        );\r\n    }\r\n}\r\n\r\n}\r\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":9511602413006487552},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":7349874591868650731},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":7349874591868650731},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":9799832789158207857},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":14123288431433884017},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":18446744073709543055},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":6557241057451440750},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":7998392938210002322},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":7998392938210002322},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":7349874591868658033},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":7349874591868658033},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":212},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":7349874591868657821},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":7349874591868657821},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":7349874591868657821},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":9511602413006487555},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":9511602413006487555},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":8574853690513424592},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":936748722493062963},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":17221764975064776704},"fn_name":null}],"covered":57,"coverable":58},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","table","builder.rs"],"content":"use std::path::Path;\r\nuse std::sync::Arc;\r\n\r\nuse crate::errors::Result;\r\nuse crate::storage::engine::piggykv::block::BlockBuilder;\r\nuse crate::storage::engine::piggykv::key::{KeySlice, KeyVec};\r\nuse crate::storage::engine::piggykv::lsm_storage::BlockCache;\r\n\r\nuse bytes::BufMut;\r\n\r\nuse super::bloom::Bloom;\r\nuse super::{BlockMeta, FileObject, SsTable};\r\n\r\n/// Builds an SSTable from key-value pairs.\r\npub struct SsTableBuilder {\r\n    builder: BlockBuilder,\r\n    first_key: KeyVec,\r\n    last_key: KeyVec,\r\n    data: Vec\u003cu8\u003e,\r\n    pub(crate) meta: Vec\u003cBlockMeta\u003e,\r\n    block_size: usize,\r\n    key_hashes: Vec\u003cu32\u003e,\r\n    max_ts: u64,\r\n}\r\n\r\nimpl SsTableBuilder {\r\n    /// Create a builder based on target block size.\r\n    pub fn new(block_size: usize) -\u003e Self {\r\n        Self {\r\n            data: Vec::new(),\r\n            meta: Vec::new(),\r\n            first_key: KeyVec::new(),\r\n            last_key: KeyVec::new(),\r\n            block_size,\r\n            builder: BlockBuilder::new(block_size),\r\n            key_hashes: Vec::new(),\r\n            max_ts: 0,\r\n        }\r\n    }\r\n\r\n    /// Adds a key-value pair to SSTable\r\n    pub fn add(\u0026mut self, key: KeySlice, value: \u0026[u8]) {\r\n        if self.first_key.is_empty() {\r\n            self.first_key.set_from_slice(key);\r\n        }\r\n        if key.ts() \u003e self.max_ts {\r\n            self.max_ts = key.ts();\r\n        }\r\n\r\n        self.key_hashes.push(farmhash::fingerprint32(key.key_ref()));\r\n\r\n        if self.builder.add(key, value) {\r\n            self.last_key.set_from_slice(key);\r\n            return;\r\n        }\r\n        assert!(!self.builder.is_empty());\r\n        // create a new block builder and append block data\r\n        self.finish_block();\r\n\r\n        // add the key-value pair to the next block\r\n        assert!(self.builder.add(key, value));\r\n        self.first_key.set_from_slice(key);\r\n        self.last_key.set_from_slice(key);\r\n    }\r\n\r\n    /// Get the estimated size of the SSTable.\r\n    pub fn estimated_size(\u0026self) -\u003e usize {\r\n        self.data.len()\r\n    }\r\n\r\n    fn finish_block(\u0026mut self) {\r\n        let builder = std::mem::replace(\u0026mut self.builder, BlockBuilder::new(self.block_size));\r\n        let encoded_block = builder.build().encode();\r\n        self.meta.push(BlockMeta {\r\n            offset: self.data.len(),\r\n            first_key: std::mem::take(\u0026mut self.first_key).into_key_bytes(),\r\n            last_key: std::mem::take(\u0026mut self.last_key).into_key_bytes(),\r\n        });\r\n        let checksum = crc32fast::hash(\u0026encoded_block);\r\n        self.data.extend(encoded_block);\r\n        self.data.put_u32(checksum);\r\n    }\r\n\r\n    /// Builds the SSTable and writes it to the given path. Use the `FileObject` structure to manipulate the disk objects.\r\n    pub fn build(\r\n        mut self,\r\n        id: usize,\r\n        block_cache: Option\u003cArc\u003cBlockCache\u003e\u003e,\r\n        bloom_false_positive_rate: f64,\r\n        path: impl AsRef\u003cPath\u003e,\r\n    ) -\u003e Result\u003cSsTable\u003e {\r\n        self.finish_block();\r\n        let mut buf = self.data;\r\n        let meta_offset = buf.len();\r\n        BlockMeta::encode_block_meta(\u0026self.meta, self.max_ts, \u0026mut buf);\r\n        buf.put_u32(meta_offset as u32);\r\n        let bloom = Bloom::build_from_key_hashes(\r\n            \u0026self.key_hashes,\r\n            Bloom::bloom_bits_per_key(self.key_hashes.len(), bloom_false_positive_rate),\r\n        );\r\n        let bloom_offset = buf.len();\r\n        bloom.encode(\u0026mut buf);\r\n        buf.put_u32(bloom_offset as u32);\r\n        let file = FileObject::create(path.as_ref(), buf)?;\r\n        Ok(SsTable {\r\n            id,\r\n            file,\r\n            first_key: self.meta.first().unwrap().first_key.clone(),\r\n            last_key: self.meta.last().unwrap().last_key.clone(),\r\n            block_meta: self.meta,\r\n            block_meta_offset: meta_offset,\r\n            block_cache,\r\n            bloom: Some(bloom),\r\n            max_ts: self.max_ts,\r\n        })\r\n    }\r\n    #[cfg(test)]\r\n    pub(crate) fn build_for_test(self, path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cSsTable\u003e {\r\n        self.build(0, None,0.01, path)\r\n    }\r\n\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":30,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":10520408729537478656},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":1426},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":7926335344172074386},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":14123288431433875456},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":10520408729537478656},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":10520408729537478656},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":12321848580485677874},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":12321848580485677874},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":16645304222761352398},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":16645304222761352351},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":16645304222761352351},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":16645304222761354594},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":16645304222761354594},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":3891110078048108544},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":3891110078048108544},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":6124895493223875552},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":6124895493223875552},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6124895493223875552},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":6124895493223875552},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":6124895493223875552},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6124895493223875552},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6124895493223875552},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":6124895493223875552},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":6124895493223875552},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":6124895493223875552},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":15852670688344145920},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null}],"covered":47,"coverable":47},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","table","iterator.rs"],"content":"use std::sync::Arc;\r\n\r\nuse crate::errors::Result;\r\nuse crate::storage::engine::piggykv::block::BlockIterator;\r\nuse crate::storage::engine::piggykv::iterators::StorageIterator;\r\nuse crate::storage::engine::piggykv::key::KeySlice;\r\n\r\nuse super::SsTable;\r\n\r\n/// An iterator over the contents of an SSTable.\r\npub struct SsTableIterator {\r\n    table: Arc\u003cSsTable\u003e,\r\n    blk_iter: BlockIterator,\r\n    blk_idx: usize,\r\n}\r\n\r\nimpl SsTableIterator {\r\n    fn seek_to_first_inner(table: \u0026Arc\u003cSsTable\u003e) -\u003e Result\u003c(usize, BlockIterator)\u003e {\r\n        Ok((\r\n            0,\r\n            BlockIterator::create_and_seek_to_first(table.read_block_cached(0)?),\r\n        ))\r\n    }\r\n\r\n    /// Create a new iterator and seek to the first key-value pair.\r\n    pub fn create_and_seek_to_first(table: Arc\u003cSsTable\u003e) -\u003e Result\u003cSelf\u003e {\r\n        let (blk_idx, blk_iter) = Self::seek_to_first_inner(\u0026table)?;\r\n        let iter = Self {\r\n            blk_iter,\r\n            table,\r\n            blk_idx,\r\n        };\r\n        Ok(iter)\r\n    }\r\n\r\n    /// Seek to the first key-value pair.\r\n    pub fn seek_to_first(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        let (blk_idx, blk_iter) = Self::seek_to_first_inner(\u0026self.table)?;\r\n        self.blk_idx = blk_idx;\r\n        self.blk_iter = blk_iter;\r\n        Ok(())\r\n    }\r\n\r\n    fn seek_to_key_inner(table: \u0026Arc\u003cSsTable\u003e, key: KeySlice) -\u003e Result\u003c(usize, BlockIterator)\u003e {\r\n        let mut blk_idx = table.find_block_idx(key);\r\n        let mut blk_iter =\r\n            BlockIterator::create_and_seek_to_key(table.read_block_cached(blk_idx)?, key);\r\n        if !blk_iter.is_valid() {\r\n            blk_idx += 1;\r\n            if blk_idx \u003c table.num_of_blocks() {\r\n                blk_iter =\r\n                    BlockIterator::create_and_seek_to_first(table.read_block_cached(blk_idx)?);\r\n            }\r\n        }\r\n        Ok((blk_idx, blk_iter))\r\n    }\r\n\r\n    /// Create a new iterator and seek to the first key-value pair which \u003e= `key`.\r\n    pub fn create_and_seek_to_key(table: Arc\u003cSsTable\u003e, key: KeySlice) -\u003e Result\u003cSelf\u003e {\r\n        let (blk_idx, blk_iter) = Self::seek_to_key_inner(\u0026table, key)?;\r\n        let iter = Self {\r\n            blk_iter,\r\n            table,\r\n            blk_idx,\r\n        };\r\n        Ok(iter)\r\n    }\r\n\r\n    /// Seek to the first key-value pair which \u003e= `key`.\r\n    pub fn seek_to_key(\u0026mut self, key: KeySlice) -\u003e Result\u003c()\u003e {\r\n        let (blk_idx, blk_iter) = Self::seek_to_key_inner(\u0026self.table, key)?;\r\n        self.blk_iter = blk_iter;\r\n        self.blk_idx = blk_idx;\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl StorageIterator for SsTableIterator {\r\n    type KeyType\u003c'a\u003e = KeySlice\u003c'a\u003e;\r\n\r\n    fn value(\u0026self) -\u003e \u0026[u8] {\r\n        self.blk_iter.value()\r\n    }\r\n\r\n    fn key(\u0026self) -\u003e KeySlice {\r\n        self.blk_iter.key()\r\n    }\r\n\r\n    fn is_valid(\u0026self) -\u003e bool {\r\n        self.blk_iter.is_valid()\r\n    }\r\n\r\n    fn _next(\u0026mut self) -\u003e Result\u003c()\u003e {\r\n        self.blk_iter.next();\r\n        if !self.blk_iter.is_valid() {\r\n            self.blk_idx += 1;\r\n            if self.blk_idx \u003c self.table.num_of_blocks() {\r\n                self.blk_iter = BlockIterator::create_and_seek_to_first(\r\n                    self.table.read_block_cached(self.blk_idx)?,\r\n                );\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":8574853690513424391},"fn_name":null},{"line":19,"address":[],"length":0,"stats":{"Line":8574853690513424391},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":8574853690513424391},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":8574853690513424391},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":16429131440647569408},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":17293822569102704640},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":17293822569102704640},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":17293822569102704430},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":17293822569102704850},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":5044031582654955310},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":9007199254740991993},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":3963167672086036683},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":3963167672086036263},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":17293822569102704850},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":17798225727368200192},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":17149707381026848768},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":17942340915444056064},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":17437937757178560512},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":13258597302978742627},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":13258597302978742627},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":7566047373982444576},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":7566047373982444576},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":7638104968020370114},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":7638104968020370114},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":7638104968020370114},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":5188146770730818911},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":1873497444986135189},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":15132094747964867894},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":15132094747964874035},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":7638104968020363973},"fn_name":null}],"covered":35,"coverable":35},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","table.rs"],"content":"pub(crate) mod bloom;\r\nmod builder;\r\nmod iterator;\r\nuse crate::errors::Result;\r\n\r\nuse std::fs::File;\r\nuse std::io::Write;\r\nuse std::path::Path;\r\nuse std::sync::Arc;\r\n\r\npub use builder::SsTableBuilder;\r\nuse bytes::{Buf, BufMut};\r\npub use iterator::SsTableIterator;\r\nuse tracing::error;\r\n\r\nuse self::bloom::Bloom;\r\n\r\nuse super::{\r\n    block::Block,\r\n    key::{KeyBytes, KeySlice},\r\n    lsm_storage::BlockCache,\r\n};\r\n\r\n#[derive(Clone, Debug, PartialEq, Eq)]\r\npub struct BlockMeta {\r\n    /// Offset of this data block.\r\n    pub offset: usize,\r\n    /// The first key of the data block.\r\n    pub first_key: KeyBytes,\r\n    /// The last key of the data block.\r\n    pub last_key: KeyBytes,\r\n}\r\n\r\nimpl BlockMeta {\r\n    /// Encode block meta to a buffer.\r\n    pub fn encode_block_meta(block_meta: \u0026[BlockMeta], max_ts: u64, buf: \u0026mut Vec\u003cu8\u003e) {\r\n        let mut estimated_size = std::mem::size_of::\u003cu32\u003e(); // number of blocks\r\n        for meta in block_meta {\r\n            // The size of offset\r\n            estimated_size += std::mem::size_of::\u003cu32\u003e();\r\n            // The size of key length\r\n            estimated_size += std::mem::size_of::\u003cu16\u003e();\r\n            // The size of actual key\r\n            estimated_size += meta.first_key.raw_len();\r\n            // The size of key length\r\n            estimated_size += std::mem::size_of::\u003cu16\u003e();\r\n            // The size of actual key\r\n            estimated_size += meta.last_key.raw_len();\r\n        }\r\n        estimated_size += std::mem::size_of::\u003cu64\u003e(); // max timestamp\r\n        estimated_size += std::mem::size_of::\u003cu32\u003e(); // checksum\r\n\r\n        // Reserve the space to improve performance, especially when the size of incoming data is\r\n        // large\r\n        buf.reserve(estimated_size);\r\n        let original_len = buf.len();\r\n        buf.put_u32(block_meta.len() as u32);\r\n        for meta in block_meta {\r\n            buf.put_u32(meta.offset as u32);\r\n            buf.put_u16(meta.first_key.key_len() as u16);\r\n            buf.put_slice(meta.first_key.key_ref());\r\n            buf.put_u64(meta.first_key.ts());\r\n            buf.put_u16(meta.last_key.key_len() as u16);\r\n            buf.put_slice(meta.last_key.key_ref());\r\n            buf.put_u64(meta.last_key.ts());\r\n        }\r\n        buf.put_u64(max_ts);\r\n\r\n        buf.put_u32(crc32fast::hash(\u0026buf[original_len + 4..]));\r\n        assert_eq!(estimated_size, buf.len() - original_len);\r\n    }\r\n\r\n    /// Decode block meta from a buffer.\r\n    pub fn decode_block_meta(mut buf: \u0026[u8]) -\u003e Result\u003c(Vec\u003cBlockMeta\u003e, u64)\u003e {\r\n        let mut block_meta = Vec::new();\r\n        let num = buf.get_u32() as usize;\r\n        let checksum = crc32fast::hash(\u0026buf[..buf.remaining() - 4]);\r\n        for _ in 0..num {\r\n            let offset = buf.get_u32() as usize;\r\n            let first_key_len = buf.get_u16() as usize;\r\n            let first_key =\r\n                KeyBytes::from_bytes_with_ts(buf.copy_to_bytes(first_key_len), buf.get_u64());\r\n            let last_key_len: usize = buf.get_u16() as usize;\r\n            let last_key =\r\n                KeyBytes::from_bytes_with_ts(buf.copy_to_bytes(last_key_len), buf.get_u64());\r\n            block_meta.push(BlockMeta {\r\n                offset,\r\n                first_key,\r\n                last_key,\r\n            });\r\n        }\r\n        let max_ts = buf.get_u64();\r\n\r\n        if buf.get_u32() != checksum {\r\n            error!(\"checksum mismatched!\");\r\n            panic!(\"meta checksum mismatched\");\r\n        }\r\n\r\n        Ok((block_meta, max_ts))\r\n    }\r\n}\r\n\r\n/// A file object.\r\npub struct FileObject(Option\u003cFile\u003e, u64);\r\n\r\nimpl FileObject {\r\n    pub fn read(\u0026self, offset: u64, len: u64) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\r\n        let mut data = vec![0; len as usize];\r\n\r\n        #[cfg(windows)]\r\n        {\r\n            use std::os::windows::fs::FileExt;\r\n            self.0.as_ref().unwrap().seek_read(\u0026mut data[..], offset)?;\r\n        }\r\n        #[cfg(unix)]\r\n        {\r\n            use std::os::unix::fs::FileExt;\r\n            self.0\r\n                .as_ref()\r\n                .unwrap()\r\n                .read_exact_at(\u0026mut data[..], offset)?;\r\n        }\r\n        Ok(data)\r\n    }\r\n\r\n    pub fn size(\u0026self) -\u003e u64 {\r\n        self.1\r\n    }\r\n\r\n    /// Create a new file object (day 2) and write the file to the disk (day 4).\r\n    pub fn create(path: \u0026Path, data: Vec\u003cu8\u003e) -\u003e Result\u003cSelf\u003e {\r\n        // std::fs::write(path, \u0026data)?;\r\n        // println!(\"reach\");\r\n        let mut file = File::options()\r\n            .read(true)\r\n            .write(true)\r\n            .create(true)\r\n            .truncate(false)\r\n            .open(path)\r\n            .unwrap();\r\n        file.write_all(\u0026data)?;\r\n        file.sync_all().unwrap();\r\n        Ok(FileObject(Some(file), data.len() as u64))\r\n    }\r\n\r\n    pub fn open(path: \u0026Path) -\u003e Result\u003cSelf\u003e {\r\n        let file = File::options().read(true).write(true).open(path)?;\r\n        let size = file.metadata()?.len();\r\n        Ok(FileObject(Some(file), size))\r\n    }\r\n}\r\n\r\n/// An SSTable.\r\npub struct SsTable {\r\n    /// The actual storage unit of SsTable, the format is as above.\r\n    pub(crate) file: FileObject,\r\n    /// The meta blocks that hold info for data blocks.\r\n    pub(crate) block_meta: Vec\u003cBlockMeta\u003e,\r\n    /// The offset that indicates the start point of meta blocks in `file`.\r\n    pub(crate) block_meta_offset: usize,\r\n    id: usize,\r\n    block_cache: Option\u003cArc\u003cBlockCache\u003e\u003e,\r\n    first_key: KeyBytes,\r\n    last_key: KeyBytes,\r\n    pub(crate) bloom: Option\u003cBloom\u003e,\r\n    max_ts: u64,\r\n\r\n}\r\nimpl SsTable {\r\n    pub fn sync(\u0026self) -\u003e Result\u003c()\u003e {\r\n        self.file.0.as_ref().unwrap().sync_all()?;\r\n        Ok(())\r\n    }\r\n    /// Open SSTable from a file.\r\n    pub fn open(id: usize, block_cache: Option\u003cArc\u003cBlockCache\u003e\u003e, file: FileObject) -\u003e Result\u003cSelf\u003e {\r\n        let len = file.size();\r\n        let raw_bloom_offset = file.read(len - 4, 4)?;\r\n        let bloom_offset = (\u0026raw_bloom_offset[..]).get_u32() as u64;\r\n        let raw_bloom = file.read(bloom_offset, len - 4 - bloom_offset)?;\r\n        let bloom_filter = Bloom::decode(\u0026raw_bloom)?;\r\n        let raw_meta_offset = file.read(bloom_offset - 4, 4)?;\r\n        let block_meta_offset = (\u0026raw_meta_offset[..]).get_u32() as u64;\r\n        let raw_meta = file.read(block_meta_offset, bloom_offset - 4 - block_meta_offset)?;\r\n        let (block_meta, max_ts) = BlockMeta::decode_block_meta(\u0026raw_meta[..])?;\r\n        Ok(Self {\r\n            file,\r\n            first_key: block_meta.first().unwrap().first_key.clone(),\r\n            last_key: block_meta.last().unwrap().last_key.clone(),\r\n            block_meta,\r\n            block_meta_offset: block_meta_offset as usize,\r\n            id,\r\n            block_cache,\r\n            bloom: Some(bloom_filter),\r\n            max_ts,\r\n        })\r\n    }\r\n\r\n    /// Create a mock SST with only first key + last key metadata\r\n    pub fn create_meta_only(\r\n        id: usize,\r\n        file_size: u64,\r\n        first_key: KeyBytes,\r\n        last_key: KeyBytes,\r\n    ) -\u003e Self {\r\n        Self {\r\n            file: FileObject(None, file_size),\r\n            block_meta: vec![],\r\n            block_meta_offset: 0,\r\n            id,\r\n            block_cache: None,\r\n            first_key,\r\n            last_key,\r\n            bloom: None,\r\n            max_ts:0,\r\n        }\r\n    }\r\n\r\n    /// Read a block from the disk.\r\n    pub fn read_block(\u0026self, block_idx: usize) -\u003e Result\u003cArc\u003cBlock\u003e\u003e {\r\n        let offset = self.block_meta[block_idx].offset;\r\n        let offset_end = self\r\n            .block_meta\r\n            .get(block_idx + 1)\r\n            .map_or(self.block_meta_offset, |x| x.offset);\r\n        let block_len = offset_end - offset - 4;\r\n        let block_data_with_chksum: Vec\u003cu8\u003e = self\r\n            .file\r\n            .read(offset as u64, (offset_end - offset) as u64)?;\r\n        let block_data = \u0026block_data_with_chksum[..block_len];\r\n        let checksum = (\u0026block_data_with_chksum[block_len..]).get_u32();\r\n        if checksum != crc32fast::hash(block_data) {\r\n            error!(\"block checksum mismatched!\");\r\n            panic!(\"block checksum mismatched\");\r\n        }\r\n        Ok(Arc::new(Block::decode(block_data)))\r\n    }\r\n\r\n    /// Read a block from disk, with block cache.\r\n    pub fn read_block_cached(\u0026self, block_idx: usize) -\u003e Result\u003cArc\u003cBlock\u003e\u003e {\r\n        if let Some(ref block_cache) = self.block_cache {\r\n            let blk = block_cache\r\n                .try_get_with((self.id, block_idx), || self.read_block(block_idx))\r\n                .unwrap();\r\n            Ok(blk)\r\n        } else {\r\n            self.read_block(block_idx)\r\n        }\r\n    }\r\n\r\n    /// Find the block that may contain `key`.\r\n    pub fn find_block_idx(\u0026self, key: KeySlice) -\u003e usize {\r\n        self.block_meta\r\n            .partition_point(|meta| meta.first_key.as_key_slice() \u003c= key)\r\n            .saturating_sub(1)\r\n    }\r\n\r\n    /// Get number of data blocks.\r\n    pub fn num_of_blocks(\u0026self) -\u003e usize {\r\n        self.block_meta.len()\r\n    }\r\n\r\n    pub fn first_key(\u0026self) -\u003e \u0026KeyBytes {\r\n        \u0026self.first_key\r\n    }\r\n\r\n    pub fn last_key(\u0026self) -\u003e \u0026KeyBytes {\r\n        \u0026self.last_key\r\n    }\r\n\r\n    pub fn table_size(\u0026self) -\u003e u64 {\r\n        self.file.1\r\n    }\r\n\r\n    pub fn sst_id(\u0026self) -\u003e usize {\r\n        self.id\r\n    }\r\n    \r\n    pub fn max_ts(\u0026self) -\u003e u64 {\r\n        self.max_ts\r\n    }\r\n    #[cfg(test)]\r\n    pub(crate) fn open_for_test(file: FileObject) -\u003e Result\u003cSelf\u003e {\r\n        Self::open(0, None, file)\r\n    }\r\n\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use std::sync::Arc;\r\n\r\n    use bytes::Bytes;\r\n\r\n    use crate::storage::engine::piggykv::{iterators::StorageIterator, key::{KeySlice, KeyVec}};\r\n    use tempfile::{tempdir, TempDir};\r\n    use super::{SsTable, SsTableBuilder, SsTableIterator};\r\n\r\n\r\n    #[test]\r\n    fn test_sst_build_single_key() {\r\n        let mut builder = SsTableBuilder::new(16);\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(b\"233\"), b\"233333\");\r\n        let dir = tempdir().unwrap();\r\n        builder.build_for_test(dir.path().join(\"1.sst\")).unwrap();\r\n    }\r\n    \r\n    #[test]\r\n    fn test_sst_build_two_blocks() {\r\n        let mut builder = SsTableBuilder::new(16);\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(b\"11\"), b\"11\");\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(b\"22\"), b\"22\");\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(b\"33\"), b\"11\");\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(b\"44\"), b\"22\");\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(b\"55\"), b\"11\");\r\n        builder.add(KeySlice::for_testing_from_slice_no_ts(b\"66\"), b\"22\");\r\n        assert!(builder.meta.len() \u003e= 2);\r\n        let dir = tempdir().unwrap();\r\n        builder.build_for_test(dir.path().join(\"1.sst\")).unwrap();\r\n    }\r\n    \r\n    fn key_of(idx: usize) -\u003e KeyVec {\r\n        KeyVec::for_testing_from_vec_no_ts(format!(\"key_{:03}\", idx * 5).into_bytes())\r\n    }\r\n    \r\n    fn value_of(idx: usize) -\u003e Vec\u003cu8\u003e {\r\n        format!(\"value_{:010}\", idx).into_bytes()\r\n    }\r\n    \r\n    fn num_of_keys() -\u003e usize {\r\n        100\r\n    }\r\n    \r\n    fn generate_sst() -\u003e (TempDir, SsTable) {\r\n        let mut builder = SsTableBuilder::new(128);\r\n        for idx in 0..num_of_keys() {\r\n            let key = key_of(idx);\r\n            let value = value_of(idx);\r\n            builder.add(key.as_key_slice(), \u0026value[..]);\r\n        }\r\n        let dir = tempdir().unwrap();\r\n        let path = dir.path().join(\"1.sst\");\r\n        (dir, builder.build_for_test(path).unwrap())\r\n    }\r\n    \r\n    #[test]\r\n    fn test_sst_build_all() {\r\n        generate_sst();\r\n    }\r\n    \r\n    #[test]\r\n    fn test_sst_decode() {\r\n        let (_dir, sst) = generate_sst();\r\n        let meta = sst.block_meta.clone();\r\n        let new_sst = SsTable::open_for_test(sst.file).unwrap();\r\n        assert_eq!(new_sst.block_meta, meta);\r\n        assert_eq!(\r\n            new_sst.first_key().for_testing_key_ref(),\r\n            key_of(0).for_testing_key_ref()\r\n        );\r\n        assert_eq!(\r\n            new_sst.last_key().for_testing_key_ref(),\r\n            key_of(num_of_keys() - 1).for_testing_key_ref()\r\n        );\r\n    }\r\n    \r\n    fn as_bytes(x: \u0026[u8]) -\u003e Bytes {\r\n        Bytes::copy_from_slice(x)\r\n    }\r\n    \r\n    #[test]\r\n    fn test_sst_iterator() {\r\n        let (_dir, sst) = generate_sst();\r\n        let sst = Arc::new(sst);\r\n        let mut iter = SsTableIterator::create_and_seek_to_first(sst).unwrap();\r\n        for _ in 0..5 {\r\n            for i in 0..num_of_keys() {\r\n                let key = iter.key();\r\n                let value = iter.value();\r\n                assert_eq!(\r\n                    key.for_testing_key_ref(),\r\n                    key_of(i).for_testing_key_ref(),\r\n                    \"expected key: {:?}, actual key: {:?}\",\r\n                    as_bytes(key_of(i).for_testing_key_ref()),\r\n                    as_bytes(key.for_testing_key_ref())\r\n                );\r\n                assert_eq!(\r\n                    value,\r\n                    value_of(i),\r\n                    \"expected value: {:?}, actual value: {:?}\",\r\n                    as_bytes(\u0026value_of(i)),\r\n                    as_bytes(value)\r\n                );\r\n                iter._next().unwrap();\r\n            }\r\n            iter.seek_to_first().unwrap();\r\n        }\r\n    }\r\n    \r\n    #[test]\r\n    fn test_sst_seek_key() {\r\n        let (_dir, sst) = generate_sst();\r\n        let sst = Arc::new(sst);\r\n        let mut iter = SsTableIterator::create_and_seek_to_key(sst, key_of(0).as_key_slice()).unwrap();\r\n        for offset in 1..=5 {\r\n            for i in 0..num_of_keys() {\r\n                let key = iter.key();\r\n                let value = iter.value();\r\n                assert_eq!(\r\n                    key.for_testing_key_ref(),\r\n                    key_of(i).for_testing_key_ref(),\r\n                    \"expected key: {:?}, actual key: {:?}\",\r\n                    as_bytes(key_of(i).for_testing_key_ref()),\r\n                    as_bytes(key.for_testing_key_ref())\r\n                );\r\n                assert_eq!(\r\n                    value,\r\n                    value_of(i),\r\n                    \"expected value: {:?}, actual value: {:?}\",\r\n                    as_bytes(\u0026value_of(i)),\r\n                    as_bytes(value)\r\n                );\r\n                iter.seek_to_key(KeySlice::for_testing_from_slice_no_ts(\r\n                    \u0026format!(\"key_{:03}\", i * 5 + offset).into_bytes(),\r\n                ))\r\n                .unwrap();\r\n            }\r\n            iter.seek_to_key(KeySlice::for_testing_from_slice_no_ts(b\"k\"))\r\n                .unwrap();\r\n        }\r\n    }\r\n    \r\n}\r\n","traces":[{"line":36,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":38,"address":[],"length":0,"stats":{"Line":7854277750134145024},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":7854277750134145168},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":6124895493223874608},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":6124895493223874608},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":6124895493223874608},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":6124895493223874608},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":6124895493223874608},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":6124895493223874608},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":6124895493223874608},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6917529027641081856},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":3746994889972252672},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":3746994889972252672},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":3746994889972252720},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":3746994889972252624},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":7926335344172072960},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":5260204364768739331},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":5260204364768739325},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":189,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":190,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":191,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":15996785876420001792},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":5764607523034234832},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":2882303761517117488},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":18446744073709551568},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":2666130979403333369},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":7854277750134145071},"fn_name":null},{"line":246,"address":[],"length":0,"stats":{"Line":13474770085092524295},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":17293822569102704643},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":17293822569102704643},"fn_name":null},{"line":253,"address":[],"length":0,"stats":{"Line":13474770085092524082},"fn_name":null},{"line":258,"address":[],"length":0,"stats":{"Line":10232178353385767122},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":10232178353385767122},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":12682136550675316788},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":12682136550675316788},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":1513209474796492280},"fn_name":null},{"line":267,"address":[],"length":0,"stats":{"Line":1513209474796492280},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":14555633995661448486},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":14555633995661448486},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":12393906174523605001},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":12393906174523605001},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":279,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null}],"covered":113,"coverable":119},{"path":["E:","\\","sql-layer","src","storage","engine","piggykv","wal.rs"],"content":"use crate::errors::Result;\r\nuse std::fs::{File, OpenOptions};\r\nuse std::hash::Hasher;\r\nuse std::io::{BufWriter, Read, Write};\r\nuse std::path::Path;\r\nuse std::sync::Arc;\r\n\r\nuse bytes::{Buf, BufMut, Bytes};\r\nuse crossbeam_skiplist::SkipMap;\r\nuse parking_lot::Mutex;\r\n\r\nuse super::key::{KeyBytes, KeySlice};\r\n\r\npub struct Wal {\r\n    file: Arc\u003cMutex\u003cBufWriter\u003cFile\u003e\u003e\u003e,\r\n}\r\n\r\nimpl Wal {\r\n    pub fn create(path: impl AsRef\u003cPath\u003e) -\u003e Result\u003cSelf\u003e {\r\n        Ok(Self {\r\n            file: Arc::new(Mutex::new(BufWriter::new(\r\n                OpenOptions::new()\r\n                    .read(true)\r\n                    .create_new(true)\r\n                    .write(true)\r\n                    .open(path)\r\n                    .expect(\"failed to create WAL\"),\r\n            ))),\r\n        })\r\n    }\r\n\r\n    pub fn recover(path: impl AsRef\u003cPath\u003e, skiplist: \u0026SkipMap\u003cKeyBytes, Bytes\u003e) -\u003e Result\u003cSelf\u003e {\r\n        let path = path.as_ref();\r\n        let mut file = OpenOptions::new()\r\n            .read(true)\r\n            .append(true)\r\n            .open(path)\r\n            .expect(\"failed to recover from WAL\");\r\n        let mut buf = Vec::new();\r\n        file.read_to_end(\u0026mut buf)?;\r\n        let mut rbuf: \u0026[u8] = buf.as_slice();\r\n        while rbuf.has_remaining() {\r\n            let mut hasher = crc32fast::Hasher::new();\r\n            let key_len = rbuf.get_u16() as usize;\r\n            hasher.write_u16(key_len as u16);\r\n            let key = Bytes::copy_from_slice(\u0026rbuf[..key_len]);\r\n            hasher.write(\u0026key);\r\n            rbuf.advance(key_len);\r\n            let ts = rbuf.get_u64();\r\n            hasher.write_u64(ts);\r\n\r\n            let value_len = rbuf.get_u16() as usize;\r\n            hasher.write_u16(value_len as u16);\r\n            let value = Bytes::copy_from_slice(\u0026rbuf[..value_len]);\r\n            hasher.write(\u0026value);\r\n            rbuf.advance(value_len);\r\n            let checksum = rbuf.get_u32();\r\n            if hasher.finalize() != checksum {\r\n                panic!(\"checksum mismatch\");\r\n            }\r\n            skiplist.insert(KeyBytes::from_bytes_with_ts(key, ts), value);\r\n        }\r\n        Ok(Self {\r\n            file: Arc::new(Mutex::new(BufWriter::new(file))),\r\n        })\r\n    }\r\n\r\n    pub fn put(\u0026self, key: KeySlice, value: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        let mut file = self.file.lock();\r\n        let mut buf: Vec\u003cu8\u003e =\r\n            Vec::with_capacity(key.raw_len() + value.len() + std::mem::size_of::\u003cu16\u003e());\r\n        let mut hasher = crc32fast::Hasher::new();\r\n        hasher.write_u16(key.key_len() as u16);\r\n        buf.put_u16(key.key_len() as u16);\r\n        hasher.write(key.key_ref());\r\n        buf.put_slice(key.key_ref());\r\n        hasher.write_u64(key.ts());\r\n        buf.put_u64(key.ts());\r\n        hasher.write_u16(value.len() as u16);\r\n        buf.put_u16(value.len() as u16);\r\n        buf.put_slice(value);\r\n        hasher.write(value);\r\n        buf.put_u32(hasher.finalize());\r\n        file.write_all(\u0026buf)?;\r\n        Ok(())\r\n    }\r\n\r\n    pub fn sync(\u0026self) -\u003e Result\u003c()\u003e {\r\n        let mut file = self.file.lock();\r\n        file.flush()?;\r\n        file.get_mut().sync_all()?;\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":19,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":77,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":81,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":6485183463413514449},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":6485183463413514521},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":6485183463413514377},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null}],"covered":32,"coverable":59},{"path":["E:","\\","sql-layer","src","storage","mod.rs"],"content":"pub mod engine;\r\npub mod piggy_stroage;\r\nmod table_codec;\r\n\r\nuse crate::catalog::{ColumnCatalog, ColumnRef, IndexName, TableCatalog, TableName};\r\n\r\nuse crate::expression::simplify::ConstantBinary;\r\nuse crate::expression::ScalarExpression;\r\nuse crate::types::index::{Index, IndexMetaRef};\r\nuse crate::types::tuple::{Tuple, TupleId};\r\nuse crate::types::ColumnId;\r\nuse crate::{errors::*};\r\n\r\npub trait Storage: Sync + Send {\r\n    type TransactionType: Transaction;\r\n    #[allow(async_fn_in_trait)]\r\n    async fn transaction(\u0026self) -\u003e Result\u003cSelf::TransactionType\u003e;\r\n}\r\n\r\n/// Optional bounds of the reader, of the form (offset, limit).\r\npub(crate) type Bounds = (Option\u003cusize\u003e, Option\u003cusize\u003e);\r\ntype Projections = Vec\u003cScalarExpression\u003e;\r\n\r\npub trait Transaction: Sync + Send + 'static {\r\n    type IterType\u003c'a\u003e: Iter;\r\n    type IndexIterType\u003c'a\u003e: Iter;\r\n\r\n    /// The bounds is applied to the whole data batches, not per batch.\r\n    ///\r\n    /// The projections is column indices.\r\n    fn read(\r\n        \u0026self,\r\n        table_name: TableName,\r\n        bound: Bounds,\r\n        projection: Projections,\r\n    ) -\u003e Result\u003cSelf::IterType\u003c'_\u003e\u003e;\r\n\r\n    fn read_by_index(\r\n        \u0026self,\r\n        table_name: TableName,\r\n        projection: Projections,\r\n        index_meta: IndexMetaRef,\r\n        binaries: Vec\u003cConstantBinary\u003e,\r\n    ) -\u003e Result\u003cSelf::IndexIterType\u003c'_\u003e\u003e;\r\n\r\n    fn add_index(\r\n        \u0026mut self,\r\n        table_name: \u0026str,\r\n        index: Index,\r\n        tuple_ids: Vec\u003cTupleId\u003e,\r\n        is_unique: bool,\r\n    ) -\u003e Result\u003c()\u003e;\r\n\r\n    fn del_index(\u0026mut self, table_name: \u0026str, index: \u0026Index) -\u003e Result\u003c()\u003e;\r\n\r\n    fn append(\u0026mut self, table_name: \u0026str, tuple: Tuple, is_overwrite: bool) -\u003e Result\u003c()\u003e;\r\n\r\n    fn delete(\u0026mut self, table_name: \u0026str, tuple_id: TupleId) -\u003e Result\u003c()\u003e;\r\n\r\n    fn add_column(\r\n        \u0026mut self,\r\n        table_name: \u0026TableName,\r\n        column: \u0026ColumnCatalog,\r\n        if_not_exists: bool,\r\n    ) -\u003e Result\u003cColumnId\u003e;\r\n\r\n    fn drop_column(\u0026mut self, table_name: \u0026TableName, column: \u0026str, if_exists: bool) -\u003e Result\u003c()\u003e;\r\n\r\n    fn create_table(\r\n        \u0026mut self,\r\n        table_name: TableName,\r\n        columns: Vec\u003cColumnCatalog\u003e,\r\n        if_not_exists: bool,\r\n    ) -\u003e Result\u003cTableName\u003e;\r\n\r\n    fn drop_table(\u0026mut self, table_name: \u0026str, if_exists: bool) -\u003e Result\u003c()\u003e;\r\n    fn drop_data(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e;\r\n    fn table(\u0026self, table_name: TableName) -\u003e Option\u003cTableCatalog\u003e;\r\n\r\n    fn show_tables(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e;\r\n\r\n    #[allow(async_fn_in_trait)]\r\n    async fn commit(self) -\u003e Result\u003c()\u003e;\r\n    #[allow(async_fn_in_trait)]\r\n    async fn rollback(self) -\u003e Result\u003c()\u003e;\r\n\r\n    fn set_isolation(\u0026mut self, serializable: bool) -\u003e Result\u003c()\u003e;\r\n    fn create_index(\r\n        \u0026mut self,\r\n        table_name: TableName,\r\n        index_name: IndexName,\r\n        column_name: \u0026str,\r\n    ) -\u003e Result\u003c()\u003e;\r\n    fn drop_index(\r\n        \u0026mut self,\r\n        table_name: TableName,\r\n        index_name: IndexName,\r\n        if_not_exists: bool,\r\n    ) -\u003e Result\u003c()\u003e;\r\n}\r\n#[allow(dead_code)]\r\nenum IndexValue {\r\n    PrimaryKey(Tuple),\r\n    Normal(TupleId),\r\n}\r\n\r\npub trait Iter: Sync + Send {\r\n    fn fetch_tuple(\u0026mut self) -\u003e Result\u003cOption\u003cVec\u003cTuple\u003e\u003e\u003e;\r\n}\r\n\r\npub(crate) fn tuple_projection(\r\n    projections: \u0026Projections,\r\n    schema: \u0026[ColumnRef],\r\n    tuple: Tuple,\r\n) -\u003e Result\u003cTuple\u003e {\r\n    let projection_len = projections.len();\r\n    let mut values = Vec::with_capacity(projection_len);\r\n    for expr in projections.iter() {\r\n        values.push(expr.eval(\u0026tuple, schema)?);\r\n    }\r\n    Ok(Tuple {\r\n        id: tuple.id,\r\n        values,\r\n    })\r\n}\r\n\r\n","traces":[{"line":111,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":12898309332789100544},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null}],"covered":8,"coverable":8},{"path":["E:","\\","sql-layer","src","storage","piggy_stroage.rs"],"content":"use std::mem;\r\nuse std::ops::Bound;\r\nuse std::{collections::VecDeque, path::PathBuf, sync::Arc};\r\n\r\nuse itertools::Itertools;\r\nuse moka::sync::Cache;\r\nuse tracing::debug;\r\n\r\nuse crate::catalog::{ColumnCatalog, ColumnRef, IndexName};\r\nuse crate::catalog::{TableCatalog, TableName};\r\nuse crate::expression::simplify::ConstantBinary;\r\n\r\nuse crate::errors::*;\r\nuse crate::storage::table_codec::TableCodec;\r\nuse crate::types::index::{Index, IndexMeta, IndexMetaRef};\r\nuse crate::types::tuple::{Tuple, TupleId};\r\nuse crate::types::value::ValueRef;\r\nuse crate::types::ColumnId;\r\n\r\nuse super::engine::piggykv::iterators::StorageIterator;\r\nuse super::engine::piggykv::mvcc::txn::{Transaction as StorageTransaction, TxnIterator};\r\nuse super::engine::piggykv::PiggyKV;\r\nuse super::{engine::piggykv::lsm_storage::LsmStorageOptions, Projections, Storage};\r\nuse super::{tuple_projection, Bounds, Iter, Transaction};\r\npub struct PiggyKVStroage {\r\n    db: Arc\u003cPiggyKV\u003e,\r\n    cache: Arc\u003cCache\u003cTableName, TableCatalog\u003e\u003e,\r\n}\r\nimpl PiggyKVStroage {\r\n    pub fn new(path: PathBuf, option: Option\u003cLsmStorageOptions\u003e) -\u003e Self {\r\n        let option = match option {\r\n            Some(op) =\u003e op,\r\n            None =\u003e LsmStorageOptions::leveled_compaction(),\r\n        };\r\n        let db = PiggyKV::open(path, option).unwrap();\r\n        let cache = Arc::new(Cache::new(40));\r\n        Self { db, cache }\r\n    }\r\n}\r\nimpl Drop for PiggyKVStroage {\r\n    fn drop(\u0026mut self) {\r\n        self.db.close().unwrap();\r\n    }\r\n}\r\npub struct TransactionWarpper {\r\n    txn: Arc\u003cStorageTransaction\u003e,\r\n    cache: Arc\u003cCache\u003cTableName, TableCatalog\u003e\u003e,\r\n}\r\n\r\nimpl Storage for PiggyKVStroage {\r\n    type TransactionType = TransactionWarpper;\r\n\r\n    async fn transaction(\u0026self) -\u003e Result\u003cSelf::TransactionType\u003e {\r\n        Ok(TransactionWarpper {\r\n            txn: self.db.new_txn().unwrap(),\r\n            cache: self.cache.clone(),\r\n        })\r\n    }\r\n}\r\npub struct IndexIteratorWarpper {\r\n    projection: Projections,\r\n\r\n    index_meta: IndexMetaRef,\r\n    table: TableCatalog,\r\n    txn: Arc\u003cStorageTransaction\u003e,\r\n    binaries: VecDeque\u003cConstantBinary\u003e,\r\n}\r\n\r\nimpl IndexIteratorWarpper {\r\n    fn val_to_key(\u0026self, val: ValueRef) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\r\n        if self.index_meta.is_unique {\r\n            let index = Index::new(self.index_meta.id, vec![val]);\r\n\r\n            TableCodec::encode_index_key(\u0026self.table.name, \u0026index)\r\n        } else {\r\n            TableCodec::encode_tuple_key(\u0026self.table.name, \u0026val)\r\n        }\r\n    }\r\n    fn get_tuple_by_id(\u0026self, tuple_id: \u0026TupleId) -\u003e Result\u003cOption\u003cTuple\u003e\u003e {\r\n        let key = TableCodec::encode_tuple_key(\u0026self.table.name, tuple_id)?;\r\n        let schema = self.table.all_columns();\r\n        self.txn\r\n            .get(\u0026key)\r\n            .unwrap()\r\n            .map(|bytes| {\r\n                let tuple = TableCodec::decode_tuple(\u0026schema, \u0026bytes);\r\n\r\n                tuple_projection(\u0026self.projection, \u0026schema, tuple)\r\n            })\r\n            .transpose()\r\n    }\r\n}\r\nimpl Iter for IndexIteratorWarpper {\r\n    fn fetch_tuple(\u0026mut self) -\u003e Result\u003cOption\u003cVec\u003cTuple\u003e\u003e\u003e {\r\n        let mut tuples: Vec\u003cTuple\u003e = Vec::new();\r\n        let schema = self.table.all_columns();\r\n        for binary in self.binaries.iter().cloned() {\r\n            match binary {\r\n                ConstantBinary::Scope { min, max } =\u003e {\r\n                    let table_name = \u0026self.table.name;\r\n                    let index_meta = \u0026self.index_meta;\r\n\r\n                    let bound_encode = |bound: Bound\u003cValueRef\u003e| -\u003e Result\u003c_\u003e {\r\n                        match bound {\r\n                            Bound::Included(val) =\u003e Ok(Bound::Included(self.val_to_key(val)?)),\r\n                            Bound::Excluded(val) =\u003e Ok(Bound::Excluded(self.val_to_key(val)?)),\r\n                            Bound::Unbounded =\u003e Ok(Bound::Unbounded),\r\n                        }\r\n                    };\r\n                    let check_bound = |value: \u0026mut Bound\u003cVec\u003cu8\u003e\u003e, bound: Vec\u003cu8\u003e| {\r\n                        if matches!(value, Bound::Unbounded) {\r\n                            let _ = mem::replace(value, Bound::Included(bound));\r\n                        }\r\n                    };\r\n                    let (bound_min, bound_max) = if index_meta.is_unique {\r\n                        TableCodec::index_bound(table_name, \u0026index_meta.id)\r\n                    } else {\r\n                        TableCodec::tuple_bound(table_name)\r\n                    };\r\n\r\n                    let mut encode_min = bound_encode(min)?;\r\n                    check_bound(\u0026mut encode_min, bound_min);\r\n\r\n                    let mut encode_max = bound_encode(max)?;\r\n                    check_bound(\u0026mut encode_max, bound_max);\r\n                    let encode_min = match encode_min {\r\n                        Bound::Included(ref lo) =\u003e Bound::Included(lo.as_slice()),\r\n                        Bound::Excluded(ref lo) =\u003e Bound::Excluded(lo.as_slice()),\r\n                        Bound::Unbounded =\u003e Bound::Unbounded,\r\n                    };\r\n                    let encode_max = match encode_max {\r\n                        Bound::Included(ref lo) =\u003e Bound::Included(lo.as_slice()),\r\n                        Bound::Excluded(ref lo) =\u003e Bound::Excluded(lo.as_slice()),\r\n                        Bound::Unbounded =\u003e Bound::Unbounded,\r\n                    };\r\n                    let collect_iter = self.txn.scan(encode_min, encode_max)?;\r\n                    if self.index_meta.is_primary {\r\n                        //\r\n                        let collect = collect_iter\r\n                            .map(|(_, v)| -\u003e Tuple { TableCodec::decode_tuple(\u0026schema, \u0026v) })\r\n                            .collect_vec();\r\n                        tuples.extend(collect);\r\n                    } else {\r\n                        let index_values = collect_iter\r\n                            .map(|(_, v)| TableCodec::decode_index(\u0026v).expect(\"decode index error\"))\r\n                            .collect_vec();\r\n                        for tuple_ids in index_values {\r\n                            for tuple_id in tuple_ids {\r\n                                if let Some(tuple) = self.get_tuple_by_id(\u0026tuple_id)? {\r\n                                    tuples.push(tuple);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                ConstantBinary::Eq(val) =\u003e {\r\n                    let key = self.val_to_key(val)?;\r\n                    if let Some(Ok(bytes)) = self.txn.get(\u0026key).transpose() {\r\n                        let mut index_values = Vec::new();\r\n\r\n                        if self.index_meta.is_unique {\r\n                            for tuple_id in TableCodec::decode_index(\u0026bytes)? {\r\n                                index_values.push(tuple_id);\r\n                            }\r\n                            for tuple_id in index_values {\r\n                                if let Some(tuple) = self.get_tuple_by_id(\u0026tuple_id)? {\r\n                                    tuples.push(tuple);\r\n                                }\r\n                            }\r\n                        } else if self.index_meta.is_primary {\r\n                            let tuple = TableCodec::decode_tuple(\u0026schema, \u0026bytes);\r\n                            tuples.push(tuple);\r\n                        } else {\r\n                            todo!()\r\n                        }\r\n                    }\r\n                }\r\n                _ =\u003e (),\r\n            }\r\n        }\r\n\r\n        Ok(Some(tuples))\r\n    }\r\n}\r\n\r\npub struct IteratorWarpper {\r\n    projection: Projections,\r\n    all_columns: Vec\u003cColumnRef\u003e,\r\n    bound: Bounds,\r\n    iter: TxnIterator,\r\n}\r\nimpl Iter for IteratorWarpper {\r\n    fn fetch_tuple(\u0026mut self) -\u003e Result\u003cOption\u003cVec\u003cTuple\u003e\u003e\u003e {\r\n        let limit = match self.bound.1 {\r\n            Some(limit) =\u003e limit,\r\n            None =\u003e usize::MAX,\r\n        };\r\n        let offset = self.bound.0.unwrap_or(0);\r\n        // let mut tuples = vec![];\r\n        let tuples = self\r\n            .iter\r\n            .by_ref()\r\n            .skip(offset)\r\n            .filter_map(|(_, val)| {\r\n                tuple_projection(\r\n                    \u0026self.projection,\r\n                    \u0026self.all_columns,\r\n                    TableCodec::decode_tuple(\u0026self.all_columns, \u0026val),\r\n                )\r\n                .ok()\r\n            })\r\n            .take(limit)\r\n            .collect_vec();\r\n\r\n        Ok(Some(tuples))\r\n    }\r\n}\r\n\r\nimpl Transaction for TransactionWarpper {\r\n    type IterType\u003c'a\u003e = IteratorWarpper;\r\n\r\n    type IndexIterType\u003c'a\u003e = IndexIteratorWarpper;\r\n\r\n    fn read(\r\n        \u0026self,\r\n        table_name: TableName,\r\n        bound: Bounds,\r\n        projection: Projections,\r\n    ) -\u003e Result\u003cSelf::IterType\u003c'_\u003e\u003e {\r\n        let all_columns = self\r\n            .table(table_name.clone())\r\n            .ok_or(DatabaseError::TableNotFound)?\r\n            .all_columns();\r\n        let (min, max) = TableCodec::tuple_bound(\u0026table_name);\r\n\r\n        Ok(IteratorWarpper {\r\n            projection,\r\n            all_columns,\r\n            bound,\r\n            iter: self\r\n                .txn\r\n                .scan(Bound::Included(\u0026min), Bound::Included(\u0026max))\r\n                .unwrap(),\r\n        })\r\n    }\r\n\r\n    fn read_by_index(\r\n        \u0026self,\r\n        table_name: TableName,\r\n        projection: Projections,\r\n        index_meta: IndexMetaRef,\r\n        binaries: Vec\u003cConstantBinary\u003e,\r\n    ) -\u003e Result\u003cSelf::IndexIterType\u003c'_\u003e\u003e {\r\n        let table = self\r\n            .table(table_name.clone())\r\n            .ok_or(DatabaseError::TableNotFound)?;\r\n        Ok(IndexIteratorWarpper {\r\n            projection,\r\n            index_meta,\r\n            table,\r\n            binaries: VecDeque::from(binaries),\r\n            txn: self.txn.clone(),\r\n        })\r\n    }\r\n\r\n    fn add_index(\r\n        \u0026mut self,\r\n        table_name: \u0026str,\r\n        index: Index,\r\n        tuple_ids: Vec\u003cTupleId\u003e,\r\n        is_unique: bool,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let (key, value) = TableCodec::encode_index(table_name, \u0026index, \u0026tuple_ids)?;\r\n\r\n        if let Some(bytes) = self.txn.get(\u0026key).unwrap() {\r\n            if is_unique {\r\n                let old_tuple_ids = TableCodec::decode_index(\u0026bytes)?;\r\n\r\n                if old_tuple_ids[0] != tuple_ids[0] {\r\n                    return Err(DatabaseError::DuplicateUniqueValue);\r\n                } else {\r\n                    return Ok(());\r\n                }\r\n            } else {\r\n                todo!(\"\")\r\n            }\r\n        }\r\n\r\n        self.txn.put(\u0026key, \u0026value);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn del_index(\u0026mut self, table_name: \u0026str, index: \u0026Index) -\u003e Result\u003c()\u003e {\r\n        let key = TableCodec::encode_index_key(table_name, index)?;\r\n\r\n        self.txn.delete(\u0026key);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn append(\u0026mut self, table_name: \u0026str, tuple: Tuple, is_overwrite: bool) -\u003e Result\u003c()\u003e {\r\n        let (key, value) = TableCodec::encode_tuple(table_name, \u0026tuple)?;\r\n\r\n        if !is_overwrite \u0026\u0026 self.txn.get(\u0026key).unwrap().is_some() \u0026\u0026 tuple.id.is_some() {\r\n            return Err(DatabaseError::DuplicatePrimaryKey);\r\n        }\r\n        self.txn.put(\u0026key, \u0026value);\r\n        Ok(())\r\n    }\r\n\r\n    fn delete(\u0026mut self, table_name: \u0026str, tuple_id: TupleId) -\u003e Result\u003c()\u003e {\r\n        let key = TableCodec::encode_tuple_key(table_name, \u0026tuple_id)?;\r\n        self.txn.delete(\u0026key);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn add_column(\r\n        \u0026mut self,\r\n        table_name: \u0026TableName,\r\n        column: \u0026ColumnCatalog,\r\n        if_not_exists: bool,\r\n    ) -\u003e Result\u003cColumnId\u003e {\r\n        // if self.concurrency_transaction.load(Ordering::SeqCst) \u003e 1 {\r\n        //     return Err(DatabaseError::DDLSerialError(\r\n        //         self.concurrency_transaction.load(Ordering::SeqCst),\r\n        //     ));\r\n        // }\r\n\r\n        if let Some(mut catalog) = self.table(table_name.clone()) {\r\n            if !column.nullable \u0026\u0026 column.default_value().is_none() {\r\n                return Err(DatabaseError::NeedNullAbleOrDefault);\r\n            }\r\n\r\n            for col in catalog.all_columns() {\r\n                if col.name() == column.name() {\r\n                    if if_not_exists {\r\n                        return Ok(col.id().unwrap());\r\n                    } else {\r\n                        return Err(DatabaseError::DuplicateColumn);\r\n                    }\r\n                }\r\n            }\r\n\r\n            let col_id = catalog.add_column(column.clone())?;\r\n\r\n            if column.desc.is_unique {\r\n                let meta_ref = catalog.add_index_meta(\r\n                    format!(\"uk_{}\", column.name()),\r\n                    vec![col_id],\r\n                    true,\r\n                    false,\r\n                );\r\n                let (key, value) = TableCodec::encode_index_meta(table_name, meta_ref)?;\r\n                self.txn.put(\u0026key, \u0026value);\r\n            }\r\n\r\n            let column = catalog.get_column_by_id(\u0026col_id).unwrap();\r\n            let (key, value) = TableCodec::encode_column(table_name, column)?;\r\n            self.txn.put(\u0026key, \u0026value);\r\n            self.cache.remove(table_name);\r\n            Ok(col_id)\r\n        } else {\r\n            Err(DatabaseError::TableNotFound)\r\n        }\r\n    }\r\n\r\n    fn drop_column(\u0026mut self, table_name: \u0026TableName, column: \u0026str, if_exists: bool) -\u003e Result\u003c()\u003e {\r\n        if let Some(catalog) = self.table(table_name.clone()) {\r\n            let column = match catalog.get_column_by_name(column) {\r\n                Some(col) =\u003e col,\r\n                None =\u003e {\r\n                    if if_exists {\r\n                        return Ok(());\r\n                    } else {\r\n                        return Err(DatabaseError::NotFound(\r\n                            \"Coloum\",\r\n                            format!(\"{} not found\", column),\r\n                        ));\r\n                    }\r\n                }\r\n            };\r\n\r\n            if let Some(index_meta) = catalog.get_unique_index(\u0026column.id().unwrap()) {\r\n                let (index_meta_key, _) = TableCodec::encode_index_meta(table_name, index_meta)?;\r\n                self.txn.delete(\u0026index_meta_key);\r\n\r\n                let (index_min, index_max) = TableCodec::index_bound(table_name, \u0026index_meta.id);\r\n                self._drop_data(\u0026index_min, \u0026index_max)?;\r\n            }\r\n            let (key, _) = TableCodec::encode_column(table_name, column)?;\r\n            self.txn.delete(\u0026key);\r\n            self.cache.remove(table_name);\r\n            Ok(())\r\n        } else {\r\n            Err(DatabaseError::TableNotFound)\r\n        }\r\n    }\r\n\r\n    fn create_table(\r\n        \u0026mut self,\r\n        table_name: TableName,\r\n        columns: Vec\u003cColumnCatalog\u003e,\r\n        if_not_exists: bool,\r\n    ) -\u003e Result\u003cTableName\u003e {\r\n        let (table_key, value) = TableCodec::encode_root_table(\u0026table_name)?;\r\n        if self.txn.get(\u0026table_key).transpose().is_some() {\r\n            if if_not_exists {\r\n                return Ok(table_name);\r\n            }\r\n            return Err(DatabaseError::TableExists);\r\n        }\r\n        self.txn.put(\u0026table_key, \u0026value);\r\n\r\n        let mut table_catalog = TableCatalog::new(table_name.clone(), columns)?;\r\n\r\n        self.create_primary_key(\u0026mut table_catalog)?;\r\n        self._create_index(\u0026mut table_catalog, None)?;\r\n        // println!(\"create_table:table_catalog: {:#?}\", table_catalog);\r\n        for column in table_catalog.columns.values() {\r\n            let (key, value) = TableCodec::encode_column(\u0026table_name, column)?;\r\n            self.txn.put(\u0026key, \u0026value);\r\n        }\r\n        // info!(\"create_table:table_catalog: {:#?}\", table_catalog);\r\n        self.cache.insert(table_name.clone(), table_catalog);\r\n\r\n        Ok(table_name)\r\n    }\r\n\r\n    fn drop_table(\u0026mut self, table_name: \u0026str, if_exists: bool) -\u003e Result\u003c()\u003e {\r\n        if self.table(Arc::new(table_name.to_string())).is_none() {\r\n            if if_exists {\r\n                return Ok(());\r\n            } else {\r\n                return Err(DatabaseError::TableNotFound);\r\n            }\r\n        }\r\n        self.drop_data(table_name)?;\r\n\r\n        let (column_min, column_max) = TableCodec::columns_bound(table_name);\r\n        self._drop_data(\u0026column_min, \u0026column_max)?;\r\n\r\n        let (index_meta_min, index_meta_max) = TableCodec::index_meta_bound(table_name);\r\n        self._drop_data(\u0026index_meta_min, \u0026index_meta_max)?;\r\n\r\n        self.txn\r\n            .delete(\u0026TableCodec::encode_root_table_key(table_name));\r\n        self.cache.remove(\u0026Arc::new(table_name.to_string()));\r\n        Ok(())\r\n    }\r\n\r\n    fn drop_data(\u0026mut self, table_name: \u0026str) -\u003e Result\u003c()\u003e {\r\n        //\r\n        let (tuple_min, tuple_max) = TableCodec::tuple_bound(table_name);\r\n        self._drop_data(\u0026tuple_min, \u0026tuple_max)?;\r\n        //\r\n        let (index_min, index_max) = TableCodec::all_index_bound(table_name);\r\n        self._drop_data(\u0026index_min, \u0026index_max)?;\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn table(\u0026self, table_name: TableName) -\u003e Option\u003cTableCatalog\u003e {\r\n        match self.cache.get(\u0026table_name) {\r\n            Some(table) =\u003e Some(table),\r\n            None =\u003e {\r\n                // debug!(\"cache:{:?}\",self.cache);\r\n                let columns = match self.column_collect(table_name.clone()) {\r\n                    Ok(cols) =\u003e cols,\r\n                    Err(e) =\u003e {\r\n                        debug!(\"cannot fetch table {},because:{}\", table_name, e);\r\n                        return None;\r\n                    }\r\n                };\r\n\r\n                let indexes = self\r\n                    .index_meta_collect(\u0026table_name)?\r\n                    .into_iter()\r\n                    .map(Arc::new)\r\n                    .collect_vec();\r\n                //todo\r\n                match TableCatalog::new_with_indexes(table_name.clone(), columns, indexes) {\r\n                    Ok(table) =\u003e {\r\n                        self.cache.insert(table_name, table.clone());\r\n                        Some(table)\r\n                    }\r\n                    Err(e) =\u003e {\r\n                        debug!(\"cannot fetch table {},because:{}\", table_name, e);\r\n                        None\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    fn show_tables(\u0026self) -\u003e Result\u003cVec\u003cString\u003e\u003e {\r\n        let (min, max) = TableCodec::root_table_bound();\r\n        let scan = self\r\n            .txn\r\n            .scan(Bound::Included(\u0026min), Bound::Included(\u0026max))\r\n            .unwrap();\r\n        let metas = scan\r\n            .filter_map(|(_, val)| TableCodec::decode_root_table(\u0026val).ok())\r\n            .collect_vec();\r\n\r\n        // self.txn.debug();\r\n        Ok(metas)\r\n    }\r\n\r\n    async fn commit(self) -\u003e Result\u003c()\u003e {\r\n        self.txn.commit()?;\r\n        Ok(())\r\n    }\r\n\r\n    async fn rollback(self) -\u003e Result\u003c()\u003e {\r\n        Ok(())\r\n    }\r\n\r\n    fn set_isolation(\u0026mut self, _serializable: bool) -\u003e Result\u003c()\u003e {\r\n        todo!()\r\n    }\r\n\r\n    fn create_index(\r\n        \u0026mut self,\r\n        table_name: TableName,\r\n        index_name: IndexName,\r\n        column_name: \u0026str,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        let indexs = self.index_meta_collect(\u0026table_name).unwrap_or_default();\r\n        let indexs = indexs.into_iter().map(Arc::new).collect_vec();\r\n        let mut cols = self.column_collect(table_name.clone())?;\r\n        let col = cols.iter_mut().find(|col| col.name() == column_name);\r\n        if let Some(col) = col {\r\n            col.desc.is_unique = true;\r\n            let mut table = TableCatalog::new_with_indexes(table_name.clone(), cols, indexs)?;\r\n            self._create_index(\u0026mut table, Some(index_name.to_string()))?;\r\n            self.cache.remove(\u0026table_name);\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn drop_index(\r\n        \u0026mut self,\r\n        table_name: TableName,\r\n        index_name: IndexName,\r\n        _if_not_exists: bool,\r\n    ) -\u003e Result\u003c()\u003e {\r\n        //check index exists\r\n        //operator in copy temp data\r\n        let mut indexs = self.index_meta_collect(\u0026table_name).unwrap();\r\n        let (i, _) = indexs\r\n            .iter()\r\n            .find_position(|meta| meta.name == format!(\"{}_{}\", \"uk\", index_name))\r\n            .unwrap();\r\n        let item = indexs.remove(i);\r\n        let mut cols = self.column_collect(table_name.clone()).unwrap();\r\n        let indexs = indexs.into_iter().map(Arc::new).collect_vec();\r\n        cols.get_mut(item.column_ids[0] as usize).and_then(|col| {\r\n            col.desc.is_unique = false;\r\n            Some(())\r\n        });\r\n        //\r\n        //todo\r\n        //tablecodec,,\r\n        //IO\r\n        let (index_meta_min, index_meta_max) = TableCodec::index_meta_bound(\u0026table_name);\r\n        self._drop_data(\u0026index_meta_min, \u0026index_meta_max)?;\r\n        for meta in indexs.iter() {\r\n            let (key, value) = TableCodec::encode_index_meta(\u0026table_name, meta)?;\r\n            self.txn.put(\u0026key, \u0026value);\r\n        }\r\n        //\r\n        let (index_min, index_max) = TableCodec::index_bound(\u0026table_name, \u0026item.id);\r\n        self._drop_data(\u0026index_min, \u0026index_max)?;\r\n\r\n        let table = TableCatalog::new_with_indexes(table_name.clone(), cols, indexs)?;\r\n        self.update_table_meta(\u0026table)?;\r\n        self.cache.remove(\u0026table_name);\r\n\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl TransactionWarpper {\r\n    fn _drop_data(\u0026self, min: \u0026[u8], max: \u0026[u8]) -\u003e Result\u003c()\u003e {\r\n        let mut scan = self\r\n            .txn\r\n            .scan(Bound::Included(min), Bound::Included(max))\r\n            .unwrap();\r\n        // let mut iter = scan.iter();\r\n        while scan.is_valid() {\r\n            let key = scan.key();\r\n            self.txn.delete(key);\r\n            scan.next().unwrap();\r\n        }\r\n\r\n        // for key in data_keys {\r\n        //     self.txn.delete(key);\r\n        // }\r\n\r\n        Ok(())\r\n    }\r\n    fn update_table_meta(\u0026self, table: \u0026TableCatalog) -\u003e Result\u003c()\u003e {\r\n        for column in table.columns.values() {\r\n            let (key, value) = TableCodec::encode_column(\u0026table.name, column)?;\r\n            self.txn.put(\u0026key, \u0026value);\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    ///\r\n    fn index_meta_collect(\u0026self, name: \u0026str) -\u003e Option\u003cVec\u003cIndexMeta\u003e\u003e {\r\n        let (index_min, index_max) = TableCodec::index_meta_bound(name);\r\n        let mut index_metas = vec![];\r\n        let mut scan = self\r\n            .txn\r\n            .scan(Bound::Included(\u0026index_min), Bound::Included(\u0026index_max))\r\n            .expect(\"scan index meta error\");\r\n        // let mut index_iter = index_scan.iter();\r\n        while scan.is_valid() {\r\n            if let Ok(index_meta) = TableCodec::decode_index_meta(scan.value()) {\r\n                index_metas.push(index_meta);\r\n            }\r\n            scan.next().unwrap();\r\n        }\r\n        Some(index_metas)\r\n    }\r\n    ///\r\n    fn column_collect(\u0026self, table_name: TableName) -\u003e Result\u003cVec\u003cColumnCatalog\u003e\u003e {\r\n        let (column_min, column_max) = TableCodec::columns_bound(\u0026table_name);\r\n        let mut scan = self\r\n            .txn\r\n            .scan(Bound::Included(\u0026column_min), Bound::Included(\u0026column_max))\r\n            .unwrap();\r\n        let mut columns = vec![];\r\n        while scan.is_valid() {\r\n            let col = TableCodec::decode_column(scan.value())?;\r\n            columns.push(col);\r\n            scan.next().unwrap();\r\n        }\r\n\r\n        Ok(columns)\r\n    }\r\n    fn create_primary_key(\u0026self, table: \u0026mut TableCatalog) -\u003e Result\u003c()\u003e {\r\n        let table_name = table.name.clone();\r\n\r\n        let index_column = table\r\n            .all_columns()\r\n            .into_iter()\r\n            .filter(|col| col.desc.is_primary)\r\n            .collect_vec();\r\n\r\n        for col in index_column {\r\n            // FIXME: composite indexes may exist on future\r\n            let prefix = \"pk\";\r\n            if let Some(col_id) = col.id() {\r\n                let meta_ref = table.add_index_meta(\r\n                    format!(\"{}_{}\", prefix, col.name()),\r\n                    vec![col_id],\r\n                    col.desc.is_unique,\r\n                    col.desc.is_primary,\r\n                );\r\n                // println!(\"{:#?}\", meta_ref);\r\n\r\n                let (key, value) = TableCodec::encode_index_meta(\u0026table_name, meta_ref)?;\r\n\r\n                self.txn.put(\u0026key, \u0026value);\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n\r\n    fn _create_index(\u0026self, table: \u0026mut TableCatalog, index_name: Option\u003cString\u003e) -\u003e Result\u003c()\u003e {\r\n        let table_name = table.name.clone();\r\n\r\n        for col in table\r\n            .all_columns()\r\n            .into_iter()\r\n            .filter(|col| col.desc.is_unique)\r\n        {\r\n            let mut name = col.name().to_string();\r\n            if let Some(index_name) = \u0026index_name {\r\n                name = index_name.clone();\r\n            }\r\n            // FIXME: composite indexes may exist on future\r\n            let prefix = \"uk\";\r\n            if let Some(col_id) = col.id() {\r\n                let meta_ref = table.add_index_meta(\r\n                    format!(\"{}_{}\", prefix, name),\r\n                    vec![col_id],\r\n                    col.desc.is_unique,\r\n                    col.desc.is_primary,\r\n                );\r\n                // println!(\"meta_ref:{:#?}\", meta_ref);\r\n\r\n                let (key, value) = TableCodec::encode_index_meta(\u0026table_name, meta_ref)?;\r\n\r\n                self.txn.put(\u0026key, \u0026value);\r\n            }\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n#[cfg(test)]\r\nmod test {\r\n\r\n    use crate::{\r\n        catalog::ColumnDesc,\r\n        expression::ScalarExpression,\r\n        types::{value::DataValue, LogicalType},\r\n    };\r\n\r\n    use super::*;\r\n    #[tokio::test]\r\n    async fn test_in_storage() -\u003e Result\u003c()\u003e {\r\n        let path = tempdir::TempDir::new(\"piggydb\")\r\n            .unwrap()\r\n            .path()\r\n            .join(\"piggydb\");\r\n\r\n        let storage = PiggyKVStroage::new(path, None);\r\n        let mut transaction = storage.transaction().await?;\r\n        let columns = vec![\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c1\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Integer, true, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c2\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Boolean, false, false, None),\r\n                // None,\r\n            )),\r\n        ];\r\n        let source_columns = columns\r\n            .iter()\r\n            .map(|col_ref| ColumnCatalog::clone(\u0026col_ref))\r\n            .collect_vec();\r\n        let _ = transaction.create_table(Arc::new(\"test\".to_string()), source_columns, false)?;\r\n        let table_catalog = transaction.table(Arc::new(\"test\".to_string()));\r\n        assert!(table_catalog.is_some());\r\n        let cols = table_catalog.unwrap().all_columns();\r\n\r\n        transaction.append(\r\n            \u0026\"test\".to_string(),\r\n            Tuple {\r\n                id: Some(Arc::new(DataValue::Int32(Some(1)))),\r\n                values: vec![\r\n                    Arc::new(DataValue::Int32(Some(1))),\r\n                    Arc::new(DataValue::Boolean(Some(true))),\r\n                ],\r\n            },\r\n            false,\r\n        )?;\r\n        transaction.append(\r\n            \u0026\"test\".to_string(),\r\n            Tuple {\r\n                id: Some(Arc::new(DataValue::Int32(Some(2)))),\r\n                values: vec![\r\n                    Arc::new(DataValue::Int32(Some(2))),\r\n                    Arc::new(DataValue::Boolean(Some(false))),\r\n                ],\r\n            },\r\n            false,\r\n        )?;\r\n        let mut iter = transaction.read(\r\n            Arc::new(\"test\".to_string()),\r\n            (None, None),\r\n            vec![ScalarExpression::ColumnRef(cols[0].clone())],\r\n        )?;\r\n\r\n        let tuples = iter.fetch_tuple()?;\r\n        println!(\"{:#?}\", tuples);\r\n\r\n        if let Some(tuples) = tuples {\r\n            assert_eq!(tuples[0].id, Some(Arc::new(DataValue::Int32(Some(1)))));\r\n            assert_eq!(tuples[0].values, vec![Arc::new(DataValue::Int32(Some(1))),],);\r\n            assert_eq!(tuples[1].id, Some(Arc::new(DataValue::Int32(Some(2)))));\r\n            assert_eq!(tuples[1].values, vec![Arc::new(DataValue::Int32(Some(2))),],);\r\n        }\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":31,"address":[],"length":0,"stats":{"Line":6341068275337658368},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":18158513697557839872},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":9079256848778919936},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":9079256848778919936},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":9079256848778919936},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":80,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":5188146770730811392},"fn_name":null},{"line":195,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":196,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":230,"address":[],"length":0,"stats":{"Line":5188146770730811392},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":1585267068834414592},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":277,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":280,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":291,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":294,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":2449958197289549824},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":309,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":12249790986447749120},"fn_name":null},{"line":409,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":412,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":418,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":421,"address":[],"length":0,"stats":{"Line":12610078956637388800},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":6485183463413514240},"fn_name":null},{"line":426,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":434,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":439,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":442,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":445,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":448,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":449,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":453,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":455,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":456,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":458,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":432345564227567617},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":478,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":486,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":489,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":500,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":12249790986447749120},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":513,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":551,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":552,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":559,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":574,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":577,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":579,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":587,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":588,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":3170534137668829184},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":594,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":602,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":609,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":613,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":614,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":615,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":616,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":617,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":618,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":623,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":625,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":643,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":6269010681299730432},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":18374686479671623680},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":671,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":674,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":675,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":677,"address":[],"length":0,"stats":{"Line":9151314442816847872},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":6269010681299730432},"fn_name":null},{"line":682,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":697,"address":[],"length":0,"stats":{"Line":3026418949592973312},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":6124895493223874560},"fn_name":null}],"covered":166,"coverable":296},{"path":["E:","\\","sql-layer","src","storage","table_codec.rs"],"content":"use crate::catalog::{ColumnCatalog, ColumnRef};\r\nuse crate::errors::Result;\r\n\r\nuse crate::types::index::{Index, IndexId, IndexMeta};\r\nuse crate::types::tuple::{Tuple, TupleId};\r\nuse crate::types::value::DataValue;\r\nuse crate::types::LogicalType;\r\nuse bytes::Bytes;\r\nuse lazy_static::lazy_static;\r\nconst BOUND_MIN_TAG: u8 = 0;\r\nconst BOUND_MAX_TAG: u8 = 1;\r\nlazy_static! {\r\n    static ref ROOT_BYTES: Vec\u003cu8\u003e = b\"Root\".to_vec();\r\n}\r\n\r\n#[derive(Clone)]\r\npub struct TableCodec {}\r\n\r\n#[derive(Copy, Clone)]\r\nenum CodecType {\r\n    Column,\r\n    IndexMeta,\r\n    Index,\r\n    Tuple,\r\n    Root,\r\n}\r\n\r\nimpl TableCodec {\r\n    /// TableName + Type\r\n    ///\r\n    /// Tips: Root full key = key_prefix\r\n    fn key_prefix(ty: CodecType, table_name: \u0026str) -\u003e Vec\u003cu8\u003e {\r\n        let mut table_bytes = table_name.to_string().into_bytes();\r\n\r\n        match ty {\r\n            CodecType::Column =\u003e {\r\n                table_bytes.push(b'0');\r\n            }\r\n            CodecType::IndexMeta =\u003e {\r\n                table_bytes.push(b'1');\r\n            }\r\n            CodecType::Index =\u003e {\r\n                table_bytes.push(b'2');\r\n            }\r\n            CodecType::Tuple =\u003e {\r\n                table_bytes.push(b'3');\r\n            }\r\n            CodecType::Root =\u003e {\r\n                let mut bytes = ROOT_BYTES.clone();\r\n                bytes.push(BOUND_MIN_TAG);\r\n                bytes.append(\u0026mut table_bytes);\r\n\r\n                table_bytes = bytes\r\n            }\r\n        }\r\n\r\n        table_bytes\r\n    }\r\n\r\n    pub fn tuple_bound(table_name: \u0026str) -\u003e (Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\r\n        let op = |bound_id| {\r\n            let mut key_prefix = Self::key_prefix(CodecType::Tuple, table_name);\r\n\r\n            key_prefix.push(bound_id);\r\n            key_prefix\r\n        };\r\n\r\n        (op(BOUND_MIN_TAG), op(BOUND_MAX_TAG))\r\n    }\r\n    ///\r\n    pub fn index_meta_bound(table_name: \u0026str) -\u003e (Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\r\n        let op = |bound_id| {\r\n            let mut key_prefix = Self::key_prefix(CodecType::IndexMeta, table_name);\r\n\r\n            key_prefix.push(bound_id);\r\n            key_prefix\r\n        };\r\n\r\n        (op(BOUND_MIN_TAG), op(BOUND_MAX_TAG))\r\n    }\r\n    ///\r\n    pub fn index_bound(table_name: \u0026str, index_id: \u0026IndexId) -\u003e (Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\r\n        let op = |bound_id| {\r\n            let mut key_prefix = Self::key_prefix(CodecType::Index, table_name);\r\n\r\n            key_prefix.push(BOUND_MIN_TAG);\r\n            key_prefix.append(\u0026mut index_id.to_be_bytes().to_vec());\r\n            key_prefix.push(bound_id);\r\n            key_prefix\r\n        };\r\n\r\n        (op(BOUND_MIN_TAG), op(BOUND_MAX_TAG))\r\n    }\r\n\r\n    pub fn all_index_bound(table_name: \u0026str) -\u003e (Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\r\n        let op = |bound_id| {\r\n            let mut key_prefix = Self::key_prefix(CodecType::Index, table_name);\r\n\r\n            key_prefix.push(bound_id);\r\n            key_prefix\r\n        };\r\n\r\n        (op(BOUND_MIN_TAG), op(BOUND_MAX_TAG))\r\n    }\r\n\r\n    pub fn root_table_bound() -\u003e (Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\r\n        let op = |bound_id| {\r\n            let mut key_prefix = ROOT_BYTES.clone();\r\n\r\n            key_prefix.push(bound_id);\r\n            key_prefix\r\n        };\r\n\r\n        (op(BOUND_MIN_TAG), op(BOUND_MAX_TAG))\r\n    }\r\n\r\n    pub fn columns_bound(table_name: \u0026str) -\u003e (Vec\u003cu8\u003e, Vec\u003cu8\u003e) {\r\n        let op = |bound_id| {\r\n            let mut key_prefix = Self::key_prefix(CodecType::Column, table_name);\r\n\r\n            key_prefix.push(bound_id);\r\n            key_prefix\r\n        };\r\n\r\n        (op(BOUND_MIN_TAG), op(BOUND_MAX_TAG))\r\n    }\r\n\r\n    /// Key: {TableName}{TUPLE_TAG}{BOUND_MIN_TAG}{RowID}(Sorted)\r\n    /// Value: Tuple\r\n    pub fn encode_tuple(table_name: \u0026str, tuple: \u0026Tuple) -\u003e Result\u003c(Bytes, Bytes)\u003e {\r\n        // let tuple_id = tuple.id.clone().ok_or(DatabaseError::PrimaryKeyNotFound)?;\r\n        let tuple_id = tuple.id.clone();\r\n        let key = match tuple_id {\r\n            Some(tuple_id) =\u003e Self::encode_tuple_key(table_name, \u0026tuple_id)?,\r\n            None =\u003e Self::encode_tuple_key_without_primary_key(table_name)?,\r\n        };\r\n\r\n        Ok((Bytes::from(key), Bytes::from(tuple.serialize_to())))\r\n    }\r\n    pub fn encode_tuple_key_without_primary_key(table_name: \u0026str) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\r\n        let mut key_prefix = Self::key_prefix(CodecType::Tuple, table_name);\r\n        key_prefix.push(BOUND_MIN_TAG);\r\n        let id = DataValue::init(\u0026LogicalType::UUID);\r\n        id.to_primary_key(\u0026mut key_prefix)?;\r\n        Ok(key_prefix)\r\n    }\r\n\r\n    pub fn encode_tuple_key(table_name: \u0026str, tuple_id: \u0026TupleId) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\r\n        let mut key_prefix = Self::key_prefix(CodecType::Tuple, table_name);\r\n        key_prefix.push(BOUND_MIN_TAG);\r\n\r\n        tuple_id.to_primary_key(\u0026mut key_prefix)?;\r\n\r\n        Ok(key_prefix)\r\n    }\r\n\r\n    pub fn decode_tuple(columns: \u0026[ColumnRef], bytes: \u0026[u8]) -\u003e Tuple {\r\n        Tuple::deserialize_from(columns, bytes)\r\n    }\r\n\r\n    /// Key: {TableName}{INDEX_META_TAG}{BOUND_MIN_TAG}{IndexID}\r\n    /// Value: IndexMeta\r\n    pub fn encode_index_meta(table_name: \u0026str, index_meta: \u0026IndexMeta) -\u003e Result\u003c(Bytes, Bytes)\u003e {\r\n        let mut key_prefix = Self::key_prefix(CodecType::IndexMeta, table_name);\r\n        key_prefix.push(BOUND_MIN_TAG);\r\n        key_prefix.append(\u0026mut index_meta.id.to_be_bytes().to_vec());\r\n\r\n        Ok((\r\n            Bytes::from(key_prefix),\r\n            Bytes::from(bincode::serialize(\u0026index_meta)?),\r\n        ))\r\n    }\r\n\r\n    pub fn decode_index_meta(bytes: \u0026[u8]) -\u003e Result\u003cIndexMeta\u003e {\r\n        Ok(bincode::deserialize(bytes)?)\r\n    }\r\n\r\n    /// NonUnique Index:\r\n    /// Key: {TableName}{INDEX_TAG}{BOUND_MIN_TAG}{IndexID}{BOUND_MIN_TAG}{DataValue1}{DataValue2} ..\r\n    /// Value: TupleIDs\r\n    ///\r\n    /// Unique Index:\r\n    /// Key: {TableName}{INDEX_TAG}{BOUND_MIN_TAG}{IndexID}{BOUND_MIN_TAG}{DataValue}\r\n    /// Value: TupleIDs\r\n    ///\r\n    /// Tips: The unique index has only one ColumnID and one corresponding DataValue,\r\n    /// so it can be positioned directly.\r\n    pub fn encode_index(\r\n        name: \u0026str,\r\n        index: \u0026Index,\r\n        tuple_ids: \u0026[TupleId],\r\n    ) -\u003e Result\u003c(Bytes, Bytes)\u003e {\r\n        let key = TableCodec::encode_index_key(name, index)?;\r\n\r\n        Ok((\r\n            Bytes::from(key),\r\n            Bytes::from(bincode::serialize(tuple_ids)?),\r\n        ))\r\n    }\r\n\r\n    pub fn encode_index_key(name: \u0026str, index: \u0026Index) -\u003e Result\u003cVec\u003cu8\u003e\u003e {\r\n        let mut key_prefix = Self::key_prefix(CodecType::Index, name);\r\n        key_prefix.push(BOUND_MIN_TAG);\r\n        key_prefix.append(\u0026mut index.id.to_be_bytes().to_vec());\r\n        key_prefix.push(BOUND_MIN_TAG);\r\n\r\n        for col_v in \u0026index.column_values {\r\n            col_v.to_index_key(\u0026mut key_prefix)?;\r\n        }\r\n\r\n        Ok(key_prefix)\r\n    }\r\n\r\n    pub fn decode_index(bytes: \u0026[u8]) -\u003e Result\u003cVec\u003cTupleId\u003e\u003e {\r\n        Ok(bincode::deserialize(bytes)?)\r\n    }\r\n\r\n    /// Key: {TableName}{COLUMN_TAG}{BOUND_MIN_TAG}{ColumnId}\r\n    /// Value: ColumnCatalog\r\n    ///\r\n    /// Tips: the `0` for bound range\r\n    pub fn encode_column(table_name: \u0026str, col: \u0026ColumnCatalog) -\u003e Result\u003c(Bytes, Bytes)\u003e {\r\n        let bytes = bincode::serialize(col)?;\r\n        let mut key_prefix = Self::key_prefix(CodecType::Column, table_name);\r\n\r\n        key_prefix.push(BOUND_MIN_TAG);\r\n        key_prefix.append(\u0026mut col.id().unwrap().to_be_bytes().to_vec());\r\n\r\n        Ok((Bytes::from(key_prefix), Bytes::from(bytes)))\r\n    }\r\n\r\n    pub fn decode_column(bytes: \u0026[u8]) -\u003e Result\u003cColumnCatalog\u003e {\r\n        Ok(bincode::deserialize::\u003cColumnCatalog\u003e(bytes)?)\r\n    }\r\n\r\n    /// Key: Root{BOUND_MIN_TAG}{TableName}\r\n    /// Value: TableName\r\n    pub fn encode_root_table(table_name: \u0026str) -\u003e Result\u003c(Bytes, Bytes)\u003e {\r\n        let key = Self::encode_root_table_key(table_name);\r\n\r\n        Ok((\r\n            Bytes::from(key),\r\n            Bytes::from(table_name.to_owned().into_bytes()),\r\n        ))\r\n    }\r\n\r\n    pub fn encode_root_table_key(table_name: \u0026str) -\u003e Vec\u003cu8\u003e {\r\n        Self::key_prefix(CodecType::Root, table_name)\r\n    }\r\n\r\n    pub fn decode_root_table(bytes: \u0026[u8]) -\u003e Result\u003cString\u003e {\r\n        Ok(String::from_utf8(bytes.to_vec())?)\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use crate::catalog::{ColumnCatalog, ColumnDesc, TableCatalog};\r\n    use crate::storage::table_codec::TableCodec;\r\n    use crate::types::index::{Index, IndexMeta};\r\n    use crate::types::tuple::Tuple;\r\n    use crate::types::value::DataValue;\r\n    use crate::types::LogicalType;\r\n    use bytes::Bytes;\r\n    use itertools::Itertools;\r\n    use std::collections::BTreeSet;\r\n    use std::ops::Bound;\r\n    use std::sync::Arc;\r\n\r\n    fn build_table_codec() -\u003e TableCatalog {\r\n        let columns = vec![ColumnCatalog::new(\r\n            \"c1\".into(),\r\n            false,\r\n            ColumnDesc::new(LogicalType::Integer, true, false, None),\r\n            // None,\r\n        )];\r\n        TableCatalog::new(Arc::new(\"t1\".to_string()), columns).unwrap()\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_tuple() -\u003e Result\u003c()\u003e {\r\n        let table_catalog = build_table_codec();\r\n\r\n        let tuple = Tuple {\r\n            id: Some(Arc::new(DataValue::Int32(Some(0)))),\r\n            values: vec![Arc::new(DataValue::Int32(Some(0)))],\r\n        };\r\n        let (_, bytes) = TableCodec::encode_tuple(\u0026table_catalog.name, \u0026tuple)?;\r\n\r\n        assert_eq!(\r\n            TableCodec::decode_tuple(\u0026table_catalog.all_columns(), \u0026bytes),\r\n            tuple\r\n        );\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_root_catalog() {\r\n        let table_catalog = build_table_codec();\r\n        let (_, bytes) = TableCodec::encode_root_table(\u0026table_catalog.name).unwrap();\r\n\r\n        let table_name = TableCodec::decode_root_table(\u0026bytes).unwrap();\r\n\r\n        assert_eq!(table_name, table_catalog.name.as_str());\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_index_meta() -\u003e Result\u003c()\u003e {\r\n        let index_meta = IndexMeta {\r\n            id: 0,\r\n            column_ids: vec![0],\r\n            name: \"index_1\".to_string(),\r\n            is_unique: false,\r\n            is_primary: false,\r\n        };\r\n        let (_, bytes) = TableCodec::encode_index_meta(\u0026\"T1\".to_string(), \u0026index_meta)?;\r\n\r\n        assert_eq!(TableCodec::decode_index_meta(\u0026bytes)?, index_meta);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_index() -\u003e Result\u003c()\u003e {\r\n        let table_catalog = build_table_codec();\r\n\r\n        let index = Index {\r\n            id: 0,\r\n            column_values: vec![Arc::new(DataValue::Int32(Some(0)))],\r\n        };\r\n        let tuple_ids = vec![Arc::new(DataValue::Int32(Some(0)))];\r\n        let (_, bytes) = TableCodec::encode_index(\u0026table_catalog.name, \u0026index, \u0026tuple_ids)?;\r\n\r\n        assert_eq!(TableCodec::decode_index(\u0026bytes)?, tuple_ids);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_column() {\r\n        let table_catalog = build_table_codec();\r\n        let col = table_catalog.all_columns()[0].clone();\r\n\r\n        let (_, bytes) = TableCodec::encode_column(\u0026table_catalog.name, \u0026col).unwrap();\r\n        let decode_col = TableCodec::decode_column(\u0026bytes).unwrap();\r\n\r\n        assert_eq!(\u0026decode_col, col.as_ref());\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_column_bound() {\r\n        let mut set = BTreeSet::new();\r\n        let op = |col_id: usize, table_name: \u0026str| {\r\n            let mut col = ColumnCatalog::new(\r\n                \"\".to_string(),\r\n                false,\r\n                ColumnDesc {\r\n                    column_datatype: LogicalType::Invalid,\r\n                    is_primary: false,\r\n                    is_unique: false,\r\n                    default: None,\r\n                },\r\n                // None,\r\n            );\r\n\r\n            col.summary.id = Some(col_id as u32);\r\n\r\n            let (key, _) = TableCodec::encode_column(\u0026table_name.to_string(), \u0026col).unwrap();\r\n            key\r\n        };\r\n\r\n        set.insert(op(0, \"T0\"));\r\n        set.insert(op(1, \"T0\"));\r\n        set.insert(op(2, \"T0\"));\r\n\r\n        set.insert(op(0, \"T1\"));\r\n        set.insert(op(1, \"T1\"));\r\n        set.insert(op(2, \"T1\"));\r\n\r\n        set.insert(op(0, \"T2\"));\r\n        set.insert(op(0, \"T2\"));\r\n        set.insert(op(0, \"T2\"));\r\n\r\n        let (min, max) = TableCodec::columns_bound(\u0026Arc::new(\"T1\".to_string()));\r\n\r\n        let vec = set\r\n            .range::\u003cBytes, (Bound\u003c\u0026Bytes\u003e, Bound\u003c\u0026Bytes\u003e)\u003e((\r\n                Bound::Included(\u0026Bytes::from(min)),\r\n                Bound::Included(\u0026Bytes::from(max)),\r\n            ))\r\n            .collect_vec();\r\n\r\n        assert_eq!(vec.len(), 3);\r\n\r\n        assert_eq!(vec[0], \u0026op(0, \"T1\"));\r\n        assert_eq!(vec[1], \u0026op(1, \"T1\"));\r\n        assert_eq!(vec[2], \u0026op(2, \"T1\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_index_meta_bound() {\r\n        let mut set = BTreeSet::new();\r\n        let op = |index_id: usize, table_name: \u0026str| {\r\n            let index_meta = IndexMeta {\r\n                id: index_id as u32,\r\n                column_ids: vec![],\r\n                name: \"\".to_string(),\r\n                is_unique: false,\r\n                is_primary: false,\r\n            };\r\n\r\n            let (key, _) =\r\n                TableCodec::encode_index_meta(\u0026table_name.to_string(), \u0026index_meta).unwrap();\r\n            key\r\n        };\r\n\r\n        set.insert(op(0, \"T0\"));\r\n        set.insert(op(1, \"T0\"));\r\n        set.insert(op(2, \"T0\"));\r\n\r\n        set.insert(op(0, \"T1\"));\r\n        set.insert(op(1, \"T1\"));\r\n        set.insert(op(2, \"T1\"));\r\n\r\n        set.insert(op(0, \"T2\"));\r\n        set.insert(op(1, \"T2\"));\r\n        set.insert(op(2, \"T2\"));\r\n\r\n        let (min, max) = TableCodec::index_meta_bound(\u0026\"T1\".to_string());\r\n\r\n        let vec = set\r\n            .range::\u003cBytes, (Bound\u003c\u0026Bytes\u003e, Bound\u003c\u0026Bytes\u003e)\u003e((\r\n                Bound::Included(\u0026Bytes::from(min)),\r\n                Bound::Included(\u0026Bytes::from(max)),\r\n            ))\r\n            .collect_vec();\r\n\r\n        assert_eq!(vec.len(), 3);\r\n\r\n        assert_eq!(vec[0], \u0026op(0, \"T1\"));\r\n        assert_eq!(vec[1], \u0026op(1, \"T1\"));\r\n        assert_eq!(vec[2], \u0026op(2, \"T1\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_index_bound() {\r\n        let mut set = BTreeSet::new();\r\n        let column = ColumnCatalog::new(\r\n            \"\".to_string(),\r\n            false,\r\n            ColumnDesc::new(LogicalType::Boolean, false, false, None),\r\n            // None,\r\n        );\r\n        let table_catalog = TableCatalog::new(Arc::new(\"T0\".to_string()), vec![column]).unwrap();\r\n\r\n        let op = |value: DataValue, index_id: usize, table_name: \u0026String| {\r\n            let index = Index {\r\n                id: index_id as u32,\r\n                column_values: vec![Arc::new(value)],\r\n            };\r\n\r\n            TableCodec::encode_index_key(table_name, \u0026index).unwrap()\r\n        };\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), 0, \u0026table_catalog.name));\r\n        set.insert(op(DataValue::Int32(Some(1)), 0, \u0026table_catalog.name));\r\n        set.insert(op(DataValue::Int32(Some(2)), 0, \u0026table_catalog.name));\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), 1, \u0026table_catalog.name));\r\n        set.insert(op(DataValue::Int32(Some(1)), 1, \u0026table_catalog.name));\r\n        set.insert(op(DataValue::Int32(Some(2)), 1, \u0026table_catalog.name));\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), 2, \u0026table_catalog.name));\r\n        set.insert(op(DataValue::Int32(Some(1)), 2, \u0026table_catalog.name));\r\n        set.insert(op(DataValue::Int32(Some(2)), 2, \u0026table_catalog.name));\r\n\r\n        println!(\"{:#?}\", set);\r\n\r\n        let (min, max) = TableCodec::index_bound(\u0026table_catalog.name, \u00261);\r\n\r\n        println!(\"{:?}\", min);\r\n        println!(\"{:?}\", max);\r\n\r\n        let vec = set\r\n            .range::\u003cVec\u003cu8\u003e, (Bound\u003c\u0026Vec\u003cu8\u003e\u003e, Bound\u003c\u0026Vec\u003cu8\u003e\u003e)\u003e((\r\n                Bound::Included(\u0026min),\r\n                Bound::Included(\u0026max),\r\n            ))\r\n            .collect_vec();\r\n\r\n        assert_eq!(vec.len(), 3);\r\n\r\n        assert_eq!(\r\n            vec[0],\r\n            \u0026op(DataValue::Int32(Some(0)), 1, \u0026table_catalog.name)\r\n        );\r\n        assert_eq!(\r\n            vec[1],\r\n            \u0026op(DataValue::Int32(Some(1)), 1, \u0026table_catalog.name)\r\n        );\r\n        assert_eq!(\r\n            vec[2],\r\n            \u0026op(DataValue::Int32(Some(2)), 1, \u0026table_catalog.name)\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_index_all_bound() {\r\n        let mut set = BTreeSet::new();\r\n        let op = |value: DataValue, index_id: usize, table_name: \u0026str| {\r\n            let index = Index {\r\n                id: index_id as u32,\r\n                column_values: vec![Arc::new(value)],\r\n            };\r\n\r\n            TableCodec::encode_index_key(\u0026table_name.to_string(), \u0026index).unwrap()\r\n        };\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), 0, \"T0\"));\r\n        set.insert(op(DataValue::Int32(Some(1)), 0, \"T0\"));\r\n        set.insert(op(DataValue::Int32(Some(2)), 0, \"T0\"));\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), 0, \"T1\"));\r\n        set.insert(op(DataValue::Int32(Some(1)), 0, \"T1\"));\r\n        set.insert(op(DataValue::Int32(Some(2)), 0, \"T1\"));\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), 0, \"T2\"));\r\n        set.insert(op(DataValue::Int32(Some(1)), 0, \"T2\"));\r\n        set.insert(op(DataValue::Int32(Some(2)), 0, \"T2\"));\r\n\r\n        let (min, max) = TableCodec::all_index_bound(\u0026\"T1\".to_string());\r\n\r\n        let vec = set\r\n            .range::\u003cVec\u003cu8\u003e, (Bound\u003c\u0026Vec\u003cu8\u003e\u003e, Bound\u003c\u0026Vec\u003cu8\u003e\u003e)\u003e((\r\n                Bound::Included(\u0026min),\r\n                Bound::Included(\u0026max),\r\n            ))\r\n            .collect_vec();\r\n\r\n        assert_eq!(vec.len(), 3);\r\n\r\n        assert_eq!(vec[0], \u0026op(DataValue::Int32(Some(0)), 0, \"T1\"));\r\n        assert_eq!(vec[1], \u0026op(DataValue::Int32(Some(1)), 0, \"T1\"));\r\n        assert_eq!(vec[2], \u0026op(DataValue::Int32(Some(2)), 0, \"T1\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_table_codec_tuple_bound() {\r\n        let mut set = BTreeSet::new();\r\n        let op = |tuple_id: DataValue, table_name: \u0026str| {\r\n            TableCodec::encode_tuple_key(\u0026table_name.to_string(), \u0026Arc::new(tuple_id)).unwrap()\r\n        };\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), \"T0\"));\r\n        set.insert(op(DataValue::Int32(Some(1)), \"T0\"));\r\n        set.insert(op(DataValue::Int32(Some(2)), \"T0\"));\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), \"T1\"));\r\n        set.insert(op(DataValue::Int32(Some(1)), \"T1\"));\r\n        set.insert(op(DataValue::Int32(Some(2)), \"T1\"));\r\n\r\n        set.insert(op(DataValue::Int32(Some(0)), \"T2\"));\r\n        set.insert(op(DataValue::Int32(Some(1)), \"T2\"));\r\n        set.insert(op(DataValue::Int32(Some(2)), \"T2\"));\r\n\r\n        let (min, max) = TableCodec::tuple_bound(\u0026\"T1\".to_string());\r\n\r\n        let vec = set\r\n            .range::\u003cVec\u003cu8\u003e, (Bound\u003c\u0026Vec\u003cu8\u003e\u003e, Bound\u003c\u0026Vec\u003cu8\u003e\u003e)\u003e((\r\n                Bound::Included(\u0026min),\r\n                Bound::Included(\u0026max),\r\n            ))\r\n            .collect_vec();\r\n\r\n        assert_eq!(vec.len(), 3);\r\n\r\n        assert_eq!(vec[0], \u0026op(DataValue::Int32(Some(0)), \"T1\"));\r\n        assert_eq!(vec[1], \u0026op(DataValue::Int32(Some(1)), \"T1\"));\r\n        assert_eq!(vec[2], \u0026op(DataValue::Int32(Some(2)), \"T1\"));\r\n    }\r\n\r\n    #[test]\r\n    fn test_root_codec_name_bound() {\r\n        let mut set = BTreeSet::new();\r\n        let op = |table_name: \u0026str| TableCodec::encode_root_table_key(\u0026table_name.to_string());\r\n\r\n        set.insert(b\"A\".to_vec());\r\n\r\n        set.insert(op(\"T0\"));\r\n        set.insert(op(\"T1\"));\r\n        set.insert(op(\"T2\"));\r\n\r\n        set.insert(b\"Z\".to_vec());\r\n\r\n        let (min, max) = TableCodec::root_table_bound();\r\n\r\n        let vec = set\r\n            .range::\u003cVec\u003cu8\u003e, (Bound\u003c\u0026Vec\u003cu8\u003e\u003e, Bound\u003c\u0026Vec\u003cu8\u003e\u003e)\u003e((\r\n                Bound::Included(\u0026min),\r\n                Bound::Included(\u0026max),\r\n            ))\r\n            .collect_vec();\r\n\r\n        assert_eq!(vec[0], \u0026op(\"T0\"));\r\n        assert_eq!(vec[1], \u0026op(\"T1\"));\r\n        assert_eq!(vec[2], \u0026op(\"T2\"));\r\n    }\r\n}\r\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":13690942867206307838},"fn_name":null},{"line":37,"address":[],"length":0,"stats":{"Line":13690942867206307838},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":10376293541461622786},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":10376293541461622786},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":5476377146882523136},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":5476377146882523136},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":5476377146882523136},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":152,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":10088063165309911040},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":193,"address":[],"length":0,"stats":{"Line":1729382256910270464},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":202,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":2882303761517117440},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":13402712491054596096},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":8358680908399640576},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":238,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":239,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":241,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":242,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":6701356245527298048},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":252,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null}],"covered":98,"coverable":107},{"path":["E:","\\","sql-layer","src","types","index.rs"],"content":"use crate::types::value::ValueRef;\r\nuse crate::types::ColumnId;\r\n\r\nuse serde::{Deserialize, Serialize};\r\nuse std::{\r\n    fmt::{self, Formatter},\r\n    sync::Arc,\r\n};\r\n\r\npub type IndexId = u32;\r\npub type IndexMetaRef = Arc\u003cIndexMeta\u003e;\r\n\r\n#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq)]\r\npub struct IndexMeta {\r\n    pub id: IndexId,\r\n    pub column_ids: Vec\u003cColumnId\u003e,\r\n    pub name: String,\r\n    pub is_unique: bool,\r\n    pub is_primary: bool,\r\n}\r\n\r\npub struct Index {\r\n    pub id: IndexId,\r\n    pub column_values: Vec\u003cValueRef\u003e,\r\n}\r\n\r\nimpl Index {\r\n    pub fn new(id: IndexId, column_values: Vec\u003cValueRef\u003e) -\u003e Self {\r\n        Index { id, column_values }\r\n    }\r\n}\r\n\r\nimpl fmt::Display for IndexMeta {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        write!(f, \"{}\", self.name)\r\n    }\r\n}\r\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":3},{"path":["E:","\\","sql-layer","src","types","mod.rs"],"content":"pub mod index;\r\npub mod tuple;\r\npub mod tuple_builder;\r\npub mod value;\r\n\r\nuse chrono::{NaiveDate, NaiveDateTime};\r\nuse rust_decimal::Decimal;\r\nuse serde::{Deserialize, Serialize};\r\nuse sqlparser::ast::ExactNumberInfo;\r\nuse std::any::TypeId;\r\nuse strum_macros::AsRefStr;\r\n\r\nuse crate::errors::{DatabaseError, Result};\r\n\r\npub type ColumnId = u32;\r\n\r\n/// Sqlrs type conversion:\r\n/// sqlparser::ast::DataType -\u003e LogicalType -\u003e arrow::datatypes::DataType\r\n#[derive(\r\n    Debug, Clone, Copy, PartialEq, Eq, Hash, AsRefStr, PartialOrd, Ord, Serialize, Deserialize,\r\n)]\r\npub enum LogicalType {\r\n    Invalid,\r\n    SqlNull,\r\n    Boolean,\r\n    Tinyint,\r\n    UTinyint,\r\n    Smallint,\r\n    USmallint,\r\n    Integer,\r\n    UInteger,\r\n    Bigint,\r\n    UBigint,\r\n    Float,\r\n    Double,\r\n    Varchar(Option\u003cu32\u003e),\r\n    Date,\r\n    DateTime,\r\n    // decimal (precision, scale)\r\n    Decimal(Option\u003cu8\u003e, Option\u003cu8\u003e),\r\n    //uuid now only support to non-pk table,and use to identify a tuple\r\n    UUID,\r\n}\r\n\r\nimpl LogicalType {\r\n    pub fn type_trans\u003cT: 'static\u003e() -\u003e Option\u003cLogicalType\u003e {\r\n        let type_id = TypeId::of::\u003cT\u003e();\r\n\r\n        if type_id == TypeId::of::\u003ci8\u003e() {\r\n            Some(LogicalType::Tinyint)\r\n        } else if type_id == TypeId::of::\u003ci16\u003e() {\r\n            Some(LogicalType::Smallint)\r\n        } else if type_id == TypeId::of::\u003ci32\u003e() {\r\n            Some(LogicalType::Integer)\r\n        } else if type_id == TypeId::of::\u003ci64\u003e() {\r\n            Some(LogicalType::Bigint)\r\n        } else if type_id == TypeId::of::\u003cu8\u003e() {\r\n            Some(LogicalType::UTinyint)\r\n        } else if type_id == TypeId::of::\u003cu16\u003e() {\r\n            Some(LogicalType::USmallint)\r\n        } else if type_id == TypeId::of::\u003cu32\u003e() {\r\n            Some(LogicalType::UInteger)\r\n        } else if type_id == TypeId::of::\u003cu64\u003e() {\r\n            Some(LogicalType::UBigint)\r\n        } else if type_id == TypeId::of::\u003cf32\u003e() {\r\n            Some(LogicalType::Float)\r\n        } else if type_id == TypeId::of::\u003cf64\u003e() {\r\n            Some(LogicalType::Double)\r\n        } else if type_id == TypeId::of::\u003cNaiveDate\u003e() {\r\n            Some(LogicalType::Date)\r\n        } else if type_id == TypeId::of::\u003cNaiveDateTime\u003e() {\r\n            Some(LogicalType::DateTime)\r\n        } else if type_id == TypeId::of::\u003cDecimal\u003e() {\r\n            Some(LogicalType::Decimal(None, None))\r\n        } else if type_id == TypeId::of::\u003cString\u003e() {\r\n            Some(LogicalType::Varchar(None))\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    pub fn raw_len(\u0026self) -\u003e Option\u003cusize\u003e {\r\n        match self {\r\n            LogicalType::Invalid =\u003e Some(0),\r\n            LogicalType::SqlNull =\u003e Some(0),\r\n            LogicalType::Boolean =\u003e Some(1),\r\n            LogicalType::Tinyint =\u003e Some(1),\r\n            LogicalType::UTinyint =\u003e Some(1),\r\n            LogicalType::Smallint =\u003e Some(2),\r\n            LogicalType::USmallint =\u003e Some(2),\r\n            LogicalType::Integer =\u003e Some(4),\r\n            LogicalType::UInteger =\u003e Some(4),\r\n            LogicalType::Bigint =\u003e Some(8),\r\n            LogicalType::UBigint =\u003e Some(8),\r\n            LogicalType::Float =\u003e Some(4),\r\n            LogicalType::Double =\u003e Some(8),\r\n            // Note: The non-fixed length type's raw_len is None e.g. Varchar\r\n            LogicalType::Varchar(_) =\u003e None,\r\n            LogicalType::Date =\u003e Some(4),\r\n            LogicalType::DateTime =\u003e Some(8),\r\n            LogicalType::Decimal(_, _) =\u003e Some(16),\r\n            LogicalType::UUID =\u003e Some(16),\r\n        }\r\n    }\r\n\r\n    pub fn numeric() -\u003e Vec\u003cLogicalType\u003e {\r\n        vec![\r\n            LogicalType::Tinyint,\r\n            LogicalType::UTinyint,\r\n            LogicalType::Smallint,\r\n            LogicalType::USmallint,\r\n            LogicalType::Integer,\r\n            LogicalType::UInteger,\r\n            LogicalType::Bigint,\r\n            LogicalType::UBigint,\r\n            LogicalType::Float,\r\n            LogicalType::Double,\r\n        ]\r\n    }\r\n\r\n    pub fn is_numeric(\u0026self) -\u003e bool {\r\n        matches!(\r\n            self,\r\n            LogicalType::Tinyint\r\n                | LogicalType::UTinyint\r\n                | LogicalType::Smallint\r\n                | LogicalType::USmallint\r\n                | LogicalType::Integer\r\n                | LogicalType::UInteger\r\n                | LogicalType::Bigint\r\n                | LogicalType::UBigint\r\n                | LogicalType::Float\r\n                | LogicalType::Double\r\n        )\r\n    }\r\n\r\n    pub fn is_signed_numeric(\u0026self) -\u003e bool {\r\n        matches!(\r\n            self,\r\n            LogicalType::Tinyint\r\n                | LogicalType::Smallint\r\n                | LogicalType::Integer\r\n                | LogicalType::Bigint\r\n        )\r\n    }\r\n\r\n    pub fn is_unsigned_numeric(\u0026self) -\u003e bool {\r\n        matches!(\r\n            self,\r\n            LogicalType::UTinyint\r\n                | LogicalType::USmallint\r\n                | LogicalType::UInteger\r\n                | LogicalType::UBigint\r\n        )\r\n    }\r\n\r\n    pub fn is_floating_point_numeric(\u0026self) -\u003e bool {\r\n        matches!(self, LogicalType::Float | LogicalType::Double)\r\n    }\r\n\r\n    pub fn max_logical_type(left: \u0026LogicalType, right: \u0026LogicalType) -\u003e Result\u003cLogicalType\u003e {\r\n        if left == right {\r\n            return Ok(*left);\r\n        }\r\n        match (left, right) {\r\n            // SqlNull type can be cast to anything\r\n            (LogicalType::SqlNull, _) =\u003e return Ok(*right),\r\n            (_, LogicalType::SqlNull) =\u003e return Ok(*left),\r\n            _ =\u003e {}\r\n        }\r\n        if left.is_numeric() \u0026\u0026 right.is_numeric() {\r\n            return LogicalType::combine_numeric_types(left, right);\r\n        }\r\n        if matches!(\r\n            (left, right),\r\n            (LogicalType::Date, LogicalType::Varchar(_))\r\n                | (LogicalType::Varchar(_), LogicalType::Date)\r\n        ) {\r\n            return Ok(LogicalType::Date);\r\n        }\r\n        if matches!(\r\n            (left, right),\r\n            (LogicalType::Date, LogicalType::DateTime) | (LogicalType::DateTime, LogicalType::Date)\r\n        ) {\r\n            return Ok(LogicalType::DateTime);\r\n        }\r\n        if matches!(\r\n            (left, right),\r\n            (LogicalType::DateTime, LogicalType::Varchar(_))\r\n                | (LogicalType::Varchar(_), LogicalType::DateTime)\r\n        ) {\r\n            return Ok(LogicalType::DateTime);\r\n        }\r\n        Err(DatabaseError::Incomparable(*left, *right))\r\n    }\r\n\r\n    fn combine_numeric_types(left: \u0026LogicalType, right: \u0026LogicalType) -\u003e Result\u003cLogicalType\u003e {\r\n        if left == right {\r\n            return Ok(*left);\r\n        }\r\n        if left.is_signed_numeric() \u0026\u0026 right.is_unsigned_numeric() {\r\n            // this method is symmetric\r\n            // arrange it so the left type is smaller\r\n            // to limit the number of options we need to check\r\n            return LogicalType::combine_numeric_types(right, left);\r\n        }\r\n\r\n        if LogicalType::can_implicit_cast(left, right) {\r\n            return Ok(*right);\r\n        }\r\n        if LogicalType::can_implicit_cast(right, left) {\r\n            return Ok(*left);\r\n        }\r\n        // we can't cast implicitly either way and types are not equal\r\n        // this happens when left is signed and right is unsigned\r\n        // e.g. INTEGER and UINTEGER\r\n        // in this case we need to upcast to make sure the types fit\r\n        match (left, right) {\r\n            (LogicalType::Bigint, _) | (_, LogicalType::UBigint) =\u003e Ok(LogicalType::Double),\r\n            (LogicalType::Integer, _) | (_, LogicalType::UInteger) =\u003e Ok(LogicalType::Bigint),\r\n            (LogicalType::Smallint, _) | (_, LogicalType::USmallint) =\u003e Ok(LogicalType::Integer),\r\n            (LogicalType::Tinyint, _) | (_, LogicalType::UTinyint) =\u003e Ok(LogicalType::Smallint),\r\n            _ =\u003e Err(DatabaseError::Incomparable(*left, *right)),\r\n        }\r\n    }\r\n\r\n    pub fn can_implicit_cast(from: \u0026LogicalType, to: \u0026LogicalType) -\u003e bool {\r\n        if from == to {\r\n            return true;\r\n        }\r\n        match from {\r\n            LogicalType::Invalid =\u003e false,\r\n            LogicalType::SqlNull =\u003e true,\r\n            LogicalType::Boolean =\u003e false,\r\n            LogicalType::Tinyint =\u003e matches!(\r\n                to,\r\n                LogicalType::Smallint\r\n                    | LogicalType::Integer\r\n                    | LogicalType::Bigint\r\n                    | LogicalType::Float\r\n                    | LogicalType::Double\r\n            ),\r\n            LogicalType::UTinyint =\u003e matches!(\r\n                to,\r\n                LogicalType::USmallint\r\n                    | LogicalType::UInteger\r\n                    | LogicalType::UBigint\r\n                    | LogicalType::Smallint\r\n                    | LogicalType::Integer\r\n                    | LogicalType::Bigint\r\n                    | LogicalType::Float\r\n                    | LogicalType::Double\r\n            ),\r\n            LogicalType::Smallint =\u003e matches!(\r\n                to,\r\n                LogicalType::Integer\r\n                    | LogicalType::Bigint\r\n                    | LogicalType::Float\r\n                    | LogicalType::Double\r\n            ),\r\n            LogicalType::USmallint =\u003e matches!(\r\n                to,\r\n                LogicalType::UInteger\r\n                    | LogicalType::UBigint\r\n                    | LogicalType::Integer\r\n                    | LogicalType::Bigint\r\n                    | LogicalType::Float\r\n                    | LogicalType::Double\r\n            ),\r\n            LogicalType::Integer =\u003e matches!(\r\n                to,\r\n                LogicalType::Bigint | LogicalType::Float | LogicalType::Double\r\n            ),\r\n            LogicalType::UInteger =\u003e matches!(\r\n                to,\r\n                LogicalType::UBigint\r\n                    | LogicalType::Bigint\r\n                    | LogicalType::Float\r\n                    | LogicalType::Double\r\n            ),\r\n            LogicalType::Bigint =\u003e matches!(to, LogicalType::Float | LogicalType::Double),\r\n            LogicalType::UBigint =\u003e matches!(to, LogicalType::Float | LogicalType::Double),\r\n            LogicalType::Float =\u003e matches!(to, LogicalType::Double),\r\n            LogicalType::Double =\u003e false,\r\n            LogicalType::Varchar(_) =\u003e false,\r\n            LogicalType::Date =\u003e matches!(to, LogicalType::DateTime | LogicalType::Varchar(_)),\r\n            LogicalType::DateTime =\u003e matches!(to, LogicalType::Date | LogicalType::Varchar(_)),\r\n            LogicalType::Decimal(_, _) =\u003e false,\r\n            LogicalType::UUID =\u003e false,\r\n        }\r\n    }\r\n}\r\n\r\n/// sqlparser datatype to logical type\r\nimpl TryFrom\u003csqlparser::ast::DataType\u003e for LogicalType {\r\n    type Error = DatabaseError;\r\n\r\n    fn try_from(value: sqlparser::ast::DataType) -\u003e Result\u003cSelf\u003e {\r\n        match value {\r\n            sqlparser::ast::DataType::Char(len) | sqlparser::ast::DataType::Varchar(len) =\u003e {\r\n                Ok(LogicalType::Varchar(len.map(|len| len.length as u32)))\r\n            }\r\n            sqlparser::ast::DataType::Float(_) =\u003e Ok(LogicalType::Float),\r\n            sqlparser::ast::DataType::Double =\u003e Ok(LogicalType::Double),\r\n            sqlparser::ast::DataType::TinyInt(_) =\u003e Ok(LogicalType::Tinyint),\r\n            sqlparser::ast::DataType::UnsignedTinyInt(_) =\u003e Ok(LogicalType::UTinyint),\r\n            sqlparser::ast::DataType::SmallInt(_) =\u003e Ok(LogicalType::Smallint),\r\n            sqlparser::ast::DataType::UnsignedSmallInt(_) =\u003e Ok(LogicalType::USmallint),\r\n            sqlparser::ast::DataType::Int(_) | sqlparser::ast::DataType::Integer(_) =\u003e {\r\n                Ok(LogicalType::Integer)\r\n            }\r\n            sqlparser::ast::DataType::UnsignedInt(_)\r\n            | sqlparser::ast::DataType::UnsignedInteger(_) =\u003e Ok(LogicalType::UInteger),\r\n            sqlparser::ast::DataType::BigInt(_) =\u003e Ok(LogicalType::Bigint),\r\n            sqlparser::ast::DataType::UnsignedBigInt(_) =\u003e Ok(LogicalType::UBigint),\r\n            sqlparser::ast::DataType::Boolean =\u003e Ok(LogicalType::Boolean),\r\n            sqlparser::ast::DataType::Datetime(_) =\u003e Ok(LogicalType::DateTime),\r\n            sqlparser::ast::DataType::Date =\u003e Ok(LogicalType::Date),\r\n            sqlparser::ast::DataType::Decimal(info) | sqlparser::ast::DataType::Dec(info) =\u003e {\r\n                match info {\r\n                    ExactNumberInfo::None =\u003e Ok(Self::Decimal(None, None)),\r\n                    ExactNumberInfo::Precision(p) =\u003e Ok(Self::Decimal(Some(p as u8), None)),\r\n                    ExactNumberInfo::PrecisionAndScale(p, s) =\u003e {\r\n                        Ok(Self::Decimal(Some(p as u8), Some(s as u8)))\r\n                    }\r\n                }\r\n            }\r\n            other =\u003e Err(DatabaseError::NotImplementedSqlparserDataType(\r\n                other.to_string(),\r\n            )),\r\n        }\r\n    }\r\n}\r\n\r\nimpl std::fmt::Display for LogicalType {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        write!(f, \"{}\", self.as_ref().to_uppercase())\r\n    }\r\n}\r\n","traces":[{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":10376293541461622784},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":10376293541461622784},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":85,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":2522015791327477761},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":2522015791327477760},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":2738188573441261568},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":138,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":139,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":16212958658533785600},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":16212958658533785600},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":15636497906230362112},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":1008806316530991104},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":192,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":194,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":198,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":199,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":212,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":228,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":229,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":232,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":243,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":261,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":274,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":282,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":284,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":285,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":300,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":301,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":308,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":59,"coverable":162},{"path":["E:","\\","sql-layer","src","types","tuple.rs"],"content":"use crate::catalog::{ColumnRef, SchemaRef};\r\nuse crate::types::value::{DataValue, ValueRef};\r\nuse comfy_table::{Cell, Table};\r\nuse integer_encoding::FixedInt;\r\nuse itertools::Itertools;\r\nuse std::fmt::Display;\r\nuse std::sync::Arc;\r\n\r\nconst BITS_MAX_INDEX: usize = 8;\r\n\r\npub type TupleId = ValueRef;\r\n\r\n#[derive(Clone, Debug, PartialEq)]\r\npub struct Tuple {\r\n    pub id: Option\u003cTupleId\u003e,\r\n    pub values: Vec\u003cValueRef\u003e,\r\n}\r\n\r\nimpl Display for Tuple {\r\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\r\n        let mut s = String::new();\r\n        s += \"[\";\r\n        let mut tuple = vec![];\r\n        for val in self.values.iter() {\r\n            tuple.push(format!(\"{}\", val));\r\n        }\r\n        s += \u0026tuple.iter().join(\",\");\r\n        s += \"]\";\r\n        write!(f, \"{:?}\", self.values)\r\n    }\r\n}\r\n\r\nimpl Tuple {\r\n    pub fn deserialize_from(columns: \u0026[ColumnRef], bytes: \u0026[u8]) -\u003e Self {\r\n        fn is_none(bits: u8, i: usize) -\u003e bool {\r\n            bits \u0026 (1 \u003c\u003c (7 - i)) \u003e 0\r\n        }\r\n\r\n        let values_len = columns.len();\r\n        let mut values = Vec::with_capacity(values_len);\r\n        let bits_len = (values_len + BITS_MAX_INDEX) / BITS_MAX_INDEX;\r\n        let mut id_option = None;\r\n\r\n        let mut pos = bits_len;\r\n\r\n        for (i, col) in columns.iter().enumerate() {\r\n            let logic_type = col.datatype();\r\n\r\n            if is_none(bytes[i / BITS_MAX_INDEX], i % BITS_MAX_INDEX) {\r\n                values.push(Arc::new(DataValue::none(logic_type)));\r\n            } else if let Some(len) = logic_type.raw_len() {\r\n                // fixed length (e.g.: int)\r\n                values.push(Arc::new(DataValue::from_raw(\r\n                    \u0026bytes[pos..pos + len],\r\n                    logic_type,\r\n                )));\r\n                pos += len;\r\n            } else {\r\n                // variable length (e.g.: varchar)\r\n                let len = u32::decode_fixed(\u0026bytes[pos..pos + 4]) as usize;\r\n                pos += 4;\r\n                values.push(Arc::new(DataValue::from_raw(\r\n                    \u0026bytes[pos..pos + len],\r\n                    logic_type,\r\n                )));\r\n                pos += len;\r\n            }\r\n\r\n            if col.desc.is_primary {\r\n                id_option = Some(values[i].clone());\r\n            }\r\n        }\r\n\r\n        Tuple {\r\n            id: id_option,\r\n            values,\r\n        }\r\n    }\r\n\r\n    /// e.g.: bits(u8)..|data_0(len for utf8_1)|utf8_0|data_1|\r\n    /// Tips: all len is u32\r\n    pub fn serialize_to(\u0026self) -\u003e Vec\u003cu8\u003e {\r\n        fn flip_bit(bits: u8, i: usize) -\u003e u8 {\r\n            bits | (1 \u003c\u003c (7 - i))\r\n        }\r\n\r\n        let values_len = self.values.len();\r\n        let bits_len = (values_len + BITS_MAX_INDEX) / BITS_MAX_INDEX;\r\n        let mut bytes = vec![0_u8; bits_len];\r\n\r\n        for (i, value) in self.values.iter().enumerate() {\r\n            if value.is_null() {\r\n                bytes[i / BITS_MAX_INDEX] = flip_bit(bytes[i / BITS_MAX_INDEX], i % BITS_MAX_INDEX);\r\n            } else {\r\n                let mut value_bytes = value.to_raw();\r\n\r\n                if value.is_variable() {\r\n                    bytes.append(\u0026mut (value_bytes.len() as u32).encode_fixed_vec());\r\n                }\r\n                bytes.append(\u0026mut value_bytes);\r\n            }\r\n        }\r\n\r\n        bytes\r\n    }\r\n}\r\n\r\npub fn create_table(tuples: \u0026(SchemaRef, Vec\u003cTuple\u003e)) -\u003e Table {\r\n    let schema = \u0026tuples.0;\r\n    let tuples = \u0026tuples.1;\r\n    let mut table = Table::new();\r\n\r\n    if tuples.is_empty() {\r\n        return table;\r\n    }\r\n\r\n    let mut header = Vec::new();\r\n    for col in schema.iter() {\r\n        header.push(Cell::new(col.name().to_string()));\r\n    }\r\n    table.set_header(header);\r\n\r\n    for tuple in tuples {\r\n        let cells = tuple\r\n            .values\r\n            .iter()\r\n            .map(|value| Cell::new(format!(\"{value}\")))\r\n            .collect_vec();\r\n\r\n        table.add_row(cells);\r\n    }\r\n\r\n    table\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use crate::catalog::{ColumnCatalog, ColumnDesc};\r\n    use crate::types::tuple::Tuple;\r\n    use crate::types::value::DataValue;\r\n    use crate::types::LogicalType;\r\n    use std::sync::Arc;\r\n\r\n    #[test]\r\n    fn test_tuple_serialize_to_and_deserialize_from() {\r\n        let columns = vec![\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c1\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Integer, true, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c2\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::UInteger, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c3\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Varchar(Some(2)), false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c4\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Smallint, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c5\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::USmallint, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c6\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Float, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c7\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Double, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c8\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Tinyint, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c9\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::UTinyint, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c10\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Boolean, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c11\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::DateTime, false, false, None),\r\n                // None,\r\n            )),\r\n            Arc::new(ColumnCatalog::new(\r\n                \"c12\".to_string(),\r\n                false,\r\n                ColumnDesc::new(LogicalType::Date, false, false, None),\r\n                // None,\r\n            )),\r\n        ];\r\n\r\n        let tuples = vec![\r\n            Tuple {\r\n                id: Some(Arc::new(DataValue::Int32(Some(0)))),\r\n                values: vec![\r\n                    Arc::new(DataValue::Int32(Some(0))),\r\n                    Arc::new(DataValue::UInt32(Some(1))),\r\n                    Arc::new(DataValue::Utf8(Some(\"LOL\".to_string()))),\r\n                    Arc::new(DataValue::Int16(Some(1))),\r\n                    Arc::new(DataValue::UInt16(Some(1))),\r\n                    Arc::new(DataValue::Float32(Some(0.1))),\r\n                    Arc::new(DataValue::Float64(Some(0.1))),\r\n                    Arc::new(DataValue::Int8(Some(1))),\r\n                    Arc::new(DataValue::UInt8(Some(1))),\r\n                    Arc::new(DataValue::Boolean(Some(true))),\r\n                    Arc::new(DataValue::Date64(Some(0))),\r\n                    Arc::new(DataValue::Date32(Some(0))),\r\n                ],\r\n            },\r\n            Tuple {\r\n                id: Some(Arc::new(DataValue::Int32(Some(1)))),\r\n                values: vec![\r\n                    Arc::new(DataValue::Int32(Some(1))),\r\n                    Arc::new(DataValue::UInt32(None)),\r\n                    Arc::new(DataValue::Utf8(None)),\r\n                    Arc::new(DataValue::Int16(None)),\r\n                    Arc::new(DataValue::UInt16(None)),\r\n                    Arc::new(DataValue::Float32(None)),\r\n                    Arc::new(DataValue::Float64(None)),\r\n                    Arc::new(DataValue::Int8(None)),\r\n                    Arc::new(DataValue::UInt8(None)),\r\n                    Arc::new(DataValue::Boolean(None)),\r\n                    Arc::new(DataValue::Date64(None)),\r\n                    Arc::new(DataValue::Date32(None)),\r\n                ],\r\n            },\r\n        ];\r\n\r\n        let tuple_0 = Tuple::deserialize_from(\u0026columns, \u0026tuples[0].serialize_to());\r\n        let tuple_1 = Tuple::deserialize_from(\u0026columns, \u0026tuples[1].serialize_to());\r\n\r\n        assert_eq!(tuples[0], tuple_0);\r\n        assert_eq!(tuples[1], tuple_1);\r\n    }\r\n}\r\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":40,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":41,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":11457157452030541824},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":12538021362599460865},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":1080863910568919041},"fn_name":null},{"line":51,"address":[],"length":0,"stats":{"Line":17221764975064776703},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":61,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":62,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":1224979098644774912},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":8214565720323784704},"fn_name":null},{"line":82,"address":[],"length":0,"stats":{"Line":1441151880758558721},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":2377900603251621889},"fn_name":null},{"line":84,"address":[],"length":0,"stats":{"Line":2377900603251621889},"fn_name":null},{"line":87,"address":[],"length":0,"stats":{"Line":1441151880758558721},"fn_name":null},{"line":88,"address":[],"length":0,"stats":{"Line":1441151880758558721},"fn_name":null},{"line":89,"address":[],"length":0,"stats":{"Line":1441151880758558721},"fn_name":null},{"line":91,"address":[],"length":0,"stats":{"Line":6845471433603153921},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":6341068275337658368},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":936748722493063168},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":4899916394579099648},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":2161727821137838080},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":12393906174523604992},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":6196953087261802496},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":16140901064495857664},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":4683743612465315840},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":4683743612465315840},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":8070450532247928832},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":4683743612465315840},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":2089670227099910144},"fn_name":null}],"covered":51,"coverable":60},{"path":["E:","\\","sql-layer","src","types","tuple_builder.rs"],"content":"use crate::catalog::ColumnRef;\r\nuse crate::errors::*;\r\nuse crate::types::value::{DataValue, ValueRef};\r\n\r\nuse std::sync::Arc;\r\n\r\nuse super::tuple::Tuple;\r\n\r\npub struct TupleBuilder {\r\n    columns: Vec\u003cColumnRef\u003e,\r\n}\r\n\r\nimpl TupleBuilder {\r\n    pub fn new( columns: Vec\u003cColumnRef\u003e) -\u003e Self {\r\n        TupleBuilder {\r\n            columns,\r\n        }\r\n    }\r\n\r\n    pub fn new_result() -\u003e Self {\r\n        TupleBuilder {\r\n            columns: Vec::new(),\r\n        }\r\n    }\r\n\r\n    pub fn push_result(self, _header: \u0026str, message: \u0026str) -\u003e Result\u003cTuple\u003e {\r\n        let values: Vec\u003cValueRef\u003e = vec![Arc::new(DataValue::Utf8(Some(String::from(message))))];\r\n        let t = Tuple { id: None, values };\r\n        Ok(t)\r\n    }\r\n\r\n    pub fn build_with_row\u003c'b\u003e(\u0026self, row: impl IntoIterator\u003cItem = \u0026'b str\u003e) -\u003e Result\u003cTuple\u003e {\r\n        let mut values = Vec::with_capacity(self.columns.len());\r\n        let mut primary_key = None;\r\n\r\n        for (i, value) in row.into_iter().enumerate() {\r\n            // debug!(\"{}: {}\", i, value);\r\n            let data_value = Arc::new(\r\n                DataValue::Utf8(Some(value.to_string())).cast(self.columns[i].datatype())?,\r\n            );\r\n\r\n            if primary_key.is_none() \u0026\u0026 self.columns[i].desc.is_primary {\r\n                primary_key = Some(data_value.clone());\r\n            }\r\n            values.push(data_value);\r\n        }\r\n        if values.len() != self.columns.len() {\r\n            return Err(DatabaseError::MisMatch(\r\n                \"types\".to_string(),\r\n                \"values\".to_string(),\r\n            ));\r\n        }\r\n\r\n        Ok(Tuple {\r\n            id: primary_key,\r\n            values,\r\n        })\r\n    }\r\n}\r\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":22,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":27,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":28,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":29,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":32,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":33,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":36,"address":[],"length":0,"stats":{"Line":78},"fn_name":null},{"line":39,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":10,"coverable":22},{"path":["E:","\\","sql-layer","src","types","value.rs"],"content":"use chrono::format::{DelayedFormat, StrftimeItems};\r\nuse chrono::{Datelike, NaiveDate, NaiveDateTime};\r\nuse integer_encoding::FixedInt;\r\nuse lazy_static::lazy_static;\r\nuse rust_decimal::prelude::FromPrimitive;\r\nuse rust_decimal::prelude::ToPrimitive;\r\nuse rust_decimal::Decimal;\r\nuse std::cmp::Ordering;\r\nuse std::fmt::Formatter;\r\nuse std::hash::Hash;\r\nuse std::str::FromStr;\r\nuse std::sync::Arc;\r\nuse std::{fmt, mem};\r\nuse uuid::Uuid;\r\n\r\nuse crate::errors::*;\r\nuse ordered_float::OrderedFloat;\r\nuse serde::{Deserialize, Serialize};\r\n\r\nuse super::LogicalType;\r\n\r\nlazy_static! {\r\n    pub static ref NULL_VALUE: ValueRef = Arc::new(DataValue::Null);\r\n    static ref UNIX_DATETIME: NaiveDateTime = NaiveDateTime::from_timestamp_opt(0, 0).unwrap();\r\n}\r\n\r\npub const DATE_FMT: \u0026str = \"%Y-%m-%d\";\r\npub const DATE_TIME_FMT: \u0026str = \"%Y-%m-%d %H:%M:%S\";\r\n\r\nconst ENCODE_GROUP_SIZE: usize = 8;\r\nconst ENCODE_MARKER: u8 = 0xFF;\r\n\r\npub type ValueRef = Arc\u003cDataValue\u003e;\r\n\r\n#[derive(Clone, Serialize, Deserialize)]\r\npub enum DataValue {\r\n    Null,\r\n    Boolean(Option\u003cbool\u003e),\r\n    Float32(Option\u003cf32\u003e),\r\n    Float64(Option\u003cf64\u003e),\r\n    Int8(Option\u003ci8\u003e),\r\n    Int16(Option\u003ci16\u003e),\r\n    Int32(Option\u003ci32\u003e),\r\n    Int64(Option\u003ci64\u003e),\r\n    UInt8(Option\u003cu8\u003e),\r\n    UInt16(Option\u003cu16\u003e),\r\n    UInt32(Option\u003cu32\u003e),\r\n    UInt64(Option\u003cu64\u003e),\r\n    Utf8(Option\u003cString\u003e),\r\n    /// Date stored as a signed 32bit int days since UNIX epoch 1970-01-01\r\n    Date32(Option\u003ci32\u003e),\r\n    /// Date stored as a signed 64bit int timestamp since UNIX epoch 1970-01-01\r\n    Date64(Option\u003ci64\u003e),\r\n    UUID(Option\u003cUuid\u003e),\r\n    Decimal(Option\u003cDecimal\u003e),\r\n}\r\n\r\nmacro_rules! generate_get_option {\r\n    ($data_value:ident, $($prefix:ident : $variant:ident($field:ty)),*) =\u003e {\r\n        impl $data_value {\r\n            $(\r\n                pub fn $prefix(\u0026self) -\u003e $field {\r\n                    if let $data_value::$variant(Some(val)) = self {\r\n                        Some(val.clone())\r\n                    } else {\r\n                        None\r\n                    }\r\n                }\r\n            )*\r\n        }\r\n    };\r\n}\r\n\r\ngenerate_get_option!(DataValue,\r\n    bool : Boolean(Option\u003cbool\u003e),\r\n    float : Float32(Option\u003cf32\u003e),\r\n    double : Float64(Option\u003cf64\u003e),\r\n    i8 : Int8(Option\u003ci8\u003e),\r\n    i16 : Int16(Option\u003ci16\u003e),\r\n    i32 : Int32(Option\u003ci32\u003e),\r\n    i64 : Int64(Option\u003ci64\u003e),\r\n    u8 : UInt8(Option\u003cu8\u003e),\r\n    u16 : UInt16(Option\u003cu16\u003e),\r\n    u32 : UInt32(Option\u003cu32\u003e),\r\n    u64 : UInt64(Option\u003cu64\u003e),\r\n    utf8 : Utf8(Option\u003cString\u003e),\r\n    // decimal : Decimal(Option\u003cDecimal\u003e),\r\n    uuid: UUID(Option\u003cUuid\u003e)\r\n\r\n);\r\n\r\nimpl PartialEq for DataValue {\r\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\r\n        use DataValue::*;\r\n        match (self, other) {\r\n            (Boolean(v1), Boolean(v2)) =\u003e v1.eq(v2),\r\n            (Boolean(_), _) =\u003e false,\r\n            (Float32(v1), Float32(v2)) =\u003e {\r\n                let v1 = v1.map(OrderedFloat);\r\n                let v2 = v2.map(OrderedFloat);\r\n                v1.eq(\u0026v2)\r\n            }\r\n            (Float32(_), _) =\u003e false,\r\n            (Float64(v1), Float64(v2)) =\u003e {\r\n                let v1 = v1.map(OrderedFloat);\r\n                let v2 = v2.map(OrderedFloat);\r\n                v1.eq(\u0026v2)\r\n            }\r\n            (Float64(_), _) =\u003e false,\r\n            (Int8(v1), Int8(v2)) =\u003e v1.eq(v2),\r\n            (Int8(_), _) =\u003e false,\r\n            (Int16(v1), Int16(v2)) =\u003e v1.eq(v2),\r\n            (Int16(_), _) =\u003e false,\r\n            (Int32(v1), Int32(v2)) =\u003e v1.eq(v2),\r\n            (Int32(_), _) =\u003e false,\r\n            (Int64(v1), Int64(v2)) =\u003e v1.eq(v2),\r\n            (Int64(_), _) =\u003e false,\r\n            (UInt8(v1), UInt8(v2)) =\u003e v1.eq(v2),\r\n            (UInt8(_), _) =\u003e false,\r\n            (UInt16(v1), UInt16(v2)) =\u003e v1.eq(v2),\r\n            (UInt16(_), _) =\u003e false,\r\n            (UInt32(v1), UInt32(v2)) =\u003e v1.eq(v2),\r\n            (UInt32(_), _) =\u003e false,\r\n            (UInt64(v1), UInt64(v2)) =\u003e v1.eq(v2),\r\n            (UInt64(_), _) =\u003e false,\r\n            (Utf8(v1), Utf8(v2)) =\u003e v1.eq(v2),\r\n            (Utf8(_), _) =\u003e false,\r\n            (Null, Null) =\u003e true,\r\n            (Null, _) =\u003e false,\r\n            (Date32(v1), Date32(v2)) =\u003e v1.eq(v2),\r\n            (Date32(_), _) =\u003e false,\r\n            (Date64(v1), Date64(v2)) =\u003e v1.eq(v2),\r\n            (Date64(_), _) =\u003e false,\r\n            (Decimal(v1), Decimal(v2)) =\u003e v1.eq(v2),\r\n            (Decimal(_), _) =\u003e false,\r\n            (UUID(v1), UUID(v2)) =\u003e v1.eq(v2),\r\n            (UUID(_), _) =\u003e false,\r\n        }\r\n    }\r\n}\r\n\r\nimpl PartialOrd for DataValue {\r\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\r\n        use DataValue::*;\r\n        match (self, other) {\r\n            (Boolean(v1), Boolean(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Boolean(_), _) =\u003e None,\r\n            (Float32(v1), Float32(v2)) =\u003e {\r\n                let v1 = v1.map(OrderedFloat);\r\n                let v2 = v2.map(OrderedFloat);\r\n                v1.partial_cmp(\u0026v2)\r\n            }\r\n            (Float32(_), _) =\u003e None,\r\n            (Float64(v1), Float64(v2)) =\u003e {\r\n                let v1 = v1.map(OrderedFloat);\r\n                let v2 = v2.map(OrderedFloat);\r\n                v1.partial_cmp(\u0026v2)\r\n            }\r\n            (Float64(_), _) =\u003e None,\r\n            (Int8(v1), Int8(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Int8(_), _) =\u003e None,\r\n            (Int16(v1), Int16(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Int16(_), _) =\u003e None,\r\n            (Int32(v1), Int32(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Int32(_), _) =\u003e None,\r\n            (Int64(v1), Int64(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Int64(_), _) =\u003e None,\r\n            (UInt8(v1), UInt8(v2)) =\u003e v1.partial_cmp(v2),\r\n            (UInt8(_), _) =\u003e None,\r\n            (UInt16(v1), UInt16(v2)) =\u003e v1.partial_cmp(v2),\r\n            (UInt16(_), _) =\u003e None,\r\n            (UInt32(v1), UInt32(v2)) =\u003e v1.partial_cmp(v2),\r\n            (UInt32(_), _) =\u003e None,\r\n            (UInt64(v1), UInt64(v2)) =\u003e v1.partial_cmp(v2),\r\n            (UInt64(_), _) =\u003e None,\r\n            (Utf8(v1), Utf8(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Utf8(_), _) =\u003e None,\r\n            (Null, Null) =\u003e Some(Ordering::Equal),\r\n            (Null, _) =\u003e None,\r\n            (Date32(v1), Date32(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Date32(_), _) =\u003e None,\r\n            (Date64(v1), Date64(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Date64(_), _) =\u003e None,\r\n            (Decimal(v1), Decimal(v2)) =\u003e v1.partial_cmp(v2),\r\n            (Decimal(_), _) =\u003e None,\r\n            (UUID(v1), UUID(v2)) =\u003e v1.partial_cmp(v2),\r\n            (UUID(_), _) =\u003e None,\r\n        }\r\n    }\r\n}\r\n\r\nmacro_rules! encode_u {\r\n    ($b:ident, $u:expr) =\u003e {\r\n        $b.extend_from_slice(\u0026$u.to_be_bytes())\r\n    };\r\n}\r\n\r\nimpl Eq for DataValue {}\r\n\r\nimpl Hash for DataValue {\r\n    fn hash\u003cH: std::hash::Hasher\u003e(\u0026self, state: \u0026mut H) {\r\n        use DataValue::*;\r\n        match self {\r\n            Boolean(v) =\u003e v.hash(state),\r\n            Float32(v) =\u003e {\r\n                let v = v.map(OrderedFloat);\r\n                v.hash(state)\r\n            }\r\n            Float64(v) =\u003e {\r\n                let v = v.map(OrderedFloat);\r\n                v.hash(state)\r\n            }\r\n            Int8(v) =\u003e v.hash(state),\r\n            Int16(v) =\u003e v.hash(state),\r\n            Int32(v) =\u003e v.hash(state),\r\n            Int64(v) =\u003e v.hash(state),\r\n            UInt8(v) =\u003e v.hash(state),\r\n            UInt16(v) =\u003e v.hash(state),\r\n            UInt32(v) =\u003e v.hash(state),\r\n            UInt64(v) =\u003e v.hash(state),\r\n            Utf8(v) =\u003e v.hash(state),\r\n            Null =\u003e 1.hash(state),\r\n            Date32(v) =\u003e v.hash(state),\r\n            Date64(v) =\u003e v.hash(state),\r\n            Decimal(v) =\u003e v.hash(state),\r\n            UUID(v) =\u003e v.hash(state),\r\n        }\r\n    }\r\n}\r\nmacro_rules! varchar_cast {\r\n    ($value:expr, $len:expr) =\u003e {\r\n        $value\r\n            .map(|v| {\r\n                let string_value = format!(\"{}\", v);\r\n                if let Some(len) = $len {\r\n                    if string_value.len() \u003e *len as usize {\r\n                        return Err(DatabaseError::TooLong);\r\n                    }\r\n                }\r\n                Ok(DataValue::Utf8(Some(string_value)))\r\n            })\r\n            .unwrap_or(Ok(DataValue::Utf8(None)))\r\n    };\r\n}\r\n\r\nimpl DataValue {\r\n    pub fn date(\u0026self) -\u003e Option\u003cNaiveDate\u003e {\r\n        if let DataValue::Date32(Some(val)) = self {\r\n            NaiveDate::from_num_days_from_ce_opt(*val)\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    pub fn datetime(\u0026self) -\u003e Option\u003cNaiveDateTime\u003e {\r\n        if let DataValue::Date64(Some(val)) = self {\r\n            NaiveDateTime::from_timestamp_opt(*val, 0)\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n    pub fn decimal(\u0026self) -\u003e Option\u003cDecimal\u003e {\r\n        if let DataValue::Decimal(Some(val)) = self {\r\n            Some(*val)\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n\r\n    pub(crate) fn check_len(\u0026self, logic_type: \u0026LogicalType) -\u003e Result\u003c()\u003e {\r\n        let is_over_len = match (logic_type, self) {\r\n            (LogicalType::Varchar(Some(len)), DataValue::Utf8(Some(val))) =\u003e {\r\n                val.len() \u003e *len as usize\r\n            }\r\n            (LogicalType::Decimal(full_len, scale_len), DataValue::Decimal(Some(val))) =\u003e {\r\n                if let Some(len) = full_len {\r\n                    if val.mantissa().ilog10() + 1 \u003e *len as u32 {\r\n                        return Err(DatabaseError::TooLong);\r\n                    }\r\n                }\r\n                if let Some(len) = scale_len {\r\n                    if val.scale() \u003e *len as u32 {\r\n                        return Err(DatabaseError::TooLong);\r\n                    }\r\n                }\r\n                false\r\n            }\r\n            _ =\u003e false,\r\n        };\r\n\r\n        if is_over_len {\r\n            return Err(DatabaseError::TooLong);\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    fn format_date(value: Option\u003ci32\u003e) -\u003e Option\u003cString\u003e {\r\n        value.and_then(|v| Self::date_format(v).map(|fmt| format!(\"{}\", fmt)))\r\n    }\r\n\r\n    fn format_datetime(value: Option\u003ci64\u003e) -\u003e Option\u003cString\u003e {\r\n        value.and_then(|v| Self::date_time_format(v).map(|fmt| format!(\"{}\", fmt)))\r\n    }\r\n\r\n    pub fn is_variable(\u0026self) -\u003e bool {\r\n        matches!(self, DataValue::Utf8(_))\r\n    }\r\n\r\n    pub fn is_null(\u0026self) -\u003e bool {\r\n        match self {\r\n            DataValue::Null =\u003e true,\r\n            DataValue::Boolean(value) =\u003e value.is_none(),\r\n            DataValue::Float32(value) =\u003e value.is_none(),\r\n            DataValue::Float64(value) =\u003e value.is_none(),\r\n            DataValue::Int8(value) =\u003e value.is_none(),\r\n            DataValue::Int16(value) =\u003e value.is_none(),\r\n            DataValue::Int32(value) =\u003e value.is_none(),\r\n            DataValue::Int64(value) =\u003e value.is_none(),\r\n            DataValue::UInt8(value) =\u003e value.is_none(),\r\n            DataValue::UInt16(value) =\u003e value.is_none(),\r\n            DataValue::UInt32(value) =\u003e value.is_none(),\r\n            DataValue::UInt64(value) =\u003e value.is_none(),\r\n            DataValue::Utf8(value) =\u003e value.is_none(),\r\n            DataValue::Date32(value) =\u003e value.is_none(),\r\n            DataValue::Date64(value) =\u003e value.is_none(),\r\n            DataValue::Decimal(value) =\u003e value.is_none(),\r\n            DataValue::UUID(value) =\u003e value.is_none(),\r\n        }\r\n    }\r\n\r\n    pub fn none(logic_type: \u0026LogicalType) -\u003e DataValue {\r\n        match logic_type {\r\n            LogicalType::Invalid =\u003e panic!(\"invalid logical type\"),\r\n            LogicalType::SqlNull =\u003e DataValue::Null,\r\n            LogicalType::Boolean =\u003e DataValue::Boolean(None),\r\n            LogicalType::Tinyint =\u003e DataValue::Int8(None),\r\n            LogicalType::UTinyint =\u003e DataValue::UInt8(None),\r\n            LogicalType::Smallint =\u003e DataValue::Int16(None),\r\n            LogicalType::USmallint =\u003e DataValue::UInt16(None),\r\n            LogicalType::Integer =\u003e DataValue::Int32(None),\r\n            LogicalType::UInteger =\u003e DataValue::UInt32(None),\r\n            LogicalType::Bigint =\u003e DataValue::Int64(None),\r\n            LogicalType::UBigint =\u003e DataValue::UInt64(None),\r\n            LogicalType::Float =\u003e DataValue::Float32(None),\r\n            LogicalType::Double =\u003e DataValue::Float64(None),\r\n            LogicalType::Varchar(_) =\u003e DataValue::Utf8(None),\r\n            LogicalType::Date =\u003e DataValue::Date32(None),\r\n            LogicalType::DateTime =\u003e DataValue::Date64(None),\r\n            LogicalType::Decimal(_, _) =\u003e DataValue::Decimal(None),\r\n            LogicalType::UUID =\u003e DataValue::UUID(None),\r\n        }\r\n    }\r\n\r\n    pub fn init(logic_type: \u0026LogicalType) -\u003e DataValue {\r\n        match logic_type {\r\n            LogicalType::Invalid =\u003e panic!(\"invalid logical type\"),\r\n            LogicalType::SqlNull =\u003e DataValue::Null,\r\n            LogicalType::Boolean =\u003e DataValue::Boolean(Some(false)),\r\n            LogicalType::Tinyint =\u003e DataValue::Int8(Some(0)),\r\n            LogicalType::UTinyint =\u003e DataValue::UInt8(Some(0)),\r\n            LogicalType::Smallint =\u003e DataValue::Int16(Some(0)),\r\n            LogicalType::USmallint =\u003e DataValue::UInt16(Some(0)),\r\n            LogicalType::Integer =\u003e DataValue::Int32(Some(0)),\r\n            LogicalType::UInteger =\u003e DataValue::UInt32(Some(0)),\r\n            LogicalType::Bigint =\u003e DataValue::Int64(Some(0)),\r\n            LogicalType::UBigint =\u003e DataValue::UInt64(Some(0)),\r\n            LogicalType::Float =\u003e DataValue::Float32(Some(0.0)),\r\n            LogicalType::Double =\u003e DataValue::Float64(Some(0.0)),\r\n            LogicalType::Varchar(_) =\u003e DataValue::Utf8(Some(\"\".to_string())),\r\n            LogicalType::Date =\u003e DataValue::Date32(Some(UNIX_DATETIME.num_days_from_ce())),\r\n            LogicalType::DateTime =\u003e DataValue::Date64(Some(UNIX_DATETIME.timestamp())),\r\n            LogicalType::Decimal(_, _) =\u003e DataValue::Decimal(Some(Decimal::new(0, 0))),\r\n            LogicalType::UUID =\u003e DataValue::UUID(Some(Uuid::new_v4())),\r\n        }\r\n    }\r\n\r\n    pub fn to_raw(\u0026self) -\u003e Vec\u003cu8\u003e {\r\n        match self {\r\n            DataValue::Null =\u003e None,\r\n            DataValue::Boolean(v) =\u003e v.map(|v| vec![v as u8]),\r\n            DataValue::Float32(v) =\u003e v.map(|v| v.to_ne_bytes().to_vec()),\r\n            DataValue::Float64(v) =\u003e v.map(|v| v.to_ne_bytes().to_vec()),\r\n            DataValue::Int8(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::Int16(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::Int32(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::Int64(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::UInt8(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::UInt16(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::UInt32(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::UInt64(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::Utf8(v) =\u003e v.clone().map(|v| v.into_bytes()),\r\n            DataValue::Date32(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::Date64(v) =\u003e v.map(|v| v.encode_fixed_vec()),\r\n            DataValue::Decimal(v) =\u003e v.map(|v| v.serialize().to_vec()),\r\n            DataValue::UUID(v) =\u003e v.map(|v| v.as_bytes().to_vec()),\r\n        }\r\n        .unwrap_or(vec![])\r\n    }\r\n\r\n    pub fn from_raw(bytes: \u0026[u8], ty: \u0026LogicalType) -\u003e Self {\r\n        match ty {\r\n            LogicalType::Invalid =\u003e panic!(\"invalid logical type\"),\r\n            LogicalType::SqlNull =\u003e DataValue::Null,\r\n            LogicalType::Boolean =\u003e DataValue::Boolean(bytes.first().map(|v| *v != 0)),\r\n            LogicalType::Tinyint =\u003e {\r\n                DataValue::Int8((!bytes.is_empty()).then(|| i8::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::UTinyint =\u003e {\r\n                DataValue::UInt8((!bytes.is_empty()).then(|| u8::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::Smallint =\u003e {\r\n                DataValue::Int16((!bytes.is_empty()).then(|| i16::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::USmallint =\u003e {\r\n                DataValue::UInt16((!bytes.is_empty()).then(|| u16::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::Integer =\u003e {\r\n                DataValue::Int32((!bytes.is_empty()).then(|| i32::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::UInteger =\u003e {\r\n                DataValue::UInt32((!bytes.is_empty()).then(|| u32::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::Bigint =\u003e {\r\n                DataValue::Int64((!bytes.is_empty()).then(|| i64::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::UBigint =\u003e {\r\n                DataValue::UInt64((!bytes.is_empty()).then(|| u64::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::Float =\u003e DataValue::Float32((!bytes.is_empty()).then(|| {\r\n                let mut buf = [0; 4];\r\n                buf.copy_from_slice(bytes);\r\n                f32::from_ne_bytes(buf)\r\n            })),\r\n            LogicalType::Double =\u003e DataValue::Float64((!bytes.is_empty()).then(|| {\r\n                let mut buf = [0; 8];\r\n                buf.copy_from_slice(bytes);\r\n                f64::from_ne_bytes(buf)\r\n            })),\r\n            LogicalType::Varchar(_) =\u003e DataValue::Utf8(\r\n                (!bytes.is_empty()).then(|| String::from_utf8(bytes.to_owned()).unwrap()),\r\n            ),\r\n            LogicalType::Date =\u003e {\r\n                DataValue::Date32((!bytes.is_empty()).then(|| i32::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::DateTime =\u003e {\r\n                DataValue::Date64((!bytes.is_empty()).then(|| i64::decode_fixed(bytes)))\r\n            }\r\n            LogicalType::Decimal(_, _) =\u003e DataValue::Decimal(\r\n                (!bytes.is_empty())\r\n                    .then(|| Decimal::deserialize(\u003c[u8; 16]\u003e::try_from(bytes).unwrap())),\r\n            ),\r\n            LogicalType::UUID =\u003e {\r\n                DataValue::UUID((!bytes.is_empty()).then(|| Uuid::from_slice(bytes).unwrap()))\r\n            }\r\n        }\r\n    }\r\n\r\n    pub fn logical_type(\u0026self) -\u003e LogicalType {\r\n        match self {\r\n            DataValue::Null =\u003e LogicalType::SqlNull,\r\n            DataValue::Boolean(_) =\u003e LogicalType::Boolean,\r\n            DataValue::Float32(_) =\u003e LogicalType::Float,\r\n            DataValue::Float64(_) =\u003e LogicalType::Double,\r\n            DataValue::Int8(_) =\u003e LogicalType::Tinyint,\r\n            DataValue::Int16(_) =\u003e LogicalType::Smallint,\r\n            DataValue::Int32(_) =\u003e LogicalType::Integer,\r\n            DataValue::Int64(_) =\u003e LogicalType::Bigint,\r\n            DataValue::UInt8(_) =\u003e LogicalType::UTinyint,\r\n            DataValue::UInt16(_) =\u003e LogicalType::USmallint,\r\n            DataValue::UInt32(_) =\u003e LogicalType::UInteger,\r\n            DataValue::UInt64(_) =\u003e LogicalType::UBigint,\r\n            DataValue::Utf8(_) =\u003e LogicalType::Varchar(None),\r\n            DataValue::Date32(_) =\u003e LogicalType::Date,\r\n            DataValue::Date64(_) =\u003e LogicalType::DateTime,\r\n            DataValue::Decimal(_) =\u003e LogicalType::Decimal(None, None),\r\n            DataValue::UUID(_) =\u003e LogicalType::UUID,\r\n        }\r\n    }\r\n\r\n    // EncodeBytes guarantees the encoded value is in ascending order for comparison,\r\n    // encoding with the following rule:\r\n    //\r\n    //\t[group1][marker1]...[groupN][markerN]\r\n    //\tgroup is 8 bytes slice which is padding with 0.\r\n    //\tmarker is `0xFF - padding 0 count`\r\n    //\r\n    // For example:\r\n    //\r\n    //\t[] -\u003e [0, 0, 0, 0, 0, 0, 0, 0, 247]\r\n    //\t[1, 2, 3] -\u003e [1, 2, 3, 0, 0, 0, 0, 0, 250]\r\n    //\t[1, 2, 3, 0] -\u003e [1, 2, 3, 0, 0, 0, 0, 0, 251]\r\n    //\t[1, 2, 3, 4, 5, 6, 7, 8] -\u003e [1, 2, 3, 4, 5, 6, 7, 8, 255, 0, 0, 0, 0, 0, 0, 0, 0, 247]\r\n    //\r\n    // Refer: https://github.com/facebook/mysql-5.6/wiki/MyRocks-record-format#memcomparable-format\r\n    fn encode_bytes(b: \u0026mut Vec\u003cu8\u003e, data: \u0026[u8]) {\r\n        let d_len = data.len();\r\n        let realloc_size = (d_len / ENCODE_GROUP_SIZE + 1) * (ENCODE_GROUP_SIZE + 1);\r\n        Self::realloc_bytes(b, realloc_size);\r\n\r\n        let mut idx = 0;\r\n        while idx \u003c= d_len {\r\n            let remain = d_len - idx;\r\n            let pad_count: usize;\r\n\r\n            if remain \u003e= ENCODE_GROUP_SIZE {\r\n                b.extend_from_slice(\u0026data[idx..idx + ENCODE_GROUP_SIZE]);\r\n                pad_count = 0;\r\n            } else {\r\n                pad_count = ENCODE_GROUP_SIZE - remain;\r\n                b.extend_from_slice(\u0026data[idx..]);\r\n                b.extend_from_slice(\u0026vec![0; pad_count]);\r\n            }\r\n\r\n            b.push(ENCODE_MARKER - pad_count as u8);\r\n            idx += ENCODE_GROUP_SIZE;\r\n        }\r\n    }\r\n\r\n    fn realloc_bytes(b: \u0026mut Vec\u003cu8\u003e, size: usize) {\r\n        let len = b.len();\r\n\r\n        if size \u003e len {\r\n            b.reserve(size - len);\r\n            b.resize(size, 0);\r\n        }\r\n    }\r\n\r\n    pub fn to_primary_key(\u0026self, b: \u0026mut Vec\u003cu8\u003e) -\u003e Result\u003c()\u003e {\r\n        match self {\r\n            DataValue::Int8(Some(v)) =\u003e encode_u!(b, *v as u8 ^ 0x80_u8),\r\n            DataValue::Int16(Some(v)) =\u003e encode_u!(b, *v as u16 ^ 0x8000_u16),\r\n            DataValue::Int32(Some(v)) =\u003e encode_u!(b, *v as u32 ^ 0x80000000_u32),\r\n            DataValue::Int64(Some(v)) =\u003e encode_u!(b, *v as u64 ^ 0x8000000000000000_u64),\r\n            DataValue::UInt8(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::UInt16(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::UInt32(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::UInt64(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::UUID(Some(v)) =\u003e Self::encode_bytes(b, v.as_bytes()),\r\n            DataValue::Utf8(Some(v)) =\u003e Self::encode_bytes(b, v.as_bytes()),\r\n            value =\u003e {\r\n                return if value.is_null() {\r\n                    Err(DatabaseError::PrimaryKeyNotFound)\r\n                } else {\r\n                    Err(DatabaseError::InvalidType)\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n\r\n    pub fn to_index_key(\u0026self, b: \u0026mut Vec\u003cu8\u003e) -\u003e Result\u003c()\u003e {\r\n        match self {\r\n            DataValue::Int8(Some(v)) =\u003e encode_u!(b, *v as u8 ^ 0x80_u8),\r\n            DataValue::Int16(Some(v)) =\u003e encode_u!(b, *v as u16 ^ 0x8000_u16),\r\n            DataValue::Int32(Some(v)) | DataValue::Date32(Some(v)) =\u003e {\r\n                encode_u!(b, *v as u32 ^ 0x80000000_u32)\r\n            }\r\n            DataValue::Int64(Some(v)) | DataValue::Date64(Some(v)) =\u003e {\r\n                encode_u!(b, *v as u64 ^ 0x8000000000000000_u64)\r\n            }\r\n            DataValue::UInt8(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::UInt16(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::UInt32(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::UInt64(Some(v)) =\u003e encode_u!(b, v),\r\n            DataValue::Utf8(Some(v)) =\u003e Self::encode_bytes(b, v.as_bytes()),\r\n            DataValue::Boolean(Some(v)) =\u003e b.push(if *v { b'1' } else { b'0' }),\r\n            DataValue::Float32(Some(f)) =\u003e {\r\n                let mut u = f.to_bits();\r\n\r\n                if *f \u003e= 0_f32 {\r\n                    u |= 0x80000000_u32;\r\n                } else {\r\n                    u = !u;\r\n                }\r\n\r\n                encode_u!(b, u);\r\n            }\r\n            DataValue::Float64(Some(f)) =\u003e {\r\n                let mut u = f.to_bits();\r\n\r\n                if *f \u003e= 0_f64 {\r\n                    u |= 0x8000000000000000_u64;\r\n                } else {\r\n                    u = !u;\r\n                }\r\n\r\n                encode_u!(b, u);\r\n            }\r\n            value =\u003e {\r\n                return if value.is_null() {\r\n                    todo!()\r\n                } else {\r\n                    Err(DatabaseError::InvalidType)\r\n                }\r\n            }\r\n        }\r\n\r\n        Ok(())\r\n    }\r\n    #[allow(dead_code)]\r\n    fn decimal_round_i(option: \u0026Option\u003cu8\u003e, decimal: \u0026mut Decimal) {\r\n        if let Some(scale) = option {\r\n            let new_decimal = decimal.trunc_with_scale(*scale as u32);\r\n            let _ = mem::replace(decimal, new_decimal);\r\n        }\r\n    }\r\n\r\n    fn decimal_round_f(option: \u0026Option\u003cu8\u003e, decimal: \u0026mut Decimal) {\r\n        if let Some(scale) = option {\r\n            let new_decimal = decimal.round_dp_with_strategy(\r\n                *scale as u32,\r\n                rust_decimal::RoundingStrategy::MidpointAwayFromZero,\r\n            );\r\n            let _ = mem::replace(decimal, new_decimal);\r\n        }\r\n    }\r\n\r\n    pub fn cast(self, to: \u0026LogicalType) -\u003e Result\u003cDataValue\u003e {\r\n        match self {\r\n            DataValue::Null =\u003e match to {\r\n                LogicalType::Invalid =\u003e {\r\n                    Err(DatabaseError::CastFail(self.logical_type(), self, *to))\r\n                }\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Boolean =\u003e Ok(DataValue::Boolean(None)),\r\n                LogicalType::Tinyint =\u003e Ok(DataValue::Int8(None)),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(None)),\r\n                LogicalType::Smallint =\u003e Ok(DataValue::Int16(None)),\r\n                LogicalType::USmallint =\u003e Ok(DataValue::UInt16(None)),\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(None)),\r\n                LogicalType::UInteger =\u003e Ok(DataValue::UInt32(None)),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(None)),\r\n                LogicalType::UBigint =\u003e Ok(DataValue::UInt64(None)),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(None)),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(None)),\r\n                LogicalType::Varchar(_) =\u003e Ok(DataValue::Utf8(None)),\r\n                LogicalType::Date =\u003e Ok(DataValue::Date32(None)),\r\n                LogicalType::DateTime =\u003e Ok(DataValue::Date64(None)),\r\n                LogicalType::Decimal(_, _) =\u003e Ok(DataValue::Decimal(None)),\r\n                LogicalType::UUID =\u003e Ok(DataValue::UUID(None)),\r\n            },\r\n            DataValue::Boolean(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Boolean =\u003e Ok(DataValue::Boolean(value)),\r\n                LogicalType::Tinyint =\u003e Ok(DataValue::Int8(value.map(|v| v.into()))),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(value.map(|v| v.into()))),\r\n                LogicalType::Smallint =\u003e Ok(DataValue::Int16(value.map(|v| v.into()))),\r\n                LogicalType::USmallint =\u003e Ok(DataValue::UInt16(value.map(|v| v.into()))),\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(value.map(|v| v.into()))),\r\n                LogicalType::UInteger =\u003e Ok(DataValue::UInt32(value.map(|v| v.into()))),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value.map(|v| v.into()))),\r\n                LogicalType::UBigint =\u003e Ok(DataValue::UInt64(value.map(|v| v.into()))),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.map(|v| v.into()))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Float32(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value)),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                LogicalType::Decimal(_, option) =\u003e Ok(DataValue::Decimal(\r\n                    value\r\n                        .map(|v| {\r\n                            let mut decimal = Decimal::from_f32(v)\r\n                                .ok_or(DatabaseError::CastFail(self.logical_type(), self, *to))?;\r\n                            Self::decimal_round_f(option, \u0026mut decimal);\r\n\r\n                            Ok::\u003cDecimal, DatabaseError\u003e(decimal)\r\n                        })\r\n                        .transpose()?,\r\n                )),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Float64(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value)),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Int8(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Tinyint =\u003e Ok(DataValue::Int8(value)),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(value.map(u8::try_from).transpose()?)),\r\n                LogicalType::USmallint =\u003e {\r\n                    Ok(DataValue::UInt16(value.map(u16::try_from).transpose()?))\r\n                }\r\n                LogicalType::UInteger =\u003e {\r\n                    Ok(DataValue::UInt32(value.map(u32::try_from).transpose()?))\r\n                }\r\n                LogicalType::UBigint =\u003e {\r\n                    Ok(DataValue::UInt64(value.map(u64::try_from).transpose()?))\r\n                }\r\n                LogicalType::Smallint =\u003e Ok(DataValue::Int16(value.map(|v| v.into()))),\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(value.map(|v| v.into()))),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value.map(|v| v.into()))),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.map(|v| v.into()))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Int16(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(value.map(u8::try_from).transpose()?)),\r\n                LogicalType::USmallint =\u003e {\r\n                    Ok(DataValue::UInt16(value.map(u16::try_from).transpose()?))\r\n                }\r\n                LogicalType::UInteger =\u003e {\r\n                    Ok(DataValue::UInt32(value.map(u32::try_from).transpose()?))\r\n                }\r\n                LogicalType::UBigint =\u003e {\r\n                    Ok(DataValue::UInt64(value.map(u64::try_from).transpose()?))\r\n                }\r\n                LogicalType::Smallint =\u003e Ok(DataValue::Int16(value)),\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(value.map(|v| v.into()))),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value.map(|v| v.into()))),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.map(|v| v.into()))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Int32(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(value.map(u8::try_from).transpose()?)),\r\n                LogicalType::USmallint =\u003e {\r\n                    Ok(DataValue::UInt16(value.map(u16::try_from).transpose()?))\r\n                }\r\n                LogicalType::UInteger =\u003e {\r\n                    Ok(DataValue::UInt32(value.map(u32::try_from).transpose()?))\r\n                }\r\n                LogicalType::UBigint =\u003e {\r\n                    Ok(DataValue::UInt64(value.map(u64::try_from).transpose()?))\r\n                }\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(value)),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value.map(|v| v.into()))),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.map(|v| v as f32))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Int64(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(value.map(u8::try_from).transpose()?)),\r\n                LogicalType::USmallint =\u003e {\r\n                    Ok(DataValue::UInt16(value.map(u16::try_from).transpose()?))\r\n                }\r\n                LogicalType::UInteger =\u003e {\r\n                    Ok(DataValue::UInt32(value.map(u32::try_from).transpose()?))\r\n                }\r\n                LogicalType::UBigint =\u003e {\r\n                    Ok(DataValue::UInt64(value.map(u64::try_from).transpose()?))\r\n                }\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value)),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.map(|v| v as f32))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v as f64))),\r\n\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::UInt8(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(value)),\r\n                LogicalType::Smallint =\u003e Ok(DataValue::Int16(value.map(|v| v.into()))),\r\n                LogicalType::USmallint =\u003e Ok(DataValue::UInt16(value.map(|v| v.into()))),\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(value.map(|v| v.into()))),\r\n                LogicalType::UInteger =\u003e Ok(DataValue::UInt32(value.map(|v| v.into()))),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value.map(|v| v.into()))),\r\n                LogicalType::UBigint =\u003e Ok(DataValue::UInt64(value.map(|v| v.into()))),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.map(|v| v.into()))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::UInt16(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::USmallint =\u003e Ok(DataValue::UInt16(value)),\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(value.map(|v| v.into()))),\r\n                LogicalType::UInteger =\u003e Ok(DataValue::UInt32(value.map(|v| v.into()))),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value.map(|v| v.into()))),\r\n                LogicalType::UBigint =\u003e Ok(DataValue::UInt64(value.map(|v| v.into()))),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.map(|v| v.into()))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::UInt32(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::UInteger =\u003e Ok(DataValue::UInt32(value)),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(value.map(|v| v.into()))),\r\n                LogicalType::UBigint =\u003e Ok(DataValue::UInt64(value.map(|v| v.into()))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.map(|v| v.into()))),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::UInt64(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::UBigint =\u003e Ok(DataValue::UInt64(value)),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Utf8(value) =\u003e match to {\r\n                LogicalType::Decimal(_, _) =\u003e Ok(DataValue::Decimal(\r\n                    value.map(|v| Decimal::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::Invalid =\u003e Err(DatabaseError::CastFail(\r\n                    LogicalType::Invalid,\r\n                    DataValue::Utf8(value),\r\n                    *to,\r\n                )),\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Boolean =\u003e Ok(DataValue::Boolean(\r\n                    value.map(|v| bool::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::Tinyint =\u003e Ok(DataValue::Int8(\r\n                    value.map(|v| i8::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::UTinyint =\u003e Ok(DataValue::UInt8(\r\n                    value.map(|v| u8::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::Smallint =\u003e Ok(DataValue::Int16(\r\n                    value.map(|v| i16::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::USmallint =\u003e Ok(DataValue::UInt16(\r\n                    value.map(|v| u16::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::Integer =\u003e Ok(DataValue::Int32(\r\n                    value.map(|v| i32::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::UInteger =\u003e Ok(DataValue::UInt32(\r\n                    value.map(|v| u32::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::Bigint =\u003e Ok(DataValue::Int64(\r\n                    value.map(|v| i64::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::UBigint =\u003e Ok(DataValue::UInt64(\r\n                    value.map(|v| u64::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(\r\n                    value.map(|v| f32::from_str(\u0026v)).transpose()?,\r\n                )),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(\r\n                    value.map(|v| f64::from_str(\u0026v)).transpose()?,\r\n                )),\r\n\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                LogicalType::Date =\u003e {\r\n                    let option = value\r\n                        .map(|v| {\r\n                            NaiveDate::parse_from_str(\u0026v, DATE_FMT)\r\n                                .map(|date| date.num_days_from_ce())\r\n                        })\r\n                        .transpose()?;\r\n\r\n                    Ok(DataValue::Date32(option))\r\n                }\r\n                LogicalType::DateTime =\u003e {\r\n                    let option = value\r\n                        .map(|v| {\r\n                            NaiveDateTime::parse_from_str(\u0026v, DATE_TIME_FMT)\r\n                                .or_else(|_| {\r\n                                    NaiveDate::parse_from_str(\u0026v, DATE_FMT)\r\n                                        .map(|date| date.and_hms_opt(0, 0, 0).unwrap())\r\n                                })\r\n                                .map(|date_time| date_time.timestamp())\r\n                        })\r\n                        .transpose()?;\r\n\r\n                    Ok(DataValue::Date64(option))\r\n                }\r\n                LogicalType::UUID =\u003e todo!(),\r\n            },\r\n            DataValue::Date32(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(Self::format_date(value), len),\r\n                LogicalType::Date =\u003e Ok(DataValue::Date32(value)),\r\n                LogicalType::DateTime =\u003e {\r\n                    let option = value.and_then(|v| {\r\n                        NaiveDate::from_num_days_from_ce_opt(v)\r\n                            .and_then(|date| date.and_hms_opt(0, 0, 0))\r\n                            .map(|date_time| date_time.timestamp())\r\n                    });\r\n\r\n                    Ok(DataValue::Date64(option))\r\n                }\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Date64(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(Self::format_datetime(value), len),\r\n                LogicalType::Date =\u003e {\r\n                    let option = value.and_then(|v| {\r\n                        NaiveDateTime::from_timestamp_opt(v, 0)\r\n                            .map(|date_time| date_time.date().num_days_from_ce())\r\n                    });\r\n\r\n                    Ok(DataValue::Date32(option))\r\n                }\r\n                LogicalType::DateTime =\u003e Ok(DataValue::Date64(value)),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            DataValue::Decimal(value) =\u003e match to {\r\n                LogicalType::SqlNull =\u003e Ok(DataValue::Null),\r\n                LogicalType::Float =\u003e Ok(DataValue::Float32(value.and_then(|v| v.to_f32()))),\r\n                LogicalType::Double =\u003e Ok(DataValue::Float64(value.and_then(|v| v.to_f64()))),\r\n                LogicalType::Decimal(_, _) =\u003e Ok(DataValue::Decimal(value)),\r\n                LogicalType::Varchar(len) =\u003e varchar_cast!(value, len),\r\n                _ =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n            },\r\n            //now not support uuid cast\r\n            DataValue::UUID(_) =\u003e Err(DatabaseError::CastFail(self.logical_type(), self, *to)),\r\n        }\r\n    }\r\n\r\n    fn date_format\u003c'a\u003e(v: i32) -\u003e Option\u003cDelayedFormat\u003cStrftimeItems\u003c'a\u003e\u003e\u003e {\r\n        NaiveDate::from_num_days_from_ce_opt(v).map(|date| date.format(DATE_FMT))\r\n    }\r\n\r\n    fn date_time_format\u003c'a\u003e(v: i64) -\u003e Option\u003cDelayedFormat\u003cStrftimeItems\u003c'a\u003e\u003e\u003e {\r\n        NaiveDateTime::from_timestamp_opt(v, 0).map(|date_time| date_time.format(DATE_TIME_FMT))\r\n    }\r\n    fn decimal_format(v: \u0026Decimal) -\u003e String {\r\n        v.to_string()\r\n    }\r\n}\r\n\r\nmacro_rules! impl_scalar {\r\n    ($ty:ty, $scalar:tt) =\u003e {\r\n        impl From\u003c$ty\u003e for DataValue {\r\n            fn from(value: $ty) -\u003e Self {\r\n                DataValue::$scalar(Some(value))\r\n            }\r\n        }\r\n\r\n        impl From\u003cOption\u003c$ty\u003e\u003e for DataValue {\r\n            fn from(value: Option\u003c$ty\u003e) -\u003e Self {\r\n                DataValue::$scalar(value)\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nimpl_scalar!(f64, Float64);\r\nimpl_scalar!(f32, Float32);\r\nimpl_scalar!(i8, Int8);\r\nimpl_scalar!(i16, Int16);\r\nimpl_scalar!(i32, Int32);\r\nimpl_scalar!(i64, Int64);\r\nimpl_scalar!(bool, Boolean);\r\nimpl_scalar!(u8, UInt8);\r\nimpl_scalar!(u16, UInt16);\r\nimpl_scalar!(u32, UInt32);\r\nimpl_scalar!(u64, UInt64);\r\nimpl_scalar!(String, Utf8);\r\n\r\nimpl From\u003c\u0026sqlparser::ast::Value\u003e for DataValue {\r\n    fn from(v: \u0026sqlparser::ast::Value) -\u003e Self {\r\n        match v {\r\n            sqlparser::ast::Value::Number(n, _) =\u003e {\r\n                // use i32 to handle most cases\r\n                if let Ok(v) = n.parse::\u003ci32\u003e() {\r\n                    v.into()\r\n                } else if let Ok(v) = n.parse::\u003ci64\u003e() {\r\n                    v.into()\r\n                } else if let Ok(v) = n.parse::\u003cf32\u003e() {\r\n                    v.into()\r\n                } else if let Ok(v) = n.parse::\u003cf64\u003e() {\r\n                    v.into()\r\n                } else {\r\n                    panic!(\"unsupported number {:?}\", n)\r\n                }\r\n            }\r\n            sqlparser::ast::Value::SingleQuotedString(s) =\u003e s.clone().into(),\r\n            sqlparser::ast::Value::DoubleQuotedString(s) =\u003e s.clone().into(),\r\n            sqlparser::ast::Value::Boolean(b) =\u003e (*b).into(),\r\n            sqlparser::ast::Value::Null =\u003e Self::Null,\r\n            _ =\u003e todo!(\"unsupported parsed scalar value {:?}\", v),\r\n        }\r\n    }\r\n}\r\n\r\nmacro_rules! format_option {\r\n    ($F:expr, $EXPR:expr) =\u003e {{\r\n        match $EXPR {\r\n            Some(e) =\u003e write!($F, \"{}\", e),\r\n            None =\u003e write!($F, \"null\"),\r\n        }\r\n    }};\r\n}\r\n\r\nimpl fmt::Display for DataValue {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        match self {\r\n            DataValue::Boolean(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Float32(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Float64(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Int8(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Int16(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Int32(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Int64(e) =\u003e format_option!(f, e)?,\r\n            DataValue::UInt8(e) =\u003e format_option!(f, e)?,\r\n            DataValue::UInt16(e) =\u003e format_option!(f, e)?,\r\n            DataValue::UInt32(e) =\u003e format_option!(f, e)?,\r\n            DataValue::UInt64(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Utf8(e) =\u003e format_option!(f, e)?,\r\n            DataValue::Null =\u003e write!(f, \"null\")?,\r\n            DataValue::Date32(e) =\u003e format_option!(f, e.and_then(DataValue::date_format))?,\r\n            DataValue::Date64(e) =\u003e format_option!(f, e.and_then(DataValue::date_time_format))?,\r\n            DataValue::Decimal(e) =\u003e format_option!(f, e.as_ref().map(DataValue::decimal_format))?,\r\n            DataValue::UUID(e) =\u003e format_option!(f, e)?,\r\n        };\r\n        Ok(())\r\n    }\r\n}\r\n\r\nimpl fmt::Debug for DataValue {\r\n    fn fmt(\u0026self, f: \u0026mut Formatter) -\u003e fmt::Result {\r\n        match self {\r\n            DataValue::Boolean(_) =\u003e write!(f, \"Boolean({})\", self),\r\n            DataValue::Float32(_) =\u003e write!(f, \"Float32({})\", self),\r\n            DataValue::Float64(_) =\u003e write!(f, \"Float64({})\", self),\r\n            DataValue::Int8(_) =\u003e write!(f, \"Int8({})\", self),\r\n            DataValue::Int16(_) =\u003e write!(f, \"Int16({})\", self),\r\n            DataValue::Int32(_) =\u003e write!(f, \"Int32({})\", self),\r\n            DataValue::Int64(_) =\u003e write!(f, \"Int64({})\", self),\r\n            DataValue::UInt8(_) =\u003e write!(f, \"UInt8({})\", self),\r\n            DataValue::UInt16(_) =\u003e write!(f, \"UInt16({})\", self),\r\n            DataValue::UInt32(_) =\u003e write!(f, \"UInt32({})\", self),\r\n            DataValue::UInt64(_) =\u003e write!(f, \"UInt64({})\", self),\r\n            DataValue::Utf8(None) =\u003e write!(f, \"Utf8({})\", self),\r\n            DataValue::Utf8(Some(_)) =\u003e write!(f, \"Utf8(\\\"{}\\\")\", self),\r\n            DataValue::Null =\u003e write!(f, \"null\"),\r\n            DataValue::Date32(_) =\u003e write!(f, \"Date32({})\", self),\r\n            DataValue::Date64(_) =\u003e write!(f, \"Date64({})\", self),\r\n            DataValue::Decimal(_) =\u003e write!(f, \"Decimal({})\", self),\r\n            DataValue::UUID(_) =\u003e write!(f, \"UUID({})\", self),\r\n        }\r\n    }\r\n}\r\n\r\n#[cfg(test)]\r\nmod test {\r\n    use super::*;\r\n    use crate::types::value::DataValue;\r\n\r\n    #[test]\r\n    fn test_to_primary_key() -\u003e Result\u003c()\u003e {\r\n        let mut key_i8_1 = Vec::new();\r\n        let mut key_i8_2 = Vec::new();\r\n        let mut key_i8_3 = Vec::new();\r\n\r\n        DataValue::Int8(Some(i8::MIN)).to_primary_key(\u0026mut key_i8_1)?;\r\n        DataValue::Int8(Some(-1_i8)).to_primary_key(\u0026mut key_i8_2)?;\r\n        DataValue::Int8(Some(i8::MAX)).to_primary_key(\u0026mut key_i8_3)?;\r\n\r\n        println!(\"{:?} \u003c {:?}\", key_i8_1, key_i8_2);\r\n        println!(\"{:?} \u003c {:?}\", key_i8_2, key_i8_3);\r\n        assert!(key_i8_1 \u003c key_i8_2);\r\n        assert!(key_i8_2 \u003c key_i8_3);\r\n\r\n        let mut key_i16_1 = Vec::new();\r\n        let mut key_i16_2 = Vec::new();\r\n        let mut key_i16_3 = Vec::new();\r\n\r\n        DataValue::Int16(Some(i16::MIN)).to_primary_key(\u0026mut key_i16_1)?;\r\n        DataValue::Int16(Some(-1_i16)).to_primary_key(\u0026mut key_i16_2)?;\r\n        DataValue::Int16(Some(i16::MAX)).to_primary_key(\u0026mut key_i16_3)?;\r\n\r\n        println!(\"{:?} \u003c {:?}\", key_i16_1, key_i16_2);\r\n        println!(\"{:?} \u003c {:?}\", key_i16_2, key_i16_3);\r\n        assert!(key_i16_1 \u003c key_i16_2);\r\n        assert!(key_i16_2 \u003c key_i16_3);\r\n\r\n        let mut key_i32_1 = Vec::new();\r\n        let mut key_i32_2 = Vec::new();\r\n        let mut key_i32_3 = Vec::new();\r\n\r\n        DataValue::Int32(Some(i32::MIN)).to_primary_key(\u0026mut key_i32_1)?;\r\n        DataValue::Int32(Some(-1_i32)).to_primary_key(\u0026mut key_i32_2)?;\r\n        DataValue::Int32(Some(i32::MAX)).to_primary_key(\u0026mut key_i32_3)?;\r\n\r\n        println!(\"{:?} \u003c {:?}\", key_i32_1, key_i32_2);\r\n        println!(\"{:?} \u003c {:?}\", key_i32_2, key_i32_3);\r\n        assert!(key_i32_1 \u003c key_i32_2);\r\n        assert!(key_i32_2 \u003c key_i32_3);\r\n\r\n        let mut key_i64_1 = Vec::new();\r\n        let mut key_i64_2 = Vec::new();\r\n        let mut key_i64_3 = Vec::new();\r\n\r\n        DataValue::Int64(Some(i64::MIN)).to_primary_key(\u0026mut key_i64_1)?;\r\n        DataValue::Int64(Some(-1_i64)).to_primary_key(\u0026mut key_i64_2)?;\r\n        DataValue::Int64(Some(i64::MAX)).to_primary_key(\u0026mut key_i64_3)?;\r\n\r\n        println!(\"{:?} \u003c {:?}\", key_i64_1, key_i64_2);\r\n        println!(\"{:?} \u003c {:?}\", key_i64_2, key_i64_3);\r\n        assert!(key_i64_1 \u003c key_i64_2);\r\n        assert!(key_i64_2 \u003c key_i64_3);\r\n\r\n        Ok(())\r\n    }\r\n\r\n    #[test]\r\n    fn test_to_index_key_f() -\u003e Result\u003c()\u003e {\r\n        let mut key_f32_1 = Vec::new();\r\n        let mut key_f32_2 = Vec::new();\r\n        let mut key_f32_3 = Vec::new();\r\n\r\n        DataValue::Float32(Some(f32::MIN)).to_index_key(\u0026mut key_f32_1)?;\r\n        DataValue::Float32(Some(-1_f32)).to_index_key(\u0026mut key_f32_2)?;\r\n        DataValue::Float32(Some(f32::MAX)).to_index_key(\u0026mut key_f32_3)?;\r\n\r\n        println!(\"{:?} \u003c {:?}\", key_f32_1, key_f32_2);\r\n        println!(\"{:?} \u003c {:?}\", key_f32_2, key_f32_3);\r\n        assert!(key_f32_1 \u003c key_f32_2);\r\n        assert!(key_f32_2 \u003c key_f32_3);\r\n\r\n        let mut key_f64_1 = Vec::new();\r\n        let mut key_f64_2 = Vec::new();\r\n        let mut key_f64_3 = Vec::new();\r\n\r\n        DataValue::Float64(Some(f64::MIN)).to_index_key(\u0026mut key_f64_1)?;\r\n        DataValue::Float64(Some(-1_f64)).to_index_key(\u0026mut key_f64_2)?;\r\n        DataValue::Float64(Some(f64::MAX)).to_index_key(\u0026mut key_f64_3)?;\r\n\r\n        println!(\"{:?} \u003c {:?}\", key_f64_1, key_f64_2);\r\n        println!(\"{:?} \u003c {:?}\", key_f64_2, key_f64_3);\r\n        assert!(key_f64_1 \u003c key_f64_2);\r\n        assert!(key_f64_2 \u003c key_f64_3);\r\n\r\n        Ok(())\r\n    }\r\n}\r\n","traces":[{"line":62,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":12898309332789100544},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":12898309332789100544},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":5260204364768739328},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":99,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":109,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":111,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":3891110078048108544},"fn_name":null},{"line":115,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":129,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[],"length":0,"stats":{"Line":6052837899185946624},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":6052837899185946624},"fn_name":null},{"line":146,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[],"length":0,"stats":{"Line":6052837899185946624},"fn_name":null},{"line":165,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":203,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":204,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[],"length":0,"stats":{"Line":4251398048237748224},"fn_name":null},{"line":216,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[],"length":0,"stats":{"Line":360287970189639680},"fn_name":null},{"line":220,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":226,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":234,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":235,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":247,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":266,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":271,"address":[],"length":0,"stats":{"Line":4611686018427387904},"fn_name":null},{"line":272,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":286,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":288,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":292,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":298,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":307,"address":[],"length":0,"stats":{"Line":8502796096475496448},"fn_name":null},{"line":310,"address":[],"length":0,"stats":{"Line":10808639105689190400},"fn_name":null},{"line":311,"address":[],"length":0,"stats":{"Line":10808639105689190400},"fn_name":null},{"line":312,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":314,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":315,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":316,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":317,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":318,"address":[],"length":0,"stats":{"Line":5404319552844595200},"fn_name":null},{"line":319,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":321,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":322,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":323,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[],"length":0,"stats":{"Line":1657324662872342528},"fn_name":null},{"line":325,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":326,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":327,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[],"length":0,"stats":{"Line":4107282860161892352},"fn_name":null},{"line":333,"address":[],"length":0,"stats":{"Line":4107282860161892352},"fn_name":null},{"line":334,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":336,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":337,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":338,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":339,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":340,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":341,"address":[],"length":0,"stats":{"Line":1441151880758558720},"fn_name":null},{"line":342,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":343,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":346,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":347,"address":[],"length":0,"stats":{"Line":792633534417207296},"fn_name":null},{"line":348,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":349,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":350,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":356,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":357,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":358,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":361,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":364,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":366,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":379,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":380,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":382,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":383,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":384,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":385,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":386,"address":[],"length":0,"stats":{"Line":8646911284551352320},"fn_name":null},{"line":387,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":389,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":390,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":391,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":393,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":394,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":395,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":398,"address":[],"length":0,"stats":{"Line":4467570830351532032},"fn_name":null},{"line":401,"address":[],"length":0,"stats":{"Line":10376293541461622784},"fn_name":null},{"line":402,"address":[],"length":0,"stats":{"Line":10376293541461622784},"fn_name":null},{"line":403,"address":[],"length":0,"stats":{"Line":18446744073709551614},"fn_name":null},{"line":404,"address":[],"length":0,"stats":{"Line":1},"fn_name":null},{"line":405,"address":[],"length":0,"stats":{"Line":648518346341351424},"fn_name":null},{"line":407,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":410,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":413,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":416,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":419,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[],"length":0,"stats":{"Line":7566047373982433283},"fn_name":null},{"line":425,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":431,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":432,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":433,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":435,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":436,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":437,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":438,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":441,"address":[],"length":0,"stats":{"Line":13835058055282163712},"fn_name":null},{"line":444,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":447,"address":[],"length":0,"stats":{"Line":7566047373982433280},"fn_name":null},{"line":450,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":454,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":459,"address":[],"length":0,"stats":{"Line":7133701809754865664},"fn_name":null},{"line":460,"address":[],"length":0,"stats":{"Line":7133701809754865664},"fn_name":null},{"line":461,"address":[],"length":0,"stats":{"Line":18446744073709551611},"fn_name":null},{"line":462,"address":[],"length":0,"stats":{"Line":2305843009213693955},"fn_name":null},{"line":463,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":464,"address":[],"length":0,"stats":{"Line":4251398048237748224},"fn_name":null},{"line":465,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":466,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":467,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":468,"address":[],"length":0,"stats":{"Line":4395513236313604098},"fn_name":null},{"line":469,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":470,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[],"length":0,"stats":{"Line":1369094286720630784},"fn_name":null},{"line":472,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":473,"address":[],"length":0,"stats":{"Line":10448351135499550720},"fn_name":null},{"line":474,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":476,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":477,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":496,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":497,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":498,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":499,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":501,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":502,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":503,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":504,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":506,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":507,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":510,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":511,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":512,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":515,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":516,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":520,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":521,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":523,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":524,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":525,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":530,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":531,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":532,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":533,"address":[],"length":0,"stats":{"Line":2810246167479189504},"fn_name":null},{"line":534,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":535,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":536,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":537,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":539,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":540,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":541,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":542,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":543,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":550,"address":[],"length":0,"stats":{"Line":3458764513820540928},"fn_name":null},{"line":553,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":554,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":555,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":556,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":557,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":558,"address":[],"length":0,"stats":{"Line":2594073385365405696},"fn_name":null},{"line":560,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":561,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":563,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":564,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":565,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":566,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":567,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":568,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":569,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":570,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":572,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":573,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":575,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":578,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":580,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":581,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":583,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":584,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":586,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":589,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":591,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":592,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":593,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":595,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":600,"address":[],"length":0,"stats":{"Line":3314649325744685056},"fn_name":null},{"line":603,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":604,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":605,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":606,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":610,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":611,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":620,"address":[],"length":0,"stats":{"Line":14699749183737298944},"fn_name":null},{"line":621,"address":[],"length":0,"stats":{"Line":14699749183737298944},"fn_name":null},{"line":622,"address":[],"length":0,"stats":{"Line":18446744073709551615},"fn_name":null},{"line":624,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":626,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":627,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":628,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":629,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":630,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":631,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":632,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":633,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":634,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":635,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":636,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":637,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":638,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":639,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":640,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":641,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":642,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":644,"address":[],"length":0,"stats":{"Line":2305843009213693953},"fn_name":null},{"line":645,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":646,"address":[],"length":0,"stats":{"Line":2305843009213693952},"fn_name":null},{"line":647,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":648,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":649,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":650,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":651,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":652,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":653,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":654,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":655,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":656,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":657,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":658,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":660,"address":[],"length":0,"stats":{"Line":1945555039024054272},"fn_name":null},{"line":661,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":662,"address":[],"length":0,"stats":{"Line":1873497444986126336},"fn_name":null},{"line":663,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":664,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":665,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":666,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":667,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":668,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":669,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":674,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":676,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":678,"address":[],"length":0,"stats":{"Line":4251398048237748224},"fn_name":null},{"line":679,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":680,"address":[],"length":0,"stats":{"Line":4251398048237748224},"fn_name":null},{"line":681,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":683,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":685,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":686,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":687,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":688,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":690,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":693,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":696,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":698,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":699,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":700,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":701,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":702,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":703,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":705,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":707,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":708,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":709,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":711,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":714,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":717,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":719,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":720,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":721,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":722,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":723,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":724,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":725,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":727,"address":[],"length":0,"stats":{"Line":14483576401623515136},"fn_name":null},{"line":728,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":729,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":731,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":734,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":737,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":739,"address":[],"length":0,"stats":{"Line":14267403619509731328},"fn_name":null},{"line":740,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":741,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":742,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":743,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":744,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":746,"address":[],"length":0,"stats":{"Line":4395513236313604096},"fn_name":null},{"line":747,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":748,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":750,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":753,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":756,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":758,"address":[],"length":0,"stats":{"Line":4395513236313604096},"fn_name":null},{"line":759,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":760,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":761,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":763,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":765,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":766,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":767,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":768,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":769,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":770,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":771,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":772,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":773,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":774,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":775,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":776,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":777,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":779,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":780,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":781,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":782,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":783,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":784,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":785,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":786,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":787,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":788,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":790,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":792,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":793,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":794,"address":[],"length":0,"stats":{"Line":1297036692682702848},"fn_name":null},{"line":795,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":796,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":797,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":798,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":799,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":801,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":802,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":803,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":804,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":805,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":807,"address":[],"length":0,"stats":{"Line":3891110078048108544},"fn_name":null},{"line":809,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":811,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":812,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":813,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":814,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":816,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":818,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":821,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":824,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":827,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":830,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":833,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":836,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":839,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":842,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":845,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":848,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":851,"address":[],"length":0,"stats":{"Line":3602879701896396800},"fn_name":null},{"line":853,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":854,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":855,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":856,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":860,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":863,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":864,"address":[],"length":0,"stats":{"Line":576460752303423488},"fn_name":null},{"line":865,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":866,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":867,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":868,"address":[],"length":0,"stats":{"Line":432345564227567616},"fn_name":null},{"line":870,"address":[],"length":0,"stats":{"Line":864691128455135232},"fn_name":null},{"line":874,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":878,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":879,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":880,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":881,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":883,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":884,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":885,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":886,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":889,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":891,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":893,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":894,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":895,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":897,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":898,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":899,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":902,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":904,"address":[],"length":0,"stats":{"Line":288230376151711744},"fn_name":null},{"line":905,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":907,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":908,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":909,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":910,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":911,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":912,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":913,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":916,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":920,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":921,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":924,"address":[],"length":0,"stats":{"Line":504403158265495552},"fn_name":null},{"line":925,"address":[],"length":0,"stats":{"Line":1513209474796486656},"fn_name":null},{"line":927,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":928,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":935,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":936,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":941,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":942,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":962,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":963,"address":[],"length":0,"stats":{"Line":8718968878589280256},"fn_name":null},{"line":964,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":966,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":967,"address":[],"length":0,"stats":{"Line":7998392938210000896},"fn_name":null},{"line":968,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":969,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":970,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":971,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":972,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":973,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":975,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":978,"address":[],"length":0,"stats":{"Line":720575940379279360},"fn_name":null},{"line":979,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":980,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":981,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":997,"address":[],"length":0,"stats":{"Line":13546827679130451968},"fn_name":null},{"line":998,"address":[],"length":0,"stats":{"Line":13546827679130451968},"fn_name":null},{"line":999,"address":[],"length":0,"stats":{"Line":6},"fn_name":null},{"line":1000,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1001,"address":[],"length":0,"stats":{"Line":216172782113783808},"fn_name":null},{"line":1002,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1003,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1004,"address":[],"length":0,"stats":{"Line":15852670688344145920},"fn_name":null},{"line":1005,"address":[],"length":0,"stats":{"Line":3},"fn_name":null},{"line":1006,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1007,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1008,"address":[],"length":0,"stats":{"Line":4323455642275676160},"fn_name":null},{"line":1009,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1010,"address":[],"length":0,"stats":{"Line":17005592192950992896},"fn_name":null},{"line":1011,"address":[],"length":0,"stats":{"Line":18446744073709551613},"fn_name":null},{"line":1012,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1013,"address":[],"length":0,"stats":{"Line":3242591731706757120},"fn_name":null},{"line":1014,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1015,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1017,"address":[],"length":0,"stats":{"Line":13546827679130451966},"fn_name":null},{"line":1022,"address":[],"length":0,"stats":{"Line":3602879701896396800},"fn_name":null},{"line":1023,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":1024,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1025,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1026,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1027,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1028,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1029,"address":[],"length":0,"stats":{"Line":3386706919782612992},"fn_name":null},{"line":1030,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1031,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1032,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1033,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1034,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1035,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1036,"address":[],"length":0,"stats":{"Line":72057594037927936},"fn_name":null},{"line":1037,"address":[],"length":0,"stats":{"Line":144115188075855872},"fn_name":null},{"line":1038,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1039,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1040,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":1041,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":221,"coverable":613},{"path":["E:","\\","sql-layer","tests","sqllogictest","src","lib.rs"],"content":"use std::time::Instant;\r\n\r\nuse piggysql::{\r\n    db::Database,\r\n    errors::DatabaseError,\r\n    storage::{piggy_stroage::PiggyKVStroage, Storage},\r\n};\r\nuse sqllogictest::{AsyncDB, DBOutput, DefaultColumnType};\r\n\r\npub struct Mock\u003cS: Storage\u003e {\r\n    pub db: Database\u003cS\u003e,\r\n}\r\n\r\n// impl Mock\u003cMVCCLayer\u003cMemory\u003e\u003e {\r\n//     pub fn new() -\u003e Self {\r\n//         Self {\r\n//             db: Database::new_memory().unwrap(),\r\n//         }\r\n//     }\r\n// }\r\nimpl Mock\u003cPiggyKVStroage\u003e {\r\n    pub fn new_lsm(path: std::path::PathBuf) -\u003e Self {\r\n        Self {\r\n            db: Database::new_lsm(path).unwrap(),\r\n        }\r\n    }\r\n}\r\n#[async_trait::async_trait]\r\nimpl AsyncDB for Mock\u003cPiggyKVStroage\u003e {\r\n    type Error = DatabaseError;\r\n\r\n    type ColumnType = DefaultColumnType;\r\n\r\n    async fn run(\r\n        \u0026mut self,\r\n        sql: \u0026str,\r\n    ) -\u003e Result\u003csqllogictest::DBOutput\u003cSelf::ColumnType\u003e, Self::Error\u003e {\r\n        let start = Instant::now();\r\n        let (schema, tuples) = self.db.run(sql).await?;\r\n        println!(\"| Input SQL:\");\r\n        println!(\" | {}\", sql);\r\n        println!(\" | Time consuming: {:?}\", start.elapsed());\r\n        if tuples.is_empty() {\r\n            return Ok(DBOutput::StatementComplete(0));\r\n        }\r\n        let types = vec![DefaultColumnType::Any; schema.len()];\r\n        let rows = tuples\r\n            .into_iter()\r\n            .map(|tuple| {\r\n                tuple\r\n                    .values\r\n                    .into_iter()\r\n                    .map(|value| format!(\"{}\", value))\r\n                    .collect()\r\n            })\r\n            .collect();\r\n        Ok(DBOutput::Rows { types, rows })\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0},{"path":["E:","\\","sql-layer","tests","sqllogictest","src","main.rs"],"content":"use std::path::Path;\r\n\r\nuse sqllogictest::Runner;\r\nuse sqllogictest_test::Mock;\r\nuse tempfile::{tempdir, TempDir};\r\n\r\n#[tokio::main]\r\nasync fn main() {\r\n    const SLT_PATTERN: \u0026str = \"tests/slt/**/*.slt\";\r\n    // const TEST: \u0026str = \"tests/slt/join.slt\";\r\n    let path = Path::new(env!(\"CARGO_MANIFEST_DIR\")).join(\"..\").join(\"..\");\r\n    std::env::set_current_dir(path).unwrap();\r\n\r\n    println!(\"PiggySQL Test Start!\\n\");\r\n\r\n    for slt_file in glob::glob(SLT_PATTERN).expect(\"failed to find slt files\") {\r\n        let temp_dir = TempDir::new().expect(\"unable to create temporary working directory\");\r\n        let filepath = slt_file\r\n            .expect(\"failed to read slt file\")\r\n            .to_str()\r\n            .unwrap()\r\n            .to_string();\r\n        println!(\"-\u003e Now the test file is: {}\", filepath);\r\n\r\n        let db = Mock::new_lsm(temp_dir.path().join(\"test\"));\r\n        let mut tester = Runner::new(db);\r\n\r\n        if let Err(err) = tester.run_file_async(filepath).await {\r\n            panic!(\"test error: {}\", err);\r\n        }\r\n        println!(\"-\u003e Pass!\\n\\n\")\r\n    }\r\n}\r\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>